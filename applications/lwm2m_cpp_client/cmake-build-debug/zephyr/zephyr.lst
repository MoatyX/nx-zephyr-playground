
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
	 * "Disable" legacy i8259 interrupt controllers. Note that we
	 * can't actually disable them, but we mask all their interrupt
	 * sources which is effectively the same thing (almost).
	 */

	movb $0xff, %al
  100000:	b0 ff                	mov    $0xff,%al
	outb %al, $0x21
  100002:	e6 21                	out    %al,$0x21
	outb %al, $0xA1
  100004:	e6 a1                	out    %al,$0xa1
#endif

#ifdef CONFIG_MULTIBOOT
	jmp 1f
  100006:	eb 0c                	jmp    100014 <__start+0x14>
  100008:	02 b0 ad 1b 02 00    	add    0x21bad(%eax),%dh
  10000e:	00 00                	add    %al,(%eax)
  100010:	fc                   	cld    
  100011:	4f                   	dec    %edi
  100012:	52                   	push   %edx
  100013:	e4 0f                	in     $0xf,%al
SECTION_FUNC(TEXT_START, __start)

#include "../common.S"

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  100015:	20 c0                	and    %al,%al
	andl	$0x9fffffff, %eax
  100017:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  10001c:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  10001f:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
  100020:	0f 01 15 c0 00 10 00 	lgdtl  0x1000c0

	/* If we set our own GDT, update the segment registers as well.
	 */
	movw	$DATA_SEG, %ax	/* data segment selector (entry = 3) */
  100027:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
  10002b:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
  10002d:	8e c0                	mov    %eax,%es
	movw	%ax, %ss	/* set SS */
  10002f:	8e d0                	mov    %eax,%ss
	xorw	%ax, %ax	/* AX = 0 */
  100031:	66 31 c0             	xor    %ax,%ax
	movw	%ax, %fs	/* Zero FS */
  100034:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* Zero GS */
  100036:	8e e8                	mov    %eax,%gs

	ljmp	$CODE_SEG, $__csSet	/* set CS = 0x08 */
  100038:	ea 3f 00 10 00 08 00 	ljmp   $0x8,$0x10003f

0010003f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  10003f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  100042:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  100045:	0f 22 c0             	mov    %eax,%cr0
	 * interfering with interrupt handler use of this stack.
	 * If it is a cold boot then _sys_resume_from_deep_sleep() should
	 * not do anything and must return immediately.
	 */
#ifdef CONFIG_INIT_STACKS
	movl $0xAAAAAAAA, %eax
  100048:	b8 aa aa aa aa       	mov    $0xaaaaaaaa,%eax
	leal z_interrupt_stacks, %edi
  10004d:	8d 3d ec 4b 14 00    	lea    0x144bec,%edi
#ifdef CONFIG_X86_STACK_PROTECTION
	addl $4096, %edi
#endif
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
  100053:	b9 00 02 00 00       	mov    $0x200,%ecx
	rep  stosl
  100058:	f3 ab                	rep stos %eax,%es:(%edi)
#endif

	movl	$z_interrupt_stacks, %esp
  10005a:	bc ec 4b 14 00       	mov    $0x144bec,%esp
	/* In this configuration, all stacks, including IRQ stack, are declared
	 * with a 4K non-present guard page preceding the stack buffer
	 */
	addl	$(CONFIG_ISR_STACK_SIZE + 4096), %esp
#else
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  10005f:	81 c4 00 08 00 00    	add    $0x800,%esp
	 * Clear BSS: bzero (__bss_start, __bss_num_words*4)
	 *
	 * It's assumed that BSS size will be a multiple of a long (4 bytes),
	 * and aligned on a double word (32-bit) boundary
	 */
	movl	$__bss_start, %edi	/* load BSS start address */
  100065:	bf 00 a0 12 00       	mov    $0x12a000,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes in .bss */
  10006a:	b9 62 13 00 00       	mov    $0x1362,%ecx
	call	_x86_bss_zero
  10006f:	e8 3f 00 00 00       	call   1000b3 <_x86_bss_zero>

#if defined(CONFIG_X86_ENABLE_TSS)
	mov $MAIN_TSS, %ax
	ltr %ax
#endif
	lidt	z_x86_idt		/* load 32-bit operand size IDT */
  100074:	0f 01 1d b9 00 10 00 	lidtl  0x1000b9

#ifdef CONFIG_X86_MMU
	/* Install page tables */
	movl $z_x86_kernel_ptables, %eax
  10007b:	b8 00 90 14 00       	mov    $0x149000,%eax
	movl %eax, %cr3
  100080:	0f 22 d8             	mov    %eax,%cr3

#ifdef CONFIG_X86_PAE
	/* Enable PAE */
	movl %cr4, %eax
  100083:	0f 20 e0             	mov    %cr4,%eax
	orl $CR4_PAE, %eax
  100086:	83 c8 20             	or     $0x20,%eax
	movl %eax, %cr4
  100089:	0f 22 e0             	mov    %eax,%cr4

	/* IA32_EFER NXE bit set */
	movl $0xC0000080, %ecx
  10008c:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  100091:	0f 32                	rdmsr  
	orl $0x800, %eax
  100093:	0d 00 08 00 00       	or     $0x800,%eax
	wrmsr
  100098:	0f 30                	wrmsr  
#endif /* CONFIG_X86_PAE */

	/* Enable paging (CR0.PG, bit 31) / write protect (CR0.WP, bit 16) */
	movl %cr0, %eax
  10009a:	0f 20 c0             	mov    %cr0,%eax
	orl $(CR0_PG | CR0_WP), %eax
  10009d:	0d 00 00 01 80       	or     $0x80010000,%eax
	movl %eax, %cr0
  1000a2:	0f 22 c0             	mov    %eax,%cr0
#endif /* CONFIG_X86_MMU */

#ifdef CONFIG_LOAPIC
	/* For BSP, cpu_number is 0 */
	xorl	%eax, %eax
  1000a5:	31 c0                	xor    %eax,%eax
	pushl	%eax
  1000a7:	50                   	push   %eax
	call	z_loapic_enable
  1000a8:	e8 a4 a3 00 00       	call   10a451 <z_loapic_enable>
#endif

	pushl	%ebx		/* pointer to multiboot info, or NULL */
  1000ad:	53                   	push   %ebx
	call	z_x86_prep_c	/* enter kernel; never returns */
  1000ae:	e8 5e ab 00 00       	call   10ac11 <z_x86_prep_c>

001000b3 <_x86_bss_zero>:

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  1000b3:	31 c0                	xor    %eax,%eax
	cld
  1000b5:	fc                   	cld    
	rep
  1000b6:	f3 ab                	rep stos %eax,%es:(%edi)
	stosl				/* zero memory per 4 bytes */

#endif /* CONFIG_SSE */
	ret
  1000b8:	c3                   	ret    

001000b9 <z_x86_idt>:
  1000b9:	ff 07 10 8b 12 00 90                                .......

001000c0 <_gdt>:
  1000c0:	17 00 c0 00 10 00 00 00 ff ff 00 00 00 9b cf 00     ................
  1000d0:	ff ff 00 00 00 93 cf 00                             ........

001000d8 <_gdt_rom_end>:
  1000d8:	66 90                	xchg   %ax,%ax
  1000da:	66 90                	xchg   %ax,%ax
  1000dc:	66 90                	xchg   %ax,%ax
  1000de:	66 90                	xchg   %ax,%ax

001000e0 <__divdi3>:
  1000e0:	55                   	push   %ebp
  1000e1:	57                   	push   %edi
  1000e2:	56                   	push   %esi
  1000e3:	53                   	push   %ebx
  1000e4:	83 ec 1c             	sub    $0x1c,%esp
  1000e7:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  1000eb:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  1000ef:	89 0c 24             	mov    %ecx,(%esp)
  1000f2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  1000f6:	8b 44 24 38          	mov    0x38(%esp),%eax
  1000fa:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  1000fe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100105:	00 
  100106:	89 dd                	mov    %ebx,%ebp
  100108:	85 db                	test   %ebx,%ebx
  10010a:	79 18                	jns    100124 <__divdi3+0x44>
  10010c:	f7 d9                	neg    %ecx
  10010e:	83 d3 00             	adc    $0x0,%ebx
  100111:	89 0c 24             	mov    %ecx,(%esp)
  100114:	f7 db                	neg    %ebx
  100116:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  10011a:	89 dd                	mov    %ebx,%ebp
  10011c:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  100123:	ff 
  100124:	89 d3                	mov    %edx,%ebx
  100126:	85 d2                	test   %edx,%edx
  100128:	79 0d                	jns    100137 <__divdi3+0x57>
  10012a:	f7 d8                	neg    %eax
  10012c:	83 d2 00             	adc    $0x0,%edx
  10012f:	f7 54 24 08          	notl   0x8(%esp)
  100133:	f7 da                	neg    %edx
  100135:	89 d3                	mov    %edx,%ebx
  100137:	89 c7                	mov    %eax,%edi
  100139:	85 db                	test   %ebx,%ebx
  10013b:	8b 04 24             	mov    (%esp),%eax
  10013e:	75 10                	jne    100150 <__divdi3+0x70>
  100140:	39 ef                	cmp    %ebp,%edi
  100142:	76 54                	jbe    100198 <__divdi3+0xb8>
  100144:	89 ea                	mov    %ebp,%edx
  100146:	31 f6                	xor    %esi,%esi
  100148:	f7 f7                	div    %edi
  10014a:	89 c1                	mov    %eax,%ecx
  10014c:	eb 0a                	jmp    100158 <__divdi3+0x78>
  10014e:	66 90                	xchg   %ax,%ax
  100150:	39 eb                	cmp    %ebp,%ebx
  100152:	76 24                	jbe    100178 <__divdi3+0x98>
  100154:	31 f6                	xor    %esi,%esi
  100156:	31 c9                	xor    %ecx,%ecx
  100158:	89 c8                	mov    %ecx,%eax
  10015a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  10015e:	89 f2                	mov    %esi,%edx
  100160:	85 c9                	test   %ecx,%ecx
  100162:	74 07                	je     10016b <__divdi3+0x8b>
  100164:	f7 d8                	neg    %eax
  100166:	83 d2 00             	adc    $0x0,%edx
  100169:	f7 da                	neg    %edx
  10016b:	83 c4 1c             	add    $0x1c,%esp
  10016e:	5b                   	pop    %ebx
  10016f:	5e                   	pop    %esi
  100170:	5f                   	pop    %edi
  100171:	5d                   	pop    %ebp
  100172:	c3                   	ret    
  100173:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100177:	90                   	nop
  100178:	0f bd f3             	bsr    %ebx,%esi
  10017b:	83 f6 1f             	xor    $0x1f,%esi
  10017e:	75 38                	jne    1001b8 <__divdi3+0xd8>
  100180:	39 eb                	cmp    %ebp,%ebx
  100182:	72 07                	jb     10018b <__divdi3+0xab>
  100184:	31 c9                	xor    %ecx,%ecx
  100186:	3b 3c 24             	cmp    (%esp),%edi
  100189:	77 cd                	ja     100158 <__divdi3+0x78>
  10018b:	b9 01 00 00 00       	mov    $0x1,%ecx
  100190:	eb c6                	jmp    100158 <__divdi3+0x78>
  100192:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100198:	85 ff                	test   %edi,%edi
  10019a:	75 0b                	jne    1001a7 <__divdi3+0xc7>
  10019c:	b8 01 00 00 00       	mov    $0x1,%eax
  1001a1:	31 d2                	xor    %edx,%edx
  1001a3:	f7 f3                	div    %ebx
  1001a5:	89 c7                	mov    %eax,%edi
  1001a7:	31 d2                	xor    %edx,%edx
  1001a9:	89 e8                	mov    %ebp,%eax
  1001ab:	f7 f7                	div    %edi
  1001ad:	89 c6                	mov    %eax,%esi
  1001af:	8b 04 24             	mov    (%esp),%eax
  1001b2:	f7 f7                	div    %edi
  1001b4:	89 c1                	mov    %eax,%ecx
  1001b6:	eb a0                	jmp    100158 <__divdi3+0x78>
  1001b8:	b8 20 00 00 00       	mov    $0x20,%eax
  1001bd:	89 f1                	mov    %esi,%ecx
  1001bf:	29 f0                	sub    %esi,%eax
  1001c1:	89 fa                	mov    %edi,%edx
  1001c3:	d3 e3                	shl    %cl,%ebx
  1001c5:	88 c1                	mov    %al,%cl
  1001c7:	d3 ea                	shr    %cl,%edx
  1001c9:	89 f1                	mov    %esi,%ecx
  1001cb:	09 da                	or     %ebx,%edx
  1001cd:	d3 e7                	shl    %cl,%edi
  1001cf:	89 eb                	mov    %ebp,%ebx
  1001d1:	88 c1                	mov    %al,%cl
  1001d3:	d3 eb                	shr    %cl,%ebx
  1001d5:	89 f1                	mov    %esi,%ecx
  1001d7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1001db:	d3 e5                	shl    %cl,%ebp
  1001dd:	8b 14 24             	mov    (%esp),%edx
  1001e0:	88 c1                	mov    %al,%cl
  1001e2:	d3 ea                	shr    %cl,%edx
  1001e4:	09 d5                	or     %edx,%ebp
  1001e6:	89 da                	mov    %ebx,%edx
  1001e8:	89 e8                	mov    %ebp,%eax
  1001ea:	f7 74 24 0c          	divl   0xc(%esp)
  1001ee:	89 d3                	mov    %edx,%ebx
  1001f0:	89 c5                	mov    %eax,%ebp
  1001f2:	f7 e7                	mul    %edi
  1001f4:	39 d3                	cmp    %edx,%ebx
  1001f6:	72 18                	jb     100210 <__divdi3+0x130>
  1001f8:	8b 3c 24             	mov    (%esp),%edi
  1001fb:	89 f1                	mov    %esi,%ecx
  1001fd:	d3 e7                	shl    %cl,%edi
  1001ff:	39 c7                	cmp    %eax,%edi
  100201:	73 04                	jae    100207 <__divdi3+0x127>
  100203:	39 d3                	cmp    %edx,%ebx
  100205:	74 09                	je     100210 <__divdi3+0x130>
  100207:	89 e9                	mov    %ebp,%ecx
  100209:	31 f6                	xor    %esi,%esi
  10020b:	e9 48 ff ff ff       	jmp    100158 <__divdi3+0x78>
  100210:	8d 4d ff             	lea    -0x1(%ebp),%ecx
  100213:	31 f6                	xor    %esi,%esi
  100215:	e9 3e ff ff ff       	jmp    100158 <__divdi3+0x78>
  10021a:	66 90                	xchg   %ax,%ax
  10021c:	66 90                	xchg   %ax,%ax
  10021e:	66 90                	xchg   %ax,%ax

00100220 <__udivdi3>:
  100220:	55                   	push   %ebp
  100221:	57                   	push   %edi
  100222:	56                   	push   %esi
  100223:	53                   	push   %ebx
  100224:	83 ec 1c             	sub    $0x1c,%esp
  100227:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  10022b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  10022f:	8b 74 24 34          	mov    0x34(%esp),%esi
  100233:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  100237:	85 d2                	test   %edx,%edx
  100239:	75 1d                	jne    100258 <__udivdi3+0x38>
  10023b:	39 f3                	cmp    %esi,%ebx
  10023d:	76 51                	jbe    100290 <__udivdi3+0x70>
  10023f:	31 ff                	xor    %edi,%edi
  100241:	89 e8                	mov    %ebp,%eax
  100243:	89 f2                	mov    %esi,%edx
  100245:	f7 f3                	div    %ebx
  100247:	89 fa                	mov    %edi,%edx
  100249:	83 c4 1c             	add    $0x1c,%esp
  10024c:	5b                   	pop    %ebx
  10024d:	5e                   	pop    %esi
  10024e:	5f                   	pop    %edi
  10024f:	5d                   	pop    %ebp
  100250:	c3                   	ret    
  100251:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  100258:	39 f2                	cmp    %esi,%edx
  10025a:	76 14                	jbe    100270 <__udivdi3+0x50>
  10025c:	31 ff                	xor    %edi,%edi
  10025e:	31 c0                	xor    %eax,%eax
  100260:	89 fa                	mov    %edi,%edx
  100262:	83 c4 1c             	add    $0x1c,%esp
  100265:	5b                   	pop    %ebx
  100266:	5e                   	pop    %esi
  100267:	5f                   	pop    %edi
  100268:	5d                   	pop    %ebp
  100269:	c3                   	ret    
  10026a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100270:	0f bd fa             	bsr    %edx,%edi
  100273:	83 f7 1f             	xor    $0x1f,%edi
  100276:	75 48                	jne    1002c0 <__udivdi3+0xa0>
  100278:	39 f2                	cmp    %esi,%edx
  10027a:	72 06                	jb     100282 <__udivdi3+0x62>
  10027c:	31 c0                	xor    %eax,%eax
  10027e:	39 eb                	cmp    %ebp,%ebx
  100280:	77 de                	ja     100260 <__udivdi3+0x40>
  100282:	b8 01 00 00 00       	mov    $0x1,%eax
  100287:	eb d7                	jmp    100260 <__udivdi3+0x40>
  100289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  100290:	89 d9                	mov    %ebx,%ecx
  100292:	85 db                	test   %ebx,%ebx
  100294:	75 0b                	jne    1002a1 <__udivdi3+0x81>
  100296:	b8 01 00 00 00       	mov    $0x1,%eax
  10029b:	31 d2                	xor    %edx,%edx
  10029d:	f7 f3                	div    %ebx
  10029f:	89 c1                	mov    %eax,%ecx
  1002a1:	31 d2                	xor    %edx,%edx
  1002a3:	89 f0                	mov    %esi,%eax
  1002a5:	f7 f1                	div    %ecx
  1002a7:	89 c6                	mov    %eax,%esi
  1002a9:	89 e8                	mov    %ebp,%eax
  1002ab:	89 f7                	mov    %esi,%edi
  1002ad:	f7 f1                	div    %ecx
  1002af:	89 fa                	mov    %edi,%edx
  1002b1:	83 c4 1c             	add    $0x1c,%esp
  1002b4:	5b                   	pop    %ebx
  1002b5:	5e                   	pop    %esi
  1002b6:	5f                   	pop    %edi
  1002b7:	5d                   	pop    %ebp
  1002b8:	c3                   	ret    
  1002b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  1002c0:	89 f9                	mov    %edi,%ecx
  1002c2:	b8 20 00 00 00       	mov    $0x20,%eax
  1002c7:	29 f8                	sub    %edi,%eax
  1002c9:	d3 e2                	shl    %cl,%edx
  1002cb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1002cf:	88 c1                	mov    %al,%cl
  1002d1:	89 da                	mov    %ebx,%edx
  1002d3:	d3 ea                	shr    %cl,%edx
  1002d5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1002d9:	09 d1                	or     %edx,%ecx
  1002db:	89 f2                	mov    %esi,%edx
  1002dd:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1002e1:	89 f9                	mov    %edi,%ecx
  1002e3:	d3 e3                	shl    %cl,%ebx
  1002e5:	88 c1                	mov    %al,%cl
  1002e7:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1002eb:	d3 ea                	shr    %cl,%edx
  1002ed:	89 f9                	mov    %edi,%ecx
  1002ef:	89 eb                	mov    %ebp,%ebx
  1002f1:	d3 e6                	shl    %cl,%esi
  1002f3:	88 c1                	mov    %al,%cl
  1002f5:	d3 eb                	shr    %cl,%ebx
  1002f7:	09 de                	or     %ebx,%esi
  1002f9:	89 f0                	mov    %esi,%eax
  1002fb:	f7 74 24 08          	divl   0x8(%esp)
  1002ff:	89 d6                	mov    %edx,%esi
  100301:	89 c3                	mov    %eax,%ebx
  100303:	f7 64 24 0c          	mull   0xc(%esp)
  100307:	39 d6                	cmp    %edx,%esi
  100309:	72 15                	jb     100320 <__udivdi3+0x100>
  10030b:	89 f9                	mov    %edi,%ecx
  10030d:	d3 e5                	shl    %cl,%ebp
  10030f:	39 c5                	cmp    %eax,%ebp
  100311:	73 04                	jae    100317 <__udivdi3+0xf7>
  100313:	39 d6                	cmp    %edx,%esi
  100315:	74 09                	je     100320 <__udivdi3+0x100>
  100317:	89 d8                	mov    %ebx,%eax
  100319:	31 ff                	xor    %edi,%edi
  10031b:	e9 40 ff ff ff       	jmp    100260 <__udivdi3+0x40>
  100320:	8d 43 ff             	lea    -0x1(%ebx),%eax
  100323:	31 ff                	xor    %edi,%edi
  100325:	e9 36 ff ff ff       	jmp    100260 <__udivdi3+0x40>
  10032a:	66 90                	xchg   %ax,%ax
  10032c:	66 90                	xchg   %ax,%ax
  10032e:	66 90                	xchg   %ax,%ax

00100330 <__udivmoddi4>:
  100330:	55                   	push   %ebp
  100331:	57                   	push   %edi
  100332:	56                   	push   %esi
  100333:	53                   	push   %ebx
  100334:	83 ec 2c             	sub    $0x2c,%esp
  100337:	8b 44 24 40          	mov    0x40(%esp),%eax
  10033b:	8b 5c 24 44          	mov    0x44(%esp),%ebx
  10033f:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
  100343:	89 44 24 10          	mov    %eax,0x10(%esp)
  100347:	8b 74 24 48          	mov    0x48(%esp),%esi
  10034b:	89 da                	mov    %ebx,%edx
  10034d:	85 ff                	test   %edi,%edi
  10034f:	75 5f                	jne    1003b0 <__udivmoddi4+0x80>
  100351:	39 de                	cmp    %ebx,%esi
  100353:	76 33                	jbe    100388 <__udivmoddi4+0x58>
  100355:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10035c:	00 
  10035d:	f7 f6                	div    %esi
  10035f:	8b 7c 24 50          	mov    0x50(%esp),%edi
  100363:	89 c5                	mov    %eax,%ebp
  100365:	85 ff                	test   %edi,%edi
  100367:	74 0d                	je     100376 <__udivmoddi4+0x46>
  100369:	8b 44 24 50          	mov    0x50(%esp),%eax
  10036d:	89 10                	mov    %edx,(%eax)
  10036f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  100376:	89 e8                	mov    %ebp,%eax
  100378:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10037c:	83 c4 2c             	add    $0x2c,%esp
  10037f:	5b                   	pop    %ebx
  100380:	5e                   	pop    %esi
  100381:	5f                   	pop    %edi
  100382:	5d                   	pop    %ebp
  100383:	c3                   	ret    
  100384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100388:	89 f1                	mov    %esi,%ecx
  10038a:	85 f6                	test   %esi,%esi
  10038c:	75 0b                	jne    100399 <__udivmoddi4+0x69>
  10038e:	b8 01 00 00 00       	mov    $0x1,%eax
  100393:	31 d2                	xor    %edx,%edx
  100395:	f7 f6                	div    %esi
  100397:	89 c1                	mov    %eax,%ecx
  100399:	89 d8                	mov    %ebx,%eax
  10039b:	31 d2                	xor    %edx,%edx
  10039d:	f7 f1                	div    %ecx
  10039f:	89 c3                	mov    %eax,%ebx
  1003a1:	8b 44 24 10          	mov    0x10(%esp),%eax
  1003a5:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1003a9:	f7 f1                	div    %ecx
  1003ab:	eb b2                	jmp    10035f <__udivmoddi4+0x2f>
  1003ad:	8d 76 00             	lea    0x0(%esi),%esi
  1003b0:	39 df                	cmp    %ebx,%edi
  1003b2:	76 34                	jbe    1003e8 <__udivmoddi4+0xb8>
  1003b4:	8b 74 24 50          	mov    0x50(%esp),%esi
  1003b8:	85 f6                	test   %esi,%esi
  1003ba:	0f 84 28 01 00 00    	je     1004e8 <__udivmoddi4+0x1b8>
  1003c0:	8b 44 24 50          	mov    0x50(%esp),%eax
  1003c4:	8b 7c 24 10          	mov    0x10(%esp),%edi
  1003c8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1003cf:	00 
  1003d0:	31 ed                	xor    %ebp,%ebp
  1003d2:	89 38                	mov    %edi,(%eax)
  1003d4:	89 58 04             	mov    %ebx,0x4(%eax)
  1003d7:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1003db:	89 e8                	mov    %ebp,%eax
  1003dd:	83 c4 2c             	add    $0x2c,%esp
  1003e0:	5b                   	pop    %ebx
  1003e1:	5e                   	pop    %esi
  1003e2:	5f                   	pop    %edi
  1003e3:	5d                   	pop    %ebp
  1003e4:	c3                   	ret    
  1003e5:	8d 76 00             	lea    0x0(%esi),%esi
  1003e8:	0f bd cf             	bsr    %edi,%ecx
  1003eb:	83 f1 1f             	xor    $0x1f,%ecx
  1003ee:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1003f2:	75 34                	jne    100428 <__udivmoddi4+0xf8>
  1003f4:	39 df                	cmp    %ebx,%edi
  1003f6:	0f 82 fc 00 00 00    	jb     1004f8 <__udivmoddi4+0x1c8>
  1003fc:	31 ed                	xor    %ebp,%ebp
  1003fe:	3b 74 24 10          	cmp    0x10(%esp),%esi
  100402:	0f 86 f0 00 00 00    	jbe    1004f8 <__udivmoddi4+0x1c8>
  100408:	8b 4c 24 50          	mov    0x50(%esp),%ecx
  10040c:	85 c9                	test   %ecx,%ecx
  10040e:	0f 84 62 ff ff ff    	je     100376 <__udivmoddi4+0x46>
  100414:	8b 7c 24 50          	mov    0x50(%esp),%edi
  100418:	89 07                	mov    %eax,(%edi)
  10041a:	89 57 04             	mov    %edx,0x4(%edi)
  10041d:	e9 54 ff ff ff       	jmp    100376 <__udivmoddi4+0x46>
  100422:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  100428:	b8 20 00 00 00       	mov    $0x20,%eax
  10042d:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  100431:	89 c2                	mov    %eax,%edx
  100433:	89 e9                	mov    %ebp,%ecx
  100435:	29 ea                	sub    %ebp,%edx
  100437:	89 f0                	mov    %esi,%eax
  100439:	d3 e7                	shl    %cl,%edi
  10043b:	88 d1                	mov    %dl,%cl
  10043d:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  100441:	d3 e8                	shr    %cl,%eax
  100443:	89 e9                	mov    %ebp,%ecx
  100445:	09 c7                	or     %eax,%edi
  100447:	d3 e6                	shl    %cl,%esi
  100449:	89 74 24 14          	mov    %esi,0x14(%esp)
  10044d:	88 d1                	mov    %dl,%cl
  10044f:	89 de                	mov    %ebx,%esi
  100451:	89 d0                	mov    %edx,%eax
  100453:	d3 ee                	shr    %cl,%esi
  100455:	89 e9                	mov    %ebp,%ecx
  100457:	89 ea                	mov    %ebp,%edx
  100459:	d3 e3                	shl    %cl,%ebx
  10045b:	89 dd                	mov    %ebx,%ebp
  10045d:	88 c1                	mov    %al,%cl
  10045f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  100463:	d3 eb                	shr    %cl,%ebx
  100465:	09 dd                	or     %ebx,%ebp
  100467:	88 d1                	mov    %dl,%cl
  100469:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  10046d:	89 e8                	mov    %ebp,%eax
  10046f:	d3 e3                	shl    %cl,%ebx
  100471:	89 f2                	mov    %esi,%edx
  100473:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  100477:	f7 f7                	div    %edi
  100479:	89 d1                	mov    %edx,%ecx
  10047b:	89 c3                	mov    %eax,%ebx
  10047d:	89 c5                	mov    %eax,%ebp
  10047f:	f7 64 24 14          	mull   0x14(%esp)
  100483:	89 c6                	mov    %eax,%esi
  100485:	89 54 24 10          	mov    %edx,0x10(%esp)
  100489:	39 d1                	cmp    %edx,%ecx
  10048b:	72 08                	jb     100495 <__udivmoddi4+0x165>
  10048d:	75 15                	jne    1004a4 <__udivmoddi4+0x174>
  10048f:	39 44 24 18          	cmp    %eax,0x18(%esp)
  100493:	73 0f                	jae    1004a4 <__udivmoddi4+0x174>
  100495:	2b 44 24 14          	sub    0x14(%esp),%eax
  100499:	19 fa                	sbb    %edi,%edx
  10049b:	8d 6b ff             	lea    -0x1(%ebx),%ebp
  10049e:	89 54 24 10          	mov    %edx,0x10(%esp)
  1004a2:	89 c6                	mov    %eax,%esi
  1004a4:	8b 44 24 50          	mov    0x50(%esp),%eax
  1004a8:	85 c0                	test   %eax,%eax
  1004aa:	74 64                	je     100510 <__udivmoddi4+0x1e0>
  1004ac:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  1004b0:	89 ca                	mov    %ecx,%edx
  1004b2:	8b 44 24 18          	mov    0x18(%esp),%eax
  1004b6:	8a 4c 24 1c          	mov    0x1c(%esp),%cl
  1004ba:	29 f0                	sub    %esi,%eax
  1004bc:	1b 54 24 10          	sbb    0x10(%esp),%edx
  1004c0:	89 d3                	mov    %edx,%ebx
  1004c2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1004c9:	00 
  1004ca:	d3 e3                	shl    %cl,%ebx
  1004cc:	89 f9                	mov    %edi,%ecx
  1004ce:	8b 7c 24 50          	mov    0x50(%esp),%edi
  1004d2:	d3 e8                	shr    %cl,%eax
  1004d4:	09 d8                	or     %ebx,%eax
  1004d6:	d3 ea                	shr    %cl,%edx
  1004d8:	89 07                	mov    %eax,(%edi)
  1004da:	89 57 04             	mov    %edx,0x4(%edi)
  1004dd:	e9 94 fe ff ff       	jmp    100376 <__udivmoddi4+0x46>
  1004e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  1004e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1004ef:	00 
  1004f0:	31 ed                	xor    %ebp,%ebp
  1004f2:	e9 7f fe ff ff       	jmp    100376 <__udivmoddi4+0x46>
  1004f7:	90                   	nop
  1004f8:	89 da                	mov    %ebx,%edx
  1004fa:	8b 44 24 10          	mov    0x10(%esp),%eax
  1004fe:	bd 01 00 00 00       	mov    $0x1,%ebp
  100503:	29 f0                	sub    %esi,%eax
  100505:	19 fa                	sbb    %edi,%edx
  100507:	e9 fc fe ff ff       	jmp    100408 <__udivmoddi4+0xd8>
  10050c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  100510:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100517:	00 
  100518:	e9 59 fe ff ff       	jmp    100376 <__udivmoddi4+0x46>
  10051d:	90                   	nop

0010051e <_ZN2nx13lwm2m_contextC1EPKc>:
    return 0;
}

namespace nx
{
    lwm2m_context::lwm2m_context(const char *endpoint_name)
  10051e:	55                   	push   %ebp
  10051f:	31 c0                	xor    %eax,%eax
  100521:	89 e5                	mov    %esp,%ebp
  100523:	b9 58 00 00 00       	mov    $0x58,%ecx
  100528:	57                   	push   %edi
  100529:	8b 55 08             	mov    0x8(%ebp),%edx
  10052c:	8d 7a 08             	lea    0x8(%edx),%edi
  10052f:	f3 ab                	rep stos %eax,%es:(%edi)
    {
        endpoint_name_ = endpoint_name;
  100531:	8b 45 0c             	mov    0xc(%ebp),%eax
  100534:	89 02                	mov    %eax,(%edx)
    }
  100536:	5f                   	pop    %edi
  100537:	5d                   	pop    %ebp
  100538:	c3                   	ret    
  100539:	90                   	nop

0010053a <_ZN2nx13lwm2m_context18set_server_addressEtPKc>:

    void lwm2m_context::set_server_address(uint16_t short_server_id, const char *server_addr)
    {
  10053a:	55                   	push   %ebp
  10053b:	89 e5                	mov    %esp,%ebp
  10053d:	56                   	push   %esi
  10053e:	53                   	push   %ebx
  10053f:	50                   	push   %eax
        * later once we have a working Template. 
        * we will use member lwm2m instances to do the following steps
        */
        uint16_t server_url_len = 0;
        uint8_t server_url_flags = 0;
        lwm2m_engine_get_res_data("0/0/0", (void **)&server_address_, &server_url_len, &server_url_flags);
  100540:	8d 45 f5             	lea    -0xb(%ebp),%eax
    {
  100543:	8b 75 08             	mov    0x8(%ebp),%esi
        lwm2m_engine_get_res_data("0/0/0", (void **)&server_address_, &server_url_len, &server_url_flags);
  100546:	50                   	push   %eax
  100547:	8d 45 f6             	lea    -0xa(%ebp),%eax
    {
  10054a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
        lwm2m_engine_get_res_data("0/0/0", (void **)&server_address_, &server_url_len, &server_url_flags);
  10054d:	50                   	push   %eax
  10054e:	8d 46 04             	lea    0x4(%esi),%eax
  100551:	50                   	push   %eax
        uint16_t server_url_len = 0;
  100552:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
        lwm2m_engine_get_res_data("0/0/0", (void **)&server_address_, &server_url_len, &server_url_flags);
  100558:	68 47 47 12 00       	push   $0x124747
        uint8_t server_url_flags = 0;
  10055d:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
        lwm2m_engine_get_res_data("0/0/0", (void **)&server_address_, &server_url_len, &server_url_flags);
  100561:	e8 b7 7c 01 00       	call   11821d <lwm2m_engine_get_res_data>
  100566:	83 c4 10             	add    $0x10,%esp

        // TODO: remove later to support DTLS and Bootrapping
        snprintk(server_address_, server_url_len, "coap://%s", server_addr);
  100569:	ff 75 10             	pushl  0x10(%ebp)
  10056c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  100570:	68 4d 47 12 00       	push   $0x12474d
  100575:	50                   	push   %eax
  100576:	ff 76 04             	pushl  0x4(%esi)
  100579:	e8 81 0d 00 00       	call   1012ff <snprintk>
  10057e:	83 c4 10             	add    $0x10,%esp

        // Match Security object instance ID with a Short Server ID of the Server instance
        lwm2m_engine_set_u16("0/0/10", short_server_id); //security object instance "ID"
  100581:	0f b7 db             	movzwl %bx,%ebx
  100584:	53                   	push   %ebx
  100585:	68 57 47 12 00       	push   $0x124757
  10058a:	e8 71 7c 01 00       	call   118200 <lwm2m_engine_set_u16>
  10058f:	5a                   	pop    %edx
  100590:	59                   	pop    %ecx
        lwm2m_engine_set_u16("1/0/0", short_server_id);  //server object instance "Short Server ID"
  100591:	53                   	push   %ebx
  100592:	68 5e 47 12 00       	push   $0x12475e
  100597:	e8 64 7c 01 00       	call   118200 <lwm2m_engine_set_u16>
  10059c:	5b                   	pop    %ebx
  10059d:	5e                   	pop    %esi
        lwm2m_engine_set_string("0/0/0", "coap://192.0.2.2");
  10059e:	68 64 47 12 00       	push   $0x124764
  1005a3:	68 47 47 12 00       	push   $0x124747
  1005a8:	e8 2d 7c 01 00       	call   1181da <lwm2m_engine_set_string>
  1005ad:	58                   	pop    %eax
  1005ae:	5a                   	pop    %edx

        //test code
        lwm2m_engine_set_res_data("3/0/14", &testVal, 20, 0);
  1005af:	6a 00                	push   $0x0
  1005b1:	6a 14                	push   $0x14
  1005b3:	68 c0 ea 12 00       	push   $0x12eac0
  1005b8:	68 1c 47 12 00       	push   $0x12471c
  1005bd:	e8 40 7b 01 00       	call   118102 <lwm2m_engine_set_res_data>
  1005c2:	83 c4 10             	add    $0x10,%esp
        lwm2m_engine_register_pre_write_callback("3/0/14", writing);
  1005c5:	68 fb 05 10 00       	push   $0x1005fb
  1005ca:	68 1c 47 12 00       	push   $0x12471c
  1005cf:	e8 0f 7e 01 00       	call   1183e3 <lwm2m_engine_register_pre_write_callback>
  1005d4:	59                   	pop    %ecx
  1005d5:	5b                   	pop    %ebx
    }
  1005d6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1005d9:	5b                   	pop    %ebx
  1005da:	5e                   	pop    %esi
  1005db:	5d                   	pop    %ebp
  1005dc:	c3                   	ret    
  1005dd:	90                   	nop

001005de <_ZN2nx13lwm2m_context5startEjPFvP9lwm2m_ctx21lwm2m_rd_client_eventE>:

    void lwm2m_context::start(uint32_t flags, lwm2m_ctx_event_cb_t client_event_callback)
    {
  1005de:	55                   	push   %ebp
  1005df:	89 e5                	mov    %esp,%ebp
        lwm2m_rd_client_start(&clientt, endpoint_name_, flags, client_event_callback); //start client
  1005e1:	ff 75 10             	pushl  0x10(%ebp)
  1005e4:	ff 75 0c             	pushl  0xc(%ebp)
  1005e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1005ea:	ff 30                	pushl  (%eax)
  1005ec:	68 00 a0 12 00       	push   $0x12a000
  1005f1:	e8 70 d1 01 00       	call   11d766 <lwm2m_rd_client_start>
  1005f6:	83 c4 10             	add    $0x10,%esp
    }
  1005f9:	c9                   	leave  
  1005fa:	c3                   	ret    

001005fb <_Z7writingtttPj>:
void* writing(uint16_t obj_inst_id, uint16_t res_id, uint16_t res_inst_id, size_t *data_len) {
  1005fb:	55                   	push   %ebp
  1005fc:	89 e5                	mov    %esp,%ebp
  1005fe:	57                   	push   %edi
  1005ff:	56                   	push   %esi
  100600:	53                   	push   %ebx
  100601:	83 ec 14             	sub    $0x14,%esp
    LOG_INF("writing");
  100604:	a1 98 5b 14 00       	mov    0x145b98,%eax
  100609:	83 e0 07             	and    $0x7,%eax
  10060c:	83 f8 02             	cmp    $0x2,%eax
  10060f:	76 20                	jbe    100631 <_Z7writingtttPj+0x36>
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  100611:	b8 b0 30 12 00       	mov    $0x1230b0,%eax
  100616:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  10061b:	c1 e8 03             	shr    $0x3,%eax
  10061e:	c1 e0 06             	shl    $0x6,%eax
  100621:	83 c8 03             	or     $0x3,%eax
  100624:	50                   	push   %eax
  100625:	68 14 47 12 00       	push   $0x124714
  10062a:	e8 1e 2f 00 00       	call   10354d <log_0>
  10062f:	59                   	pop    %ecx
  100630:	5b                   	pop    %ebx
		parm0.val = timeout;
		return (int) arch_syscall_invoke3(*(uintptr_t *)&mutex, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
  100631:	6a 00                	push   $0x0
    lwm2m_engine_get_string("3/0/14", &val, 20);
  100633:	8d 7d e0             	lea    -0x20(%ebp),%edi
  100636:	6a 64                	push   $0x64
  100638:	68 e8 5c 14 00       	push   $0x145ce8
  10063d:	e8 8e 05 02 00       	call   120bd0 <z_impl_k_mutex_lock>
  100642:	83 c4 0c             	add    $0xc,%esp
  100645:	6a 14                	push   $0x14
  100647:	57                   	push   %edi
  100648:	68 1c 47 12 00       	push   $0x12471c
  10064d:	e8 a1 7c 01 00       	call   1182f3 <lwm2m_engine_get_string>
  100652:	83 c4 0c             	add    $0xc,%esp
    const char* vall = log_strdup(val);
  100655:	57                   	push   %edi
  100656:	e8 fc 2b 00 00       	call   103257 <log_strdup>
  10065b:	89 c6                	mov    %eax,%esi
    LOG_INF("data: %s, data_len: %d", vall, strlen(val));
  10065d:	a1 98 5b 14 00       	mov    0x145b98,%eax
  100662:	83 e0 07             	and    $0x7,%eax
    const char* vall = log_strdup(val);
  100665:	5a                   	pop    %edx
    LOG_INF("data: %s, data_len: %d", vall, strlen(val));
  100666:	83 f8 02             	cmp    $0x2,%eax
  100669:	76 2d                	jbe    100698 <_Z7writingtttPj+0x9d>
  10066b:	57                   	push   %edi
  10066c:	e8 ab b6 00 00       	call   10bd1c <strlen>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  100671:	bb b0 30 12 00       	mov    $0x1230b0,%ebx
  100676:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
			sizeof(struct log_source_const_data);
  10067c:	c1 eb 03             	shr    $0x3,%ebx
  10067f:	c1 e3 06             	shl    $0x6,%ebx
  100682:	83 cb 03             	or     $0x3,%ebx
  100685:	66 89 1c 24          	mov    %bx,(%esp)
  100689:	50                   	push   %eax
  10068a:	56                   	push   %esi
  10068b:	68 23 47 12 00       	push   $0x124723
  100690:	e8 1b 2f 00 00       	call   1035b0 <log_2>
  100695:	83 c4 10             	add    $0x10,%esp
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
  100698:	68 e8 5c 14 00       	push   $0x145ce8
  10069d:	e8 2c 06 02 00       	call   120cce <z_impl_k_mutex_unlock>
  1006a2:	58                   	pop    %eax
}
  1006a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1006a6:	31 c0                	xor    %eax,%eax
  1006a8:	5b                   	pop    %ebx
  1006a9:	5e                   	pop    %esi
  1006aa:	5f                   	pop    %edi
  1006ab:	5d                   	pop    %ebp
  1006ac:	c3                   	ret    

001006ad <_Z11test_threadPvS_S_>:
[[noreturn]] void test_thread(void* arg1, void* arg2, void* arg3) {
  1006ad:	55                   	push   %ebp
  1006ae:	89 e5                	mov    %esp,%ebp
  1006b0:	56                   	push   %esi
  1006b1:	53                   	push   %ebx
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  1006b2:	bb b0 30 12 00       	mov    $0x1230b0,%ebx
  1006b7:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
			sizeof(struct log_source_const_data);
  1006bd:	c1 eb 03             	shr    $0x3,%ebx
            LOG_INF("test val: %s", log_strdup(testVal));
  1006c0:	c1 e3 06             	shl    $0x6,%ebx
	return z_impl_k_mutex_lock(mutex, timeout);
  1006c3:	6a 00                	push   $0x0
  1006c5:	6a 64                	push   $0x64
  1006c7:	68 e8 5c 14 00       	push   $0x145ce8
  1006cc:	e8 ff 04 02 00       	call   120bd0 <z_impl_k_mutex_lock>
  1006d1:	83 c4 0c             	add    $0xc,%esp
        if(testVal[0] != 0)
  1006d4:	80 3d c0 ea 12 00 00 	cmpb   $0x0,0x12eac0
  1006db:	74 2e                	je     10070b <_Z11test_threadPvS_S_+0x5e>
            LOG_INF("test val: %s", log_strdup(testVal));
  1006dd:	a1 98 5b 14 00       	mov    0x145b98,%eax
  1006e2:	83 e0 07             	and    $0x7,%eax
  1006e5:	83 f8 02             	cmp    $0x2,%eax
  1006e8:	76 21                	jbe    10070b <_Z11test_threadPvS_S_+0x5e>
  1006ea:	68 c0 ea 12 00       	push   $0x12eac0
  1006ef:	e8 63 2b 00 00       	call   103257 <log_strdup>
  1006f4:	89 de                	mov    %ebx,%esi
  1006f6:	83 ce 03             	or     $0x3,%esi
  1006f9:	66 89 34 24          	mov    %si,(%esp)
  1006fd:	50                   	push   %eax
  1006fe:	68 3a 47 12 00       	push   $0x12473a
  100703:	e8 6e 2e 00 00       	call   103576 <log_1>
  100708:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_mutex_unlock(mutex);
  10070b:	68 e8 5c 14 00       	push   $0x145ce8
  100710:	e8 b9 05 02 00       	call   120cce <z_impl_k_mutex_unlock>
	return z_impl_k_sleep(timeout);
  100715:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10071c:	6a 64                	push   $0x64
  10071e:	e8 f0 10 02 00       	call   121813 <z_impl_k_sleep>
  100723:	58                   	pop    %eax
  100724:	5a                   	pop    %edx
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
  100725:	eb 9c                	jmp    1006c3 <_Z11test_threadPvS_S_+0x16>

00100727 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event>:
#define SERVER_ADDR CONFIG_NET_CONFIG_PEER_IPV4_ADDR

// Client event callback function
static void rd_client_event(struct lwm2m_ctx *client,
                            enum lwm2m_rd_client_event client_event)
{
  100727:	55                   	push   %ebp
  100728:	89 e5                	mov    %esp,%ebp
  10072a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10072d:	8d 50 ff             	lea    -0x1(%eax),%edx
  100730:	83 fa 09             	cmp    $0x9,%edx
  100733:	0f 87 96 01 00 00    	ja     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
  100739:	a1 9c 5b 14 00       	mov    0x145b9c,%eax
    case LWM2M_RD_CLIENT_EVENT_DISCONNECT:
        LOG_DBG("Disconnected");
        break;

    case LWM2M_RD_CLIENT_EVENT_QUEUE_MODE_RX_OFF:
        LOG_DBG("Queue mode RX window closed");
  10073e:	a8 04                	test   $0x4,%al
  100740:	ff 24 95 4c 3e 12 00 	jmp    *0x123e4c(,%edx,4)
        LOG_DBG("Bootstrap registration failure!");
  100747:	0f 84 82 01 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  10074d:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  100752:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  100757:	c1 e8 03             	shr    $0x3,%eax
  10075a:	c1 e0 06             	shl    $0x6,%eax
  10075d:	83 c8 04             	or     $0x4,%eax
  100760:	50                   	push   %eax
  100761:	68 92 47 12 00       	push   $0x124792
  100766:	68 a2 47 12 00       	push   $0x1247a2
  10076b:	e9 57 01 00 00       	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Bootstrap registration complete");
  100770:	0f 84 59 01 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  100776:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  10077b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  100780:	c1 e8 03             	shr    $0x3,%eax
  100783:	c1 e0 06             	shl    $0x6,%eax
  100786:	83 c8 04             	or     $0x4,%eax
  100789:	50                   	push   %eax
  10078a:	68 92 47 12 00       	push   $0x124792
  10078f:	68 c6 47 12 00       	push   $0x1247c6
  100794:	e9 2e 01 00 00       	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Bootstrap transfer complete");
  100799:	0f 84 30 01 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  10079f:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  1007a4:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  1007a9:	c1 e8 03             	shr    $0x3,%eax
  1007ac:	c1 e0 06             	shl    $0x6,%eax
  1007af:	83 c8 04             	or     $0x4,%eax
  1007b2:	50                   	push   %eax
  1007b3:	68 92 47 12 00       	push   $0x124792
  1007b8:	68 ea 47 12 00       	push   $0x1247ea
  1007bd:	e9 05 01 00 00       	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Registration failure!");
  1007c2:	0f 84 07 01 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  1007c8:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  1007cd:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  1007d2:	c1 e8 03             	shr    $0x3,%eax
  1007d5:	c1 e0 06             	shl    $0x6,%eax
  1007d8:	83 c8 04             	or     $0x4,%eax
  1007db:	50                   	push   %eax
  1007dc:	68 92 47 12 00       	push   $0x124792
  1007e1:	68 0a 48 12 00       	push   $0x12480a
  1007e6:	e9 dc 00 00 00       	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Registration complete");
  1007eb:	0f 84 de 00 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  1007f1:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  1007f6:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  1007fb:	c1 e8 03             	shr    $0x3,%eax
  1007fe:	c1 e0 06             	shl    $0x6,%eax
  100801:	83 c8 04             	or     $0x4,%eax
  100804:	50                   	push   %eax
  100805:	68 92 47 12 00       	push   $0x124792
  10080a:	68 24 48 12 00       	push   $0x124824
  10080f:	e9 b3 00 00 00       	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Registration update failure!");
  100814:	0f 84 b5 00 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  10081a:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  10081f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  100824:	c1 e8 03             	shr    $0x3,%eax
  100827:	c1 e0 06             	shl    $0x6,%eax
  10082a:	83 c8 04             	or     $0x4,%eax
  10082d:	50                   	push   %eax
  10082e:	68 92 47 12 00       	push   $0x124792
  100833:	68 3e 48 12 00       	push   $0x12483e
  100838:	e9 8a 00 00 00       	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Registration update complete");
  10083d:	0f 84 8c 00 00 00    	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  100843:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  100848:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  10084d:	c1 e8 03             	shr    $0x3,%eax
  100850:	c1 e0 06             	shl    $0x6,%eax
  100853:	83 c8 04             	or     $0x4,%eax
  100856:	50                   	push   %eax
  100857:	68 92 47 12 00       	push   $0x124792
  10085c:	68 5f 48 12 00       	push   $0x12485f
  100861:	eb 64                	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Deregister failure!");
  100863:	74 6a                	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  100865:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  10086a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  10086f:	c1 e8 03             	shr    $0x3,%eax
  100872:	c1 e0 06             	shl    $0x6,%eax
  100875:	83 c8 04             	or     $0x4,%eax
  100878:	50                   	push   %eax
  100879:	68 92 47 12 00       	push   $0x124792
  10087e:	68 80 48 12 00       	push   $0x124880
  100883:	eb 42                	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Disconnected");
  100885:	74 48                	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  100887:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  10088c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  100891:	c1 e8 03             	shr    $0x3,%eax
  100894:	c1 e0 06             	shl    $0x6,%eax
  100897:	83 c8 04             	or     $0x4,%eax
  10089a:	50                   	push   %eax
  10089b:	68 92 47 12 00       	push   $0x124792
  1008a0:	68 98 48 12 00       	push   $0x124898
  1008a5:	eb 20                	jmp    1008c7 <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a0>
        LOG_DBG("Queue mode RX window closed");
  1008a7:	74 26                	je     1008cf <_ZL15rd_client_eventP9lwm2m_ctx21lwm2m_rd_client_event+0x1a8>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  1008a9:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  1008ae:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  1008b3:	c1 e8 03             	shr    $0x3,%eax
  1008b6:	c1 e0 06             	shl    $0x6,%eax
  1008b9:	83 c8 04             	or     $0x4,%eax
  1008bc:	50                   	push   %eax
  1008bd:	68 92 47 12 00       	push   $0x124792
  1008c2:	68 a9 48 12 00       	push   $0x1248a9
  1008c7:	e8 aa 2c 00 00       	call   103576 <log_1>
  1008cc:	83 c4 0c             	add    $0xc,%esp
        break;
    }
}
  1008cf:	c9                   	leave  
  1008d0:	c3                   	ret    

001008d1 <main>:

void main()
{
  1008d1:	55                   	push   %ebp
  1008d2:	89 e5                	mov    %esp,%ebp
  1008d4:	53                   	push   %ebx
  1008d5:	81 ec 68 01 00 00    	sub    $0x168,%esp
    LOG_INF("Starting the C++ Client");
  1008db:	a1 9c 5b 14 00       	mov    0x145b9c,%eax
  1008e0:	83 e0 07             	and    $0x7,%eax
  1008e3:	83 f8 02             	cmp    $0x2,%eax
  1008e6:	76 20                	jbe    100908 <main+0x37>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  1008e8:	b8 b8 30 12 00       	mov    $0x1230b8,%eax
  1008ed:	2d b0 30 12 00       	sub    $0x1230b0,%eax
			sizeof(struct log_source_const_data);
  1008f2:	c1 e8 03             	shr    $0x3,%eax
  1008f5:	c1 e0 06             	shl    $0x6,%eax
  1008f8:	83 c8 03             	or     $0x3,%eax
  1008fb:	50                   	push   %eax
  1008fc:	68 c9 48 12 00       	push   $0x1248c9
  100901:	e8 47 2c 00 00       	call   10354d <log_0>
  100906:	59                   	pop    %ecx
  100907:	5b                   	pop    %ebx
    nx::lwm2m_context context(DEVICE_NAME);
  100908:	68 e1 48 12 00       	push   $0x1248e1
  10090d:	8d 9d 94 fe ff ff    	lea    -0x16c(%ebp),%ebx
  100913:	53                   	push   %ebx
  100914:	e8 05 fc ff ff       	call   10051e <_ZN2nx13lwm2m_contextC1EPKc>
  100919:	58                   	pop    %eax
  10091a:	5a                   	pop    %edx
    context.set_server_address(101, SERVER_ADDR);
  10091b:	68 6b 47 12 00       	push   $0x12476b
  100920:	6a 65                	push   $0x65
  100922:	53                   	push   %ebx
  100923:	e8 12 fc ff ff       	call   10053a <_ZN2nx13lwm2m_context18set_server_addressEtPKc>
  100928:	83 c4 0c             	add    $0xc,%esp
    context.start(0, rd_client_event);
  10092b:	68 27 07 10 00       	push   $0x100727
  100930:	6a 00                	push   $0x0
  100932:	53                   	push   %ebx
  100933:	e8 a6 fc ff ff       	call   1005de <_ZN2nx13lwm2m_context5startEjPFvP9lwm2m_ctx21lwm2m_rd_client_eventE>
  100938:	83 c4 0c             	add    $0xc,%esp
  10093b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10093e:	c9                   	leave  
  10093f:	c3                   	ret    

00100940 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
  100940:	80 e2 08             	and    $0x8,%dl
  100943:	74 0b                	je     100950 <foldcase+0x10>
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  100945:	8d 50 bf             	lea    -0x41(%eax),%edx
  100948:	83 fa 19             	cmp    $0x19,%edx
  10094b:	77 03                	ja     100950 <foldcase+0x10>
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
  10094d:	83 c0 20             	add    $0x20,%eax
        return tolower(ch);
    return ch;
}
  100950:	c3                   	ret    

00100951 <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
  100951:	55                   	push   %ebp
  100952:	89 e5                	mov    %esp,%ebp
  100954:	57                   	push   %edi
  100955:	56                   	push   %esi
  100956:	53                   	push   %ebx
  100957:	83 ec 1c             	sub    $0x1c,%esp
  10095a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
  10095d:	85 c0                	test   %eax,%eax
  10095f:	74 04                	je     100965 <fnmatchx+0x14>
  100961:	85 d2                	test   %edx,%edx
  100963:	75 0a                	jne    10096f <fnmatchx+0x1e>
    {
        return FNM_NOMATCH;
  100965:	b8 01 00 00 00       	mov    $0x1,%eax
  10096a:	e9 1b 03 00 00       	jmp    100c8a <fnmatchx+0x339>
  10096f:	89 c7                	mov    %eax,%edi
    }

    if (recursion-- == 0)
        return FNM_NORES;
  100971:	b8 03 00 00 00       	mov    $0x3,%eax
    if (recursion-- == 0)
  100976:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10097a:	0f 84 0a 03 00 00    	je     100c8a <fnmatchx+0x339>
  100980:	89 cb                	mov    %ecx,%ebx
  100982:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    for (stringstart = string;;) {
        switch (c = FOLDCASE(*pattern++, flags)) {
  100985:	8d 47 01             	lea    0x1(%edi),%eax
  100988:	89 da                	mov    %ebx,%edx
  10098a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10098d:	0f b6 07             	movzbl (%edi),%eax
  100990:	e8 ab ff ff ff       	call   100940 <foldcase>
  100995:	8a 16                	mov    (%esi),%dl
  100997:	0f be c8             	movsbl %al,%ecx
  10099a:	88 55 f3             	mov    %dl,-0xd(%ebp)
  10099d:	3c 3f                	cmp    $0x3f,%al
  10099f:	74 43                	je     1009e4 <fnmatchx+0x93>
  1009a1:	7f 12                	jg     1009b5 <fnmatchx+0x64>
  1009a3:	84 c0                	test   %al,%al
  1009a5:	74 23                	je     1009ca <fnmatchx+0x79>
  1009a7:	3c 2a                	cmp    $0x2a,%al
  1009a9:	0f 85 c2 02 00 00    	jne    100c71 <fnmatchx+0x320>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
                return FNM_NOMATCH;
            ++string;
            break;
        case '*':
            c = FOLDCASE(*pattern, flags);
  1009af:	0f b6 47 01          	movzbl 0x1(%edi),%eax
  1009b3:	eb 75                	jmp    100a2a <fnmatchx+0xd9>
        switch (c = FOLDCASE(*pattern++, flags)) {
  1009b5:	3c 5b                	cmp    $0x5b,%al
  1009b7:	0f 84 3d 01 00 00    	je     100afa <fnmatchx+0x1a9>
  1009bd:	3c 5c                	cmp    $0x5c,%al
  1009bf:	0f 84 8f 02 00 00    	je     100c54 <fnmatchx+0x303>
  1009c5:	e9 a7 02 00 00       	jmp    100c71 <fnmatchx+0x320>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  1009ca:	80 e3 10             	and    $0x10,%bl
  1009cd:	74 0c                	je     1009db <fnmatchx+0x8a>
                return 0;
  1009cf:	31 c0                	xor    %eax,%eax
            if ((flags & FNM_LEADING_DIR) && *string == '/')
  1009d1:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
  1009d5:	0f 84 af 02 00 00    	je     100c8a <fnmatchx+0x339>
            return *string == EOS ? 0 : FNM_NOMATCH;
  1009db:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  1009df:	e9 a5 00 00 00       	jmp    100a89 <fnmatchx+0x138>
            if (*string == EOS)
  1009e4:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  1009e8:	0f 84 77 ff ff ff    	je     100965 <fnmatchx+0x14>
            if (*string == '/' && (flags & FNM_PATHNAME))
  1009ee:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
  1009f2:	75 0a                	jne    1009fe <fnmatchx+0xad>
  1009f4:	f6 c3 02             	test   $0x2,%bl
  1009f7:	74 28                	je     100a21 <fnmatchx+0xd0>
  1009f9:	e9 67 ff ff ff       	jmp    100965 <fnmatchx+0x14>
            if (*string == '.' && (flags & FNM_PERIOD) &&
  1009fe:	80 7d f3 2e          	cmpb   $0x2e,-0xd(%ebp)
  100a02:	75 1d                	jne    100a21 <fnmatchx+0xd0>
  100a04:	f6 c3 04             	test   $0x4,%bl
  100a07:	74 18                	je     100a21 <fnmatchx+0xd0>
  100a09:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  100a0c:	0f 84 53 ff ff ff    	je     100965 <fnmatchx+0x14>
                (string == stringstart ||
  100a12:	f6 c3 02             	test   $0x2,%bl
  100a15:	74 0a                	je     100a21 <fnmatchx+0xd0>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
  100a17:	80 7e ff 2f          	cmpb   $0x2f,-0x1(%esi)
  100a1b:	0f 84 44 ff ff ff    	je     100965 <fnmatchx+0x14>
            ++string;
  100a21:	46                   	inc    %esi
                if (*string != '[')
                    return FNM_NOMATCH;
            } else
                pattern = r;
            ++string;
            break;
  100a22:	8b 7d ec             	mov    -0x14(%ebp),%edi
  100a25:	e9 5b ff ff ff       	jmp    100985 <fnmatchx+0x34>
                c = FOLDCASE(*++pattern, flags);
  100a2a:	89 da                	mov    %ebx,%edx
  100a2c:	e8 0f ff ff ff       	call   100940 <foldcase>
            while (c == '*')
  100a31:	3c 2a                	cmp    $0x2a,%al
  100a33:	75 0b                	jne    100a40 <fnmatchx+0xef>
                c = FOLDCASE(*++pattern, flags);
  100a35:	ff 45 ec             	incl   -0x14(%ebp)
  100a38:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100a3b:	0f b6 00             	movzbl (%eax),%eax
  100a3e:	eb ea                	jmp    100a2a <fnmatchx+0xd9>
            if (*string == '.' && (flags & FNM_PERIOD) &&
  100a40:	80 7d f3 2e          	cmpb   $0x2e,-0xd(%ebp)
  100a44:	75 1d                	jne    100a63 <fnmatchx+0x112>
  100a46:	f6 c3 04             	test   $0x4,%bl
  100a49:	74 18                	je     100a63 <fnmatchx+0x112>
  100a4b:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  100a4e:	0f 84 11 ff ff ff    	je     100965 <fnmatchx+0x14>
                (string == stringstart ||
  100a54:	f6 c3 02             	test   $0x2,%bl
  100a57:	74 0a                	je     100a63 <fnmatchx+0x112>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
  100a59:	80 7e ff 2f          	cmpb   $0x2f,-0x1(%esi)
  100a5d:	0f 84 02 ff ff ff    	je     100965 <fnmatchx+0x14>
            if (c == EOS) {
  100a63:	84 c0                	test   %al,%al
  100a65:	75 2d                	jne    100a94 <fnmatchx+0x143>
                if (flags & FNM_PATHNAME)
  100a67:	89 d8                	mov    %ebx,%eax
  100a69:	83 e0 02             	and    $0x2,%eax
  100a6c:	0f 84 18 02 00 00    	je     100c8a <fnmatchx+0x339>
                return 0;
  100a72:	31 c0                	xor    %eax,%eax
                        0 : FNM_NOMATCH;
  100a74:	80 e3 10             	and    $0x10,%bl
  100a77:	0f 85 0d 02 00 00    	jne    100c8a <fnmatchx+0x339>
                        strchr(string, '/') == NULL ?
  100a7d:	6a 2f                	push   $0x2f
  100a7f:	56                   	push   %esi
  100a80:	e8 5d b2 00 00       	call   10bce2 <strchr>
  100a85:	5f                   	pop    %edi
                        0 : FNM_NOMATCH;
  100a86:	85 c0                	test   %eax,%eax
                        strchr(string, '/') == NULL ?
  100a88:	5a                   	pop    %edx
                        0 : FNM_NOMATCH;
  100a89:	0f 95 c0             	setne  %al
  100a8c:	0f b6 c0             	movzbl %al,%eax
  100a8f:	e9 f6 01 00 00       	jmp    100c8a <fnmatchx+0x339>
            } else if (c == '/' && flags & FNM_PATHNAME) {
  100a94:	3c 2f                	cmp    $0x2f,%al
  100a96:	75 43                	jne    100adb <fnmatchx+0x18a>
  100a98:	f6 c3 02             	test   $0x2,%bl
  100a9b:	74 3e                	je     100adb <fnmatchx+0x18a>
                if ((string = strchr(string, '/')) == NULL)
  100a9d:	6a 2f                	push   $0x2f
  100a9f:	56                   	push   %esi
  100aa0:	e8 3d b2 00 00       	call   10bce2 <strchr>
  100aa5:	59                   	pop    %ecx
  100aa6:	85 c0                	test   %eax,%eax
  100aa8:	5e                   	pop    %esi
  100aa9:	89 c6                	mov    %eax,%esi
  100aab:	0f 85 71 ff ff ff    	jne    100a22 <fnmatchx+0xd1>
  100ab1:	e9 af fe ff ff       	jmp    100965 <fnmatchx+0x14>
    if (recursion-- == 0)
  100ab6:	8b 45 08             	mov    0x8(%ebp),%eax
                switch ((e = fnmatchx(pattern, string,
  100ab9:	89 d9                	mov    %ebx,%ecx
    if (recursion-- == 0)
  100abb:	48                   	dec    %eax
                switch ((e = fnmatchx(pattern, string,
  100abc:	83 e1 fb             	and    $0xfffffffb,%ecx
  100abf:	50                   	push   %eax
  100ac0:	89 f2                	mov    %esi,%edx
  100ac2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100ac5:	e8 87 fe ff ff       	call   100951 <fnmatchx>
  100aca:	5a                   	pop    %edx
  100acb:	83 f8 01             	cmp    $0x1,%eax
  100ace:	0f 85 b6 01 00 00    	jne    100c8a <fnmatchx+0x339>
                if (test == '/' && flags & FNM_PATHNAME)
  100ad4:	89 f8                	mov    %edi,%eax
  100ad6:	3c 2f                	cmp    $0x2f,%al
  100ad8:	74 16                	je     100af0 <fnmatchx+0x19f>
                ++string;
  100ada:	46                   	inc    %esi
            while ((test = FOLDCASE(*string, flags)) != EOS) {
  100adb:	0f b6 06             	movzbl (%esi),%eax
  100ade:	89 da                	mov    %ebx,%edx
  100ae0:	e8 5b fe ff ff       	call   100940 <foldcase>
  100ae5:	89 c7                	mov    %eax,%edi
  100ae7:	84 c0                	test   %al,%al
  100ae9:	75 cb                	jne    100ab6 <fnmatchx+0x165>
  100aeb:	e9 75 fe ff ff       	jmp    100965 <fnmatchx+0x14>
                if (test == '/' && flags & FNM_PATHNAME)
  100af0:	f6 c3 02             	test   $0x2,%bl
  100af3:	74 e5                	je     100ada <fnmatchx+0x189>
  100af5:	e9 6b fe ff ff       	jmp    100965 <fnmatchx+0x14>
            if (*string == EOS)
  100afa:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  100afe:	0f 84 61 fe ff ff    	je     100965 <fnmatchx+0x14>
            if (*string == '/' && flags & FNM_PATHNAME)
  100b04:	80 7d f3 2f          	cmpb   $0x2f,-0xd(%ebp)
  100b08:	75 09                	jne    100b13 <fnmatchx+0x1c2>
  100b0a:	f6 c3 02             	test   $0x2,%bl
  100b0d:	0f 85 52 fe ff ff    	jne    100965 <fnmatchx+0x14>
            if ((r = rangematch(pattern,
  100b13:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  100b17:	89 da                	mov    %ebx,%edx
  100b19:	e8 22 fe ff ff       	call   100940 <foldcase>
    if (pattern == NULL)
  100b1e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
            if ((r = rangematch(pattern,
  100b22:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (pattern == NULL)
  100b25:	0f 84 3a fe ff ff    	je     100965 <fnmatchx+0x14>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
  100b2b:	8a 47 01             	mov    0x1(%edi),%al
  100b2e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  100b31:	3c 21                	cmp    $0x21,%al
  100b33:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100b36:	0f 94 c2             	sete   %dl
  100b39:	3c 5e                	cmp    $0x5e,%al
  100b3b:	0f 94 c0             	sete   %al
  100b3e:	08 c2                	or     %al,%dl
  100b40:	88 55 f1             	mov    %dl,-0xf(%ebp)
  100b43:	74 06                	je     100b4b <fnmatchx+0x1fa>
        ++pattern;
  100b45:	8d 47 02             	lea    0x2(%edi),%eax
  100b48:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100b4b:	89 d8                	mov    %ebx,%eax
            ok = 1;
  100b4d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100b54:	83 e0 01             	and    $0x1,%eax
            ok = 1;
  100b57:	31 ff                	xor    %edi,%edi
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100b59:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
  100b5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100b5f:	89 da                	mov    %ebx,%edx
  100b61:	8d 48 01             	lea    0x1(%eax),%ecx
  100b64:	0f b6 00             	movzbl (%eax),%eax
  100b67:	e8 d4 fd ff ff       	call   100940 <foldcase>
  100b6c:	88 45 f2             	mov    %al,-0xe(%ebp)
  100b6f:	3c 5d                	cmp    $0x5d,%al
  100b71:	0f 84 a8 00 00 00    	je     100c1f <fnmatchx+0x2ce>
        if (c == '/')
  100b77:	3c 2f                	cmp    $0x2f,%al
  100b79:	0f 84 bf 00 00 00    	je     100c3e <fnmatchx+0x2ed>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
  100b7f:	3c 5c                	cmp    $0x5c,%al
  100b81:	75 1a                	jne    100b9d <fnmatchx+0x24c>
  100b83:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  100b87:	75 1e                	jne    100ba7 <fnmatchx+0x256>
            c = FOLDCASE(*pattern++, flags);
  100b89:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100b8c:	89 da                	mov    %ebx,%edx
  100b8e:	8d 48 02             	lea    0x2(%eax),%ecx
  100b91:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  100b95:	e8 a6 fd ff ff       	call   100940 <foldcase>
  100b9a:	88 45 f2             	mov    %al,-0xe(%ebp)
        if (c == EOS)
  100b9d:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  100ba1:	0f 84 be fd ff ff    	je     100965 <fnmatchx+0x14>
        if (*pattern == '-' 
  100ba7:	80 39 2d             	cmpb   $0x2d,(%ecx)
  100baa:	75 56                	jne    100c02 <fnmatchx+0x2b1>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
  100bac:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
  100bb0:	89 da                	mov    %ebx,%edx
  100bb2:	e8 89 fd ff ff       	call   100940 <foldcase>
  100bb7:	88 45 dc             	mov    %al,-0x24(%ebp)
  100bba:	3c 5d                	cmp    $0x5d,%al
  100bbc:	74 44                	je     100c02 <fnmatchx+0x2b1>
  100bbe:	84 c0                	test   %al,%al
  100bc0:	74 40                	je     100c02 <fnmatchx+0x2b1>
            pattern += 2;
  100bc2:	8d 51 02             	lea    0x2(%ecx),%edx
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
  100bc5:	3c 5c                	cmp    $0x5c,%al
            pattern += 2;
  100bc7:	89 55 e8             	mov    %edx,-0x18(%ebp)
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
  100bca:	75 22                	jne    100bee <fnmatchx+0x29d>
  100bcc:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  100bd0:	75 1c                	jne    100bee <fnmatchx+0x29d>
                c2 = FOLDCASE(*pattern++, flags);
  100bd2:	8d 41 03             	lea    0x3(%ecx),%eax
  100bd5:	89 da                	mov    %ebx,%edx
  100bd7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100bda:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  100bde:	e8 5d fd ff ff       	call   100940 <foldcase>
  100be3:	88 45 dc             	mov    %al,-0x24(%ebp)
            if (c2 == EOS)
  100be6:	84 c0                	test   %al,%al
  100be8:	0f 84 77 fd ff ff    	je     100965 <fnmatchx+0x14>
            if (c <= test && test <= c2)
  100bee:	0f be 45 f2          	movsbl -0xe(%ebp),%eax
  100bf2:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  100bf5:	7c 1c                	jl     100c13 <fnmatchx+0x2c2>
  100bf7:	0f be 55 dc          	movsbl -0x24(%ebp),%edx
  100bfb:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  100bfe:	7f 13                	jg     100c13 <fnmatchx+0x2c2>
  100c00:	eb 0c                	jmp    100c0e <fnmatchx+0x2bd>
        } else if (c == test)
  100c02:	0f be 45 f2          	movsbl -0xe(%ebp),%eax
  100c06:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100c09:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  100c0c:	75 05                	jne    100c13 <fnmatchx+0x2c2>
            ok = 1;
  100c0e:	bf 01 00 00 00       	mov    $0x1,%edi
  100c13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  100c1a:	e9 3d ff ff ff       	jmp    100b5c <fnmatchx+0x20b>
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
  100c1f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  100c23:	75 82                	jne    100ba7 <fnmatchx+0x256>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
  100c25:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
            if ((r = rangematch(pattern,
  100c29:	39 f8                	cmp    %edi,%eax
  100c2b:	0f 84 34 fd ff ff    	je     100965 <fnmatchx+0x14>
  100c31:	85 c9                	test   %ecx,%ecx
  100c33:	0f 84 2c fd ff ff    	je     100965 <fnmatchx+0x14>
            if (r == (void *)-1) {
  100c39:	83 f9 ff             	cmp    $0xffffffff,%ecx
  100c3c:	75 0d                	jne    100c4b <fnmatchx+0x2fa>
                if (*string != '[')
  100c3e:	80 7d f3 5b          	cmpb   $0x5b,-0xd(%ebp)
  100c42:	0f 85 1d fd ff ff    	jne    100965 <fnmatchx+0x14>
  100c48:	8b 4d ec             	mov    -0x14(%ebp),%ecx
            ++string;
  100c4b:	46                   	inc    %esi
            break;
  100c4c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  100c4f:	e9 ce fd ff ff       	jmp    100a22 <fnmatchx+0xd1>
        case '\\':
            if (!(flags & FNM_NOESCAPE)) {
  100c54:	f6 c3 01             	test   $0x1,%bl
  100c57:	75 18                	jne    100c71 <fnmatchx+0x320>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
  100c59:	0f b6 47 01          	movzbl 0x1(%edi),%eax
  100c5d:	89 da                	mov    %ebx,%edx
  100c5f:	e8 dc fc ff ff       	call   100940 <foldcase>
  100c64:	0f be c8             	movsbl %al,%ecx
  100c67:	84 c0                	test   %al,%al
  100c69:	74 06                	je     100c71 <fnmatchx+0x320>
  100c6b:	8d 47 02             	lea    0x2(%edi),%eax
  100c6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    --pattern;
                }
            }
            /* FALLTHROUGH */
        default:
            if (c != FOLDCASE(*string++, flags))
  100c71:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  100c75:	89 da                	mov    %ebx,%edx
  100c77:	46                   	inc    %esi
  100c78:	e8 c3 fc ff ff       	call   100940 <foldcase>
  100c7d:	39 c1                	cmp    %eax,%ecx
  100c7f:	0f 84 9d fd ff ff    	je     100a22 <fnmatchx+0xd1>
  100c85:	e9 db fc ff ff       	jmp    100965 <fnmatchx+0x14>
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
  100c8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100c8d:	5b                   	pop    %ebx
  100c8e:	5e                   	pop    %esi
  100c8f:	5f                   	pop    %edi
  100c90:	5d                   	pop    %ebp
  100c91:	c3                   	ret    

00100c92 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
  100c92:	55                   	push   %ebp
  100c93:	89 e5                	mov    %esp,%ebp
  100c95:	8b 45 08             	mov    0x8(%ebp),%eax
    return fnmatchx(pattern, string, flags, 64);
  100c98:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100c9b:	8b 55 0c             	mov    0xc(%ebp),%edx
  100c9e:	c7 45 08 40 00 00 00 	movl   $0x40,0x8(%ebp)
}
  100ca5:	5d                   	pop    %ebp
    return fnmatchx(pattern, string, flags, 64);
  100ca6:	e9 a6 fc ff ff       	jmp    100951 <fnmatchx>

00100cab <_check_fd>:
	errno = ENFILE;
	return -1;
}

static int _check_fd(int fd)
{
  100cab:	55                   	push   %ebp
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
  100cac:	83 f8 03             	cmp    $0x3,%eax
{
  100caf:	89 e5                	mov    %esp,%ebp
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
  100cb1:	77 0f                	ja     100cc2 <_check_fd+0x17>
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  100cb3:	6b c0 0c             	imul   $0xc,%eax,%eax
  100cb6:	8b 90 08 a2 12 00    	mov    0x12a208(%eax),%edx
	if (!atomic_get(&fdtable[fd].refcount)) {
		errno = EBADF;
		return -1;
	}

	return 0;
  100cbc:	31 c0                	xor    %eax,%eax
	if (!atomic_get(&fdtable[fd].refcount)) {
  100cbe:	85 d2                	test   %edx,%edx
  100cc0:	75 0e                	jne    100cd0 <_check_fd+0x25>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
  100cc2:	e8 9e f7 01 00       	call   120465 <z_impl_z_errno>
		errno = EBADF;
  100cc7:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
  100ccd:	83 c8 ff             	or     $0xffffffff,%eax
}
  100cd0:	5d                   	pop    %ebp
  100cd1:	c3                   	ret    

00100cd2 <z_get_fd_obj_and_vtable>:

	return fd_entry->obj;
}

void *z_get_fd_obj_and_vtable(int fd, const struct fd_op_vtable **vtable)
{
  100cd2:	55                   	push   %ebp
  100cd3:	89 e5                	mov    %esp,%ebp
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
  100cd5:	8b 45 08             	mov    0x8(%ebp),%eax
  100cd8:	e8 ce ff ff ff       	call   100cab <_check_fd>
  100cdd:	89 c2                	mov    %eax,%edx
  100cdf:	31 c0                	xor    %eax,%eax
  100ce1:	85 d2                	test   %edx,%edx
  100ce3:	78 15                	js     100cfa <z_get_fd_obj_and_vtable+0x28>
		return NULL;
	}

	fd_entry = &fdtable[fd];
	*vtable = fd_entry->vtable;
  100ce5:	6b 45 08 0c          	imul   $0xc,0x8(%ebp),%eax
  100ce9:	8b 55 0c             	mov    0xc(%ebp),%edx
  100cec:	8b 88 04 a2 12 00    	mov    0x12a204(%eax),%ecx
  100cf2:	89 0a                	mov    %ecx,(%edx)

	return fd_entry->obj;
  100cf4:	8b 80 00 a2 12 00    	mov    0x12a200(%eax),%eax
}
  100cfa:	5d                   	pop    %ebp
  100cfb:	c3                   	ret    

00100cfc <z_reserve_fd>:

int z_reserve_fd(void)
{
  100cfc:	55                   	push   %ebp
  100cfd:	89 e5                	mov    %esp,%ebp
  100cff:	53                   	push   %ebx
	return z_impl_k_mutex_lock(mutex, timeout);
  100d00:	6a ff                	push   $0xffffffff
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  100d02:	31 db                	xor    %ebx,%ebx
  100d04:	6a ff                	push   $0xffffffff
  100d06:	68 cc 5c 14 00       	push   $0x145ccc
  100d0b:	e8 c0 fe 01 00       	call   120bd0 <z_impl_k_mutex_lock>
  100d10:	83 c4 0c             	add    $0xc,%esp
  100d13:	b8 08 a2 12 00       	mov    $0x12a208,%eax
  100d18:	8b 10                	mov    (%eax),%edx
		if (!atomic_get(&fdtable[fd].refcount)) {
  100d1a:	85 d2                	test   %edx,%edx
  100d1c:	74 19                	je     100d37 <z_reserve_fd+0x3b>
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
  100d1e:	43                   	inc    %ebx
  100d1f:	83 c0 0c             	add    $0xc,%eax
  100d22:	83 fb 04             	cmp    $0x4,%ebx
  100d25:	75 f1                	jne    100d18 <z_reserve_fd+0x1c>
  100d27:	e8 39 f7 01 00       	call   120465 <z_impl_z_errno>
	return -1;
  100d2c:	83 cb ff             	or     $0xffffffff,%ebx
	errno = ENFILE;
  100d2f:	c7 00 17 00 00 00    	movl   $0x17,(%eax)
	int fd;

	(void)k_mutex_lock(&fdtable_lock, K_FOREVER);

	fd = _find_fd_entry();
	if (fd >= 0) {
  100d35:	eb 1a                	jmp    100d51 <z_reserve_fd+0x55>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  100d37:	f0 ff 00             	lock incl (%eax)
		/* Mark entry as used, z_finalize_fd() will fill it in. */
		(void)z_fd_ref(fd);
		fdtable[fd].obj = NULL;
  100d3a:	6b c3 0c             	imul   $0xc,%ebx,%eax
  100d3d:	c7 80 00 a2 12 00 00 	movl   $0x0,0x12a200(%eax)
  100d44:	00 00 00 
		fdtable[fd].vtable = NULL;
  100d47:	c7 80 04 a2 12 00 00 	movl   $0x0,0x12a204(%eax)
  100d4e:	00 00 00 
	return z_impl_k_mutex_unlock(mutex);
  100d51:	68 cc 5c 14 00       	push   $0x145ccc
  100d56:	e8 73 ff 01 00       	call   120cce <z_impl_k_mutex_unlock>
  100d5b:	58                   	pop    %eax
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
  100d5c:	89 d8                	mov    %ebx,%eax
  100d5e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  100d61:	c9                   	leave  
  100d62:	c3                   	ret    

00100d63 <z_finalize_fd>:

void z_finalize_fd(int fd, void *obj, const struct fd_op_vtable *vtable)
{
  100d63:	55                   	push   %ebp
  100d64:	89 e5                	mov    %esp,%ebp
	 * This call is a no-op if obj is invalid or points to something
	 * not a kernel object.
	 */
	z_object_recycle(obj);
#endif
	fdtable[fd].obj = obj;
  100d66:	6b 45 08 0c          	imul   $0xc,0x8(%ebp),%eax
  100d6a:	8b 55 0c             	mov    0xc(%ebp),%edx
  100d6d:	89 90 00 a2 12 00    	mov    %edx,0x12a200(%eax)
	fdtable[fd].vtable = vtable;
  100d73:	8b 55 10             	mov    0x10(%ebp),%edx
  100d76:	89 90 04 a2 12 00    	mov    %edx,0x12a204(%eax)
}
  100d7c:	5d                   	pop    %ebp
  100d7d:	c3                   	ret    

00100d7e <z_free_fd>:

void z_free_fd(int fd)
{
  100d7e:	55                   	push   %ebp
  100d7f:	89 e5                	mov    %esp,%ebp
  100d81:	56                   	push   %esi
  100d82:	53                   	push   %ebx
  100d83:	8b 55 08             	mov    0x8(%ebp),%edx
		old_rc = atomic_get(&fdtable[fd].refcount);
  100d86:	6b ca 0c             	imul   $0xc,%edx,%ecx
  100d89:	81 c1 08 a2 12 00    	add    $0x12a208,%ecx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  100d8f:	8b 19                	mov    (%ecx),%ebx
		if (!old_rc) {
  100d91:	85 db                	test   %ebx,%ebx
  100d93:	74 25                	je     100dba <z_free_fd+0x3c>
	} while (!atomic_cas(&fdtable[fd].refcount, old_rc, old_rc - 1));
  100d95:	8d 73 ff             	lea    -0x1(%ebx),%esi
	return __atomic_compare_exchange_n(target, &old_value, new_value,
  100d98:	89 d8                	mov    %ebx,%eax
  100d9a:	f0 0f b1 31          	lock cmpxchg %esi,(%ecx)
  100d9e:	75 ef                	jne    100d8f <z_free_fd+0x11>
	if (old_rc != 1) {
  100da0:	4b                   	dec    %ebx
  100da1:	75 17                	jne    100dba <z_free_fd+0x3c>
	fdtable[fd].obj = NULL;
  100da3:	6b d2 0c             	imul   $0xc,%edx,%edx
  100da6:	c7 82 00 a2 12 00 00 	movl   $0x0,0x12a200(%edx)
  100dad:	00 00 00 
	fdtable[fd].vtable = NULL;
  100db0:	c7 82 04 a2 12 00 00 	movl   $0x0,0x12a204(%edx)
  100db7:	00 00 00 
	/* Assumes fd was already bounds-checked. */
	(void)z_fd_unref(fd);
}
  100dba:	5b                   	pop    %ebx
  100dbb:	5e                   	pop    %esi
  100dbc:	5d                   	pop    %ebp
  100dbd:	c3                   	ret    

00100dbe <char2hex>:
#include <zephyr/types.h>
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, uint8_t *x)
{
  100dbe:	55                   	push   %ebp
  100dbf:	89 e5                	mov    %esp,%ebp
  100dc1:	53                   	push   %ebx
  100dc2:	8b 45 08             	mov    0x8(%ebp),%eax
  100dc5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if (c >= '0' && c <= '9') {
  100dc8:	8d 50 d0             	lea    -0x30(%eax),%edx
  100dcb:	80 fa 09             	cmp    $0x9,%dl
  100dce:	77 04                	ja     100dd4 <char2hex+0x16>
		*x = c - '0';
  100dd0:	88 11                	mov    %dl,(%ecx)
  100dd2:	eb 1f                	jmp    100df3 <char2hex+0x35>
	} else if (c >= 'a' && c <= 'f') {
  100dd4:	8d 50 9f             	lea    -0x61(%eax),%edx
  100dd7:	80 fa 05             	cmp    $0x5,%dl
  100dda:	77 05                	ja     100de1 <char2hex+0x23>
		*x = c - 'a' + 10;
  100ddc:	83 e8 57             	sub    $0x57,%eax
  100ddf:	eb 10                	jmp    100df1 <char2hex+0x33>
	} else if (c >= 'A' && c <= 'F') {
  100de1:	8d 58 bf             	lea    -0x41(%eax),%ebx
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
  100de4:	ba ea ff ff ff       	mov    $0xffffffea,%edx
	} else if (c >= 'A' && c <= 'F') {
  100de9:	80 fb 05             	cmp    $0x5,%bl
  100dec:	77 07                	ja     100df5 <char2hex+0x37>
		*x = c - 'A' + 10;
  100dee:	83 e8 37             	sub    $0x37,%eax
  100df1:	88 01                	mov    %al,(%ecx)
	}

	return 0;
  100df3:	31 d2                	xor    %edx,%edx
}
  100df5:	5b                   	pop    %ebx
  100df6:	89 d0                	mov    %edx,%eax
  100df8:	5d                   	pop    %ebp
  100df9:	c3                   	ret    

00100dfa <hex2bin>:
	hex[2 * buflen] = '\0';
	return 2 * buflen;
}

size_t hex2bin(const char *hex, size_t hexlen, uint8_t *buf, size_t buflen)
{
  100dfa:	55                   	push   %ebp
  100dfb:	89 e5                	mov    %esp,%ebp
  100dfd:	57                   	push   %edi
  100dfe:	56                   	push   %esi
  100dff:	53                   	push   %ebx
  100e00:	83 ec 08             	sub    $0x8,%esp
  100e03:	8b 45 0c             	mov    0xc(%ebp),%eax
  100e06:	8b 5d 10             	mov    0x10(%ebp),%ebx
	uint8_t dec;

	if (buflen < hexlen / 2 + hexlen % 2) {
  100e09:	89 c2                	mov    %eax,%edx
  100e0b:	83 e0 01             	and    $0x1,%eax
  100e0e:	d1 ea                	shr    %edx
  100e10:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100e13:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  100e16:	3b 7d 14             	cmp    0x14(%ebp),%edi
  100e19:	76 04                	jbe    100e1f <hex2bin+0x25>
		return 0;
  100e1b:	31 ff                	xor    %edi,%edi
  100e1d:	eb 6b                	jmp    100e8a <hex2bin+0x90>
	}

	/* if hexlen is uneven, insert leading zero nibble */
	if (hexlen % 2) {
  100e1f:	85 c0                	test   %eax,%eax
  100e21:	74 1f                	je     100e42 <hex2bin+0x48>
		if (char2hex(hex[0], &dec) < 0) {
  100e23:	8d 45 f3             	lea    -0xd(%ebp),%eax
  100e26:	50                   	push   %eax
  100e27:	8b 45 08             	mov    0x8(%ebp),%eax
  100e2a:	0f be 00             	movsbl (%eax),%eax
  100e2d:	50                   	push   %eax
  100e2e:	e8 8b ff ff ff       	call   100dbe <char2hex>
  100e33:	5e                   	pop    %esi
  100e34:	85 c0                	test   %eax,%eax
  100e36:	5a                   	pop    %edx
  100e37:	78 e2                	js     100e1b <hex2bin+0x21>
			return 0;
		}
		buf[0] = dec;
		hex++;
  100e39:	ff 45 08             	incl   0x8(%ebp)
		buf[0] = dec;
  100e3c:	8a 45 f3             	mov    -0xd(%ebp),%al
  100e3f:	88 03                	mov    %al,(%ebx)
		buf++;
  100e41:	43                   	inc    %ebx
	}

	/* regular hex conversion */
	for (size_t i = 0; i < hexlen / 2; i++) {
  100e42:	31 f6                	xor    %esi,%esi
  100e44:	39 75 ec             	cmp    %esi,-0x14(%ebp)
  100e47:	74 41                	je     100e8a <hex2bin+0x90>
		if (char2hex(hex[2 * i], &dec) < 0) {
  100e49:	8d 4d f3             	lea    -0xd(%ebp),%ecx
  100e4c:	8b 45 08             	mov    0x8(%ebp),%eax
  100e4f:	51                   	push   %ecx
  100e50:	0f be 04 70          	movsbl (%eax,%esi,2),%eax
  100e54:	50                   	push   %eax
  100e55:	e8 64 ff ff ff       	call   100dbe <char2hex>
  100e5a:	5a                   	pop    %edx
  100e5b:	85 c0                	test   %eax,%eax
  100e5d:	59                   	pop    %ecx
  100e5e:	78 bb                	js     100e1b <hex2bin+0x21>
			return 0;
		}
		buf[i] = dec << 4;
  100e60:	8a 45 f3             	mov    -0xd(%ebp),%al

		if (char2hex(hex[2 * i + 1], &dec) < 0) {
  100e63:	8d 4d f3             	lea    -0xd(%ebp),%ecx
		buf[i] = dec << 4;
  100e66:	c1 e0 04             	shl    $0x4,%eax
  100e69:	88 04 33             	mov    %al,(%ebx,%esi,1)
		if (char2hex(hex[2 * i + 1], &dec) < 0) {
  100e6c:	8b 45 08             	mov    0x8(%ebp),%eax
  100e6f:	51                   	push   %ecx
  100e70:	0f be 44 70 01       	movsbl 0x1(%eax,%esi,2),%eax
  100e75:	50                   	push   %eax
  100e76:	e8 43 ff ff ff       	call   100dbe <char2hex>
  100e7b:	5a                   	pop    %edx
  100e7c:	85 c0                	test   %eax,%eax
  100e7e:	59                   	pop    %ecx
  100e7f:	78 9a                	js     100e1b <hex2bin+0x21>
			return 0;
		}
		buf[i] += dec;
  100e81:	8a 45 f3             	mov    -0xd(%ebp),%al
  100e84:	00 04 33             	add    %al,(%ebx,%esi,1)
	for (size_t i = 0; i < hexlen / 2; i++) {
  100e87:	46                   	inc    %esi
  100e88:	eb ba                	jmp    100e44 <hex2bin+0x4a>
	}

	return hexlen / 2 + hexlen % 2;
}
  100e8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100e8d:	89 f8                	mov    %edi,%eax
  100e8f:	5b                   	pop    %ebx
  100e90:	5e                   	pop    %esi
  100e91:	5f                   	pop    %edi
  100e92:	5d                   	pop    %ebp
  100e93:	c3                   	ret    

00100e94 <print_digits>:
}
#endif /* CONFIG_PRINTK */

static void print_digits(out_func_t out, void *ctx, printk_val_t num, unsigned int base,
			 bool pad_before, char pad_char, int min_width)
{
  100e94:	57                   	push   %edi
  100e95:	8d 7c 24 08          	lea    0x8(%esp),%edi
  100e99:	83 e4 f8             	and    $0xfffffff8,%esp
  100e9c:	89 f9                	mov    %edi,%ecx
  100e9e:	ff 77 fc             	pushl  -0x4(%edi)
  100ea1:	55                   	push   %ebp
  100ea2:	89 e5                	mov    %esp,%ebp
  100ea4:	57                   	push   %edi
  100ea5:	56                   	push   %esi
  100ea6:	53                   	push   %ebx
	char buf[DIGITS_BUFLEN];
	unsigned int i;

	/* Print it backwards into the end of the buffer, low digits first */
	for (i = DIGITS_BUFLEN - 1U; num != 0U; i--) {
  100ea7:	bb 14 00 00 00       	mov    $0x14,%ebx
{
  100eac:	83 ec 3c             	sub    $0x3c,%esp
  100eaf:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100eb2:	8b 41 08             	mov    0x8(%ecx),%eax
  100eb5:	8b 37                	mov    (%edi),%esi
  100eb7:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100eba:	8b 41 14             	mov    0x14(%ecx),%eax
  100ebd:	89 45 bc             	mov    %eax,-0x44(%ebp)
  100ec0:	8a 41 0c             	mov    0xc(%ecx),%al
  100ec3:	88 45 c6             	mov    %al,-0x3a(%ebp)
  100ec6:	8a 41 10             	mov    0x10(%ecx),%al
  100ec9:	89 55 c8             	mov    %edx,-0x38(%ebp)
  100ecc:	8b 7f 04             	mov    0x4(%edi),%edi
  100ecf:	88 45 c7             	mov    %al,-0x39(%ebp)
	for (i = DIGITS_BUFLEN - 1U; num != 0U; i--) {
  100ed2:	89 f8                	mov    %edi,%eax
  100ed4:	09 f0                	or     %esi,%eax
  100ed6:	74 29                	je     100f01 <print_digits+0x6d>
		buf[i] = "0123456789abcdef"[num % base];
  100ed8:	8d 45 d0             	lea    -0x30(%ebp),%eax
  100edb:	31 d2                	xor    %edx,%edx
  100edd:	50                   	push   %eax
  100ede:	8b 45 c0             	mov    -0x40(%ebp),%eax
  100ee1:	52                   	push   %edx
  100ee2:	50                   	push   %eax
  100ee3:	57                   	push   %edi
  100ee4:	56                   	push   %esi
  100ee5:	e8 46 f4 ff ff       	call   100330 <__udivmoddi4>
  100eea:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  100eed:	83 c4 14             	add    $0x14,%esp
		num /= base;
  100ef0:	89 c6                	mov    %eax,%esi
  100ef2:	89 d7                	mov    %edx,%edi
		buf[i] = "0123456789abcdef"[num % base];
  100ef4:	8a 89 fe 48 12 00    	mov    0x1248fe(%ecx),%cl
  100efa:	88 4c 1d db          	mov    %cl,-0x25(%ebp,%ebx,1)
	for (i = DIGITS_BUFLEN - 1U; num != 0U; i--) {
  100efe:	4b                   	dec    %ebx
  100eff:	eb d1                	jmp    100ed2 <print_digits+0x3e>
	}

	if (i == DIGITS_BUFLEN - 1U) {
  100f01:	83 fb 14             	cmp    $0x14,%ebx
  100f04:	75 06                	jne    100f0c <print_digits+0x78>
		buf[i] = '0';
  100f06:	c6 45 ef 30          	movb   $0x30,-0x11(%ebp)
  100f0a:	eb 01                	jmp    100f0d <print_digits+0x79>
	} else {
		i++;
  100f0c:	43                   	inc    %ebx
	}

	int pad = MAX(min_width - (int)(DIGITS_BUFLEN - i), 0);
  100f0d:	8b 45 bc             	mov    -0x44(%ebp),%eax
  100f10:	8d 74 03 eb          	lea    -0x15(%ebx,%eax,1),%esi
  100f14:	85 f6                	test   %esi,%esi
  100f16:	79 02                	jns    100f1a <print_digits+0x86>
  100f18:	31 f6                	xor    %esi,%esi

	for (/**/; pad > 0 && pad_before; pad--) {
		out(pad_char, ctx);
  100f1a:	0f be 7d c7          	movsbl -0x39(%ebp),%edi
	for (/**/; pad > 0 && pad_before; pad--) {
  100f1e:	85 f6                	test   %esi,%esi
  100f20:	7e 14                	jle    100f36 <print_digits+0xa2>
  100f22:	80 7d c6 00          	cmpb   $0x0,-0x3a(%ebp)
  100f26:	74 0e                	je     100f36 <print_digits+0xa2>
		out(pad_char, ctx);
  100f28:	ff 75 c8             	pushl  -0x38(%ebp)
  100f2b:	8b 45 cc             	mov    -0x34(%ebp),%eax
	for (/**/; pad > 0 && pad_before; pad--) {
  100f2e:	4e                   	dec    %esi
		out(pad_char, ctx);
  100f2f:	57                   	push   %edi
  100f30:	ff d0                	call   *%eax
  100f32:	58                   	pop    %eax
  100f33:	5a                   	pop    %edx
	for (/**/; pad > 0 && pad_before; pad--) {
  100f34:	eb e8                	jmp    100f1e <print_digits+0x8a>
	}
	for (/**/; i < DIGITS_BUFLEN; i++) {
  100f36:	83 fb 14             	cmp    $0x14,%ebx
  100f39:	77 13                	ja     100f4e <print_digits+0xba>
		out(buf[i], ctx);
  100f3b:	ff 75 c8             	pushl  -0x38(%ebp)
  100f3e:	0f be 44 1d db       	movsbl -0x25(%ebp,%ebx,1),%eax
  100f43:	50                   	push   %eax
  100f44:	8b 45 cc             	mov    -0x34(%ebp),%eax
  100f47:	ff d0                	call   *%eax
  100f49:	59                   	pop    %ecx
  100f4a:	5f                   	pop    %edi
	for (/**/; i < DIGITS_BUFLEN; i++) {
  100f4b:	43                   	inc    %ebx
  100f4c:	eb e8                	jmp    100f36 <print_digits+0xa2>
	}
	for (/**/; pad > 0; pad--) {
		out(pad_char, ctx);
  100f4e:	0f be 5d c7          	movsbl -0x39(%ebp),%ebx
	for (/**/; pad > 0; pad--) {
  100f52:	85 f6                	test   %esi,%esi
  100f54:	74 0e                	je     100f64 <print_digits+0xd0>
		out(pad_char, ctx);
  100f56:	ff 75 c8             	pushl  -0x38(%ebp)
  100f59:	8b 45 cc             	mov    -0x34(%ebp),%eax
	for (/**/; pad > 0; pad--) {
  100f5c:	4e                   	dec    %esi
		out(pad_char, ctx);
  100f5d:	53                   	push   %ebx
  100f5e:	ff d0                	call   *%eax
  100f60:	58                   	pop    %eax
  100f61:	5a                   	pop    %edx
	for (/**/; pad > 0; pad--) {
  100f62:	eb ee                	jmp    100f52 <print_digits+0xbe>
	}
}
  100f64:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100f67:	5b                   	pop    %ebx
  100f68:	5e                   	pop    %esi
  100f69:	5f                   	pop    %edi
  100f6a:	5d                   	pop    %ebp
  100f6b:	8d 67 f8             	lea    -0x8(%edi),%esp
  100f6e:	5f                   	pop    %edi
  100f6f:	c3                   	ret    

00100f70 <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
  100f70:	55                   	push   %ebp
  100f71:	89 e5                	mov    %esp,%ebp
  100f73:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
  100f76:	ff 00                	incl   (%eax)
	return _char_out(c);
}
  100f78:	5d                   	pop    %ebp
	return _char_out(c);
  100f79:	ff 25 80 5a 14 00    	jmp    *0x145a80

00100f7f <str_out>:
	int max;
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
  100f7f:	55                   	push   %ebp
  100f80:	89 e5                	mov    %esp,%ebp
  100f82:	56                   	push   %esi
  100f83:	53                   	push   %ebx
  100f84:	8b 45 0c             	mov    0xc(%ebp),%eax
  100f87:	8b 48 08             	mov    0x8(%eax),%ecx
	if (ctx->str == NULL || ctx->count >= ctx->max) {
  100f8a:	8b 10                	mov    (%eax),%edx
  100f8c:	85 d2                	test   %edx,%edx
  100f8e:	8d 71 01             	lea    0x1(%ecx),%esi
  100f91:	74 07                	je     100f9a <str_out+0x1b>
  100f93:	8b 58 04             	mov    0x4(%eax),%ebx
  100f96:	39 cb                	cmp    %ecx,%ebx
  100f98:	7f 05                	jg     100f9f <str_out+0x20>
		ctx->count++;
  100f9a:	89 70 08             	mov    %esi,0x8(%eax)
		return c;
  100f9d:	eb 14                	jmp    100fb3 <str_out+0x34>
	}

	if (ctx->count == ctx->max - 1) {
  100f9f:	4b                   	dec    %ebx
  100fa0:	01 ca                	add    %ecx,%edx
		ctx->str[ctx->count++] = '\0';
  100fa2:	89 70 08             	mov    %esi,0x8(%eax)
	if (ctx->count == ctx->max - 1) {
  100fa5:	39 cb                	cmp    %ecx,%ebx
  100fa7:	75 05                	jne    100fae <str_out+0x2f>
		ctx->str[ctx->count++] = '\0';
  100fa9:	c6 02 00             	movb   $0x0,(%edx)
  100fac:	eb 05                	jmp    100fb3 <str_out+0x34>
	} else {
		ctx->str[ctx->count++] = c;
  100fae:	8a 45 08             	mov    0x8(%ebp),%al
  100fb1:	88 02                	mov    %al,(%edx)
	}

	return c;
}
  100fb3:	5b                   	pop    %ebx
  100fb4:	8b 45 08             	mov    0x8(%ebp),%eax
  100fb7:	5e                   	pop    %esi
  100fb8:	5d                   	pop    %ebp
  100fb9:	c3                   	ret    

00100fba <__printk_hook_install>:
{
  100fba:	55                   	push   %ebp
  100fbb:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
  100fbd:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100fc0:	5d                   	pop    %ebp
	_char_out = fn;
  100fc1:	a3 80 5a 14 00       	mov    %eax,0x145a80
}
  100fc6:	c3                   	ret    

00100fc7 <z_vprintk>:
{
  100fc7:	55                   	push   %ebp
  100fc8:	89 e5                	mov    %esp,%ebp
  100fca:	57                   	push   %edi
  100fcb:	56                   	push   %esi
	int might_format = 0; /* 1 if encountered a '%' */
  100fcc:	31 ff                	xor    %edi,%edi
{
  100fce:	53                   	push   %ebx
  100fcf:	83 ec 10             	sub    $0x10,%esp
	char length_mod = 0;
  100fd2:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
{
  100fd6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100fd9:	8b 75 14             	mov    0x14(%ebp),%esi
	int min_width = -1;
  100fdc:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
	enum pad_type padding = PAD_NONE;
  100fe3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	while (*fmt) {
  100fea:	8b 45 10             	mov    0x10(%ebp),%eax
  100fed:	0f be 00             	movsbl (%eax),%eax
  100ff0:	84 c0                	test   %al,%al
  100ff2:	0f 84 86 02 00 00    	je     10127e <z_vprintk+0x2b7>
		if (!might_format) {
  100ff8:	85 ff                	test   %edi,%edi
  100ffa:	75 14                	jne    101010 <z_vprintk+0x49>
			if (*fmt != '%') {
  100ffc:	3c 25                	cmp    $0x25,%al
  100ffe:	0f 84 32 02 00 00    	je     101236 <z_vprintk+0x26f>
				out((int)*fmt, ctx);
  101004:	53                   	push   %ebx
  101005:	50                   	push   %eax
  101006:	ff 55 08             	call   *0x8(%ebp)
  101009:	58                   	pop    %eax
  10100a:	5a                   	pop    %edx
  10100b:	e9 66 02 00 00       	jmp    101276 <z_vprintk+0x2af>
			switch (*fmt) {
  101010:	3c 7a                	cmp    $0x7a,%al
  101012:	0f 8f 07 02 00 00    	jg     10121f <z_vprintk+0x258>
  101018:	3c 62                	cmp    $0x62,%al
  10101a:	7f 1b                	jg     101037 <z_vprintk+0x70>
  10101c:	3c 30                	cmp    $0x30,%al
  10101e:	74 3e                	je     10105e <z_vprintk+0x97>
  101020:	7f 2b                	jg     10104d <z_vprintk+0x86>
  101022:	3c 25                	cmp    $0x25,%al
  101024:	0f 84 f0 01 00 00    	je     10121a <z_vprintk+0x253>
  10102a:	3c 2d                	cmp    $0x2d,%al
  10102c:	0f 84 1d 02 00 00    	je     10124f <z_vprintk+0x288>
  101032:	e9 e8 01 00 00       	jmp    10121f <z_vprintk+0x258>
  101037:	8d 50 9d             	lea    -0x63(%eax),%edx
  10103a:	80 fa 17             	cmp    $0x17,%dl
  10103d:	0f 87 dc 01 00 00    	ja     10121f <z_vprintk+0x258>
  101043:	0f b6 d2             	movzbl %dl,%edx
  101046:	ff 24 95 74 3e 12 00 	jmp    *0x123e74(,%edx,4)
  10104d:	3c 39                	cmp    $0x39,%al
  10104f:	7e 1d                	jle    10106e <z_vprintk+0xa7>
  101051:	3c 58                	cmp    $0x58,%al
  101053:	0f 84 21 01 00 00    	je     10117a <z_vprintk+0x1b3>
  101059:	e9 c1 01 00 00       	jmp    10121f <z_vprintk+0x258>
				if (min_width < 0 && padding == PAD_NONE) {
  10105e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101062:	79 0a                	jns    10106e <z_vprintk+0xa7>
  101064:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  101068:	0f 84 ea 01 00 00    	je     101258 <z_vprintk+0x291>
				if (min_width < 0) {
  10106e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101072:	79 05                	jns    101079 <z_vprintk+0xb2>
					min_width = *fmt - '0';
  101074:	83 e8 30             	sub    $0x30,%eax
  101077:	eb 08                	jmp    101081 <z_vprintk+0xba>
					min_width = 10 * min_width + *fmt - '0';
  101079:	6b 55 e8 0a          	imul   $0xa,-0x18(%ebp),%edx
  10107d:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
				if (padding == PAD_NONE) {
  101081:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
					min_width = 10 * min_width + *fmt - '0';
  101085:	89 45 e8             	mov    %eax,-0x18(%ebp)
				if (padding == PAD_NONE) {
  101088:	0f 85 e8 01 00 00    	jne    101276 <z_vprintk+0x2af>
					padding = PAD_SPACE_BEFORE;
  10108e:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
  101095:	e9 dc 01 00 00       	jmp    101276 <z_vprintk+0x2af>
				if (*fmt == 'h' && length_mod == 'h') {
  10109a:	3c 68                	cmp    $0x68,%al
  10109c:	75 0b                	jne    1010a9 <z_vprintk+0xe2>
  10109e:	80 7d ef 68          	cmpb   $0x68,-0x11(%ebp)
  1010a2:	75 13                	jne    1010b7 <z_vprintk+0xf0>
  1010a4:	e9 b8 01 00 00       	jmp    101261 <z_vprintk+0x29a>
				} else if (*fmt == 'l' && length_mod == 'l') {
  1010a9:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
  1010ad:	75 08                	jne    1010b7 <z_vprintk+0xf0>
  1010af:	3c 6c                	cmp    $0x6c,%al
  1010b1:	0f 84 b0 01 00 00    	je     101267 <z_vprintk+0x2a0>
				} else if (length_mod == 0) {
  1010b7:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  1010bb:	0f 85 5e 01 00 00    	jne    10121f <z_vprintk+0x258>
  1010c1:	e9 a7 01 00 00       	jmp    10126d <z_vprintk+0x2a6>
				if (length_mod == 'z') {
  1010c6:	80 7d ef 7a          	cmpb   $0x7a,-0x11(%ebp)
  1010ca:	74 06                	je     1010d2 <z_vprintk+0x10b>
				} else if (length_mod == 'l') {
  1010cc:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
  1010d0:	75 0c                	jne    1010de <z_vprintk+0x117>
					d = va_arg(ap, long);
  1010d2:	8d 4e 04             	lea    0x4(%esi),%ecx
  1010d5:	8b 36                	mov    (%esi),%esi
  1010d7:	89 f7                	mov    %esi,%edi
  1010d9:	c1 ff 1f             	sar    $0x1f,%edi
  1010dc:	eb 22                	jmp    101100 <z_vprintk+0x139>
				} else if (length_mod == 'L') {
  1010de:	80 7d ef 4c          	cmpb   $0x4c,-0x11(%ebp)
  1010e2:	75 0a                	jne    1010ee <z_vprintk+0x127>
					long long lld = va_arg(ap, long long);
  1010e4:	8d 4e 08             	lea    0x8(%esi),%ecx
					d = (printk_val_t) lld;
  1010e7:	8b 7e 04             	mov    0x4(%esi),%edi
  1010ea:	8b 36                	mov    (%esi),%esi
  1010ec:	eb 12                	jmp    101100 <z_vprintk+0x139>
				} else if (*fmt == 'u') {
  1010ee:	8d 4e 04             	lea    0x4(%esi),%ecx
					d = va_arg(ap, unsigned int);
  1010f1:	31 ff                	xor    %edi,%edi
  1010f3:	8b 36                	mov    (%esi),%esi
				} else if (*fmt == 'u') {
  1010f5:	3c 75                	cmp    $0x75,%al
  1010f7:	74 27                	je     101120 <z_vprintk+0x159>
					d = va_arg(ap, int);
  1010f9:	89 f7                	mov    %esi,%edi
  1010fb:	c1 ff 1f             	sar    $0x1f,%edi
				if (*fmt != 'u' && negative(d)) {
  1010fe:	eb 04                	jmp    101104 <z_vprintk+0x13d>
  101100:	3c 75                	cmp    $0x75,%al
  101102:	74 1c                	je     101120 <z_vprintk+0x159>
  101104:	85 ff                	test   %edi,%edi
  101106:	79 18                	jns    101120 <z_vprintk+0x159>
					out((int)'-', ctx);
  101108:	53                   	push   %ebx
  101109:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10110c:	6a 2d                	push   $0x2d
  10110e:	ff 55 08             	call   *0x8(%ebp)
					d = -d;
  101111:	f7 de                	neg    %esi
  101113:	83 d7 00             	adc    $0x0,%edi
					min_width--;
  101116:	ff 4d e8             	decl   -0x18(%ebp)
					out((int)'-', ctx);
  101119:	59                   	pop    %ecx
					min_width--;
  10111a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					out((int)'-', ctx);
  10111d:	58                   	pop    %eax
					d = -d;
  10111e:	f7 df                	neg    %edi
	print_digits(out, ctx, num, 10U, padding != PAD_SPACE_AFTER,
  101120:	31 c0                	xor    %eax,%eax
  101122:	89 da                	mov    %ebx,%edx
  101124:	ff 75 e8             	pushl  -0x18(%ebp)
  101127:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
  10112b:	0f 94 c0             	sete   %al
  10112e:	48                   	dec    %eax
  10112f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  101132:	83 e0 f0             	and    $0xfffffff0,%eax
  101135:	83 c0 30             	add    $0x30,%eax
  101138:	50                   	push   %eax
  101139:	31 c0                	xor    %eax,%eax
  10113b:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
  10113f:	0f 95 c0             	setne  %al
  101142:	50                   	push   %eax
  101143:	8b 45 08             	mov    0x8(%ebp),%eax
  101146:	6a 0a                	push   $0xa
  101148:	57                   	push   %edi
  101149:	56                   	push   %esi
  10114a:	e8 45 fd ff ff       	call   100e94 <print_digits>
}
  10114f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	print_digits(out, ctx, num, 10U, padding != PAD_SPACE_AFTER,
  101152:	83 c4 18             	add    $0x18,%esp
}
  101155:	89 ce                	mov    %ecx,%esi
  101157:	e9 18 01 00 00       	jmp    101274 <z_vprintk+0x2ad>
				out('0', ctx);
  10115c:	53                   	push   %ebx
  10115d:	6a 30                	push   $0x30
  10115f:	ff 55 08             	call   *0x8(%ebp)
  101162:	59                   	pop    %ecx
  101163:	5f                   	pop    %edi
				out('x', ctx);
  101164:	53                   	push   %ebx
  101165:	6a 78                	push   $0x78
  101167:	ff 55 08             	call   *0x8(%ebp)
  10116a:	58                   	pop    %eax
				min_width = sizeof(void *) * 2U;
  10116b:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
				out('x', ctx);
  101172:	5a                   	pop    %edx
				padding = PAD_ZERO_BEFORE;
  101173:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				if (*fmt == 'p') {
  10117a:	8b 45 10             	mov    0x10(%ebp),%eax
  10117d:	80 38 70             	cmpb   $0x70,(%eax)
					x = (uintptr_t)va_arg(ap, void *);
  101180:	8b 06                	mov    (%esi),%eax
				if (*fmt == 'p') {
  101182:	74 14                	je     101198 <z_vprintk+0x1d1>
				} else if (length_mod == 'l') {
  101184:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
  101188:	74 0e                	je     101198 <z_vprintk+0x1d1>
				} else if (length_mod == 'L') {
  10118a:	80 7d ef 4c          	cmpb   $0x4c,-0x11(%ebp)
  10118e:	75 08                	jne    101198 <z_vprintk+0x1d1>
					x = va_arg(ap, unsigned long long);
  101190:	8b 56 04             	mov    0x4(%esi),%edx
  101193:	83 c6 08             	add    $0x8,%esi
  101196:	eb 05                	jmp    10119d <z_vprintk+0x1d6>
					x = va_arg(ap, unsigned int);
  101198:	31 d2                	xor    %edx,%edx
  10119a:	83 c6 04             	add    $0x4,%esi
	print_digits(out, ctx, num, 16U, padding != PAD_SPACE_AFTER,
  10119d:	31 c9                	xor    %ecx,%ecx
  10119f:	ff 75 e8             	pushl  -0x18(%ebp)
  1011a2:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
  1011a6:	0f 94 c1             	sete   %cl
  1011a9:	49                   	dec    %ecx
  1011aa:	83 e1 f0             	and    $0xfffffff0,%ecx
  1011ad:	83 c1 30             	add    $0x30,%ecx
  1011b0:	51                   	push   %ecx
  1011b1:	31 c9                	xor    %ecx,%ecx
  1011b3:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
  1011b7:	0f 95 c1             	setne  %cl
  1011ba:	51                   	push   %ecx
  1011bb:	6a 10                	push   $0x10
  1011bd:	52                   	push   %edx
  1011be:	89 da                	mov    %ebx,%edx
  1011c0:	50                   	push   %eax
  1011c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1011c4:	e8 cb fc ff ff       	call   100e94 <print_digits>
  1011c9:	83 c4 18             	add    $0x18,%esp
  1011cc:	e9 a3 00 00 00       	jmp    101274 <z_vprintk+0x2ad>
				char *s = va_arg(ap, char *);
  1011d1:	8b 16                	mov    (%esi),%edx
  1011d3:	8d 7e 04             	lea    0x4(%esi),%edi
  1011d6:	89 d6                	mov    %edx,%esi
				while (*s) {
  1011d8:	0f be 06             	movsbl (%esi),%eax
  1011db:	84 c0                	test   %al,%al
  1011dd:	74 10                	je     1011ef <z_vprintk+0x228>
					out((int)(*s++), ctx);
  1011df:	53                   	push   %ebx
  1011e0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1011e3:	50                   	push   %eax
  1011e4:	ff 55 08             	call   *0x8(%ebp)
  1011e7:	58                   	pop    %eax
  1011e8:	46                   	inc    %esi
  1011e9:	5a                   	pop    %edx
  1011ea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1011ed:	eb e9                	jmp    1011d8 <z_vprintk+0x211>
				if (padding == PAD_SPACE_AFTER) {
  1011ef:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
  1011f3:	75 7d                	jne    101272 <z_vprintk+0x2ab>
					int remaining = min_width - (s - start);
  1011f5:	29 d6                	sub    %edx,%esi
  1011f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1011fa:	29 f0                	sub    %esi,%eax
  1011fc:	89 c6                	mov    %eax,%esi
					while (remaining-- > 0) {
  1011fe:	85 f6                	test   %esi,%esi
  101200:	7e 70                	jle    101272 <z_vprintk+0x2ab>
						out(' ', ctx);
  101202:	53                   	push   %ebx
  101203:	4e                   	dec    %esi
  101204:	6a 20                	push   $0x20
  101206:	ff 55 08             	call   *0x8(%ebp)
  101209:	59                   	pop    %ecx
  10120a:	58                   	pop    %eax
  10120b:	eb f1                	jmp    1011fe <z_vprintk+0x237>
				out(c, ctx);
  10120d:	53                   	push   %ebx
				int c = va_arg(ap, int);
  10120e:	8d 7e 04             	lea    0x4(%esi),%edi
				out(c, ctx);
  101211:	ff 36                	pushl  (%esi)
  101213:	ff 55 08             	call   *0x8(%ebp)
  101216:	58                   	pop    %eax
  101217:	5a                   	pop    %edx
				break;
  101218:	eb 58                	jmp    101272 <z_vprintk+0x2ab>
				out((int)'%', ctx);
  10121a:	53                   	push   %ebx
  10121b:	6a 25                	push   $0x25
  10121d:	eb 10                	jmp    10122f <z_vprintk+0x268>
				out((int)'%', ctx);
  10121f:	53                   	push   %ebx
  101220:	6a 25                	push   $0x25
  101222:	ff 55 08             	call   *0x8(%ebp)
  101225:	59                   	pop    %ecx
				out((int)*fmt, ctx);
  101226:	8b 45 10             	mov    0x10(%ebp),%eax
				out((int)'%', ctx);
  101229:	5f                   	pop    %edi
				out((int)*fmt, ctx);
  10122a:	53                   	push   %ebx
  10122b:	0f be 00             	movsbl (%eax),%eax
  10122e:	50                   	push   %eax
  10122f:	ff 55 08             	call   *0x8(%ebp)
  101232:	58                   	pop    %eax
  101233:	5a                   	pop    %edx
				break;
  101234:	eb 3e                	jmp    101274 <z_vprintk+0x2ad>
				length_mod = 0;
  101236:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
				min_width = -1;
  10123a:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
				padding = PAD_NONE;
  101241:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				might_format = 1;
  101248:	bf 01 00 00 00       	mov    $0x1,%edi
  10124d:	eb 27                	jmp    101276 <z_vprintk+0x2af>
			switch (*fmt) {
  10124f:	c7 45 f0 03 00 00 00 	movl   $0x3,-0x10(%ebp)
  101256:	eb 1e                	jmp    101276 <z_vprintk+0x2af>
					padding = PAD_ZERO_BEFORE;
  101258:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
  10125f:	eb 15                	jmp    101276 <z_vprintk+0x2af>
					length_mod = 'H';
  101261:	c6 45 ef 48          	movb   $0x48,-0x11(%ebp)
  101265:	eb 0f                	jmp    101276 <z_vprintk+0x2af>
					length_mod = 'L';
  101267:	c6 45 ef 4c          	movb   $0x4c,-0x11(%ebp)
  10126b:	eb 09                	jmp    101276 <z_vprintk+0x2af>
  10126d:	88 45 ef             	mov    %al,-0x11(%ebp)
  101270:	eb 04                	jmp    101276 <z_vprintk+0x2af>
				char *s = va_arg(ap, char *);
  101272:	89 fe                	mov    %edi,%esi
			might_format = 0;
  101274:	31 ff                	xor    %edi,%edi
		++fmt;
  101276:	ff 45 10             	incl   0x10(%ebp)
  101279:	e9 6c fd ff ff       	jmp    100fea <z_vprintk+0x23>
}
  10127e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101281:	5b                   	pop    %ebx
  101282:	5e                   	pop    %esi
  101283:	5f                   	pop    %edi
  101284:	5d                   	pop    %ebp
  101285:	c3                   	ret    

00101286 <vprintk>:
{
  101286:	55                   	push   %ebp
  101287:	89 e5                	mov    %esp,%ebp
  101289:	50                   	push   %eax
	z_vprintk(char_out, &ctx, fmt, ap);
  10128a:	ff 75 0c             	pushl  0xc(%ebp)
  10128d:	ff 75 08             	pushl  0x8(%ebp)
  101290:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct out_context ctx = { 0 };
  101293:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	z_vprintk(char_out, &ctx, fmt, ap);
  10129a:	50                   	push   %eax
  10129b:	68 70 0f 10 00       	push   $0x100f70
  1012a0:	e8 22 fd ff ff       	call   100fc7 <z_vprintk>
  1012a5:	83 c4 10             	add    $0x10,%esp
}
  1012a8:	c9                   	leave  
  1012a9:	c3                   	ret    

001012aa <printk>:
{
  1012aa:	55                   	push   %ebp
  1012ab:	89 e5                	mov    %esp,%ebp
	va_start(ap, fmt);
  1012ad:	8d 45 0c             	lea    0xc(%ebp),%eax
		vprintk(fmt, ap);
  1012b0:	50                   	push   %eax
  1012b1:	ff 75 08             	pushl  0x8(%ebp)
  1012b4:	e8 cd ff ff ff       	call   101286 <vprintk>
  1012b9:	58                   	pop    %eax
  1012ba:	5a                   	pop    %edx
}
  1012bb:	c9                   	leave  
  1012bc:	c3                   	ret    

001012bd <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
  1012bd:	55                   	push   %ebp
  1012be:	89 e5                	mov    %esp,%ebp
  1012c0:	53                   	push   %ebx
  1012c1:	83 ec 0c             	sub    $0xc,%esp
	struct str_context ctx = { str, size, 0 };

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
  1012c4:	ff 75 14             	pushl  0x14(%ebp)
  1012c7:	ff 75 10             	pushl  0x10(%ebp)
	struct str_context ctx = { str, size, 0 };
  1012ca:	8b 45 0c             	mov    0xc(%ebp),%eax
{
  1012cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct str_context ctx = { str, size, 0 };
  1012d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
  1012d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1012d6:	50                   	push   %eax
	struct str_context ctx = { str, size, 0 };
  1012d7:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
  1012da:	68 7f 0f 10 00       	push   $0x100f7f
	struct str_context ctx = { str, size, 0 };
  1012df:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
  1012e6:	e8 dc fc ff ff       	call   100fc7 <z_vprintk>

	if (ctx.count < ctx.max) {
  1012eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
  1012ee:	83 c4 10             	add    $0x10,%esp
	if (ctx.count < ctx.max) {
  1012f1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  1012f4:	7d 04                	jge    1012fa <vsnprintk+0x3d>
		str[ctx.count] = '\0';
  1012f6:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
	}

	return ctx.count;
}
  1012fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1012fd:	c9                   	leave  
  1012fe:	c3                   	ret    

001012ff <snprintk>:
{
  1012ff:	55                   	push   %ebp
  101300:	89 e5                	mov    %esp,%ebp
	va_start(ap, fmt);
  101302:	8d 45 14             	lea    0x14(%ebp),%eax
	ret = vsnprintk(str, size, fmt, ap);
  101305:	50                   	push   %eax
  101306:	ff 75 10             	pushl  0x10(%ebp)
  101309:	ff 75 0c             	pushl  0xc(%ebp)
  10130c:	ff 75 08             	pushl  0x8(%ebp)
  10130f:	e8 a9 ff ff ff       	call   1012bd <vsnprintk>
  101314:	83 c4 10             	add    $0x10,%esp
}
  101317:	c9                   	leave  
  101318:	c3                   	ret    

00101319 <set_child>:
}

static void set_child(struct rbnode *n, int side, void *val)
{
	CHECK(n);
	if (side != 0) {
  101319:	85 d2                	test   %edx,%edx
  10131b:	74 04                	je     101321 <set_child+0x8>
		n->children[1] = val;
  10131d:	89 48 04             	mov    %ecx,0x4(%eax)
  101320:	c3                   	ret    
	} else {
		uintptr_t old = (uintptr_t) n->children[0];
		uintptr_t new = (uintptr_t) val;

		n->children[0] = (void *) (new | (old & 1UL));
  101321:	8b 10                	mov    (%eax),%edx
  101323:	83 e2 01             	and    $0x1,%edx
  101326:	09 d1                	or     %edx,%ecx
  101328:	89 08                	mov    %ecx,(%eax)
	}
}
  10132a:	c3                   	ret    

0010132b <find_and_stack>:
 * contain at least tree->max_depth entries!  Returns the number of
 * entries pushed onto the stack.
 */
static int find_and_stack(struct rbtree *tree, struct rbnode *node,
			  struct rbnode **stack)
{
  10132b:	55                   	push   %ebp
  10132c:	89 e5                	mov    %esp,%ebp
  10132e:	57                   	push   %edi
  10132f:	56                   	push   %esi
  101330:	89 c7                	mov    %eax,%edi
  101332:	53                   	push   %ebx
  101333:	89 ce                	mov    %ecx,%esi
  101335:	53                   	push   %ebx
	int sz = 0;

	stack[sz++] = tree->root;
  101336:	bb 01 00 00 00       	mov    $0x1,%ebx
  10133b:	8b 00                	mov    (%eax),%eax
  10133d:	89 01                	mov    %eax,(%ecx)

	while (stack[sz - 1] != node) {
  10133f:	8b 44 9e fc          	mov    -0x4(%esi,%ebx,4),%eax
  101343:	39 d0                	cmp    %edx,%eax
  101345:	74 2c                	je     101373 <find_and_stack+0x48>
		int side = tree->lessthan_fn(node, stack[sz - 1]) ? 0 : 1;
  101347:	50                   	push   %eax
  101348:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10134b:	52                   	push   %edx
  10134c:	ff 57 04             	call   *0x4(%edi)
  10134f:	5a                   	pop    %edx
	if (side != 0) {
  101350:	8b 55 f0             	mov    -0x10(%ebp),%edx
		int side = tree->lessthan_fn(node, stack[sz - 1]) ? 0 : 1;
  101353:	59                   	pop    %ecx
  101354:	88 c1                	mov    %al,%cl
	if (side != 0) {
  101356:	84 c9                	test   %cl,%cl
		struct rbnode *ch = get_child(stack[sz - 1], side);
  101358:	8b 44 9e fc          	mov    -0x4(%esi,%ebx,4),%eax
	if (side != 0) {
  10135c:	75 05                	jne    101363 <find_and_stack+0x38>
		return n->children[1];
  10135e:	8b 40 04             	mov    0x4(%eax),%eax
  101361:	eb 05                	jmp    101368 <find_and_stack+0x3d>
	uintptr_t l = (uintptr_t) n->children[0];
  101363:	8b 00                	mov    (%eax),%eax
	l &= ~1UL;
  101365:	83 e0 fe             	and    $0xfffffffe,%eax

		if (ch != NULL) {
  101368:	85 c0                	test   %eax,%eax
  10136a:	74 07                	je     101373 <find_and_stack+0x48>
			stack[sz++] = ch;
  10136c:	43                   	inc    %ebx
  10136d:	89 44 9e fc          	mov    %eax,-0x4(%esi,%ebx,4)
  101371:	eb cc                	jmp    10133f <find_and_stack+0x14>
			break;
		}
	}

	return sz;
}
  101373:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101376:	89 d8                	mov    %ebx,%eax
  101378:	5b                   	pop    %ebx
  101379:	5e                   	pop    %esi
  10137a:	5f                   	pop    %edi
  10137b:	5d                   	pop    %ebp
  10137c:	c3                   	ret    

0010137d <rotate>:
 *  N  c  -->  a   P
 * a b            b c
 *
 */
static void rotate(struct rbnode **stack, int stacksz)
{
  10137d:	55                   	push   %ebp
  10137e:	89 e5                	mov    %esp,%ebp
  101380:	57                   	push   %edi
	CHECK(stacksz >= 2);

	struct rbnode *parent = stack[stacksz - 2];
  101381:	8d 3c 95 f8 ff ff ff 	lea    -0x8(,%edx,4),%edi
{
  101388:	56                   	push   %esi
  101389:	53                   	push   %ebx
	struct rbnode *parent = stack[stacksz - 2];
  10138a:	8d 34 38             	lea    (%eax,%edi,1),%esi
{
  10138d:	83 ec 1c             	sub    $0x1c,%esp
	struct rbnode *child = stack[stacksz - 1];
  101390:	8d 4c 38 04          	lea    0x4(%eax,%edi,1),%ecx
	struct rbnode *parent = stack[stacksz - 2];
  101394:	89 75 e0             	mov    %esi,-0x20(%ebp)
  101397:	8b 36                	mov    (%esi),%esi
{
  101399:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	struct rbnode *child = stack[stacksz - 1];
  10139c:	8b 19                	mov    (%ecx),%ebx
	return get_child(parent, 1) == child ? 1 : 0;
  10139e:	31 d2                	xor    %edx,%edx
	struct rbnode *child = stack[stacksz - 1];
  1013a0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	int side = get_side(parent, child);
  1013a3:	8b 4e 04             	mov    0x4(%esi),%ecx
	return get_child(parent, 1) == child ? 1 : 0;
  1013a6:	39 cb                	cmp    %ecx,%ebx
  1013a8:	0f 94 c2             	sete   %dl
  1013ab:	89 55 e8             	mov    %edx,-0x18(%ebp)
	if (side != 0) {
  1013ae:	75 05                	jne    1013b5 <rotate+0x38>
		return n->children[1];
  1013b0:	8b 53 04             	mov    0x4(%ebx),%edx
  1013b3:	eb 05                	jmp    1013ba <rotate+0x3d>
	l &= ~1UL;
  1013b5:	8b 13                	mov    (%ebx),%edx
  1013b7:	83 e2 fe             	and    $0xfffffffe,%edx
  1013ba:	89 55 ec             	mov    %edx,-0x14(%ebp)
	struct rbnode *a = get_child(child, side);
	struct rbnode *b = get_child(child, side == 0 ? 1 : 0);
  1013bd:	31 d2                	xor    %edx,%edx
  1013bf:	39 cb                	cmp    %ecx,%ebx
  1013c1:	0f 95 c2             	setne  %dl
  1013c4:	89 55 d8             	mov    %edx,-0x28(%ebp)
	if (side != 0) {
  1013c7:	74 05                	je     1013ce <rotate+0x51>
		return n->children[1];
  1013c9:	8b 4b 04             	mov    0x4(%ebx),%ecx
  1013cc:	eb 05                	jmp    1013d3 <rotate+0x56>
	l &= ~1UL;
  1013ce:	8b 0b                	mov    (%ebx),%ecx
  1013d0:	83 e1 fe             	and    $0xfffffffe,%ecx

	if (stacksz >= 3) {
  1013d3:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
	l &= ~1UL;
  1013d7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if (stacksz >= 3) {
  1013da:	7e 13                	jle    1013ef <rotate+0x72>
		struct rbnode *grandparent = stack[stacksz - 3];
  1013dc:	8b 44 38 fc          	mov    -0x4(%eax,%edi,1),%eax
	return get_child(parent, 1) == child ? 1 : 0;
  1013e0:	31 d2                	xor    %edx,%edx

		set_child(grandparent, get_side(grandparent, parent), child);
  1013e2:	89 d9                	mov    %ebx,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
  1013e4:	39 70 04             	cmp    %esi,0x4(%eax)
  1013e7:	0f 94 c2             	sete   %dl
		set_child(grandparent, get_side(grandparent, parent), child);
  1013ea:	e8 2a ff ff ff       	call   101319 <set_child>
	}

	set_child(child, side, a);
  1013ef:	89 d8                	mov    %ebx,%eax
  1013f1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1013f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1013f7:	e8 1d ff ff ff       	call   101319 <set_child>
	set_child(child, side == 0 ? 1 : 0, parent);
  1013fc:	89 f1                	mov    %esi,%ecx
  1013fe:	8b 55 d8             	mov    -0x28(%ebp),%edx
  101401:	e8 13 ff ff ff       	call   101319 <set_child>
	set_child(parent, side, b);
  101406:	89 f0                	mov    %esi,%eax
  101408:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10140b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10140e:	e8 06 ff ff ff       	call   101319 <set_child>
	stack[stacksz - 2] = child;
  101413:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101416:	89 18                	mov    %ebx,(%eax)
	stack[stacksz - 1] = parent;
  101418:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10141b:	89 30                	mov    %esi,(%eax)
}
  10141d:	83 c4 1c             	add    $0x1c,%esp
  101420:	5b                   	pop    %ebx
  101421:	5e                   	pop    %esi
  101422:	5f                   	pop    %edi
  101423:	5d                   	pop    %ebp
  101424:	c3                   	ret    

00101425 <fix_missing_black>:
 * then clean it up (replace it with a simple NULL child in the
 * parent) when finished.
 */
static void fix_missing_black(struct rbnode **stack, int stacksz,
			      struct rbnode *null_node)
{
  101425:	55                   	push   %ebp
  101426:	89 e5                	mov    %esp,%ebp
  101428:	57                   	push   %edi
  101429:	56                   	push   %esi
  10142a:	53                   	push   %ebx
  10142b:	83 ec 1c             	sub    $0x1c,%esp
  10142e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101431:	89 55 e8             	mov    %edx,-0x18(%ebp)
  101434:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	/* Loop upward until we reach the root */
	while (stacksz > 1) {
  101437:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
  10143b:	0f 8e 84 01 00 00    	jle    1015c5 <fix_missing_black+0x1a0>
		struct rbnode *c0, *c1, *inner, *outer;
		struct rbnode *n = stack[stacksz - 1];
  101441:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101444:	8d 0c 85 fc ff ff ff 	lea    -0x4(,%eax,4),%ecx
  10144b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10144e:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  101451:	8b 07                	mov    (%edi),%eax
  101453:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct rbnode *parent = stack[stacksz - 2];
  101456:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101459:	8b 74 08 fc          	mov    -0x4(%eax,%ecx,1),%esi
		int n_side = get_side(parent, n);
  10145d:	8b 46 04             	mov    0x4(%esi),%eax
	return get_child(parent, 1) == child ? 1 : 0;
  101460:	89 c2                	mov    %eax,%edx
		int n_side = get_side(parent, n);
  101462:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return get_child(parent, 1) == child ? 1 : 0;
  101465:	31 c0                	xor    %eax,%eax
  101467:	39 55 f0             	cmp    %edx,-0x10(%ebp)
  10146a:	0f 94 c0             	sete   %al
  10146d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (side != 0) {
  101470:	89 d3                	mov    %edx,%ebx
  101472:	75 05                	jne    101479 <fix_missing_black+0x54>
	l &= ~1UL;
  101474:	8b 1e                	mov    (%esi),%ebx
  101476:	83 e3 fe             	and    $0xfffffffe,%ebx
		/* Guarantee the sibling is black, rotating N down a
		 * level if needed (after rotate() our parent is the
		 * child of our previous-sibling, so N is lower in the
		 * tree)
		 */
		if (!is_black(sib)) {
  101479:	f6 03 01             	testb  $0x1,(%ebx)
  10147c:	75 3a                	jne    1014b8 <fix_missing_black+0x93>
			stack[stacksz - 1] = sib;
			rotate(stack, stacksz);
  10147e:	8b 45 ec             	mov    -0x14(%ebp),%eax
			stack[stacksz - 1] = sib;
  101481:	89 1f                	mov    %ebx,(%edi)
			rotate(stack, stacksz);
  101483:	8b 55 e8             	mov    -0x18(%ebp),%edx
  101486:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  101489:	e8 ef fe ff ff       	call   10137d <rotate>
	*p = (*p & ~1UL) | (uint8_t)color;
  10148e:	83 26 fe             	andl   $0xfffffffe,(%esi)
			set_color(parent, RED);
			set_color(sib, BLACK);
			stack[stacksz++] = n;
  101491:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101494:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  101497:	8b 75 f0             	mov    -0x10(%ebp),%esi
	*p = (*p & ~1UL) | (uint8_t)color;
  10149a:	83 0b 01             	orl    $0x1,(%ebx)
			stack[stacksz++] = n;
  10149d:	89 74 08 04          	mov    %esi,0x4(%eax,%ecx,1)
	if (side != 0) {
  1014a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
			stack[stacksz++] = n;
  1014a4:	ff 45 e8             	incl   -0x18(%ebp)

			parent = stack[stacksz - 2];
  1014a7:	8b 37                	mov    (%edi),%esi
	if (side != 0) {
  1014a9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  1014ac:	74 05                	je     1014b3 <fix_missing_black+0x8e>
		return n->children[1];
  1014ae:	8b 5e 04             	mov    0x4(%esi),%ebx
  1014b1:	eb 05                	jmp    1014b8 <fix_missing_black+0x93>
	l &= ~1UL;
  1014b3:	8b 1e                	mov    (%esi),%ebx
  1014b5:	83 e3 fe             	and    $0xfffffffe,%ebx
  1014b8:	8b 03                	mov    (%ebx),%eax
		return n->children[1];
  1014ba:	8b 53 04             	mov    0x4(%ebx),%edx
	l &= ~1UL;
  1014bd:	83 e0 fe             	and    $0xfffffffe,%eax
  1014c0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return (struct rbnode *) l;
  1014c3:	89 c7                	mov    %eax,%edi
		/* Cases where the sibling has only black children
		 * have simple resolutions
		 */
		c0 = get_child(sib, 0);
		c1 = get_child(sib, 1);
		if ((c0 == NULL || is_black(c0)) && (c1 == NULL ||
  1014c5:	74 05                	je     1014cc <fix_missing_black+0xa7>
  1014c7:	f6 00 01             	testb  $0x1,(%eax)
  1014ca:	74 38                	je     101504 <fix_missing_black+0xdf>
  1014cc:	85 d2                	test   %edx,%edx
  1014ce:	74 05                	je     1014d5 <fix_missing_black+0xb0>
  1014d0:	f6 02 01             	testb  $0x1,(%edx)
  1014d3:	74 49                	je     10151e <fix_missing_black+0xf9>
					is_black(c1))) {
			if (n == null_node) {
  1014d5:	8b 7d d8             	mov    -0x28(%ebp),%edi
  1014d8:	39 7d f0             	cmp    %edi,-0x10(%ebp)
  1014db:	75 0c                	jne    1014e9 <fix_missing_black+0xc4>
				set_child(parent, n_side, NULL);
  1014dd:	31 c9                	xor    %ecx,%ecx
  1014df:	8b 55 dc             	mov    -0x24(%ebp),%edx
  1014e2:	89 f0                	mov    %esi,%eax
  1014e4:	e8 30 fe ff ff       	call   101319 <set_child>
	return get_color(n) == BLACK;
  1014e9:	8b 06                	mov    (%esi),%eax
	*p = (*p & ~1UL) | (uint8_t)color;
  1014eb:	83 23 fe             	andl   $0xfffffffe,(%ebx)
			}

			set_color(sib, RED);
			if (is_black(parent)) {
  1014ee:	a8 01                	test   $0x1,%al
  1014f0:	74 08                	je     1014fa <fix_missing_black+0xd5>
				/* Balance the sibling's subtree by
				 * coloring it red, then our parent
				 * has a missing black so iterate
				 * upward
				 */
				stacksz--;
  1014f2:	ff 4d e8             	decl   -0x18(%ebp)
				continue;
  1014f5:	e9 3d ff ff ff       	jmp    101437 <fix_missing_black+0x12>
	*p = (*p & ~1UL) | (uint8_t)color;
  1014fa:	83 c8 01             	or     $0x1,%eax
  1014fd:	89 06                	mov    %eax,(%esi)
			} else {
				/* Recoloring makes the whole tree OK */
				set_color(parent, BLACK);
				return;
  1014ff:	e9 c1 00 00 00       	jmp    1015c5 <fix_missing_black+0x1a0>
	if (side != 0) {
  101504:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101507:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
  10150a:	74 20                	je     10152c <fix_missing_black+0x107>
		return n->children[1];
  10150c:	89 d0                	mov    %edx,%eax
		/* We know sibling has at least one red child.  Fix it
		 * so that the far/outer position (i.e. on the
		 * opposite side from N) is definitely red.
		 */
		outer = get_child(sib, n_side == 0 ? 1 : 0);
		if (!(outer != NULL && is_red(outer))) {
  10150e:	85 c0                	test   %eax,%eax
  101510:	75 1a                	jne    10152c <fix_missing_black+0x107>
	if (side != 0) {
  101512:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101515:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
  101518:	75 19                	jne    101533 <fix_missing_black+0x10e>
  10151a:	89 d7                	mov    %edx,%edi
  10151c:	eb 15                	jmp    101533 <fix_missing_black+0x10e>
  10151e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101521:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  101524:	0f 84 93 00 00 00    	je     1015bd <fix_missing_black+0x198>
		return n->children[1];
  10152a:	89 d0                	mov    %edx,%eax
		if (!(outer != NULL && is_red(outer))) {
  10152c:	f6 00 01             	testb  $0x1,(%eax)
  10152f:	74 4c                	je     10157d <fix_missing_black+0x158>
  101531:	eb df                	jmp    101512 <fix_missing_black+0xed>
			inner = get_child(sib, n_side);

			stack[stacksz - 1] = sib;
  101533:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101536:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  101539:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
  101540:	01 c1                	add    %eax,%ecx
  101542:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  101545:	89 19                	mov    %ebx,(%ecx)
			stack[stacksz++] = inner;
  101547:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10154a:	89 7c 01 04          	mov    %edi,0x4(%ecx,%eax,1)
  10154e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101551:	8d 50 01             	lea    0x1(%eax),%edx
			rotate(stack, stacksz);
  101554:	89 c8                	mov    %ecx,%eax
  101556:	e8 22 fe ff ff       	call   10137d <rotate>
	*p = (*p & ~1UL) | (uint8_t)color;
  10155b:	83 23 fe             	andl   $0xfffffffe,(%ebx)
			set_color(inner, BLACK);

			/* Restore stack state to have N on the top
			 * and make sib reflect the new sibling
			 */
			sib = stack[stacksz - 2];
  10155e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
	*p = (*p & ~1UL) | (uint8_t)color;
  101561:	83 0f 01             	orl    $0x1,(%edi)
	if (side != 0) {
  101564:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			sib = stack[stacksz - 2];
  101567:	8b 19                	mov    (%ecx),%ebx
	if (side != 0) {
  101569:	39 7d f0             	cmp    %edi,-0x10(%ebp)
  10156c:	74 05                	je     101573 <fix_missing_black+0x14e>
		return n->children[1];
  10156e:	8b 43 04             	mov    0x4(%ebx),%eax
  101571:	eb 05                	jmp    101578 <fix_missing_black+0x153>
	l &= ~1UL;
  101573:	8b 03                	mov    (%ebx),%eax
  101575:	83 e0 fe             	and    $0xfffffffe,%eax
			outer = get_child(sib, n_side == 0 ? 1 : 0);
			stack[stacksz - 2] = n;
  101578:	8b 7d f0             	mov    -0x10(%ebp),%edi
  10157b:	89 39                	mov    %edi,(%ecx)
	return ((uintptr_t)n->children[0]) & 1UL;
  10157d:	8b 16                	mov    (%esi),%edx
	*p = (*p & ~1UL) | (uint8_t)color;
  10157f:	8b 0b                	mov    (%ebx),%ecx
  101581:	83 e1 fe             	and    $0xfffffffe,%ecx
	return ((uintptr_t)n->children[0]) & 1UL;
  101584:	83 e2 01             	and    $0x1,%edx
	*p = (*p & ~1UL) | (uint8_t)color;
  101587:	09 ca                	or     %ecx,%edx
		 */
		CHECK(is_red(outer));
		set_color(sib, get_color(parent));
		set_color(parent, BLACK);
		set_color(outer, BLACK);
		stack[stacksz - 1] = sib;
  101589:	8b 7d e8             	mov    -0x18(%ebp),%edi
	*p = (*p & ~1UL) | (uint8_t)color;
  10158c:	89 13                	mov    %edx,(%ebx)
		rotate(stack, stacksz);
  10158e:	89 fa                	mov    %edi,%edx
	*p = (*p & ~1UL) | (uint8_t)color;
  101590:	83 0e 01             	orl    $0x1,(%esi)
  101593:	83 08 01             	orl    $0x1,(%eax)
		stack[stacksz - 1] = sib;
  101596:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101599:	89 5c b8 fc          	mov    %ebx,-0x4(%eax,%edi,4)
		rotate(stack, stacksz);
  10159d:	e8 db fd ff ff       	call   10137d <rotate>
		if (n == null_node) {
  1015a2:	8b 7d d8             	mov    -0x28(%ebp),%edi
  1015a5:	39 7d f0             	cmp    %edi,-0x10(%ebp)
  1015a8:	75 1b                	jne    1015c5 <fix_missing_black+0x1a0>
			set_child(parent, n_side, NULL);
  1015aa:	8b 55 dc             	mov    -0x24(%ebp),%edx
		}
		return;
	}
}
  1015ad:	83 c4 1c             	add    $0x1c,%esp
			set_child(parent, n_side, NULL);
  1015b0:	89 f0                	mov    %esi,%eax
  1015b2:	31 c9                	xor    %ecx,%ecx
}
  1015b4:	5b                   	pop    %ebx
  1015b5:	5e                   	pop    %esi
  1015b6:	5f                   	pop    %edi
  1015b7:	5d                   	pop    %ebp
			set_child(parent, n_side, NULL);
  1015b8:	e9 5c fd ff ff       	jmp    101319 <set_child>
	return (struct rbnode *) l;
  1015bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1015c0:	e9 49 ff ff ff       	jmp    10150e <fix_missing_black+0xe9>
}
  1015c5:	83 c4 1c             	add    $0x1c,%esp
  1015c8:	5b                   	pop    %ebx
  1015c9:	5e                   	pop    %esi
  1015ca:	5f                   	pop    %edi
  1015cb:	5d                   	pop    %ebp
  1015cc:	c3                   	ret    

001015cd <stack_left_limb>:
 * node to iterate.  By construction node will always be a right child
 * or the root, so is_left must be false.
 */
static inline struct rbnode *stack_left_limb(struct rbnode *n,
					     struct _rb_foreach *f)
{
  1015cd:	55                   	push   %ebp
	f->top++;
  1015ce:	8b 4a 08             	mov    0x8(%edx),%ecx
{
  1015d1:	89 e5                	mov    %esp,%ebp
  1015d3:	56                   	push   %esi
  1015d4:	53                   	push   %ebx
	f->stack[f->top] = n;
  1015d5:	8b 32                	mov    (%edx),%esi
	f->top++;
  1015d7:	8d 59 01             	lea    0x1(%ecx),%ebx
  1015da:	89 5a 08             	mov    %ebx,0x8(%edx)
	f->stack[f->top] = n;
  1015dd:	89 04 9e             	mov    %eax,(%esi,%ebx,4)
	f->is_left[f->top] = 0;
  1015e0:	8b 5a 04             	mov    0x4(%edx),%ebx
  1015e3:	c6 44 0b 01 00       	movb   $0x0,0x1(%ebx,%ecx,1)
	uintptr_t l = (uintptr_t) n->children[0];
  1015e8:	8b 00                	mov    (%eax),%eax
	return (struct rbnode *) l;
  1015ea:	8b 4a 08             	mov    0x8(%edx),%ecx

	while ((n = get_child(n, 0)) != NULL) {
  1015ed:	83 e0 fe             	and    $0xfffffffe,%eax
  1015f0:	8b 1a                	mov    (%edx),%ebx
  1015f2:	74 13                	je     101607 <stack_left_limb+0x3a>
		f->top++;
  1015f4:	8d 71 01             	lea    0x1(%ecx),%esi
  1015f7:	89 72 08             	mov    %esi,0x8(%edx)
		f->stack[f->top] = n;
  1015fa:	89 04 b3             	mov    %eax,(%ebx,%esi,4)
		f->is_left[f->top] = 1;
  1015fd:	8b 5a 04             	mov    0x4(%edx),%ebx
  101600:	c6 44 0b 01 01       	movb   $0x1,0x1(%ebx,%ecx,1)
  101605:	eb e1                	jmp    1015e8 <stack_left_limb+0x1b>
	}

	return f->stack[f->top];
  101607:	8b 04 8b             	mov    (%ebx,%ecx,4),%eax
}
  10160a:	5b                   	pop    %ebx
  10160b:	5e                   	pop    %esi
  10160c:	5d                   	pop    %ebp
  10160d:	c3                   	ret    

0010160e <z_rb_get_minmax>:
{
  10160e:	55                   	push   %ebp
  10160f:	89 e5                	mov    %esp,%ebp
	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
  101611:	8b 45 08             	mov    0x8(%ebp),%eax
{
  101614:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
  101617:	8b 00                	mov    (%eax),%eax
  101619:	85 c0                	test   %eax,%eax
  10161b:	74 16                	je     101633 <z_rb_get_minmax+0x25>
	if (side != 0) {
  10161d:	85 c9                	test   %ecx,%ecx
  10161f:	74 05                	je     101626 <z_rb_get_minmax+0x18>
		return n->children[1];
  101621:	8b 50 04             	mov    0x4(%eax),%edx
  101624:	eb 05                	jmp    10162b <z_rb_get_minmax+0x1d>
	l &= ~1UL;
  101626:	8b 10                	mov    (%eax),%edx
  101628:	83 e2 fe             	and    $0xfffffffe,%edx
	for (n = tree->root; n != NULL && get_child(n, side) != NULL;
  10162b:	85 d2                	test   %edx,%edx
  10162d:	74 04                	je     101633 <z_rb_get_minmax+0x25>
  10162f:	89 d0                	mov    %edx,%eax
  101631:	eb e6                	jmp    101619 <z_rb_get_minmax+0xb>
}
  101633:	5d                   	pop    %ebp
  101634:	c3                   	ret    

00101635 <rb_insert>:
{
  101635:	55                   	push   %ebp
  101636:	89 e5                	mov    %esp,%ebp
  101638:	57                   	push   %edi
  101639:	56                   	push   %esi
  10163a:	53                   	push   %ebx
  10163b:	83 ec 1c             	sub    $0x1c,%esp
  10163e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  101641:	8b 7d 08             	mov    0x8(%ebp),%edi
		n->children[0] = (void *) (new | (old & 1UL));
  101644:	83 23 01             	andl   $0x1,(%ebx)
		n->children[1] = val;
  101647:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	if (tree->root == NULL) {
  10164e:	83 3f 00             	cmpl   $0x0,(%edi)
  101651:	75 14                	jne    101667 <rb_insert+0x32>
		tree->root = node;
  101653:	89 1f                	mov    %ebx,(%edi)
		tree->max_depth = 1;
  101655:	c7 47 08 01 00 00 00 	movl   $0x1,0x8(%edi)
	*p = (*p & ~1UL) | (uint8_t)color;
  10165c:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
		return;
  101662:	e9 0e 01 00 00       	jmp    101775 <rb_insert+0x140>
  101667:	89 e0                	mov    %esp,%eax
	int stacksz = find_and_stack(tree, node, stack);
  101669:	89 da                	mov    %ebx,%edx
  10166b:	89 45 d8             	mov    %eax,-0x28(%ebp)
	struct rbnode *stack[tree->max_depth + 1];
  10166e:	8b 47 08             	mov    0x8(%edi),%eax
  101671:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
  101678:	29 c4                	sub    %eax,%esp
  10167a:	8d 44 24 03          	lea    0x3(%esp),%eax
  10167e:	89 c1                	mov    %eax,%ecx
  101680:	83 e0 fc             	and    $0xfffffffc,%eax
  101683:	c1 e9 02             	shr    $0x2,%ecx
  101686:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101689:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	int stacksz = find_and_stack(tree, node, stack);
  10168c:	89 c1                	mov    %eax,%ecx
  10168e:	89 f8                	mov    %edi,%eax
  101690:	e8 96 fc ff ff       	call   10132b <find_and_stack>
  101695:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct rbnode *parent = stack[stacksz - 1];
  101698:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10169b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10169e:	8d 34 88             	lea    (%eax,%ecx,4),%esi
  1016a1:	8b 46 fc             	mov    -0x4(%esi),%eax
  1016a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
  1016a7:	50                   	push   %eax
  1016a8:	53                   	push   %ebx
  1016a9:	ff 57 04             	call   *0x4(%edi)
  1016ac:	5a                   	pop    %edx
  1016ad:	83 f0 01             	xor    $0x1,%eax
  1016b0:	59                   	pop    %ecx
	set_child(parent, side, node);
  1016b1:	89 d9                	mov    %ebx,%ecx
	int side = tree->lessthan_fn(node, parent) ? 0 : 1;
  1016b3:	0f b6 d0             	movzbl %al,%edx
	set_child(parent, side, node);
  1016b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1016b9:	e8 5b fc ff ff       	call   101319 <set_child>
	stack[stacksz++] = node;
  1016be:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1016c1:	40                   	inc    %eax
	*p = (*p & ~1UL) | (uint8_t)color;
  1016c2:	83 23 fe             	andl   $0xfffffffe,(%ebx)
	stack[stacksz++] = node;
  1016c5:	89 1e                	mov    %ebx,(%esi)
  1016c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1016ca:	89 c3                	mov    %eax,%ebx
	while (stacksz > 1) {
  1016cc:	83 fb 01             	cmp    $0x1,%ebx
  1016cf:	7e 7d                	jle    10174e <rb_insert+0x119>
		struct rbnode *parent = stack[stacksz - 2];
  1016d1:	8b 56 fc             	mov    -0x4(%esi),%edx
	return ((uintptr_t)n->children[0]) & 1UL;
  1016d4:	8d 46 fc             	lea    -0x4(%esi),%eax
  1016d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (is_black(parent)) {
  1016da:	f6 02 01             	testb  $0x1,(%edx)
  1016dd:	75 7c                	jne    10175b <rb_insert+0x126>
		struct rbnode *grandparent = stack[stacksz - 3];
  1016df:	8b 4e f8             	mov    -0x8(%esi),%ecx
		int side = get_side(grandparent, parent);
  1016e2:	8d 46 f8             	lea    -0x8(%esi),%eax
  1016e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1016e8:	8b 41 04             	mov    0x4(%ecx),%eax
  1016eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (side != 0) {
  1016ee:	39 c2                	cmp    %eax,%edx
  1016f0:	75 05                	jne    1016f7 <rb_insert+0xc2>
	l &= ~1UL;
  1016f2:	8b 01                	mov    (%ecx),%eax
  1016f4:	83 e0 fe             	and    $0xfffffffe,%eax
		if ((aunt != NULL) && is_red(aunt)) {
  1016f7:	85 c0                	test   %eax,%eax
  1016f9:	74 16                	je     101711 <rb_insert+0xdc>
	return ((uintptr_t)n->children[0]) & 1UL;
  1016fb:	83 ee 08             	sub    $0x8,%esi
		if ((aunt != NULL) && is_red(aunt)) {
  1016fe:	f6 00 01             	testb  $0x1,(%eax)
  101701:	75 0e                	jne    101711 <rb_insert+0xdc>
	*p = (*p & ~1UL) | (uint8_t)color;
  101703:	83 21 fe             	andl   $0xfffffffe,(%ecx)
			stacksz -= 2;
  101706:	83 eb 02             	sub    $0x2,%ebx
	*p = (*p & ~1UL) | (uint8_t)color;
  101709:	83 0a 01             	orl    $0x1,(%edx)
  10170c:	83 08 01             	orl    $0x1,(%eax)
			continue;
  10170f:	eb bb                	jmp    1016cc <rb_insert+0x97>
	return get_child(parent, 1) == child ? 1 : 0;
  101711:	8b 75 f0             	mov    -0x10(%ebp),%esi
  101714:	8b 4a 04             	mov    0x4(%edx),%ecx
  101717:	3b 55 e8             	cmp    -0x18(%ebp),%edx
  10171a:	0f 94 c0             	sete   %al
  10171d:	39 4c 9e fc          	cmp    %ecx,-0x4(%esi,%ebx,4)
  101721:	0f 94 c2             	sete   %dl
		if (parent_side != side) {
  101724:	38 d0                	cmp    %dl,%al
  101726:	74 09                	je     101731 <rb_insert+0xfc>
			rotate(stack, stacksz);
  101728:	89 da                	mov    %ebx,%edx
  10172a:	89 f0                	mov    %esi,%eax
  10172c:	e8 4c fc ff ff       	call   10137d <rotate>
		rotate(stack, stacksz - 1);
  101731:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101734:	8d 53 ff             	lea    -0x1(%ebx),%edx
  101737:	e8 41 fc ff ff       	call   10137d <rotate>
		set_color(stack[stacksz - 3], BLACK);
  10173c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10173f:	8b 00                	mov    (%eax),%eax
	*p = (*p & ~1UL) | (uint8_t)color;
  101741:	83 08 01             	orl    $0x1,(%eax)
		set_color(stack[stacksz - 2], RED);
  101744:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101747:	8b 00                	mov    (%eax),%eax
	*p = (*p & ~1UL) | (uint8_t)color;
  101749:	83 20 fe             	andl   $0xfffffffe,(%eax)
}
  10174c:	eb 0d                	jmp    10175b <rb_insert+0x126>
	set_color(stack[0], BLACK);
  10174e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101751:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
	*p = (*p & ~1UL) | (uint8_t)color;
  101758:	83 08 01             	orl    $0x1,(%eax)
	if (stacksz > tree->max_depth) {
  10175b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10175e:	39 47 08             	cmp    %eax,0x8(%edi)
  101761:	7d 03                	jge    101766 <rb_insert+0x131>
		tree->max_depth = stacksz;
  101763:	89 47 08             	mov    %eax,0x8(%edi)
	tree->root = stack[0];
  101766:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101769:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
  101770:	89 07                	mov    %eax,(%edi)
	CHECK(is_black(tree->root));
  101772:	8b 65 d8             	mov    -0x28(%ebp),%esp
}
  101775:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101778:	5b                   	pop    %ebx
  101779:	5e                   	pop    %esi
  10177a:	5f                   	pop    %edi
  10177b:	5d                   	pop    %ebp
  10177c:	c3                   	ret    

0010177d <rb_remove>:
{
  10177d:	55                   	push   %ebp
  10177e:	89 e5                	mov    %esp,%ebp
  101780:	57                   	push   %edi
  101781:	56                   	push   %esi
  101782:	53                   	push   %ebx
  101783:	83 ec 18             	sub    $0x18,%esp
	struct rbnode *stack[tree->max_depth + 1];
  101786:	8b 45 08             	mov    0x8(%ebp),%eax
{
  101789:	89 65 e0             	mov    %esp,-0x20(%ebp)
  10178c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct rbnode *stack[tree->max_depth + 1];
  10178f:	8b 40 08             	mov    0x8(%eax),%eax
	int stacksz = find_and_stack(tree, node, stack);
  101792:	89 da                	mov    %ebx,%edx
	struct rbnode *stack[tree->max_depth + 1];
  101794:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
  10179b:	29 c4                	sub    %eax,%esp
  10179d:	8d 44 24 03          	lea    0x3(%esp),%eax
  1017a1:	89 c1                	mov    %eax,%ecx
  1017a3:	83 e0 fc             	and    $0xfffffffc,%eax
  1017a6:	c1 e9 02             	shr    $0x2,%ecx
  1017a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1017ac:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	int stacksz = find_and_stack(tree, node, stack);
  1017af:	89 c1                	mov    %eax,%ecx
  1017b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1017b4:	e8 72 fb ff ff       	call   10132b <find_and_stack>
  1017b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (node != stack[stacksz - 1]) {
  1017bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1017bf:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1017c2:	8d 3c b8             	lea    (%eax,%edi,4),%edi
  1017c5:	39 5f fc             	cmp    %ebx,-0x4(%edi)
  1017c8:	0f 85 7c 01 00 00    	jne    10194a <rb_remove+0x1cd>
	if (get_child(node, 0) != NULL && get_child(node, 1) != NULL) {
  1017ce:	8b 33                	mov    (%ebx),%esi
  1017d0:	83 e6 fe             	and    $0xfffffffe,%esi
  1017d3:	0f 84 e0 00 00 00    	je     1018b9 <rb_remove+0x13c>
  1017d9:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1017dd:	0f 84 d6 00 00 00    	je     1018b9 <rb_remove+0x13c>
		hiparent = stacksz > 1 ? stack[stacksz - 2] : NULL;
  1017e3:	31 c0                	xor    %eax,%eax
  1017e5:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
  1017e9:	7e 03                	jle    1017ee <rb_remove+0x71>
  1017eb:	8b 47 f8             	mov    -0x8(%edi),%eax
		stack[stacksz++] = node2;
  1017ee:	ff 45 f0             	incl   -0x10(%ebp)
  1017f1:	89 37                	mov    %esi,(%edi)
		return n->children[1];
  1017f3:	8b 56 04             	mov    0x4(%esi),%edx
		while (get_child(node2, 1)) {
  1017f6:	85 d2                	test   %edx,%edx
  1017f8:	74 11                	je     10180b <rb_remove+0x8e>
			stack[stacksz++] = node2;
  1017fa:	ff 45 f0             	incl   -0x10(%ebp)
  1017fd:	8b 75 ec             	mov    -0x14(%ebp),%esi
  101800:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101803:	89 54 8e fc          	mov    %edx,-0x4(%esi,%ecx,4)
  101807:	89 d6                	mov    %edx,%esi
  101809:	eb e8                	jmp    1017f3 <rb_remove+0x76>
		loparent = stack[stacksz - 2];
  10180b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10180e:	8b 55 f0             	mov    -0x10(%ebp),%edx
		if (hiparent != NULL) {
  101811:	85 c0                	test   %eax,%eax
  101813:	8d 0c 91             	lea    (%ecx,%edx,4),%ecx
  101816:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
		loparent = stack[stacksz - 2];
  101819:	8b 49 f8             	mov    -0x8(%ecx),%ecx
  10181c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
		if (hiparent != NULL) {
  10181f:	74 11                	je     101832 <rb_remove+0xb5>
	return get_child(parent, 1) == child ? 1 : 0;
  101821:	31 d2                	xor    %edx,%edx
			set_child(hiparent, get_side(hiparent, node), node2);
  101823:	89 f1                	mov    %esi,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
  101825:	39 58 04             	cmp    %ebx,0x4(%eax)
  101828:	0f 94 c2             	sete   %dl
			set_child(hiparent, get_side(hiparent, node), node2);
  10182b:	e8 e9 fa ff ff       	call   101319 <set_child>
  101830:	eb 05                	jmp    101837 <rb_remove+0xba>
			tree->root = node2;
  101832:	8b 45 08             	mov    0x8(%ebp),%eax
  101835:	89 30                	mov    %esi,(%eax)
		if (loparent == node) {
  101837:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
  10183a:	75 17                	jne    101853 <rb_remove+0xd6>
		n->children[0] = (void *) (new | (old & 1UL));
  10183c:	8b 03                	mov    (%ebx),%eax
	l &= ~1UL;
  10183e:	8b 16                	mov    (%esi),%edx
		n->children[0] = (void *) (new | (old & 1UL));
  101840:	83 e0 01             	and    $0x1,%eax
	l &= ~1UL;
  101843:	83 e2 fe             	and    $0xfffffffe,%edx
		n->children[0] = (void *) (new | (old & 1UL));
  101846:	09 d0                	or     %edx,%eax
  101848:	89 03                	mov    %eax,(%ebx)
  10184a:	8b 06                	mov    (%esi),%eax
  10184c:	83 e0 01             	and    $0x1,%eax
  10184f:	09 d8                	or     %ebx,%eax
  101851:	eb 2c                	jmp    10187f <rb_remove+0x102>
	return get_child(parent, 1) == child ? 1 : 0;
  101853:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101856:	31 d2                	xor    %edx,%edx
			set_child(loparent, get_side(loparent, node2), node);
  101858:	89 d9                	mov    %ebx,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
  10185a:	39 70 04             	cmp    %esi,0x4(%eax)
  10185d:	0f 94 c2             	sete   %dl
			set_child(loparent, get_side(loparent, node2), node);
  101860:	e8 b4 fa ff ff       	call   101319 <set_child>
	uintptr_t l = (uintptr_t) n->children[0];
  101865:	8b 13                	mov    (%ebx),%edx
		n->children[0] = (void *) (new | (old & 1UL));
  101867:	89 d0                	mov    %edx,%eax
	l &= ~1UL;
  101869:	8b 0e                	mov    (%esi),%ecx
		n->children[0] = (void *) (new | (old & 1UL));
  10186b:	83 e0 01             	and    $0x1,%eax
	l &= ~1UL;
  10186e:	83 e1 fe             	and    $0xfffffffe,%ecx
		n->children[0] = (void *) (new | (old & 1UL));
  101871:	09 c8                	or     %ecx,%eax
	l &= ~1UL;
  101873:	83 e2 fe             	and    $0xfffffffe,%edx
		n->children[0] = (void *) (new | (old & 1UL));
  101876:	89 03                	mov    %eax,(%ebx)
  101878:	8b 06                	mov    (%esi),%eax
  10187a:	83 e0 01             	and    $0x1,%eax
  10187d:	09 d0                	or     %edx,%eax
  10187f:	89 06                	mov    %eax,(%esi)
		stack[stacksz0 - 1] = stack[stacksz - 1];
  101881:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		return n->children[1];
  101884:	8b 43 04             	mov    0x4(%ebx),%eax
		n->children[1] = val;
  101887:	89 46 04             	mov    %eax,0x4(%esi)
  10188a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
		stack[stacksz0 - 1] = stack[stacksz - 1];
  101891:	8b 51 fc             	mov    -0x4(%ecx),%edx
		tmp = stack[stacksz0 - 1];
  101894:	8b 47 fc             	mov    -0x4(%edi),%eax
		stack[stacksz0 - 1] = stack[stacksz - 1];
  101897:	89 57 fc             	mov    %edx,-0x4(%edi)
		stack[stacksz - 1] = tmp;
  10189a:	89 41 fc             	mov    %eax,-0x4(%ecx)
	return ((uintptr_t)n->children[0]) & 1UL;
  10189d:	8b 0b                	mov    (%ebx),%ecx
  10189f:	8b 16                	mov    (%esi),%edx
	*p = (*p & ~1UL) | (uint8_t)color;
  1018a1:	89 c8                	mov    %ecx,%eax
	return ((uintptr_t)n->children[0]) & 1UL;
  1018a3:	83 e2 01             	and    $0x1,%edx
	*p = (*p & ~1UL) | (uint8_t)color;
  1018a6:	83 e0 fe             	and    $0xfffffffe,%eax
	return ((uintptr_t)n->children[0]) & 1UL;
  1018a9:	83 e1 01             	and    $0x1,%ecx
	*p = (*p & ~1UL) | (uint8_t)color;
  1018ac:	09 c2                	or     %eax,%edx
  1018ae:	89 13                	mov    %edx,(%ebx)
  1018b0:	8b 06                	mov    (%esi),%eax
  1018b2:	83 e0 fe             	and    $0xfffffffe,%eax
  1018b5:	09 c8                	or     %ecx,%eax
  1018b7:	89 06                	mov    %eax,(%esi)
	uintptr_t l = (uintptr_t) n->children[0];
  1018b9:	8b 13                	mov    (%ebx),%edx
	if (child == NULL) {
  1018bb:	89 d7                	mov    %edx,%edi
  1018bd:	83 e7 fe             	and    $0xfffffffe,%edi
  1018c0:	75 03                	jne    1018c5 <rb_remove+0x148>
		return n->children[1];
  1018c2:	8b 7b 04             	mov    0x4(%ebx),%edi
	if (stacksz < 2) {
  1018c5:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
  1018c9:	7f 1a                	jg     1018e5 <rb_remove+0x168>
		tree->root = child;
  1018cb:	8b 45 08             	mov    0x8(%ebp),%eax
		if (child != NULL) {
  1018ce:	85 ff                	test   %edi,%edi
		tree->root = child;
  1018d0:	89 38                	mov    %edi,(%eax)
		if (child != NULL) {
  1018d2:	74 05                	je     1018d9 <rb_remove+0x15c>
	*p = (*p & ~1UL) | (uint8_t)color;
  1018d4:	83 0f 01             	orl    $0x1,(%edi)
}
  1018d7:	eb 71                	jmp    10194a <rb_remove+0x1cd>
			tree->max_depth = 0;
  1018d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1018dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  1018e3:	eb 65                	jmp    10194a <rb_remove+0x1cd>
	struct rbnode *parent = stack[stacksz - 2];
  1018e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1018e8:	8b 75 f0             	mov    -0x10(%ebp),%esi
	if (child == NULL) {
  1018eb:	85 ff                	test   %edi,%edi
  1018ed:	8d 34 b0             	lea    (%eax,%esi,4),%esi
	struct rbnode *parent = stack[stacksz - 2];
  1018f0:	8b 46 f8             	mov    -0x8(%esi),%eax
	if (child == NULL) {
  1018f3:	75 18                	jne    10190d <rb_remove+0x190>
		if (is_black(node)) {
  1018f5:	80 e2 01             	and    $0x1,%dl
			fix_missing_black(stack, stacksz, node);
  1018f8:	89 d9                	mov    %ebx,%ecx
		if (is_black(node)) {
  1018fa:	75 34                	jne    101930 <rb_remove+0x1b3>
	return get_child(parent, 1) == child ? 1 : 0;
  1018fc:	31 d2                	xor    %edx,%edx
  1018fe:	39 58 04             	cmp    %ebx,0x4(%eax)
  101901:	0f 94 c2             	sete   %dl
			set_child(parent, get_side(parent, node), NULL);
  101904:	31 c9                	xor    %ecx,%ecx
  101906:	e8 0e fa ff ff       	call   101319 <set_child>
  10190b:	eb 2e                	jmp    10193b <rb_remove+0x1be>
	return get_child(parent, 1) == child ? 1 : 0;
  10190d:	31 d2                	xor    %edx,%edx
		set_child(parent, get_side(parent, node), child);
  10190f:	89 f9                	mov    %edi,%ecx
	return get_child(parent, 1) == child ? 1 : 0;
  101911:	39 58 04             	cmp    %ebx,0x4(%eax)
  101914:	0f 94 c2             	sete   %dl
		set_child(parent, get_side(parent, node), child);
  101917:	e8 fd f9 ff ff       	call   101319 <set_child>
		if (is_red(node) || is_red(child)) {
  10191c:	f6 03 01             	testb  $0x1,(%ebx)
  10191f:	74 05                	je     101926 <rb_remove+0x1a9>
  101921:	f6 07 01             	testb  $0x1,(%edi)
  101924:	75 05                	jne    10192b <rb_remove+0x1ae>
	*p = (*p & ~1UL) | (uint8_t)color;
  101926:	83 0f 01             	orl    $0x1,(%edi)
}
  101929:	eb 10                	jmp    10193b <rb_remove+0x1be>
			stack[stacksz - 1] = child;
  10192b:	89 7e fc             	mov    %edi,-0x4(%esi)
			fix_missing_black(stack, stacksz, NULL);
  10192e:	31 c9                	xor    %ecx,%ecx
  101930:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101933:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101936:	e8 ea fa ff ff       	call   101425 <fix_missing_black>
	tree->root = stack[0];
  10193b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10193e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  101941:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
  101948:	89 03                	mov    %eax,(%ebx)
  10194a:	8b 65 e0             	mov    -0x20(%ebp),%esp
}
  10194d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101950:	5b                   	pop    %ebx
  101951:	5e                   	pop    %esi
  101952:	5f                   	pop    %edi
  101953:	5d                   	pop    %ebp
  101954:	c3                   	ret    

00101955 <z_rb_foreach_next>:
 * node/stack[top] is the left child of stack[top-1]).  The special
 * case of top == -1 indicates that the stack is uninitialized and we
 * need to push an initial stack starting at the root.
 */
struct rbnode *z_rb_foreach_next(struct rbtree *tree, struct _rb_foreach *f)
{
  101955:	55                   	push   %ebp
  101956:	89 e5                	mov    %esp,%ebp
  101958:	56                   	push   %esi
  101959:	53                   	push   %ebx
	struct rbnode *n;

	if (tree->root == NULL) {
  10195a:	8b 45 08             	mov    0x8(%ebp),%eax
{
  10195d:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (tree->root == NULL) {
  101960:	8b 08                	mov    (%eax),%ecx
  101962:	85 c9                	test   %ecx,%ecx
  101964:	75 04                	jne    10196a <z_rb_foreach_next+0x15>
		return NULL;
  101966:	31 c0                	xor    %eax,%eax
  101968:	eb 59                	jmp    1019c3 <z_rb_foreach_next+0x6e>
	}

	/* Initialization condition, pick the leftmost child of the
	 * root as our first node, initializing the stack on the way.
	 */
	if (f->top == -1) {
  10196a:	8b 42 08             	mov    0x8(%edx),%eax
  10196d:	83 f8 ff             	cmp    $0xffffffff,%eax
  101970:	75 04                	jne    101976 <z_rb_foreach_next+0x21>
		return stack_left_limb(tree->root, f);
  101972:	89 c8                	mov    %ecx,%eax
  101974:	eb 15                	jmp    10198b <z_rb_foreach_next+0x36>
	}

	/* The next child from a given node is the leftmost child of
	 * it's right subtree if it has a right child
	 */
	n = get_child(f->stack[f->top], 1);
  101976:	8b 0a                	mov    (%edx),%ecx
  101978:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
		return n->children[1];
  10197f:	8b 34 81             	mov    (%ecx,%eax,4),%esi
  101982:	8b 76 04             	mov    0x4(%esi),%esi
	if (n != NULL) {
  101985:	85 f6                	test   %esi,%esi
  101987:	74 0a                	je     101993 <z_rb_foreach_next+0x3e>
		return stack_left_limb(n, f);
  101989:	89 f0                	mov    %esi,%eax
		f->top--;
	}

	f->top--;
	return f->top >= 0 ? f->stack[f->top] : NULL;
}
  10198b:	5b                   	pop    %ebx
  10198c:	5e                   	pop    %esi
  10198d:	5d                   	pop    %ebp
		return stack_left_limb(n, f);
  10198e:	e9 3a fc ff ff       	jmp    1015cd <stack_left_limb>
	if (f->is_left[f->top] != 0) {
  101993:	8b 72 04             	mov    0x4(%edx),%esi
  101996:	80 3c 06 00          	cmpb   $0x0,(%esi,%eax,1)
  10199a:	74 13                	je     1019af <z_rb_foreach_next+0x5a>
		return f->stack[--f->top];
  10199c:	48                   	dec    %eax
  10199d:	89 42 08             	mov    %eax,0x8(%edx)
  1019a0:	8b 44 19 fc          	mov    -0x4(%ecx,%ebx,1),%eax
  1019a4:	eb 1d                	jmp    1019c3 <z_rb_foreach_next+0x6e>
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
  1019a6:	80 3c 1e 00          	cmpb   $0x0,(%esi,%ebx,1)
  1019aa:	75 0d                	jne    1019b9 <z_rb_foreach_next+0x64>
		f->top--;
  1019ac:	89 42 08             	mov    %eax,0x8(%edx)
	while ((f->top > 0) && (f->is_left[f->top] == 0)) {
  1019af:	8b 5a 08             	mov    0x8(%edx),%ebx
  1019b2:	85 db                	test   %ebx,%ebx
  1019b4:	8d 43 ff             	lea    -0x1(%ebx),%eax
  1019b7:	7f ed                	jg     1019a6 <z_rb_foreach_next+0x51>
	f->top--;
  1019b9:	89 42 08             	mov    %eax,0x8(%edx)
	return f->top >= 0 ? f->stack[f->top] : NULL;
  1019bc:	85 c0                	test   %eax,%eax
  1019be:	78 a6                	js     101966 <z_rb_foreach_next+0x11>
  1019c0:	8b 04 81             	mov    (%ecx,%eax,4),%eax
}
  1019c3:	5b                   	pop    %ebx
  1019c4:	5e                   	pop    %esi
  1019c5:	5d                   	pop    %ebp
  1019c6:	c3                   	ret    

001019c7 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  1019c7:	55                   	push   %ebp
  1019c8:	89 e5                	mov    %esp,%ebp
	entry(p1, p2, p3);
  1019ca:	ff 75 14             	pushl  0x14(%ebp)
  1019cd:	ff 75 10             	pushl  0x10(%ebp)
  1019d0:	ff 75 0c             	pushl  0xc(%ebp)
  1019d3:	ff 55 08             	call   *0x8(%ebp)
  1019d6:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_current_get();
  1019d9:	e8 73 fe 01 00       	call   121851 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
  1019de:	50                   	push   %eax
  1019df:	e8 53 03 02 00       	call   121d37 <z_impl_k_thread_abort>
  1019e4:	58                   	pop    %eax

001019e5 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
  1019e5:	55                   	push   %ebp
  1019e6:	89 e5                	mov    %esp,%ebp
  1019e8:	56                   	push   %esi
  1019e9:	53                   	push   %ebx
	return z_impl_k_queue_get(queue, timeout);
  1019ea:	6a ff                	push   $0xffffffff
  1019ec:	6a ff                	push   $0xffffffff
  1019ee:	ff 75 08             	pushl  0x8(%ebp)
  1019f1:	e8 61 f5 01 00       	call   120f57 <z_impl_k_queue_get>
  1019f6:	83 c4 0c             	add    $0xc,%esp
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
  1019f9:	85 c0                	test   %eax,%eax
  1019fb:	74 ed                	je     1019ea <z_work_q_main+0x5>
  1019fd:	89 c2                	mov    %eax,%edx
			continue;
		}

		handler = work->handler;
  1019ff:	8b 48 04             	mov    0x4(%eax),%ecx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  101a02:	8b 40 08             	mov    0x8(%eax),%eax
  101a05:	89 c6                	mov    %eax,%esi
  101a07:	89 c3                	mov    %eax,%ebx
  101a09:	83 e6 fe             	and    $0xfffffffe,%esi
  101a0c:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
  101a11:	75 f2                	jne    101a05 <z_work_q_main+0x20>
		__ASSERT(handler != NULL, "handler must be provided");

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
  101a13:	80 e3 01             	and    $0x1,%bl
  101a16:	74 04                	je     101a1c <z_work_q_main+0x37>
					      K_WORK_STATE_PENDING)) {
			handler(work);
  101a18:	52                   	push   %edx
  101a19:	ff d1                	call   *%ecx
  101a1b:	58                   	pop    %eax
	z_impl_k_yield();
  101a1c:	e8 92 fd 01 00       	call   1217b3 <z_impl_k_yield>
  101a21:	eb c7                	jmp    1019ea <z_work_q_main+0x5>

00101a23 <chunk_field>:
				 enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
  101a23:	81 78 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%eax)
	void *cmem = &buf[c];
  101a2a:	8d 14 d0             	lea    (%eax,%edx,8),%edx
	if (big_heap(h)) {
  101a2d:	76 04                	jbe    101a33 <chunk_field+0x10>
		return ((uint32_t *)cmem)[f];
  101a2f:	8b 04 8a             	mov    (%edx,%ecx,4),%eax
  101a32:	c3                   	ret    
	} else {
		return ((uint16_t *)cmem)[f];
  101a33:	0f b7 04 4a          	movzwl (%edx,%ecx,2),%eax
	}
}
  101a37:	c3                   	ret    

00101a38 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
  101a38:	55                   	push   %ebp
	CHECK(c <= h->len);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
  101a39:	8d 14 d0             	lea    (%eax,%edx,8),%edx
{
  101a3c:	89 e5                	mov    %esp,%ebp
  101a3e:	53                   	push   %ebx

	if (big_heap(h)) {
  101a3f:	81 78 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%eax)
{
  101a46:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (big_heap(h)) {
  101a49:	76 05                	jbe    101a50 <chunk_set+0x18>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
  101a4b:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
  101a4e:	eb 04                	jmp    101a54 <chunk_set+0x1c>
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
  101a50:	66 89 1c 4a          	mov    %bx,(%edx,%ecx,2)
	}
}
  101a54:	5b                   	pop    %ebx
  101a55:	5d                   	pop    %ebp
  101a56:	c3                   	ret    

00101a57 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
  101a57:	55                   	push   %ebp
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  101a58:	b9 01 00 00 00       	mov    $0x1,%ecx
{
  101a5d:	89 e5                	mov    %esp,%ebp
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  101a5f:	e8 bf ff ff ff       	call   101a23 <chunk_field>
}
  101a64:	5d                   	pop    %ebp
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  101a65:	d1 e8                	shr    %eax
}
  101a67:	c3                   	ret    

00101a68 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
  101a68:	81 78 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%eax)
	void *cmem = &buf[c];
  101a6f:	8d 14 d0             	lea    (%eax,%edx,8),%edx
	if (big_heap(h)) {
  101a72:	76 13                	jbe    101a87 <set_chunk_used+0x1f>
		if (used) {
  101a74:	8b 42 04             	mov    0x4(%edx),%eax
  101a77:	84 c9                	test   %cl,%cl
  101a79:	74 05                	je     101a80 <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  101a7b:	83 c8 01             	or     $0x1,%eax
  101a7e:	eb 03                	jmp    101a83 <set_chunk_used+0x1b>
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  101a80:	83 e0 fe             	and    $0xfffffffe,%eax
  101a83:	89 42 04             	mov    %eax,0x4(%edx)
  101a86:	c3                   	ret    
		}
	} else {
		if (used) {
  101a87:	66 8b 42 02          	mov    0x2(%edx),%ax
  101a8b:	84 c9                	test   %cl,%cl
  101a8d:	74 05                	je     101a94 <set_chunk_used+0x2c>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
  101a8f:	83 c8 01             	or     $0x1,%eax
  101a92:	eb 03                	jmp    101a97 <set_chunk_used+0x2f>
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
  101a94:	83 e0 fe             	and    $0xfffffffe,%eax
  101a97:	66 89 42 02          	mov    %ax,0x2(%edx)
		}
	}
}
  101a9b:	c3                   	ret    

00101a9c <set_chunk_size>:
 * Note: no need to preserve the used bit here as the chunk is never in use
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, size_t size)
{
  101a9c:	55                   	push   %ebp
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  101a9d:	01 c9                	add    %ecx,%ecx
{
  101a9f:	89 e5                	mov    %esp,%ebp
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  101aa1:	51                   	push   %ecx
  101aa2:	b9 01 00 00 00       	mov    $0x1,%ecx
  101aa7:	e8 8c ff ff ff       	call   101a38 <chunk_set>
  101aac:	58                   	pop    %eax
}
  101aad:	c9                   	leave  
  101aae:	c3                   	ret    

00101aaf <bucket_idx>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
  101aaf:	81 78 08 00 80 00 00 	cmpl   $0x8000,0x8(%eax)
  101ab6:	19 c0                	sbb    %eax,%eax
	return bytes_to_chunksz(h, 1);
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
	size_t usable_sz = sz - min_chunk_size(h) + 1;
  101ab8:	42                   	inc    %edx
	return big_heap(h) ? 8 : 4;
  101ab9:	83 e0 fc             	and    $0xfffffffc,%eax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  101abc:	83 c0 10             	add    $0x10,%eax
  101abf:	c1 e8 03             	shr    $0x3,%eax
	size_t usable_sz = sz - min_chunk_size(h) + 1;
  101ac2:	29 c2                	sub    %eax,%edx
	return 31 - __builtin_clz(usable_sz);
  101ac4:	b8 1f 00 00 00       	mov    $0x1f,%eax
  101ac9:	0f bd d2             	bsr    %edx,%edx
  101acc:	83 f2 1f             	xor    $0x1f,%edx
  101acf:	29 d0                	sub    %edx,%eax
}
  101ad1:	c3                   	ret    

00101ad2 <merge_chunks>:
	set_left_chunk_size(h, right_chunk(h, rc), rsz);
}

/* Does not modify free list */
static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
  101ad2:	55                   	push   %ebp
  101ad3:	89 e5                	mov    %esp,%ebp
  101ad5:	57                   	push   %edi
  101ad6:	56                   	push   %esi
  101ad7:	89 d6                	mov    %edx,%esi
  101ad9:	53                   	push   %ebx
  101ada:	53                   	push   %ebx
  101adb:	89 cb                	mov    %ecx,%ebx
  101add:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  101ae0:	e8 72 ff ff ff       	call   101a57 <chunk_size>
  101ae5:	89 da                	mov    %ebx,%edx
  101ae7:	89 c7                	mov    %eax,%edi
  101ae9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101aec:	e8 66 ff ff ff       	call   101a57 <chunk_size>

	set_chunk_size(h, lc, newsz);
  101af1:	89 f2                	mov    %esi,%edx
	size_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  101af3:	01 c7                	add    %eax,%edi
	set_chunk_size(h, lc, newsz);
  101af5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101af8:	89 f9                	mov    %edi,%ecx
  101afa:	e8 9d ff ff ff       	call   101a9c <set_chunk_size>
	return c + chunk_size(h, c);
  101aff:	89 da                	mov    %ebx,%edx
  101b01:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b04:	e8 4e ff ff ff       	call   101a57 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
  101b09:	57                   	push   %edi
  101b0a:	31 c9                	xor    %ecx,%ecx
	return c + chunk_size(h, c);
  101b0c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
	chunk_set(h, c, LEFT_SIZE, size);
  101b0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b12:	e8 21 ff ff ff       	call   101a38 <chunk_set>
  101b17:	5e                   	pop    %esi
	set_left_chunk_size(h, right_chunk(h, rc), newsz);
}
  101b18:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101b1b:	5b                   	pop    %ebx
  101b1c:	5e                   	pop    %esi
  101b1d:	5f                   	pop    %edi
  101b1e:	5d                   	pop    %ebp
  101b1f:	c3                   	ret    

00101b20 <split_chunks>:
{
  101b20:	55                   	push   %ebp
  101b21:	89 e5                	mov    %esp,%ebp
  101b23:	57                   	push   %edi
  101b24:	56                   	push   %esi
  101b25:	53                   	push   %ebx
  101b26:	89 cb                	mov    %ecx,%ebx
  101b28:	83 ec 08             	sub    $0x8,%esp
	size_t sz0 = chunk_size(h, lc);
  101b2b:	89 55 ec             	mov    %edx,-0x14(%ebp)
{
  101b2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t sz0 = chunk_size(h, lc);
  101b31:	e8 21 ff ff ff       	call   101a57 <chunk_size>
	size_t lsz = rc - lc;
  101b36:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101b39:	89 df                	mov    %ebx,%edi
	size_t rsz = sz0 - lsz;
  101b3b:	89 d6                	mov    %edx,%esi
	size_t lsz = rc - lc;
  101b3d:	29 d7                	sub    %edx,%edi
	size_t rsz = sz0 - lsz;
  101b3f:	29 de                	sub    %ebx,%esi
	set_chunk_size(h, lc, lsz);
  101b41:	89 f9                	mov    %edi,%ecx
	size_t rsz = sz0 - lsz;
  101b43:	01 c6                	add    %eax,%esi
	set_chunk_size(h, lc, lsz);
  101b45:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b48:	e8 4f ff ff ff       	call   101a9c <set_chunk_size>
	set_chunk_size(h, rc, rsz);
  101b4d:	89 f1                	mov    %esi,%ecx
  101b4f:	89 da                	mov    %ebx,%edx
  101b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b54:	e8 43 ff ff ff       	call   101a9c <set_chunk_size>
  101b59:	31 c9                	xor    %ecx,%ecx
  101b5b:	89 da                	mov    %ebx,%edx
  101b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b60:	57                   	push   %edi
  101b61:	e8 d2 fe ff ff       	call   101a38 <chunk_set>
	return c + chunk_size(h, c);
  101b66:	89 da                	mov    %ebx,%edx
  101b68:	8b 45 f0             	mov    -0x10(%ebp),%eax
	chunk_set(h, c, LEFT_SIZE, size);
  101b6b:	5f                   	pop    %edi
	return c + chunk_size(h, c);
  101b6c:	e8 e6 fe ff ff       	call   101a57 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
  101b71:	56                   	push   %esi
  101b72:	31 c9                	xor    %ecx,%ecx
	return c + chunk_size(h, c);
  101b74:	8d 14 03             	lea    (%ebx,%eax,1),%edx
	chunk_set(h, c, LEFT_SIZE, size);
  101b77:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b7a:	e8 b9 fe ff ff       	call   101a38 <chunk_set>
  101b7f:	58                   	pop    %eax
}
  101b80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101b83:	5b                   	pop    %ebx
  101b84:	5e                   	pop    %esi
  101b85:	5f                   	pop    %edi
  101b86:	5d                   	pop    %ebp
  101b87:	c3                   	ret    

00101b88 <free_list_remove_bidx>:
{
  101b88:	55                   	push   %ebp
  101b89:	89 e5                	mov    %esp,%ebp
  101b8b:	57                   	push   %edi
  101b8c:	56                   	push   %esi
  101b8d:	53                   	push   %ebx
  101b8e:	89 c3                	mov    %eax,%ebx
  101b90:	83 ec 08             	sub    $0x8,%esp
  101b93:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	return chunk_field(h, c, FREE_NEXT);
  101b96:	b9 03 00 00 00       	mov    $0x3,%ecx
  101b9b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  101b9e:	e8 80 fe ff ff       	call   101a23 <chunk_field>
	if (next_free_chunk(h, c) == c) {
  101ba3:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101ba6:	89 c6                	mov    %eax,%esi
  101ba8:	39 c2                	cmp    %eax,%edx
  101baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101bad:	8d 78 04             	lea    0x4(%eax),%edi
  101bb0:	75 16                	jne    101bc8 <free_list_remove_bidx+0x40>
		h->avail_buckets &= ~(1 << bidx);
  101bb2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  101bb7:	8a 4d f0             	mov    -0x10(%ebp),%cl
  101bba:	d3 c0                	rol    %cl,%eax
  101bbc:	21 43 0c             	and    %eax,0xc(%ebx)
		b->next = 0;
  101bbf:	c7 04 bb 00 00 00 00 	movl   $0x0,(%ebx,%edi,4)
}
  101bc6:	eb 34                	jmp    101bfc <free_list_remove_bidx+0x74>
	return chunk_field(h, c, FREE_PREV);
  101bc8:	b9 02 00 00 00       	mov    $0x2,%ecx
  101bcd:	89 d8                	mov    %ebx,%eax
  101bcf:	e8 4f fe ff ff       	call   101a23 <chunk_field>
	chunk_set(h, c, FREE_NEXT, next);
  101bd4:	b9 03 00 00 00       	mov    $0x3,%ecx
	return chunk_field(h, c, FREE_PREV);
  101bd9:	89 c2                	mov    %eax,%edx
	chunk_set(h, c, FREE_NEXT, next);
  101bdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		b->next = second;
  101bde:	89 34 bb             	mov    %esi,(%ebx,%edi,4)
  101be1:	89 d8                	mov    %ebx,%eax
  101be3:	56                   	push   %esi
  101be4:	e8 4f fe ff ff       	call   101a38 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
  101be9:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101bec:	b9 02 00 00 00       	mov    $0x2,%ecx
  101bf1:	89 14 24             	mov    %edx,(%esp)
  101bf4:	89 f2                	mov    %esi,%edx
  101bf6:	e8 3d fe ff ff       	call   101a38 <chunk_set>
  101bfb:	58                   	pop    %eax
}
  101bfc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101bff:	5b                   	pop    %ebx
  101c00:	5e                   	pop    %esi
  101c01:	5f                   	pop    %edi
  101c02:	5d                   	pop    %ebp
  101c03:	c3                   	ret    

00101c04 <free_list_remove>:
{
  101c04:	55                   	push   %ebp
  101c05:	89 e5                	mov    %esp,%ebp
  101c07:	56                   	push   %esi
  101c08:	53                   	push   %ebx
  101c09:	89 d6                	mov    %edx,%esi
  101c0b:	89 c3                	mov    %eax,%ebx
	return sizeof(void *) > 4U || chunks > 0x7fffU;
  101c0d:	e8 45 fe ff ff       	call   101a57 <chunk_size>
	return big_heap(h) && chunk_size(h, c) == 1U;
  101c12:	81 7b 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%ebx)
  101c19:	89 c2                	mov    %eax,%edx
  101c1b:	76 05                	jbe    101c22 <free_list_remove+0x1e>
	if (!solo_free_header(h, c)) {
  101c1d:	83 f8 01             	cmp    $0x1,%eax
  101c20:	74 15                	je     101c37 <free_list_remove+0x33>
		int bidx = bucket_idx(h, chunk_size(h, c));
  101c22:	89 d8                	mov    %ebx,%eax
  101c24:	e8 86 fe ff ff       	call   101aaf <bucket_idx>
		free_list_remove_bidx(h, c, bidx);
  101c29:	89 f2                	mov    %esi,%edx
		int bidx = bucket_idx(h, chunk_size(h, c));
  101c2b:	89 c1                	mov    %eax,%ecx
		free_list_remove_bidx(h, c, bidx);
  101c2d:	89 d8                	mov    %ebx,%eax
}
  101c2f:	5b                   	pop    %ebx
  101c30:	5e                   	pop    %esi
  101c31:	5d                   	pop    %ebp
		free_list_remove_bidx(h, c, bidx);
  101c32:	e9 51 ff ff ff       	jmp    101b88 <free_list_remove_bidx>
}
  101c37:	5b                   	pop    %ebx
  101c38:	5e                   	pop    %esi
  101c39:	5d                   	pop    %ebp
  101c3a:	c3                   	ret    

00101c3b <alloc_chunk>:
	set_chunk_used(h, c, false);
	free_chunk(h, c);
}

static chunkid_t alloc_chunk(struct z_heap *h, size_t sz)
{
  101c3b:	55                   	push   %ebp
  101c3c:	89 e5                	mov    %esp,%ebp
  101c3e:	57                   	push   %edi
  101c3f:	56                   	push   %esi
  101c40:	53                   	push   %ebx
  101c41:	89 c3                	mov    %eax,%ebx
  101c43:	83 ec 10             	sub    $0x10,%esp
  101c46:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int bi = bucket_idx(h, sz);
  101c49:	e8 61 fe ff ff       	call   101aaf <bucket_idx>
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bi > bucket_idx(h, h->len)) {
  101c4e:	8b 53 08             	mov    0x8(%ebx),%edx
	int bi = bucket_idx(h, sz);
  101c51:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (bi > bucket_idx(h, h->len)) {
  101c54:	89 d8                	mov    %ebx,%eax
  101c56:	e8 54 fe ff ff       	call   101aaf <bucket_idx>
  101c5b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  101c5e:	7d 04                	jge    101c64 <alloc_chunk+0x29>
		return 0;
  101c60:	31 f6                	xor    %esi,%esi
  101c62:	eb 6c                	jmp    101cd0 <alloc_chunk+0x95>
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  101c64:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101c67:	8d 3c 83             	lea    (%ebx,%eax,4),%edi
  101c6a:	8b 47 10             	mov    0x10(%edi),%eax
  101c6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101c70:	85 c0                	test   %eax,%eax
  101c72:	74 3c                	je     101cb0 <alloc_chunk+0x75>
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
  101c74:	c7 45 e8 03 00 00 00 	movl   $0x3,-0x18(%ebp)
		do {
			chunkid_t c = b->next;
  101c7b:	8b 77 10             	mov    0x10(%edi),%esi
			if (chunk_size(h, c) >= sz) {
  101c7e:	89 d8                	mov    %ebx,%eax
  101c80:	89 f2                	mov    %esi,%edx
  101c82:	e8 d0 fd ff ff       	call   101a57 <chunk_size>
  101c87:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  101c8a:	72 05                	jb     101c91 <alloc_chunk+0x56>
				free_list_remove_bidx(h, c, bi);
  101c8c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101c8f:	eb 36                	jmp    101cc7 <alloc_chunk+0x8c>
	return chunk_field(h, c, FREE_NEXT);
  101c91:	b9 03 00 00 00       	mov    $0x3,%ecx
  101c96:	89 f2                	mov    %esi,%edx
  101c98:	89 d8                	mov    %ebx,%eax
  101c9a:	e8 84 fd ff ff       	call   101a23 <chunk_field>
				return c;
			}
			b->next = next_free_chunk(h, c);
			CHECK(b->next != 0);
		} while (--i && b->next != first);
  101c9f:	ff 4d e8             	decl   -0x18(%ebp)
			b->next = next_free_chunk(h, c);
  101ca2:	89 47 10             	mov    %eax,0x10(%edi)
		} while (--i && b->next != first);
  101ca5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  101ca8:	74 06                	je     101cb0 <alloc_chunk+0x75>
  101caa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101cae:	75 cb                	jne    101c7b <alloc_chunk+0x40>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
  101cb0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101cb3:	83 ca ff             	or     $0xffffffff,%edx
  101cb6:	41                   	inc    %ecx
  101cb7:	d3 e2                	shl    %cl,%edx
  101cb9:	89 d1                	mov    %edx,%ecx

	if ((bmask & h->avail_buckets) != 0U) {
  101cbb:	23 4b 0c             	and    0xc(%ebx),%ecx
  101cbe:	74 a0                	je     101c60 <alloc_chunk+0x25>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);
  101cc0:	0f bc c9             	bsf    %ecx,%ecx
		chunkid_t c = h->buckets[minbucket].next;
  101cc3:	8b 74 8b 10          	mov    0x10(%ebx,%ecx,4),%esi

		free_list_remove_bidx(h, c, minbucket);
  101cc7:	89 f2                	mov    %esi,%edx
  101cc9:	89 d8                	mov    %ebx,%eax
  101ccb:	e8 b8 fe ff ff       	call   101b88 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  101cd0:	83 c4 10             	add    $0x10,%esp
  101cd3:	89 f0                	mov    %esi,%eax
  101cd5:	5b                   	pop    %ebx
  101cd6:	5e                   	pop    %esi
  101cd7:	5f                   	pop    %edi
  101cd8:	5d                   	pop    %ebp
  101cd9:	c3                   	ret    

00101cda <free_list_add>:
{
  101cda:	55                   	push   %ebp
  101cdb:	89 e5                	mov    %esp,%ebp
  101cdd:	57                   	push   %edi
  101cde:	56                   	push   %esi
  101cdf:	89 d6                	mov    %edx,%esi
  101ce1:	53                   	push   %ebx
  101ce2:	89 c3                	mov    %eax,%ebx
  101ce4:	51                   	push   %ecx
  101ce5:	e8 6d fd ff ff       	call   101a57 <chunk_size>
	return big_heap(h) && chunk_size(h, c) == 1U;
  101cea:	81 7b 08 ff 7f 00 00 	cmpl   $0x7fff,0x8(%ebx)
  101cf1:	89 c2                	mov    %eax,%edx
  101cf3:	76 09                	jbe    101cfe <free_list_add+0x24>
	if (!solo_free_header(h, c)) {
  101cf5:	83 f8 01             	cmp    $0x1,%eax
  101cf8:	0f 84 8c 00 00 00    	je     101d8a <free_list_add+0xb0>
		int bidx = bucket_idx(h, chunk_size(h, c));
  101cfe:	89 d8                	mov    %ebx,%eax
  101d00:	e8 aa fd ff ff       	call   101aaf <bucket_idx>
  101d05:	89 c1                	mov    %eax,%ecx
	if (b->next == 0U) {
  101d07:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  101d0a:	8b 78 10             	mov    0x10(%eax),%edi
  101d0d:	85 ff                	test   %edi,%edi
  101d0f:	75 28                	jne    101d39 <free_list_add+0x5f>
		h->avail_buckets |= (1 << bidx);
  101d11:	ba 01 00 00 00       	mov    $0x1,%edx
  101d16:	d3 e2                	shl    %cl,%edx
  101d18:	09 53 0c             	or     %edx,0xc(%ebx)
	chunk_set(h, c, FREE_PREV, prev);
  101d1b:	b9 02 00 00 00       	mov    $0x2,%ecx
		b->next = c;
  101d20:	89 70 10             	mov    %esi,0x10(%eax)
  101d23:	89 f2                	mov    %esi,%edx
  101d25:	56                   	push   %esi
  101d26:	89 d8                	mov    %ebx,%eax
  101d28:	e8 0b fd ff ff       	call   101a38 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
  101d2d:	89 34 24             	mov    %esi,(%esp)
  101d30:	b9 03 00 00 00       	mov    $0x3,%ecx
  101d35:	89 f2                	mov    %esi,%edx
  101d37:	eb 49                	jmp    101d82 <free_list_add+0xa8>
	return chunk_field(h, c, FREE_PREV);
  101d39:	b9 02 00 00 00       	mov    $0x2,%ecx
  101d3e:	89 fa                	mov    %edi,%edx
  101d40:	89 d8                	mov    %ebx,%eax
  101d42:	e8 dc fc ff ff       	call   101a23 <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
  101d47:	b9 02 00 00 00       	mov    $0x2,%ecx
  101d4c:	50                   	push   %eax
	return chunk_field(h, c, FREE_PREV);
  101d4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	chunk_set(h, c, FREE_PREV, prev);
  101d50:	89 f2                	mov    %esi,%edx
  101d52:	89 d8                	mov    %ebx,%eax
  101d54:	e8 df fc ff ff       	call   101a38 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
  101d59:	b9 03 00 00 00       	mov    $0x3,%ecx
  101d5e:	89 f2                	mov    %esi,%edx
  101d60:	89 3c 24             	mov    %edi,(%esp)
  101d63:	e8 d0 fc ff ff       	call   101a38 <chunk_set>
  101d68:	b9 03 00 00 00       	mov    $0x3,%ecx
  101d6d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101d70:	89 34 24             	mov    %esi,(%esp)
  101d73:	e8 c0 fc ff ff       	call   101a38 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
  101d78:	89 34 24             	mov    %esi,(%esp)
  101d7b:	b9 02 00 00 00       	mov    $0x2,%ecx
  101d80:	89 fa                	mov    %edi,%edx
  101d82:	89 d8                	mov    %ebx,%eax
  101d84:	e8 af fc ff ff       	call   101a38 <chunk_set>
  101d89:	58                   	pop    %eax
}
  101d8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101d8d:	5b                   	pop    %ebx
  101d8e:	5e                   	pop    %esi
  101d8f:	5f                   	pop    %edi
  101d90:	5d                   	pop    %ebp
  101d91:	c3                   	ret    

00101d92 <sys_heap_free>:
{
  101d92:	55                   	push   %ebp
  101d93:	89 e5                	mov    %esp,%ebp
  101d95:	56                   	push   %esi
  101d96:	53                   	push   %ebx
  101d97:	53                   	push   %ebx
  101d98:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  101d9b:	8b 45 08             	mov    0x8(%ebp),%eax
	if (mem == NULL) {
  101d9e:	85 db                	test   %ebx,%ebx
  101da0:	0f 84 bf 00 00 00    	je     101e65 <sys_heap_free+0xd3>
	struct z_heap *h = heap->heap;
  101da6:	8b 30                	mov    (%eax),%esi
	return big_heap(h) ? 8 : 4;
  101da8:	81 7e 08 00 80 00 00 	cmpl   $0x8000,0x8(%esi)
  101daf:	19 c0                	sbb    %eax,%eax
	set_chunk_used(h, c, false);
  101db1:	31 c9                	xor    %ecx,%ecx
  101db3:	83 e0 fc             	and    $0xfffffffc,%eax
  101db6:	83 c0 08             	add    $0x8,%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101db9:	29 c3                	sub    %eax,%ebx
	set_chunk_used(h, c, false);
  101dbb:	89 f0                	mov    %esi,%eax
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  101dbd:	29 f3                	sub    %esi,%ebx
  101dbf:	c1 eb 03             	shr    $0x3,%ebx
	set_chunk_used(h, c, false);
  101dc2:	89 da                	mov    %ebx,%edx
  101dc4:	e8 9f fc ff ff       	call   101a68 <set_chunk_used>
	return c + chunk_size(h, c);
  101dc9:	89 da                	mov    %ebx,%edx
  101dcb:	89 f0                	mov    %esi,%eax
  101dcd:	e8 85 fc ff ff       	call   101a57 <chunk_size>
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  101dd2:	b9 01 00 00 00       	mov    $0x1,%ecx
	return c + chunk_size(h, c);
  101dd7:	8d 14 03             	lea    (%ebx,%eax,1),%edx
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  101dda:	89 f0                	mov    %esi,%eax
  101ddc:	89 55 f4             	mov    %edx,-0xc(%ebp)
  101ddf:	e8 3f fc ff ff       	call   101a23 <chunk_field>
	if (!chunk_used(h, right_chunk(h, c))) {
  101de4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101de7:	a8 01                	test   $0x1,%al
  101de9:	75 1c                	jne    101e07 <sys_heap_free+0x75>
		free_list_remove(h, right_chunk(h, c));
  101deb:	89 f0                	mov    %esi,%eax
  101ded:	e8 12 fe ff ff       	call   101c04 <free_list_remove>
	return c + chunk_size(h, c);
  101df2:	89 da                	mov    %ebx,%edx
  101df4:	89 f0                	mov    %esi,%eax
  101df6:	e8 5c fc ff ff       	call   101a57 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
  101dfb:	89 da                	mov    %ebx,%edx
  101dfd:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
  101e00:	89 f0                	mov    %esi,%eax
  101e02:	e8 cb fc ff ff       	call   101ad2 <merge_chunks>
	return c - chunk_field(h, c, LEFT_SIZE);
  101e07:	31 c9                	xor    %ecx,%ecx
  101e09:	89 da                	mov    %ebx,%edx
  101e0b:	89 f0                	mov    %esi,%eax
  101e0d:	e8 11 fc ff ff       	call   101a23 <chunk_field>
  101e12:	89 da                	mov    %ebx,%edx
  101e14:	29 c2                	sub    %eax,%edx
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  101e16:	b9 01 00 00 00       	mov    $0x1,%ecx
  101e1b:	89 f0                	mov    %esi,%eax
  101e1d:	89 55 f4             	mov    %edx,-0xc(%ebp)
  101e20:	e8 fe fb ff ff       	call   101a23 <chunk_field>
	if (!chunk_used(h, left_chunk(h, c))) {
  101e25:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101e28:	a8 01                	test   $0x1,%al
  101e2a:	75 2c                	jne    101e58 <sys_heap_free+0xc6>
		free_list_remove(h, left_chunk(h, c));
  101e2c:	89 f0                	mov    %esi,%eax
  101e2e:	e8 d1 fd ff ff       	call   101c04 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
  101e33:	89 da                	mov    %ebx,%edx
  101e35:	31 c9                	xor    %ecx,%ecx
  101e37:	89 f0                	mov    %esi,%eax
  101e39:	e8 e5 fb ff ff       	call   101a23 <chunk_field>
  101e3e:	89 da                	mov    %ebx,%edx
  101e40:	29 c2                	sub    %eax,%edx
		merge_chunks(h, left_chunk(h, c), c);
  101e42:	89 d9                	mov    %ebx,%ecx
  101e44:	89 f0                	mov    %esi,%eax
  101e46:	e8 87 fc ff ff       	call   101ad2 <merge_chunks>
  101e4b:	89 da                	mov    %ebx,%edx
  101e4d:	31 c9                	xor    %ecx,%ecx
  101e4f:	89 f0                	mov    %esi,%eax
  101e51:	e8 cd fb ff ff       	call   101a23 <chunk_field>
  101e56:	29 c3                	sub    %eax,%ebx
}
  101e58:	59                   	pop    %ecx
	free_list_add(h, c);
  101e59:	89 da                	mov    %ebx,%edx
}
  101e5b:	5b                   	pop    %ebx
	free_list_add(h, c);
  101e5c:	89 f0                	mov    %esi,%eax
}
  101e5e:	5e                   	pop    %esi
  101e5f:	5d                   	pop    %ebp
	free_list_add(h, c);
  101e60:	e9 75 fe ff ff       	jmp    101cda <free_list_add>
}
  101e65:	58                   	pop    %eax
  101e66:	5b                   	pop    %ebx
  101e67:	5e                   	pop    %esi
  101e68:	5d                   	pop    %ebp
  101e69:	c3                   	ret    

00101e6a <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
  101e6a:	55                   	push   %ebp
  101e6b:	89 e5                	mov    %esp,%ebp
  101e6d:	57                   	push   %edi
  101e6e:	56                   	push   %esi
  101e6f:	8b 55 0c             	mov    0xc(%ebp),%edx
  101e72:	53                   	push   %ebx
	if (bytes == 0U) {
  101e73:	85 d2                	test   %edx,%edx
  101e75:	75 04                	jne    101e7b <sys_heap_alloc+0x11>
		return NULL;
  101e77:	31 c0                	xor    %eax,%eax
  101e79:	eb 6a                	jmp    101ee5 <sys_heap_alloc+0x7b>
	}

	struct z_heap *h = heap->heap;
  101e7b:	8b 45 08             	mov    0x8(%ebp),%eax
  101e7e:	8b 18                	mov    (%eax),%ebx
	return big_heap(h) ? 8 : 4;
  101e80:	81 7b 08 00 80 00 00 	cmpl   $0x8000,0x8(%ebx)
  101e87:	19 c0                	sbb    %eax,%eax
  101e89:	83 e0 fc             	and    $0xfffffffc,%eax
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  101e8c:	8d 7c 10 0f          	lea    0xf(%eax,%edx,1),%edi
	size_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
  101e90:	89 d8                	mov    %ebx,%eax
  101e92:	c1 ef 03             	shr    $0x3,%edi
  101e95:	89 fa                	mov    %edi,%edx
  101e97:	e8 9f fd ff ff       	call   101c3b <alloc_chunk>
  101e9c:	89 c6                	mov    %eax,%esi
	if (c == 0U) {
  101e9e:	85 c0                	test   %eax,%eax
  101ea0:	74 d5                	je     101e77 <sys_heap_alloc+0xd>
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
  101ea2:	89 c2                	mov    %eax,%edx
  101ea4:	89 d8                	mov    %ebx,%eax
  101ea6:	e8 ac fb ff ff       	call   101a57 <chunk_size>
  101eab:	39 f8                	cmp    %edi,%eax
  101ead:	76 16                	jbe    101ec5 <sys_heap_alloc+0x5b>
		split_chunks(h, c, c + chunk_sz);
  101eaf:	01 f7                	add    %esi,%edi
  101eb1:	89 f2                	mov    %esi,%edx
  101eb3:	89 d8                	mov    %ebx,%eax
  101eb5:	89 f9                	mov    %edi,%ecx
  101eb7:	e8 64 fc ff ff       	call   101b20 <split_chunks>
		free_list_add(h, c + chunk_sz);
  101ebc:	89 fa                	mov    %edi,%edx
  101ebe:	89 d8                	mov    %ebx,%eax
  101ec0:	e8 15 fe ff ff       	call   101cda <free_list_add>
	}

	set_chunk_used(h, c, true);
  101ec5:	89 d8                	mov    %ebx,%eax
  101ec7:	b9 01 00 00 00       	mov    $0x1,%ecx
  101ecc:	89 f2                	mov    %esi,%edx
  101ece:	e8 95 fb ff ff       	call   101a68 <set_chunk_used>
	return big_heap(h) ? 8 : 4;
  101ed3:	81 7b 08 00 80 00 00 	cmpl   $0x8000,0x8(%ebx)
  101eda:	19 c0                	sbb    %eax,%eax
  101edc:	83 e0 fc             	and    $0xfffffffc,%eax
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  101edf:	8d 44 f0 08          	lea    0x8(%eax,%esi,8),%eax
  101ee3:	01 d8                	add    %ebx,%eax
	return chunk_mem(h, c);
}
  101ee5:	5b                   	pop    %ebx
  101ee6:	5e                   	pop    %esi
  101ee7:	5f                   	pop    %edi
  101ee8:	5d                   	pop    %ebp
  101ee9:	c3                   	ret    

00101eea <sys_heap_init>:
	set_chunk_used(h, c, true);
	return mem;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  101eea:	55                   	push   %ebp
  101eeb:	89 e5                	mov    %esp,%ebp
  101eed:	57                   	push   %edi
  101eee:	56                   	push   %esi
  101eef:	53                   	push   %ebx
  101ef0:	51                   	push   %ecx
  101ef1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  101ef4:	8b 45 0c             	mov    0xc(%ebp),%eax
	return big_heap_bytes(size) ? 8 : 4;
  101ef7:	81 f9 00 00 04 00    	cmp    $0x40000,%ecx
  101efd:	19 d2                	sbb    %edx,%edx
	/* Reserve the final marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  101eff:	8d 58 07             	lea    0x7(%eax),%ebx
  101f02:	83 e2 fc             	and    $0xfffffffc,%edx
  101f05:	83 e3 f8             	and    $0xfffffff8,%ebx
	bytes -= heap_footer_bytes(bytes);
  101f08:	29 d0                	sub    %edx,%eax
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  101f0a:	8d 74 08 f8          	lea    -0x8(%eax,%ecx,1),%esi

	CHECK(end > addr);
	__ASSERT(buf_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
  101f0e:	8b 45 08             	mov    0x8(%ebp),%eax
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  101f11:	83 e6 f8             	and    $0xfffffff8,%esi
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
  101f14:	29 de                	sub    %ebx,%esi
	heap->heap = h;
  101f16:	89 18                	mov    %ebx,(%eax)
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
  101f18:	c1 ee 03             	shr    $0x3,%esi
	h->chunk0_hdr_area = 0;
  101f1b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	h->len = buf_sz;
	h->avail_buckets = 0;

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
  101f21:	89 f2                	mov    %esi,%edx
	h->chunk0_hdr_area = 0;
  101f23:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	h->len = buf_sz;
  101f2a:	89 73 08             	mov    %esi,0x8(%ebx)
	h->avail_buckets = 0;
  101f2d:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
  101f34:	89 d8                	mov    %ebx,%eax
  101f36:	e8 74 fb ff ff       	call   101aaf <bucket_idx>
  101f3b:	8d 50 01             	lea    0x1(%eax),%edx
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  101f3e:	8d 04 85 1b 00 00 00 	lea    0x1b(,%eax,4),%eax
  101f45:	c1 e8 03             	shr    $0x3,%eax
  101f48:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
  101f4b:	31 c0                	xor    %eax,%eax
  101f4d:	39 d0                	cmp    %edx,%eax
  101f4f:	7d 0b                	jge    101f5c <sys_heap_init+0x72>
		h->buckets[i].next = 0;
  101f51:	c7 44 83 10 00 00 00 	movl   $0x0,0x10(%ebx,%eax,4)
  101f58:	00 
	for (int i = 0; i < nb_buckets; i++) {
  101f59:	40                   	inc    %eax
  101f5a:	eb f1                	jmp    101f4d <sys_heap_init+0x63>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
  101f5c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  101f5f:	89 d8                	mov    %ebx,%eax
  101f61:	31 d2                	xor    %edx,%edx
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
  101f63:	89 f7                	mov    %esi,%edi
	set_chunk_size(h, 0, chunk0_size);
  101f65:	e8 32 fb ff ff       	call   101a9c <set_chunk_size>
	set_chunk_used(h, 0, true);
  101f6a:	89 d8                	mov    %ebx,%eax
  101f6c:	b9 01 00 00 00       	mov    $0x1,%ecx
  101f71:	31 d2                	xor    %edx,%edx
  101f73:	e8 f0 fa ff ff       	call   101a68 <set_chunk_used>
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
  101f78:	2b 7d f0             	sub    -0x10(%ebp),%edi
  101f7b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101f7e:	89 f9                	mov    %edi,%ecx
  101f80:	89 d8                	mov    %ebx,%eax
  101f82:	e8 15 fb ff ff       	call   101a9c <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
  101f87:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101f8a:	ff 75 f0             	pushl  -0x10(%ebp)
  101f8d:	89 d8                	mov    %ebx,%eax
  101f8f:	31 c9                	xor    %ecx,%ecx
  101f91:	e8 a2 fa ff ff       	call   101a38 <chunk_set>
  101f96:	58                   	pop    %eax
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
  101f97:	89 f2                	mov    %esi,%edx
  101f99:	89 d8                	mov    %ebx,%eax
  101f9b:	31 c9                	xor    %ecx,%ecx
  101f9d:	e8 fa fa ff ff       	call   101a9c <set_chunk_size>
  101fa2:	89 d8                	mov    %ebx,%eax
  101fa4:	89 f2                	mov    %esi,%edx
  101fa6:	31 c9                	xor    %ecx,%ecx
  101fa8:	57                   	push   %edi
  101fa9:	e8 8a fa ff ff       	call   101a38 <chunk_set>
  101fae:	5a                   	pop    %edx
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
  101faf:	b9 01 00 00 00       	mov    $0x1,%ecx
  101fb4:	89 f2                	mov    %esi,%edx
  101fb6:	e8 ad fa ff ff       	call   101a68 <set_chunk_used>

	free_list_add(h, chunk0_size);
  101fbb:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
  101fbe:	8d 65 f4             	lea    -0xc(%ebp),%esp
	free_list_add(h, chunk0_size);
  101fc1:	89 d8                	mov    %ebx,%eax
}
  101fc3:	5b                   	pop    %ebx
  101fc4:	5e                   	pop    %esi
  101fc5:	5f                   	pop    %edi
  101fc6:	5d                   	pop    %ebp
	free_list_add(h, chunk0_size);
  101fc7:	e9 0e fd ff ff       	jmp    101cda <free_list_add>

00101fcc <_to_x>:
 * Writes the specified number into the buffer in the given base,
 * using the digit characters 0-9a-z (i.e. base>36 will start writing
 * odd bytes).
 */
static int _to_x(char *buf, unsigned VALTYPE n, unsigned int base)
{
  101fcc:	55                   	push   %ebp
  101fcd:	89 e5                	mov    %esp,%ebp
  101fcf:	57                   	push   %edi
  101fd0:	56                   	push   %esi
  101fd1:	53                   	push   %ebx
  101fd2:	89 c3                	mov    %eax,%ebx
  101fd4:	83 ec 08             	sub    $0x8,%esp
  101fd7:	89 d0                	mov    %edx,%eax
  101fd9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  101fdc:	89 d9                	mov    %ebx,%ecx
	int len;

	do {
		unsigned int d = n % base;

		n /= base;
  101fde:	31 d2                	xor    %edx,%edx
  101fe0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101fe3:	f7 75 f0             	divl   -0x10(%ebp)
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
  101fe6:	83 fa 0a             	cmp    $0xa,%edx
  101fe9:	8d 79 01             	lea    0x1(%ecx),%edi
  101fec:	19 f6                	sbb    %esi,%esi
  101fee:	f7 d6                	not    %esi
  101ff0:	83 e6 27             	and    $0x27,%esi
  101ff3:	8d 54 16 30          	lea    0x30(%esi,%edx,1),%edx
  101ff7:	88 57 ff             	mov    %dl,-0x1(%edi)
	} while (n);
  101ffa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101ffd:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  102000:	72 04                	jb     102006 <_to_x+0x3a>
  102002:	89 f9                	mov    %edi,%ecx
  102004:	eb d8                	jmp    101fde <_to_x+0x12>

	*buf = 0;
	len = buf - start;
  102006:	89 f8                	mov    %edi,%eax
	*buf = 0;
  102008:	c6 07 00             	movb   $0x0,(%edi)
	len = buf - start;
  10200b:	29 d8                	sub    %ebx,%eax
  10200d:	89 c7                	mov    %eax,%edi

	for (buf--; buf > start; buf--, start++) {
  10200f:	39 d9                	cmp    %ebx,%ecx
  102011:	76 0d                	jbe    102020 <_to_x+0x54>
		char tmp = *buf;
  102013:	8a 11                	mov    (%ecx),%dl
		*buf = *start;
  102015:	8a 03                	mov    (%ebx),%al
  102017:	88 01                	mov    %al,(%ecx)
	for (buf--; buf > start; buf--, start++) {
  102019:	43                   	inc    %ebx
		*start = tmp;
  10201a:	88 53 ff             	mov    %dl,-0x1(%ebx)
	for (buf--; buf > start; buf--, start++) {
  10201d:	49                   	dec    %ecx
  10201e:	eb ef                	jmp    10200f <_to_x+0x43>
	}

	return len;
}
  102020:	5a                   	pop    %edx
  102021:	89 f8                	mov    %edi,%eax
  102023:	59                   	pop    %ecx
  102024:	5b                   	pop    %ebx
  102025:	5e                   	pop    %esi
  102026:	5f                   	pop    %edi
  102027:	5d                   	pop    %ebp
  102028:	c3                   	ret    

00102029 <_to_hex>:

static int _to_hex(char *buf, unsigned VALTYPE value, bool alt_form, char prefix)
{
  102029:	55                   	push   %ebp
	int len;
	char *buf0 = buf;

	if (alt_form) {
  10202a:	84 c9                	test   %cl,%cl
{
  10202c:	89 e5                	mov    %esp,%ebp
  10202e:	57                   	push   %edi
  10202f:	56                   	push   %esi
  102030:	89 c6                	mov    %eax,%esi
  102032:	53                   	push   %ebx
  102033:	53                   	push   %ebx
  102034:	89 c3                	mov    %eax,%ebx
  102036:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (alt_form) {
  102039:	74 08                	je     102043 <_to_hex+0x1a>
		*buf++ = '0';
		*buf++ = 'x';
  10203b:	8d 58 02             	lea    0x2(%eax),%ebx
		*buf++ = '0';
  10203e:	66 c7 00 30 78       	movw   $0x7830,(%eax)
	}

	len = _to_x(buf, value, 16);
  102043:	b9 10 00 00 00       	mov    $0x10,%ecx
  102048:	89 d8                	mov    %ebx,%eax
  10204a:	e8 7d ff ff ff       	call   101fcc <_to_x>
	if (prefix == 'X') {
  10204f:	89 f9                	mov    %edi,%ecx
	len = _to_x(buf, value, 16);
  102051:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (prefix == 'X') {
  102054:	80 f9 58             	cmp    $0x58,%cl
  102057:	75 19                	jne    102072 <_to_hex+0x49>
  102059:	89 f2                	mov    %esi,%edx
		if (*buf >= 'a' && *buf <= 'z') {
  10205b:	8a 0a                	mov    (%edx),%cl
  10205d:	8d 79 9f             	lea    -0x61(%ecx),%edi
  102060:	89 f8                	mov    %edi,%eax
  102062:	3c 19                	cmp    $0x19,%al
  102064:	77 05                	ja     10206b <_to_hex+0x42>
			*buf += 'A' - 'a';
  102066:	83 e9 20             	sub    $0x20,%ecx
  102069:	88 0a                	mov    %cl,(%edx)
	} while (*buf++);
  10206b:	42                   	inc    %edx
  10206c:	80 7a ff 00          	cmpb   $0x0,-0x1(%edx)
  102070:	75 e9                	jne    10205b <_to_hex+0x32>
		_uc(buf0);
	}

	return len + (buf - buf0);
  102072:	29 f3                	sub    %esi,%ebx
  102074:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  102077:	5a                   	pop    %edx
	return len + (buf - buf0);
  102078:	01 d8                	add    %ebx,%eax
}
  10207a:	5b                   	pop    %ebx
  10207b:	5e                   	pop    %esi
  10207c:	5f                   	pop    %edi
  10207d:	5d                   	pop    %ebp
  10207e:	c3                   	ret    

0010207f <_rlrshift>:

	return (buf + _to_udec(buf, value)) - start;
}

static	void _rlrshift(uint64_t *v)
{
  10207f:	55                   	push   %ebp
  102080:	89 e5                	mov    %esp,%ebp
  102082:	57                   	push   %edi
  102083:	56                   	push   %esi
  102084:	89 c6                	mov    %eax,%esi
  102086:	53                   	push   %ebx
	*v = (*v & 1) + (*v >> 1);
  102087:	31 db                	xor    %ebx,%ebx
  102089:	8b 00                	mov    (%eax),%eax
  10208b:	8b 56 04             	mov    0x4(%esi),%edx
  10208e:	89 c7                	mov    %eax,%edi
  102090:	83 e7 01             	and    $0x1,%edi
  102093:	0f ac d0 01          	shrd   $0x1,%edx,%eax
  102097:	d1 ea                	shr    %edx
  102099:	01 f8                	add    %edi,%eax
  10209b:	11 da                	adc    %ebx,%edx
}
  10209d:	5b                   	pop    %ebx
	*v = (*v & 1) + (*v >> 1);
  10209e:	89 06                	mov    %eax,(%esi)
  1020a0:	89 56 04             	mov    %edx,0x4(%esi)
}
  1020a3:	5e                   	pop    %esi
  1020a4:	5f                   	pop    %edi
  1020a5:	5d                   	pop    %ebp
  1020a6:	c3                   	ret    

001020a7 <_ldiv5>:
 * six.  This was tested exhaustively through the first ~10B values in
 * the input space, and for ~2e12 (4 hours runtime) random inputs
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
  1020a7:	55                   	push   %ebp
	 */
	rem += 2U;

	for (i = 0; i < 3; i++) {
		hi = rem >> shifts[i];
		q = (uint64_t)(hi / 5U) << shifts[i];
  1020a8:	b9 05 00 00 00       	mov    $0x5,%ecx
{
  1020ad:	89 e5                	mov    %esp,%ebp
  1020af:	57                   	push   %edi
  1020b0:	56                   	push   %esi
  1020b1:	53                   	push   %ebx
  1020b2:	89 c3                	mov    %eax,%ebx
  1020b4:	83 ec 10             	sub    $0x10,%esp
	rem += 2U;
  1020b7:	8b 30                	mov    (%eax),%esi
  1020b9:	8b 78 04             	mov    0x4(%eax),%edi
  1020bc:	83 c6 02             	add    $0x2,%esi
  1020bf:	83 d7 00             	adc    $0x0,%edi
		q = (uint64_t)(hi / 5U) << shifts[i];
  1020c2:	31 d2                	xor    %edx,%edx
		hi = rem >> shifts[i];
  1020c4:	89 f8                	mov    %edi,%eax
		q = (uint64_t)(hi / 5U) << shifts[i];
  1020c6:	f7 f1                	div    %ecx
  1020c8:	89 c2                	mov    %eax,%edx
  1020ca:	b8 00 00 00 00       	mov    $0x0,%eax
  1020cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1020d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		rem -= q * 5U;
  1020d5:	6b 55 f0 05          	imul   $0x5,-0x10(%ebp),%edx
  1020d9:	31 c0                	xor    %eax,%eax
  1020db:	29 c6                	sub    %eax,%esi
  1020dd:	19 d7                	sbb    %edx,%edi
		hi = rem >> shifts[i];
  1020df:	89 f0                	mov    %esi,%eax
  1020e1:	89 fa                	mov    %edi,%edx
		rem -= q * 5U;
  1020e3:	89 75 e4             	mov    %esi,-0x1c(%ebp)
		hi = rem >> shifts[i];
  1020e6:	0f ac d0 03          	shrd   $0x3,%edx,%eax
		q = (uint64_t)(hi / 5U) << shifts[i];
  1020ea:	31 d2                	xor    %edx,%edx
		quot += q;
  1020ec:	8b 75 ec             	mov    -0x14(%ebp),%esi
		q = (uint64_t)(hi / 5U) << shifts[i];
  1020ef:	f7 f1                	div    %ecx
  1020f1:	31 d2                	xor    %edx,%edx
		rem -= q * 5U;
  1020f3:	89 7d e8             	mov    %edi,-0x18(%ebp)
		q = (uint64_t)(hi / 5U) << shifts[i];
  1020f6:	0f a4 c2 03          	shld   $0x3,%eax,%edx
  1020fa:	c1 e0 03             	shl    $0x3,%eax
		quot += q;
  1020fd:	8b 7d f0             	mov    -0x10(%ebp),%edi
  102100:	01 c6                	add    %eax,%esi
  102102:	11 d7                	adc    %edx,%edi
  102104:	89 75 ec             	mov    %esi,-0x14(%ebp)
		rem -= q * 5U;
  102107:	f7 e1                	mul    %ecx
  102109:	8b 75 e4             	mov    -0x1c(%ebp),%esi
		quot += q;
  10210c:	89 7d f0             	mov    %edi,-0x10(%ebp)
		rem -= q * 5U;
  10210f:	29 c6                	sub    %eax,%esi
		q = (uint64_t)(hi / 5U) << shifts[i];
  102111:	31 d2                	xor    %edx,%edx
		rem -= q * 5U;
  102113:	89 f0                	mov    %esi,%eax
		q = (uint64_t)(hi / 5U) << shifts[i];
  102115:	f7 f1                	div    %ecx
  102117:	31 d2                	xor    %edx,%edx
		quot += q;
  102119:	03 45 ec             	add    -0x14(%ebp),%eax
  10211c:	13 55 f0             	adc    -0x10(%ebp),%edx
  10211f:	89 03                	mov    %eax,(%ebx)
  102121:	89 53 04             	mov    %edx,0x4(%ebx)
	}

	*v = quot;
}
  102124:	83 c4 10             	add    $0x10,%esp
  102127:	5b                   	pop    %ebx
  102128:	5e                   	pop    %esi
  102129:	5f                   	pop    %edi
  10212a:	5d                   	pop    %ebp
  10212b:	c3                   	ret    

0010212c <_get_digit>:

static	char _get_digit(uint64_t *fr, int *digit_count)
{
  10212c:	55                   	push   %ebp
  10212d:	89 c1                	mov    %eax,%ecx
  10212f:	89 e5                	mov    %esp,%ebp
  102131:	53                   	push   %ebx
	char rval;

	if (*digit_count > 0) {
  102132:	8b 02                	mov    (%edx),%eax
		*digit_count -= 1;
		*fr = *fr * 10U;
		rval = ((*fr >> 60) & 0xF) + '0';
		*fr &= 0x0FFFFFFFFFFFFFFFull;
	} else {
		rval = '0';
  102134:	b3 30                	mov    $0x30,%bl
	if (*digit_count > 0) {
  102136:	85 c0                	test   %eax,%eax
  102138:	7e 24                	jle    10215e <_get_digit+0x32>
		*digit_count -= 1;
  10213a:	48                   	dec    %eax
  10213b:	89 02                	mov    %eax,(%edx)
		*fr = *fr * 10U;
  10213d:	b8 0a 00 00 00       	mov    $0xa,%eax
  102142:	6b 59 04 0a          	imul   $0xa,0x4(%ecx),%ebx
  102146:	f7 21                	mull   (%ecx)
  102148:	01 da                	add    %ebx,%edx
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  10214a:	89 01                	mov    %eax,(%ecx)
		rval = ((*fr >> 60) & 0xF) + '0';
  10214c:	89 d3                	mov    %edx,%ebx
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  10214e:	89 d0                	mov    %edx,%eax
		rval = ((*fr >> 60) & 0xF) + '0';
  102150:	c1 eb 1c             	shr    $0x1c,%ebx
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  102153:	25 ff ff ff 0f       	and    $0xfffffff,%eax
		rval = ((*fr >> 60) & 0xF) + '0';
  102158:	83 c3 30             	add    $0x30,%ebx
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  10215b:	89 41 04             	mov    %eax,0x4(%ecx)
	}

	return rval;
}
  10215e:	88 d8                	mov    %bl,%al
  102160:	5b                   	pop    %ebx
  102161:	5d                   	pop    %ebp
  102162:	c3                   	ret    

00102163 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
  102163:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  102167:	83 e4 f8             	and    $0xfffffff8,%esp
  10216a:	ff 71 fc             	pushl  -0x4(%ecx)
  10216d:	55                   	push   %ebp
  10216e:	89 e5                	mov    %esp,%ebp
  102170:	57                   	push   %edi
  102171:	56                   	push   %esi
  102172:	53                   	push   %ebx
  102173:	51                   	push   %ecx
  102174:	83 ec 78             	sub    $0x78,%esp
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
  102177:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
{
  10217e:	8b 01                	mov    (%ecx),%eax
  102180:	8b 59 0c             	mov    0xc(%ecx),%ebx
  102183:	89 45 ac             	mov    %eax,-0x54(%ebp)
  102186:	8b 41 04             	mov    0x4(%ecx),%eax
  102189:	89 45 a8             	mov    %eax,-0x58(%ebp)
  10218c:	8b 41 08             	mov    0x8(%ecx),%eax
  10218f:	89 45 b0             	mov    %eax,-0x50(%ebp)

	while ((c = *format++)) {
  102192:	8b 45 b0             	mov    -0x50(%ebp),%eax
  102195:	8d 70 01             	lea    0x1(%eax),%esi
  102198:	0f be 00             	movsbl (%eax),%eax
  10219b:	84 c0                	test   %al,%al
  10219d:	0f 84 a2 0a 00 00    	je     102c45 <z_prf+0xae2>
		if (c != '%') {
  1021a3:	3c 25                	cmp    $0x25,%al
  1021a5:	74 28                	je     1021cf <z_prf+0x6c>
			PUTC(c);
  1021a7:	ff 75 a8             	pushl  -0x58(%ebp)
  1021aa:	50                   	push   %eax
  1021ab:	8b 45 ac             	mov    -0x54(%ebp),%eax
  1021ae:	ff d0                	call   *%eax
  1021b0:	59                   	pop    %ecx
  1021b1:	5f                   	pop    %edi
  1021b2:	40                   	inc    %eax
  1021b3:	75 0c                	jne    1021c1 <z_prf+0x5e>
  1021b5:	c7 45 a0 ff ff ff ff 	movl   $0xffffffff,-0x60(%ebp)
  1021bc:	e9 84 0a 00 00       	jmp    102c45 <z_prf+0xae2>
			count++;
  1021c1:	ff 45 a0             	incl   -0x60(%ebp)
  1021c4:	89 5d 9c             	mov    %ebx,-0x64(%ebp)
	while ((c = *format++)) {
  1021c7:	89 75 b0             	mov    %esi,-0x50(%ebp)
  1021ca:	e9 6e 0a 00 00       	jmp    102c3d <z_prf+0xada>
		} else {
			fminus = fplus = fspace = falt = fzero = false;
  1021cf:	c6 45 83 00          	movb   $0x0,-0x7d(%ebp)
  1021d3:	c6 45 88 00          	movb   $0x0,-0x78(%ebp)
  1021d7:	c6 45 8c 00          	movb   $0x0,-0x74(%ebp)
  1021db:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
  1021df:	c6 45 a4 00          	movb   $0x0,-0x5c(%ebp)
			while (strchr("-+ #0", (c = *format++)) != NULL) {
  1021e3:	0f be 3e             	movsbl (%esi),%edi
  1021e6:	8d 46 01             	lea    0x1(%esi),%eax
  1021e9:	57                   	push   %edi
  1021ea:	89 45 b0             	mov    %eax,-0x50(%ebp)
  1021ed:	89 f8                	mov    %edi,%eax
  1021ef:	68 0f 49 12 00       	push   $0x12490f
  1021f4:	88 45 b8             	mov    %al,-0x48(%ebp)
  1021f7:	e8 e6 9a 00 00       	call   10bce2 <strchr>
  1021fc:	59                   	pop    %ecx
  1021fd:	5a                   	pop    %edx
  1021fe:	85 c0                	test   %eax,%eax
  102200:	74 4d                	je     10224f <z_prf+0xec>
				switch (c) {
  102202:	80 7d b8 2b          	cmpb   $0x2b,-0x48(%ebp)
  102206:	74 2c                	je     102234 <z_prf+0xd1>
  102208:	7f 18                	jg     102222 <z_prf+0xbf>
  10220a:	80 7d b8 20          	cmpb   $0x20,-0x48(%ebp)
  10220e:	74 2a                	je     10223a <z_prf+0xd7>
  102210:	80 7d b8 23          	cmpb   $0x23,-0x48(%ebp)
  102214:	74 2a                	je     102240 <z_prf+0xdd>
  102216:	80 7d b8 00          	cmpb   $0x0,-0x48(%ebp)
  10221a:	0f 84 25 0a 00 00    	je     102c45 <z_prf+0xae2>
  102220:	eb 28                	jmp    10224a <z_prf+0xe7>
  102222:	80 7d b8 2d          	cmpb   $0x2d,-0x48(%ebp)
  102226:	74 1e                	je     102246 <z_prf+0xe3>
  102228:	80 7d b8 30          	cmpb   $0x30,-0x48(%ebp)
  10222c:	75 1c                	jne    10224a <z_prf+0xe7>
				case '#':
					falt = true;
					break;

				case '0':
					fzero = true;
  10222e:	c6 45 83 01          	movb   $0x1,-0x7d(%ebp)
  102232:	eb 16                	jmp    10224a <z_prf+0xe7>
					fplus = true;
  102234:	c6 45 8c 01          	movb   $0x1,-0x74(%ebp)
  102238:	eb 10                	jmp    10224a <z_prf+0xe7>
					fspace = true;
  10223a:	c6 45 88 01          	movb   $0x1,-0x78(%ebp)
  10223e:	eb 0a                	jmp    10224a <z_prf+0xe7>
					falt = true;
  102240:	c6 45 a4 01          	movb   $0x1,-0x5c(%ebp)
  102244:	eb 04                	jmp    10224a <z_prf+0xe7>
				switch (c) {
  102246:	c6 45 84 01          	movb   $0x1,-0x7c(%ebp)
					fzero = true;
  10224a:	8b 75 b0             	mov    -0x50(%ebp),%esi
  10224d:	eb 94                	jmp    1021e3 <z_prf+0x80>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
  10224f:	80 7d b8 2a          	cmpb   $0x2a,-0x48(%ebp)
  102253:	75 23                	jne    102278 <z_prf+0x115>
				/* Is the width a parameter? */
				width = va_arg(vargs, int);
  102255:	8b 3b                	mov    (%ebx),%edi
  102257:	8d 43 04             	lea    0x4(%ebx),%eax
  10225a:	89 7d 90             	mov    %edi,-0x70(%ebp)
				if (width < 0) {
  10225d:	85 ff                	test   %edi,%edi
  10225f:	79 07                	jns    102268 <z_prf+0x105>
					fminus = true;
					width = -width;
  102261:	f7 5d 90             	negl   -0x70(%ebp)
					fminus = true;
  102264:	c6 45 84 01          	movb   $0x1,-0x7c(%ebp)
				}
				c = *format++;
  102268:	8a 4e 01             	mov    0x1(%esi),%cl
				width = va_arg(vargs, int);
  10226b:	89 c3                	mov    %eax,%ebx
				c = *format++;
  10226d:	8d 46 02             	lea    0x2(%esi),%eax
  102270:	88 4d b8             	mov    %cl,-0x48(%ebp)
  102273:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102276:	eb 33                	jmp    1022ab <z_prf+0x148>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  102278:	83 ef 30             	sub    $0x30,%edi
			} else if (!isdigit((int)c)) {
				width = 0;
  10227b:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
			} else if (!isdigit((int)c)) {
  102282:	83 ff 09             	cmp    $0x9,%edi
  102285:	77 24                	ja     1022ab <z_prf+0x148>
	while (isdigit((int)*p)) {
  102287:	0f be 06             	movsbl (%esi),%eax
  10228a:	8d 7e 01             	lea    0x1(%esi),%edi
  10228d:	88 45 b8             	mov    %al,-0x48(%ebp)
  102290:	8d 50 d0             	lea    -0x30(%eax),%edx
  102293:	89 7d b0             	mov    %edi,-0x50(%ebp)
  102296:	83 fa 09             	cmp    $0x9,%edx
  102299:	77 10                	ja     1022ab <z_prf+0x148>
		i = 10 * i + *p++ - '0';
  10229b:	6b 55 90 0a          	imul   $0xa,-0x70(%ebp),%edx
  10229f:	8b 75 b0             	mov    -0x50(%ebp),%esi
  1022a2:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
  1022a6:	89 45 90             	mov    %eax,-0x70(%ebp)
  1022a9:	eb dc                	jmp    102287 <z_prf+0x124>
				width = _atoi(&format);	/* Find width */
				c = *format++;
			}

			precision = -1;
			if (c == '.') {
  1022ab:	80 7d b8 2e          	cmpb   $0x2e,-0x48(%ebp)
			precision = -1;
  1022af:	c7 45 bc ff ff ff ff 	movl   $0xffffffff,-0x44(%ebp)
			if (c == '.') {
  1022b6:	75 4f                	jne    102307 <z_prf+0x1a4>
				c = *format++;
				if (c == '*') {
  1022b8:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1022bb:	80 38 2a             	cmpb   $0x2a,(%eax)
  1022be:	75 0d                	jne    1022cd <z_prf+0x16a>
					precision = va_arg(vargs, int);
  1022c0:	8b 03                	mov    (%ebx),%eax
				c = *format++;
  1022c2:	ff 45 b0             	incl   -0x50(%ebp)
					precision = va_arg(vargs, int);
  1022c5:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1022c8:	83 c3 04             	add    $0x4,%ebx
  1022cb:	eb 2b                	jmp    1022f8 <z_prf+0x195>
	int i = 0;
  1022cd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
	while (isdigit((int)*p)) {
  1022d4:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1022d7:	8b 7d b0             	mov    -0x50(%ebp),%edi
  1022da:	0f be 00             	movsbl (%eax),%eax
  1022dd:	8d 77 01             	lea    0x1(%edi),%esi
  1022e0:	8d 50 d0             	lea    -0x30(%eax),%edx
  1022e3:	83 fa 09             	cmp    $0x9,%edx
  1022e6:	77 10                	ja     1022f8 <z_prf+0x195>
		i = 10 * i + *p++ - '0';
  1022e8:	6b 4d bc 0a          	imul   $0xa,-0x44(%ebp),%ecx
  1022ec:	89 75 b0             	mov    %esi,-0x50(%ebp)
  1022ef:	8d 44 08 d0          	lea    -0x30(%eax,%ecx,1),%eax
  1022f3:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1022f6:	eb dc                	jmp    1022d4 <z_prf+0x171>
				} else {
					precision = _atoi(&format);
				}

				c = *format++;
  1022f8:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1022fb:	8a 00                	mov    (%eax),%al
  1022fd:	88 45 b8             	mov    %al,-0x48(%ebp)
  102300:	8b 45 b0             	mov    -0x50(%ebp),%eax
  102303:	40                   	inc    %eax
  102304:	89 45 b0             	mov    %eax,-0x50(%ebp)
			 *    l: long
			 *   ll: long long
			 *    z: size_t or ssize_t
			 */
			i = 0;
			if (strchr("hlz", c) != NULL) {
  102307:	0f be 75 b8          	movsbl -0x48(%ebp),%esi
  10230b:	56                   	push   %esi
  10230c:	68 15 49 12 00       	push   $0x124915
  102311:	e8 cc 99 00 00       	call   10bce2 <strchr>
  102316:	5f                   	pop    %edi
  102317:	85 c0                	test   %eax,%eax
  102319:	5a                   	pop    %edx
  10231a:	74 2f                	je     10234b <z_prf+0x1e8>
				i = c;
				c = *format++;
  10231c:	8b 45 b0             	mov    -0x50(%ebp),%eax
				if (IS_ENABLED(CONFIG_MINIMAL_LIBC_LL_PRINTF) &&
				    i == 'l' && c == 'l') {
					i = 'L';
					c = *format++;
				} else if (i == 'h' && c == 'h') {
  10231f:	83 fe 68             	cmp    $0x68,%esi
				c = *format++;
  102322:	8a 00                	mov    (%eax),%al
  102324:	88 45 b8             	mov    %al,-0x48(%ebp)
				} else if (i == 'h' && c == 'h') {
  102327:	75 04                	jne    10232d <z_prf+0x1ca>
  102329:	3c 68                	cmp    $0x68,%al
  10232b:	74 05                	je     102332 <z_prf+0x1cf>
				c = *format++;
  10232d:	ff 45 b0             	incl   -0x50(%ebp)
  102330:	eb 1b                	jmp    10234d <z_prf+0x1ea>
					i = 'H';
					c = *format++;
  102332:	8b 45 b0             	mov    -0x50(%ebp),%eax
					i = 'H';
  102335:	be 48 00 00 00       	mov    $0x48,%esi
					c = *format++;
  10233a:	8a 40 01             	mov    0x1(%eax),%al
  10233d:	88 45 b8             	mov    %al,-0x48(%ebp)
  102340:	8b 45 b0             	mov    -0x50(%ebp),%eax
  102343:	83 c0 02             	add    $0x2,%eax
  102346:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102349:	eb 02                	jmp    10234d <z_prf+0x1ea>
			i = 0;
  10234b:	31 f6                	xor    %esi,%esi

			cptr = buf;
			prefix = 0;
			zero.predot = zero.postdot = zero.trail = 0;

			switch (c) {
  10234d:	0f be 7d b8          	movsbl -0x48(%ebp),%edi
  102351:	80 7d b8 78          	cmpb   $0x78,-0x48(%ebp)
  102355:	0f 8f 4a 06 00 00    	jg     1029a5 <z_prf+0x842>
  10235b:	80 7d b8 57          	cmpb   $0x57,-0x48(%ebp)
  10235f:	7f 1b                	jg     10237c <z_prf+0x219>
  102361:	80 7d b8 25          	cmpb   $0x25,-0x48(%ebp)
  102365:	0f 84 22 06 00 00    	je     10298d <z_prf+0x82a>
  10236b:	7f 27                	jg     102394 <z_prf+0x231>
  10236d:	80 7d b8 00          	cmpb   $0x0,-0x48(%ebp)
  102371:	0f 84 ce 08 00 00    	je     102c45 <z_prf+0xae2>
  102377:	e9 29 06 00 00       	jmp    1029a5 <z_prf+0x842>
  10237c:	8a 45 b8             	mov    -0x48(%ebp),%al
  10237f:	83 e8 58             	sub    $0x58,%eax
  102382:	3c 20                	cmp    $0x20,%al
  102384:	0f 87 1b 06 00 00    	ja     1029a5 <z_prf+0x842>
  10238a:	0f b6 c0             	movzbl %al,%eax
  10238d:	ff 24 85 d4 3e 12 00 	jmp    *0x123ed4(,%eax,4)
  102394:	8a 45 b8             	mov    -0x48(%ebp),%al
  102397:	83 e8 45             	sub    $0x45,%eax
  10239a:	3c 02                	cmp    $0x2,%al
  10239c:	0f 86 87 00 00 00    	jbe    102429 <z_prf+0x2c6>
  1023a2:	e9 fe 05 00 00       	jmp    1029a5 <z_prf+0x842>
			case 'c':
				buf[0] = va_arg(vargs, int);
  1023a7:	8d 43 04             	lea    0x4(%ebx),%eax
				clen = 1;
				precision = 0;
				break;
  1023aa:	31 f6                	xor    %esi,%esi
				buf[0] = va_arg(vargs, int);
  1023ac:	89 45 9c             	mov    %eax,-0x64(%ebp)
  1023af:	8b 03                	mov    (%ebx),%eax
  1023b1:	88 45 d7             	mov    %al,-0x29(%ebp)
				clen = 1;
  1023b4:	bb 01 00 00 00       	mov    $0x1,%ebx
				break;
  1023b9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  1023c0:	e9 17 06 00 00       	jmp    1029dc <z_prf+0x879>

			case 'd':
			case 'i':
				switch (i) {
  1023c5:	8d 43 04             	lea    0x4(%ebx),%eax
  1023c8:	8b 3b                	mov    (%ebx),%edi
	if (value < 0) {
  1023ca:	89 45 9c             	mov    %eax,-0x64(%ebp)
  1023cd:	85 ff                	test   %edi,%edi
  1023cf:	79 0a                	jns    1023db <z_prf+0x278>
		value = -value;
  1023d1:	89 fa                	mov    %edi,%edx
		*buf++ = '-';
  1023d3:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
		value = -value;
  1023d7:	f7 da                	neg    %edx
  1023d9:	eb 18                	jmp    1023f3 <z_prf+0x290>
	} else if (fplus) {
  1023db:	80 7d 8c 00          	cmpb   $0x0,-0x74(%ebp)
  1023df:	74 06                	je     1023e7 <z_prf+0x284>
		*buf++ = '+';
  1023e1:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
  1023e5:	eb 0a                	jmp    1023f1 <z_prf+0x28e>
	} else if (fspace) {
  1023e7:	80 7d 88 00          	cmpb   $0x0,-0x78(%ebp)
  1023eb:	74 0b                	je     1023f8 <z_prf+0x295>
		*buf++ = ' ';
  1023ed:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
  1023f1:	89 fa                	mov    %edi,%edx
  1023f3:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  1023f6:	eb 05                	jmp    1023fd <z_prf+0x29a>
  1023f8:	89 fa                	mov    %edi,%edx
  1023fa:	8d 5d d7             	lea    -0x29(%ebp),%ebx
	return _to_x(buf, value, 10);
  1023fd:	b9 0a 00 00 00       	mov    $0xa,%ecx
  102402:	89 d8                	mov    %ebx,%eax
				default:
					val = va_arg(vargs, int);
					break;
				}
				clen = _to_dec(buf, val, fplus, fspace);
				if (fplus || fspace || val < 0) {
  102404:	c1 ef 1f             	shr    $0x1f,%edi
	return _to_x(buf, value, 10);
  102407:	e8 c0 fb ff ff       	call   101fcc <_to_x>
	return (buf + _to_udec(buf, value)) - start;
  10240c:	8d 4d f0             	lea    -0x10(%ebp),%ecx
				if (fplus || fspace || val < 0) {
  10240f:	8b 75 8c             	mov    -0x74(%ebp),%esi
	return (buf + _to_udec(buf, value)) - start;
  102412:	29 cb                	sub    %ecx,%ebx
  102414:	8d 5c 03 19          	lea    0x19(%ebx,%eax,1),%ebx
				if (fplus || fspace || val < 0) {
  102418:	8a 45 88             	mov    -0x78(%ebp),%al
  10241b:	09 c6                	or     %eax,%esi
			prefix = 0;
  10241d:	09 fe                	or     %edi,%esi
  10241f:	89 f0                	mov    %esi,%eax
  102421:	0f b6 f0             	movzbl %al,%esi
  102424:	e9 ad 05 00 00       	jmp    1029d6 <z_prf+0x873>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = va_arg(vargs, double);
  102429:	8d 43 08             	lea    0x8(%ebx),%eax
  10242c:	8b 0b                	mov    (%ebx),%ecx
  10242e:	8b 5b 04             	mov    0x4(%ebx),%ebx
	fract = (double_temp << 11) & ~HIGHBIT64;
  102431:	89 ce                	mov    %ecx,%esi
  102433:	89 df                	mov    %ebx,%edi
				u.d = va_arg(vargs, double);
  102435:	89 45 9c             	mov    %eax,-0x64(%ebp)
	fract = (double_temp << 11) & ~HIGHBIT64;
  102438:	0f a4 f7 0b          	shld   $0xb,%esi,%edi
  10243c:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
	exp = double_temp >> 52 & 0x7ff;
  102442:	89 d8                	mov    %ebx,%eax
	fract = (double_temp << 11) & ~HIGHBIT64;
  102444:	c1 e6 0b             	shl    $0xb,%esi
  102447:	89 7d 98             	mov    %edi,-0x68(%ebp)
  10244a:	89 75 94             	mov    %esi,-0x6c(%ebp)
  10244d:	8b 7d 98             	mov    -0x68(%ebp),%edi
	exp = double_temp >> 52 & 0x7ff;
  102450:	c1 e8 14             	shr    $0x14,%eax
	fract = (double_temp << 11) & ~HIGHBIT64;
  102453:	8b 75 94             	mov    -0x6c(%ebp),%esi
	exp = double_temp >> 52 & 0x7ff;
  102456:	25 ff 07 00 00       	and    $0x7ff,%eax
	fract = (double_temp << 11) & ~HIGHBIT64;
  10245b:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  10245e:	89 7d c8             	mov    %edi,-0x38(%ebp)
	if (sign) {
  102461:	85 db                	test   %ebx,%ebx
  102463:	79 06                	jns    10246b <z_prf+0x308>
		*buf++ = '-';
  102465:	c6 45 d7 2d          	movb   $0x2d,-0x29(%ebp)
  102469:	eb 19                	jmp    102484 <z_prf+0x321>
	} else if (fplus) {
  10246b:	80 7d 8c 00          	cmpb   $0x0,-0x74(%ebp)
  10246f:	74 06                	je     102477 <z_prf+0x314>
		*buf++ = '+';
  102471:	c6 45 d7 2b          	movb   $0x2b,-0x29(%ebp)
  102475:	eb 0d                	jmp    102484 <z_prf+0x321>
	} else if (fspace) {
  102477:	80 7d 88 00          	cmpb   $0x0,-0x78(%ebp)
  10247b:	8d 5d d7             	lea    -0x29(%ebp),%ebx
  10247e:	74 07                	je     102487 <z_prf+0x324>
		*buf++ = ' ';
  102480:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
  102484:	8d 5d d8             	lea    -0x28(%ebp),%ebx
	if (exp == 0x7ff) {
  102487:	3d ff 07 00 00       	cmp    $0x7ff,%eax
  10248c:	75 6b                	jne    1024f9 <z_prf+0x396>
		if (!fract) {
  10248e:	0f be 45 b8          	movsbl -0x48(%ebp),%eax
  102492:	8b 7d 98             	mov    -0x68(%ebp),%edi
  102495:	83 e8 41             	sub    $0x41,%eax
  102498:	8d 53 03             	lea    0x3(%ebx),%edx
  10249b:	0b 7d 94             	or     -0x6c(%ebp),%edi
  10249e:	75 1b                	jne    1024bb <z_prf+0x358>
			if (isupper((int)c)) {
  1024a0:	83 f8 19             	cmp    $0x19,%eax
  1024a3:	77 0b                	ja     1024b0 <z_prf+0x34d>
				*buf++ = 'I';
  1024a5:	66 c7 03 49 4e       	movw   $0x4e49,(%ebx)
				*buf++ = 'F';
  1024aa:	c6 43 02 46          	movb   $0x46,0x2(%ebx)
  1024ae:	eb 24                	jmp    1024d4 <z_prf+0x371>
				*buf++ = 'i';
  1024b0:	66 c7 03 69 6e       	movw   $0x6e69,(%ebx)
				*buf++ = 'f';
  1024b5:	c6 43 02 66          	movb   $0x66,0x2(%ebx)
  1024b9:	eb 19                	jmp    1024d4 <z_prf+0x371>
			if (isupper((int)c)) {
  1024bb:	83 f8 19             	cmp    $0x19,%eax
  1024be:	77 0b                	ja     1024cb <z_prf+0x368>
				*buf++ = 'N';
  1024c0:	66 c7 03 4e 41       	movw   $0x414e,(%ebx)
				*buf++ = 'N';
  1024c5:	c6 43 02 4e          	movb   $0x4e,0x2(%ebx)
  1024c9:	eb 09                	jmp    1024d4 <z_prf+0x371>
				*buf++ = 'n';
  1024cb:	66 c7 03 6e 61       	movw   $0x616e,(%ebx)
				*buf++ = 'n';
  1024d0:	c6 43 02 6e          	movb   $0x6e,0x2(%ebx)
		return buf - start;
  1024d4:	8d 45 d7             	lea    -0x29(%ebp),%eax
		*buf = 0;
  1024d7:	c6 43 03 00          	movb   $0x0,0x3(%ebx)
		return buf - start;
  1024db:	29 c2                	sub    %eax,%edx
			zero.predot = zero.postdot = zero.trail = 0;
  1024dd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
		return buf - start;
  1024e4:	89 d3                	mov    %edx,%ebx
			zero.predot = zero.postdot = zero.trail = 0;
  1024e6:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  1024ed:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
		return buf - start;
  1024f4:	e9 4c 03 00 00       	jmp    102845 <z_prf+0x6e2>
	if (c == 'F') {
  1024f9:	80 7d b8 46          	cmpb   $0x46,-0x48(%ebp)
  1024fd:	75 04                	jne    102503 <z_prf+0x3a0>
		c = 'f';
  1024ff:	c6 45 b8 66          	movb   $0x66,-0x48(%ebp)
	if ((exp | fract) != 0) {
  102503:	89 c7                	mov    %eax,%edi
  102505:	8b 55 94             	mov    -0x6c(%ebp),%edx
  102508:	c1 ff 1f             	sar    $0x1f,%edi
  10250b:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  10250e:	09 c2                	or     %eax,%edx
  102510:	09 f9                	or     %edi,%ecx
  102512:	09 d1                	or     %edx,%ecx
  102514:	0f 84 cc 00 00 00    	je     1025e6 <z_prf+0x483>
		if (exp == 0) {
  10251a:	85 c0                	test   %eax,%eax
  10251c:	75 21                	jne    10253f <z_prf+0x3dc>
			while (((fract <<= 1) & HIGHBIT64) == 0) {
  10251e:	8b 55 94             	mov    -0x6c(%ebp),%edx
  102521:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  102524:	01 55 94             	add    %edx,-0x6c(%ebp)
  102527:	11 4d 98             	adc    %ecx,-0x68(%ebp)
  10252a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
  10252e:	78 03                	js     102533 <z_prf+0x3d0>
				exp--;
  102530:	48                   	dec    %eax
  102531:	eb eb                	jmp    10251e <z_prf+0x3bb>
  102533:	8b 55 94             	mov    -0x6c(%ebp),%edx
  102536:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  102539:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  10253c:	89 4d c8             	mov    %ecx,-0x38(%ebp)
		fract |= HIGHBIT64;
  10253f:	81 4d c8 00 00 00 80 	orl    $0x80000000,-0x38(%ebp)
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  102546:	8d b0 02 fc ff ff    	lea    -0x3fe(%eax),%esi
		fract |= HIGHBIT64;
  10254c:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	while (exp <= -3) {
  102553:	83 fe fe             	cmp    $0xfffffffe,%esi
  102556:	7d 5e                	jge    1025b6 <z_prf+0x453>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
  102558:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  10255b:	46                   	inc    %esi
  10255c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10255f:	81 f9 32 33 33 33    	cmp    $0x33333332,%ecx
  102565:	76 0a                	jbe    102571 <z_prf+0x40e>
			_rlrshift(&fract);
  102567:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  10256a:	e8 10 fb ff ff       	call   10207f <_rlrshift>
			exp++;
  10256f:	eb e7                	jmp    102558 <z_prf+0x3f5>
		fract *= 5U;
  102571:	ba 05 00 00 00       	mov    $0x5,%edx
  102576:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  102579:	f7 e2                	mul    %edx
		decexp--;
  10257b:	ff 4d b4             	decl   -0x4c(%ebp)
		fract *= 5U;
  10257e:	01 ca                	add    %ecx,%edx
  102580:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  102583:	89 55 c8             	mov    %edx,-0x38(%ebp)
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  102586:	31 c9                	xor    %ecx,%ecx
  102588:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
  10258d:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
  102593:	39 d7                	cmp    %edx,%edi
  102595:	72 09                	jb     1025a0 <z_prf+0x43d>
			fract <<= 1;
  102597:	01 c0                	add    %eax,%eax
			exp--;
  102599:	b1 01                	mov    $0x1,%cl
			fract <<= 1;
  10259b:	11 d2                	adc    %edx,%edx
			exp--;
  10259d:	4e                   	dec    %esi
  10259e:	eb ed                	jmp    10258d <z_prf+0x42a>
  1025a0:	84 c9                	test   %cl,%cl
  1025a2:	74 af                	je     102553 <z_prf+0x3f0>
  1025a4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1025a7:	89 55 c8             	mov    %edx,-0x38(%ebp)
  1025aa:	eb a7                	jmp    102553 <z_prf+0x3f0>
  1025ac:	84 c9                	test   %cl,%cl
  1025ae:	74 06                	je     1025b6 <z_prf+0x453>
  1025b0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1025b3:	89 55 c8             	mov    %edx,-0x38(%ebp)
	while (exp > 0) {
  1025b6:	85 f6                	test   %esi,%esi
  1025b8:	7e 35                	jle    1025ef <z_prf+0x48c>
		_ldiv5(&fract);
  1025ba:	8d 45 c4             	lea    -0x3c(%ebp),%eax
		exp--;
  1025bd:	4e                   	dec    %esi
		_ldiv5(&fract);
  1025be:	e8 e4 fa ff ff       	call   1020a7 <_ldiv5>
		decexp++;
  1025c3:	ff 45 b4             	incl   -0x4c(%ebp)
  1025c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  1025c9:	8b 55 c8             	mov    -0x38(%ebp),%edx
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  1025cc:	31 c9                	xor    %ecx,%ecx
  1025ce:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
  1025d3:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
  1025d9:	39 d7                	cmp    %edx,%edi
  1025db:	72 cf                	jb     1025ac <z_prf+0x449>
			fract <<= 1;
  1025dd:	01 c0                	add    %eax,%eax
			exp--;
  1025df:	b1 01                	mov    $0x1,%cl
			fract <<= 1;
  1025e1:	11 d2                	adc    %edx,%edx
			exp--;
  1025e3:	4e                   	dec    %esi
  1025e4:	eb ed                	jmp    1025d3 <z_prf+0x470>
  1025e6:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
  1025ed:	31 f6                	xor    %esi,%esi
		_rlrshift(&fract);
  1025ef:	8d 45 c4             	lea    -0x3c(%ebp),%eax
		exp++;
  1025f2:	46                   	inc    %esi
		_rlrshift(&fract);
  1025f3:	e8 87 fa ff ff       	call   10207f <_rlrshift>
	while (exp < (0 + 4)) {
  1025f8:	83 fe 04             	cmp    $0x4,%esi
  1025fb:	75 f2                	jne    1025ef <z_prf+0x48c>
	if (precision < 0) {
  1025fd:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  102601:	79 07                	jns    10260a <z_prf+0x4a7>
		precision = 6;		/* Default precision if none given */
  102603:	c7 45 bc 06 00 00 00 	movl   $0x6,-0x44(%ebp)
	if ((c == 'g') || (c == 'G')) {
  10260a:	8a 45 b8             	mov    -0x48(%ebp),%al
	prune_zero = false;		/* Assume trailing 0's allowed     */
  10260d:	31 ff                	xor    %edi,%edi
	if ((c == 'g') || (c == 'G')) {
  10260f:	83 e0 df             	and    $0xffffffdf,%eax
  102612:	3c 47                	cmp    $0x47,%al
  102614:	75 35                	jne    10264b <z_prf+0x4e8>
		if (decexp < (-4 + 1) || decexp > precision) {
  102616:	83 7d b4 fd          	cmpl   $0xfffffffd,-0x4c(%ebp)
  10261a:	7c 08                	jl     102624 <z_prf+0x4c1>
  10261c:	8b 7d bc             	mov    -0x44(%ebp),%edi
  10261f:	39 7d b4             	cmp    %edi,-0x4c(%ebp)
  102622:	7e 0e                	jle    102632 <z_prf+0x4cf>
			c += 'e' - 'g';
  102624:	80 6d b8 02          	subb   $0x2,-0x48(%ebp)
				precision--;
  102628:	83 7d bc 01          	cmpl   $0x1,-0x44(%ebp)
  10262c:	83 55 bc ff          	adcl   $0xffffffff,-0x44(%ebp)
  102630:	eb 0a                	jmp    10263c <z_prf+0x4d9>
			precision -= decexp;
  102632:	8b 7d b4             	mov    -0x4c(%ebp),%edi
			c = 'f';
  102635:	c6 45 b8 66          	movb   $0x66,-0x48(%ebp)
			precision -= decexp;
  102639:	29 7d bc             	sub    %edi,-0x44(%ebp)
		if (!falt && (precision > 0)) {
  10263c:	8b 7d a4             	mov    -0x5c(%ebp),%edi
  10263f:	83 f7 01             	xor    $0x1,%edi
  102642:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  102646:	0f 9f c0             	setg   %al
  102649:	21 c7                	and    %eax,%edi
		exp = precision + 1;
  10264b:	8b 45 bc             	mov    -0x44(%ebp),%eax
  10264e:	40                   	inc    %eax
	if (c == 'f') {
  10264f:	80 7d b8 66          	cmpb   $0x66,-0x48(%ebp)
  102653:	75 0a                	jne    10265f <z_prf+0x4fc>
		if (exp < 0) {
  102655:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			exp = 0;
  102658:	31 f6                	xor    %esi,%esi
		if (exp < 0) {
  10265a:	03 45 bc             	add    -0x44(%ebp),%eax
  10265d:	78 0c                	js     10266b <z_prf+0x508>
	if (exp > 16) {
  10265f:	89 c6                	mov    %eax,%esi
  102661:	83 f8 10             	cmp    $0x10,%eax
  102664:	7e 05                	jle    10266b <z_prf+0x508>
  102666:	be 10 00 00 00       	mov    $0x10,%esi
  10266b:	c7 45 c0 10 00 00 00 	movl   $0x10,-0x40(%ebp)
	ltemp = 0x0800000000000000;
  102672:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  102679:	c7 45 d0 00 00 00 08 	movl   $0x8000000,-0x30(%ebp)
	while (exp--) {
  102680:	4e                   	dec    %esi
  102681:	83 fe ff             	cmp    $0xffffffff,%esi
  102684:	74 12                	je     102698 <z_prf+0x535>
		_ldiv5(&ltemp);
  102686:	8d 45 cc             	lea    -0x34(%ebp),%eax
  102689:	e8 19 fa ff ff       	call   1020a7 <_ldiv5>
		_rlrshift(&ltemp);
  10268e:	8d 45 cc             	lea    -0x34(%ebp),%eax
  102691:	e8 e9 f9 ff ff       	call   10207f <_rlrshift>
  102696:	eb e8                	jmp    102680 <z_prf+0x51d>
	fract += ltemp;
  102698:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10269b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10269e:	03 45 c4             	add    -0x3c(%ebp),%eax
  1026a1:	13 55 c8             	adc    -0x38(%ebp),%edx
  1026a4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if ((fract >> 32) & 0xF0000000) {
  1026a7:	89 d0                	mov    %edx,%eax
	fract += ltemp;
  1026a9:	89 55 c8             	mov    %edx,-0x38(%ebp)
	if ((fract >> 32) & 0xF0000000) {
  1026ac:	a9 00 00 00 f0       	test   $0xf0000000,%eax
  1026b1:	74 13                	je     1026c6 <z_prf+0x563>
		_ldiv5(&fract);
  1026b3:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  1026b6:	e8 ec f9 ff ff       	call   1020a7 <_ldiv5>
		_rlrshift(&fract);
  1026bb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  1026be:	e8 bc f9 ff ff       	call   10207f <_rlrshift>
		decexp++;
  1026c3:	ff 45 b4             	incl   -0x4c(%ebp)
	if (c == 'f') {
  1026c6:	80 7d b8 66          	cmpb   $0x66,-0x48(%ebp)
  1026ca:	0f 85 a5 00 00 00    	jne    102775 <z_prf+0x612>
		if (decexp > 0) {
  1026d0:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  1026d4:	7e 24                	jle    1026fa <z_prf+0x597>
			while (decexp > 0 && digit_count > 0) {
  1026d6:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  1026da:	7e 1a                	jle    1026f6 <z_prf+0x593>
  1026dc:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  1026e0:	7e 14                	jle    1026f6 <z_prf+0x593>
				*buf++ = _get_digit(&fract, &digit_count);
  1026e2:	8d 55 c0             	lea    -0x40(%ebp),%edx
  1026e5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  1026e8:	e8 3f fa ff ff       	call   10212c <_get_digit>
  1026ed:	43                   	inc    %ebx
				decexp--;
  1026ee:	ff 4d b4             	decl   -0x4c(%ebp)
				*buf++ = _get_digit(&fract, &digit_count);
  1026f1:	88 43 ff             	mov    %al,-0x1(%ebx)
				decexp--;
  1026f4:	eb e0                	jmp    1026d6 <z_prf+0x573>
			decexp = 0;
  1026f6:	31 f6                	xor    %esi,%esi
  1026f8:	eb 0e                	jmp    102708 <z_prf+0x5a5>
			*buf++ = '0';
  1026fa:	c6 03 30             	movb   $0x30,(%ebx)
  1026fd:	8b 75 b4             	mov    -0x4c(%ebp),%esi
  102700:	43                   	inc    %ebx
			zero.predot = zero.postdot = zero.trail = 0;
  102701:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
		if (falt || (precision > 0)) {
  102708:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  10270c:	0f 9f c0             	setg   %al
  10270f:	80 7d a4 00          	cmpb   $0x0,-0x5c(%ebp)
  102713:	75 0f                	jne    102724 <z_prf+0x5c1>
			zero.predot = zero.postdot = zero.trail = 0;
  102715:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		if (falt || (precision > 0)) {
  10271c:	84 c0                	test   %al,%al
  10271e:	0f 84 ac 00 00 00    	je     1027d0 <z_prf+0x66d>
			*buf++ = '.';
  102724:	8d 53 01             	lea    0x1(%ebx),%edx
  102727:	c6 03 2e             	movb   $0x2e,(%ebx)
		if (decexp < 0 && precision > 0) {
  10272a:	85 f6                	test   %esi,%esi
  10272c:	79 1e                	jns    10274c <z_prf+0x5e9>
  10272e:	84 c0                	test   %al,%al
  102730:	74 1a                	je     10274c <z_prf+0x5e9>
			if (zp->postdot > precision) {
  102732:	89 f0                	mov    %esi,%eax
  102734:	f7 d8                	neg    %eax
  102736:	3b 45 bc             	cmp    -0x44(%ebp),%eax
  102739:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  10273c:	7e 06                	jle    102744 <z_prf+0x5e1>
  10273e:	8b 45 bc             	mov    -0x44(%ebp),%eax
  102741:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			precision -= zp->postdot;
  102744:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
  102747:	29 4d bc             	sub    %ecx,-0x44(%ebp)
  10274a:	eb 07                	jmp    102753 <z_prf+0x5f0>
			zero.predot = zero.postdot = zero.trail = 0;
  10274c:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  102753:	89 d3                	mov    %edx,%ebx
		while (precision > 0 && digit_count > 0) {
  102755:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  102759:	7e 75                	jle    1027d0 <z_prf+0x66d>
  10275b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  10275f:	7e 6f                	jle    1027d0 <z_prf+0x66d>
			*buf++ = _get_digit(&fract, &digit_count);
  102761:	8d 55 c0             	lea    -0x40(%ebp),%edx
  102764:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  102767:	e8 c0 f9 ff ff       	call   10212c <_get_digit>
  10276c:	43                   	inc    %ebx
			precision--;
  10276d:	ff 4d bc             	decl   -0x44(%ebp)
			*buf++ = _get_digit(&fract, &digit_count);
  102770:	88 43 ff             	mov    %al,-0x1(%ebx)
			precision--;
  102773:	eb e0                	jmp    102755 <z_prf+0x5f2>
		*buf = _get_digit(&fract, &digit_count);
  102775:	8d 55 c0             	lea    -0x40(%ebp),%edx
  102778:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  10277b:	e8 ac f9 ff ff       	call   10212c <_get_digit>
  102780:	88 03                	mov    %al,(%ebx)
		if (*buf++ != '0') {
  102782:	3c 30                	cmp    $0x30,%al
  102784:	74 03                	je     102789 <z_prf+0x626>
			decexp--;
  102786:	ff 4d b4             	decl   -0x4c(%ebp)
		if (falt || (precision > 0)) {
  102789:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  10278d:	7f 09                	jg     102798 <z_prf+0x635>
  10278f:	80 7d a4 00          	cmpb   $0x0,-0x5c(%ebp)
  102793:	75 03                	jne    102798 <z_prf+0x635>
		if (*buf++ != '0') {
  102795:	43                   	inc    %ebx
  102796:	eb 27                	jmp    1027bf <z_prf+0x65c>
			*buf++ = '.';
  102798:	c6 43 01 2e          	movb   $0x2e,0x1(%ebx)
  10279c:	83 c3 02             	add    $0x2,%ebx
		while (precision > 0 && digit_count > 0) {
  10279f:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  1027a3:	7e 1a                	jle    1027bf <z_prf+0x65c>
  1027a5:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  1027a9:	7e 14                	jle    1027bf <z_prf+0x65c>
			*buf++ = _get_digit(&fract, &digit_count);
  1027ab:	8d 55 c0             	lea    -0x40(%ebp),%edx
  1027ae:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  1027b1:	e8 76 f9 ff ff       	call   10212c <_get_digit>
  1027b6:	43                   	inc    %ebx
			precision--;
  1027b7:	ff 4d bc             	decl   -0x44(%ebp)
			*buf++ = _get_digit(&fract, &digit_count);
  1027ba:	88 43 ff             	mov    %al,-0x1(%ebx)
			precision--;
  1027bd:	eb e0                	jmp    10279f <z_prf+0x63c>
			*buf++ = '.';
  1027bf:	8b 75 b4             	mov    -0x4c(%ebp),%esi
			zero.predot = zero.postdot = zero.trail = 0;
  1027c2:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  1027c9:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	if (prune_zero) {
  1027d0:	89 f8                	mov    %edi,%eax
  1027d2:	84 c0                	test   %al,%al
  1027d4:	74 16                	je     1027ec <z_prf+0x689>
		while (*--buf == '0')
  1027d6:	89 da                	mov    %ebx,%edx
  1027d8:	4b                   	dec    %ebx
  1027d9:	8a 03                	mov    (%ebx),%al
  1027db:	3c 30                	cmp    $0x30,%al
  1027dd:	74 f7                	je     1027d6 <z_prf+0x673>
		zp->trail = 0;
  1027df:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
		if (*buf != '.') {
  1027e6:	3c 2e                	cmp    $0x2e,%al
  1027e8:	74 02                	je     1027ec <z_prf+0x689>
  1027ea:	89 d3                	mov    %edx,%ebx
	if ((c == 'e') || (c == 'E')) {
  1027ec:	8a 45 b8             	mov    -0x48(%ebp),%al
  1027ef:	83 e0 df             	and    $0xffffffdf,%eax
  1027f2:	3c 45                	cmp    $0x45,%al
  1027f4:	75 47                	jne    10283d <z_prf+0x6da>
		*buf++ = c;
  1027f6:	8a 45 b8             	mov    -0x48(%ebp),%al
  1027f9:	8d 4b 02             	lea    0x2(%ebx),%ecx
  1027fc:	88 03                	mov    %al,(%ebx)
		if (decexp < 0) {
  1027fe:	85 f6                	test   %esi,%esi
			*buf++ = '+';
  102800:	b0 2b                	mov    $0x2b,%al
		if (decexp < 0) {
  102802:	79 04                	jns    102808 <z_prf+0x6a5>
			decexp = -decexp;
  102804:	f7 de                	neg    %esi
			*buf++ = '-';
  102806:	b0 2d                	mov    $0x2d,%al
  102808:	88 43 01             	mov    %al,0x1(%ebx)
		if (decexp >= 100) {
  10280b:	83 fe 63             	cmp    $0x63,%esi
  10280e:	7e 15                	jle    102825 <z_prf+0x6c2>
			*buf++ = (decexp / 100) + '0';
  102810:	89 f0                	mov    %esi,%eax
  102812:	bf 64 00 00 00       	mov    $0x64,%edi
  102817:	99                   	cltd   
  102818:	f7 ff                	idiv   %edi
  10281a:	83 c0 30             	add    $0x30,%eax
  10281d:	8d 4b 03             	lea    0x3(%ebx),%ecx
  102820:	89 d6                	mov    %edx,%esi
  102822:	88 43 02             	mov    %al,0x2(%ebx)
		*buf++ = (decexp / 10) + '0';
  102825:	89 f0                	mov    %esi,%eax
  102827:	bb 0a 00 00 00       	mov    $0xa,%ebx
  10282c:	99                   	cltd   
  10282d:	f7 fb                	idiv   %ebx
  10282f:	83 c0 30             	add    $0x30,%eax
		*buf++ = decexp + '0';
  102832:	83 c2 30             	add    $0x30,%edx
		*buf++ = (decexp / 10) + '0';
  102835:	88 01                	mov    %al,(%ecx)
		*buf++ = decexp + '0';
  102837:	8d 59 02             	lea    0x2(%ecx),%ebx
  10283a:	88 51 01             	mov    %dl,0x1(%ecx)
	return buf - start;
  10283d:	8d 45 d7             	lea    -0x29(%ebp),%eax
	*buf = 0;
  102840:	c6 03 00             	movb   $0x0,(%ebx)
	return buf - start;
  102843:	29 c3                	sub    %eax,%ebx
				double_val = u.i;

				clen = _to_float(buf, double_val, c, falt,
						 fplus, fspace, precision,
						 &zero);
				if (fplus || fspace || (buf[0] == '-')) {
  102845:	80 7d 8c 00          	cmpb   $0x0,-0x74(%ebp)
  102849:	75 13                	jne    10285e <z_prf+0x6fb>
  10284b:	80 7d 88 00          	cmpb   $0x0,-0x78(%ebp)
  10284f:	75 0d                	jne    10285e <z_prf+0x6fb>
  102851:	31 c0                	xor    %eax,%eax
  102853:	80 7d d7 2d          	cmpb   $0x2d,-0x29(%ebp)
  102857:	0f 94 c0             	sete   %al
  10285a:	89 c6                	mov    %eax,%esi
  10285c:	eb 05                	jmp    102863 <z_prf+0x700>
					prefix = 1;
  10285e:	be 01 00 00 00       	mov    $0x1,%esi
				}
				clen += zero.predot + zero.postdot + zero.trail;
  102863:	03 5d bc             	add    -0x44(%ebp),%ebx
  102866:	0f be 44 35 d7       	movsbl -0x29(%ebp,%esi,1),%eax
  10286b:	03 5d b4             	add    -0x4c(%ebp),%ebx
  10286e:	83 e8 30             	sub    $0x30,%eax
  102871:	03 5d a4             	add    -0x5c(%ebp),%ebx
				if (!isdigit((int)buf[prefix])) {
  102874:	83 f8 09             	cmp    $0x9,%eax
  102877:	0f 87 b4 01 00 00    	ja     102a31 <z_prf+0x8ce>
  10287d:	e9 9b 01 00 00       	jmp    102a1d <z_prf+0x8ba>
				precision = -1;
				break;
			}

			case 'n':
				switch (i) {
  102882:	8d 43 04             	lea    0x4(%ebx),%eax
  102885:	83 fe 68             	cmp    $0x68,%esi
  102888:	89 45 9c             	mov    %eax,-0x64(%ebp)
  10288b:	8b 03                	mov    (%ebx),%eax
  10288d:	74 14                	je     1028a3 <z_prf+0x740>
  10288f:	83 fe 6c             	cmp    $0x6c,%esi
  102892:	74 1a                	je     1028ae <z_prf+0x74b>
  102894:	83 fe 48             	cmp    $0x48,%esi
  102897:	75 15                	jne    1028ae <z_prf+0x74b>
				case 'h':
					*va_arg(vargs, short *) = count;
					break;
				case 'H':
					*va_arg(vargs, char *) = count;
  102899:	8a 55 a0             	mov    -0x60(%ebp),%dl
  10289c:	88 10                	mov    %dl,(%eax)
					break;
  10289e:	e9 9a 03 00 00       	jmp    102c3d <z_prf+0xada>
					*va_arg(vargs, short *) = count;
  1028a3:	8b 7d a0             	mov    -0x60(%ebp),%edi
  1028a6:	66 89 38             	mov    %di,(%eax)
					break;
  1028a9:	e9 8f 03 00 00       	jmp    102c3d <z_prf+0xada>
#endif
				case 'z':
					*va_arg(vargs, ssize_t *) = count;
					break;
				default:
					*va_arg(vargs, int *) = count;
  1028ae:	8b 7d a0             	mov    -0x60(%ebp),%edi
  1028b1:	89 38                	mov    %edi,(%eax)
					break;
  1028b3:	e9 85 03 00 00       	jmp    102c3d <z_prf+0xada>
				}
				continue;

			case 'p':
				val = (uintptr_t) va_arg(vargs, void *);
  1028b8:	8d 43 04             	lea    0x4(%ebx),%eax
				clen = _to_hex(buf, val, true, 'x');
  1028bb:	b9 01 00 00 00       	mov    $0x1,%ecx
				val = (uintptr_t) va_arg(vargs, void *);
  1028c0:	89 45 9c             	mov    %eax,-0x64(%ebp)
				clen = _to_hex(buf, val, true, 'x');
  1028c3:	8b 13                	mov    (%ebx),%edx
  1028c5:	8d 45 d7             	lea    -0x29(%ebp),%eax
  1028c8:	6a 78                	push   $0x78
  1028ca:	e8 5a f7 ff ff       	call   102029 <_to_hex>
				prefix = 2;
  1028cf:	be 02 00 00 00       	mov    $0x2,%esi
				clen = _to_hex(buf, val, true, 'x');
  1028d4:	59                   	pop    %ecx
  1028d5:	89 c3                	mov    %eax,%ebx
				break;
  1028d7:	e9 fa 00 00 00       	jmp    1029d6 <z_prf+0x873>

			case 's':
				cptr = va_arg(vargs, char *);
  1028dc:	8d 43 04             	lea    0x4(%ebx),%eax
  1028df:	8b 13                	mov    (%ebx),%edx
				/* Get the string length */
				if (precision < 0) {
  1028e1:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
				cptr = va_arg(vargs, char *);
  1028e5:	89 45 9c             	mov    %eax,-0x64(%ebp)
				if (precision < 0) {
  1028e8:	79 07                	jns    1028f1 <z_prf+0x78e>
					precision = INT_MAX;
  1028ea:	c7 45 bc ff ff ff 7f 	movl   $0x7fffffff,-0x44(%ebp)
				}
				for (clen = 0; clen < precision; clen++) {
  1028f1:	31 db                	xor    %ebx,%ebx
  1028f3:	39 5d bc             	cmp    %ebx,-0x44(%ebp)
  1028f6:	74 0d                	je     102905 <z_prf+0x7a2>
					if (cptr[clen] == '\0') {
  1028f8:	80 3c 1a 00          	cmpb   $0x0,(%edx,%ebx,1)
  1028fc:	0f 84 df 00 00 00    	je     1029e1 <z_prf+0x87e>
				for (clen = 0; clen < precision; clen++) {
  102902:	43                   	inc    %ebx
  102903:	eb ee                	jmp    1028f3 <z_prf+0x790>
  102905:	8b 5d bc             	mov    -0x44(%ebp),%ebx
  102908:	e9 d4 00 00 00       	jmp    1029e1 <z_prf+0x87e>

			case 'o':
			case 'u':
			case 'x':
			case 'X':
				switch (i) {
  10290d:	8d 43 04             	lea    0x4(%ebx),%eax
  102910:	8b 13                	mov    (%ebx),%edx
				case 'H':
				default:
					val = va_arg(vargs, unsigned int);
					break;
				}
				if (c == 'o') {
  102912:	80 7d b8 6f          	cmpb   $0x6f,-0x48(%ebp)
  102916:	89 45 9c             	mov    %eax,-0x64(%ebp)
  102919:	75 3b                	jne    102956 <z_prf+0x7f3>
	if (alt_form) {
  10291b:	80 7d a4 00          	cmpb   $0x0,-0x5c(%ebp)
  10291f:	74 1b                	je     10293c <z_prf+0x7d9>
		*buf++ = '0';
  102921:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
  102925:	8d 5d d8             	lea    -0x28(%ebp),%ebx
		if (!value) {
  102928:	85 d2                	test   %edx,%edx
  10292a:	75 13                	jne    10293f <z_prf+0x7dc>
			*buf++ = 0;
  10292c:	c6 45 d8 00          	movb   $0x0,-0x28(%ebp)
			prefix = 0;
  102930:	31 f6                	xor    %esi,%esi
			return 1;
  102932:	bb 01 00 00 00       	mov    $0x1,%ebx
  102937:	e9 9a 00 00 00       	jmp    1029d6 <z_prf+0x873>
  10293c:	8d 5d d7             	lea    -0x29(%ebp),%ebx
	return (buf - buf0) + _to_x(buf, value, 8);
  10293f:	89 d8                	mov    %ebx,%eax
  102941:	b9 08 00 00 00       	mov    $0x8,%ecx
  102946:	e8 81 f6 ff ff       	call   101fcc <_to_x>
  10294b:	8d 7d f0             	lea    -0x10(%ebp),%edi
  10294e:	29 fb                	sub    %edi,%ebx
  102950:	8d 5c 03 19          	lea    0x19(%ebx,%eax,1),%ebx
  102954:	eb 15                	jmp    10296b <z_prf+0x808>
					clen = _to_octal(buf, val, falt);
				} else if (c == 'u') {
  102956:	80 7d b8 75          	cmpb   $0x75,-0x48(%ebp)
  10295a:	75 13                	jne    10296f <z_prf+0x80c>
	return _to_x(buf, value, 10);
  10295c:	b9 0a 00 00 00       	mov    $0xa,%ecx
  102961:	8d 45 d7             	lea    -0x29(%ebp),%eax
  102964:	e8 63 f6 ff ff       	call   101fcc <_to_x>
  102969:	89 c3                	mov    %eax,%ebx
			prefix = 0;
  10296b:	31 f6                	xor    %esi,%esi
  10296d:	eb 67                	jmp    1029d6 <z_prf+0x873>
					clen = _to_udec(buf, val);
				} else {
					clen = _to_hex(buf, val, falt, c);
  10296f:	0f b6 4d a4          	movzbl -0x5c(%ebp),%ecx
  102973:	8d 45 d7             	lea    -0x29(%ebp),%eax
  102976:	57                   	push   %edi
  102977:	e8 ad f6 ff ff       	call   102029 <_to_hex>
					if (falt) {
						prefix = 2;
  10297c:	8b 75 a4             	mov    -0x5c(%ebp),%esi
  10297f:	c1 e6 1f             	shl    $0x1f,%esi
					clen = _to_hex(buf, val, falt, c);
  102982:	5a                   	pop    %edx
						prefix = 2;
  102983:	c1 fe 1f             	sar    $0x1f,%esi
					clen = _to_hex(buf, val, falt, c);
  102986:	89 c3                	mov    %eax,%ebx
						prefix = 2;
  102988:	83 e6 02             	and    $0x2,%esi
  10298b:	eb 49                	jmp    1029d6 <z_prf+0x873>
					}
				}
				break;

			case '%':
				PUTC('%');
  10298d:	ff 75 a8             	pushl  -0x58(%ebp)
  102990:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102993:	6a 25                	push   $0x25
  102995:	ff d0                	call   *%eax
  102997:	5e                   	pop    %esi
  102998:	40                   	inc    %eax
  102999:	5f                   	pop    %edi
  10299a:	0f 84 15 f8 ff ff    	je     1021b5 <z_prf+0x52>
				count++;
  1029a0:	ff 45 a0             	incl   -0x60(%ebp)
  1029a3:	eb 29                	jmp    1029ce <z_prf+0x86b>
				continue;

			default:
				PUTC('%');
  1029a5:	ff 75 a8             	pushl  -0x58(%ebp)
  1029a8:	8b 45 ac             	mov    -0x54(%ebp),%eax
  1029ab:	6a 25                	push   $0x25
  1029ad:	ff d0                	call   *%eax
  1029af:	5a                   	pop    %edx
  1029b0:	40                   	inc    %eax
  1029b1:	59                   	pop    %ecx
  1029b2:	0f 84 fd f7 ff ff    	je     1021b5 <z_prf+0x52>
				PUTC(c);
  1029b8:	ff 75 a8             	pushl  -0x58(%ebp)
  1029bb:	8b 45 ac             	mov    -0x54(%ebp),%eax
  1029be:	57                   	push   %edi
  1029bf:	ff d0                	call   *%eax
  1029c1:	59                   	pop    %ecx
  1029c2:	40                   	inc    %eax
  1029c3:	5e                   	pop    %esi
  1029c4:	0f 84 eb f7 ff ff    	je     1021b5 <z_prf+0x52>
				count += 2;
  1029ca:	83 45 a0 02          	addl   $0x2,-0x60(%ebp)
				continue;
  1029ce:	89 5d 9c             	mov    %ebx,-0x64(%ebp)
  1029d1:	e9 67 02 00 00       	jmp    102c3d <z_prf+0xada>

			case 0:
				return count;
			}

			if (precision >= 0) {
  1029d6:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  1029da:	78 2c                	js     102a08 <z_prf+0x8a5>
  1029dc:	8d 55 d7             	lea    -0x29(%ebp),%edx
  1029df:	eb 09                	jmp    1029ea <z_prf+0x887>
  1029e1:	31 f6                	xor    %esi,%esi
  1029e3:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
				zero_head = precision - clen + prefix;
  1029ea:	8b 4d bc             	mov    -0x44(%ebp),%ecx
			zero.predot = zero.postdot = zero.trail = 0;
  1029ed:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
				zero_head = precision - clen + prefix;
  1029f4:	01 f1                	add    %esi,%ecx
			zero.predot = zero.postdot = zero.trail = 0;
  1029f6:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
				zero_head = precision - clen + prefix;
  1029fd:	29 d9                	sub    %ebx,%ecx
			zero.predot = zero.postdot = zero.trail = 0;
  1029ff:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
  102a06:	eb 23                	jmp    102a2b <z_prf+0x8c8>
  102a08:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  102a0f:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  102a16:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
			} else if (fzero) {
  102a1d:	80 7d 83 00          	cmpb   $0x0,-0x7d(%ebp)
  102a21:	74 0e                	je     102a31 <z_prf+0x8ce>
  102a23:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  102a26:	8d 55 d7             	lea    -0x29(%ebp),%edx
  102a29:	29 d9                	sub    %ebx,%ecx
				zero_head = width - clen;
			} else {
				zero_head = 0;
			}
			if (zero_head < 0) {
  102a2b:	85 c9                	test   %ecx,%ecx
  102a2d:	79 07                	jns    102a36 <z_prf+0x8d3>
  102a2f:	eb 03                	jmp    102a34 <z_prf+0x8d1>
  102a31:	8d 55 d7             	lea    -0x29(%ebp),%edx
				zero_head = 0;
  102a34:	31 c9                	xor    %ecx,%ecx
				zero_head = 0;
			}
			width -= clen + zero_head;
  102a36:	8d 04 19             	lea    (%ecx,%ebx,1),%eax
  102a39:	89 45 8c             	mov    %eax,-0x74(%ebp)
  102a3c:	8b 45 90             	mov    -0x70(%ebp),%eax
  102a3f:	2b 45 8c             	sub    -0x74(%ebp),%eax

			/* padding for right justification */
			if (!fminus && width > 0) {
  102a42:	80 7d 84 00          	cmpb   $0x0,-0x7c(%ebp)
			width -= clen + zero_head;
  102a46:	89 45 b8             	mov    %eax,-0x48(%ebp)
			if (!fminus && width > 0) {
  102a49:	75 3d                	jne    102a88 <z_prf+0x925>
  102a4b:	89 45 90             	mov    %eax,-0x70(%ebp)
  102a4e:	85 c0                	test   %eax,%eax
  102a50:	7e 36                	jle    102a88 <z_prf+0x925>
				count += width;
				while (width-- > 0) {
  102a52:	8b 45 90             	mov    -0x70(%ebp),%eax
  102a55:	ff 4d 90             	decl   -0x70(%ebp)
  102a58:	85 c0                	test   %eax,%eax
  102a5a:	7e 20                	jle    102a7c <z_prf+0x919>
					PUTC(' ');
  102a5c:	ff 75 a8             	pushl  -0x58(%ebp)
  102a5f:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102a62:	89 4d 84             	mov    %ecx,-0x7c(%ebp)
  102a65:	6a 20                	push   $0x20
  102a67:	89 55 88             	mov    %edx,-0x78(%ebp)
  102a6a:	ff d0                	call   *%eax
  102a6c:	5f                   	pop    %edi
  102a6d:	5a                   	pop    %edx
  102a6e:	40                   	inc    %eax
  102a6f:	8b 55 88             	mov    -0x78(%ebp),%edx
  102a72:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
  102a75:	75 db                	jne    102a52 <z_prf+0x8ef>
  102a77:	e9 39 f7 ff ff       	jmp    1021b5 <z_prf+0x52>
				count += width;
  102a7c:	8b 7d b8             	mov    -0x48(%ebp),%edi
				while (width-- > 0) {
  102a7f:	8b 45 90             	mov    -0x70(%ebp),%eax
				count += width;
  102a82:	01 7d a0             	add    %edi,-0x60(%ebp)
				while (width-- > 0) {
  102a85:	89 45 b8             	mov    %eax,-0x48(%ebp)
			}

			/* data prefix */
			clen -= prefix;
			count += prefix;
			while (prefix-- > 0) {
  102a88:	8d 3c 32             	lea    (%edx,%esi,1),%edi
  102a8b:	39 fa                	cmp    %edi,%edx
  102a8d:	74 3c                	je     102acb <z_prf+0x968>
				PUTC(*cptr++);
  102a8f:	ff 75 a8             	pushl  -0x58(%ebp)
  102a92:	0f be 02             	movsbl (%edx),%eax
  102a95:	42                   	inc    %edx
  102a96:	50                   	push   %eax
  102a97:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102a9a:	89 4d 88             	mov    %ecx,-0x78(%ebp)
  102a9d:	89 55 90             	mov    %edx,-0x70(%ebp)
  102aa0:	ff d0                	call   *%eax
  102aa2:	5a                   	pop    %edx
  102aa3:	40                   	inc    %eax
  102aa4:	59                   	pop    %ecx
  102aa5:	8b 55 90             	mov    -0x70(%ebp),%edx
  102aa8:	8b 4d 88             	mov    -0x78(%ebp),%ecx
  102aab:	75 de                	jne    102a8b <z_prf+0x928>
  102aad:	e9 03 f7 ff ff       	jmp    1021b5 <z_prf+0x52>
			}

			/* zero-padded head */
			count += zero_head;
			while (zero_head-- > 0) {
				PUTC('0');
  102ab2:	ff 75 a8             	pushl  -0x58(%ebp)
  102ab5:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102ab8:	89 4d 90             	mov    %ecx,-0x70(%ebp)
  102abb:	6a 30                	push   $0x30
  102abd:	ff d0                	call   *%eax
  102abf:	5a                   	pop    %edx
  102ac0:	40                   	inc    %eax
  102ac1:	59                   	pop    %ecx
  102ac2:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  102ac5:	0f 84 ea f6 ff ff    	je     1021b5 <z_prf+0x52>
			while (zero_head-- > 0) {
  102acb:	49                   	dec    %ecx
  102acc:	83 f9 ff             	cmp    $0xffffffff,%ecx
  102acf:	75 e1                	jne    102ab2 <z_prf+0x94f>
			clen -= prefix;
  102ad1:	29 f3                	sub    %esi,%ebx
			 *	x.<zero.postdot>xxxxxx<zero.trail>[e+xx]
			 * In the non-float cases, those predot, postdot and
			 * tail params are equal to 0.
			 */
			count += clen;
			if (zero.predot) {
  102ad3:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  102ad7:	74 5a                	je     102b33 <z_prf+0x9d0>
				c = *cptr;
  102ad9:	0f be 07             	movsbl (%edi),%eax
				while (isdigit((int)c)) {
  102adc:	89 fa                	mov    %edi,%edx
  102ade:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
  102ae1:	8d 48 d0             	lea    -0x30(%eax),%ecx
  102ae4:	29 d6                	sub    %edx,%esi
  102ae6:	83 f9 09             	cmp    $0x9,%ecx
  102ae9:	77 1e                	ja     102b09 <z_prf+0x9a6>
					PUTC(c);
  102aeb:	ff 75 a8             	pushl  -0x58(%ebp)
  102aee:	89 55 90             	mov    %edx,-0x70(%ebp)
  102af1:	50                   	push   %eax
  102af2:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102af5:	ff d0                	call   *%eax
  102af7:	59                   	pop    %ecx
  102af8:	5e                   	pop    %esi
  102af9:	40                   	inc    %eax
  102afa:	0f 84 b5 f6 ff ff    	je     1021b5 <z_prf+0x52>
					clen--;
					c = *++cptr;
  102b00:	8b 55 90             	mov    -0x70(%ebp),%edx
  102b03:	42                   	inc    %edx
  102b04:	0f be 02             	movsbl (%edx),%eax
  102b07:	eb d5                	jmp    102ade <z_prf+0x97b>
  102b09:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
				}
				clen -= zero.predot;
				while (zero.predot-- > 0) {
  102b0c:	4b                   	dec    %ebx
  102b0d:	83 fb ff             	cmp    $0xffffffff,%ebx
  102b10:	74 1a                	je     102b2c <z_prf+0x9c9>
					PUTC('0');
  102b12:	ff 75 a8             	pushl  -0x58(%ebp)
  102b15:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102b18:	89 55 90             	mov    %edx,-0x70(%ebp)
  102b1b:	6a 30                	push   $0x30
  102b1d:	ff d0                	call   *%eax
  102b1f:	5f                   	pop    %edi
  102b20:	40                   	inc    %eax
  102b21:	5a                   	pop    %edx
  102b22:	8b 55 90             	mov    -0x70(%ebp),%edx
  102b25:	75 e5                	jne    102b0c <z_prf+0x9a9>
  102b27:	e9 89 f6 ff ff       	jmp    1021b5 <z_prf+0x52>
				clen -= zero.predot;
  102b2c:	2b 75 b4             	sub    -0x4c(%ebp),%esi
  102b2f:	89 d7                	mov    %edx,%edi
  102b31:	89 f3                	mov    %esi,%ebx
				}
			}
			if (zero.postdot) {
  102b33:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
  102b37:	74 57                	je     102b90 <z_prf+0xa2d>
  102b39:	89 f9                	mov    %edi,%ecx
				do {
					c = *cptr++;
  102b3b:	0f be 01             	movsbl (%ecx),%eax
					PUTC(c);
  102b3e:	ff 75 a8             	pushl  -0x58(%ebp)
					c = *cptr++;
  102b41:	41                   	inc    %ecx
					PUTC(c);
  102b42:	88 45 b4             	mov    %al,-0x4c(%ebp)
  102b45:	50                   	push   %eax
  102b46:	8b 45 ac             	mov    -0x54(%ebp),%eax
					c = *cptr++;
  102b49:	89 4d 90             	mov    %ecx,-0x70(%ebp)
					PUTC(c);
  102b4c:	ff d0                	call   *%eax
  102b4e:	5a                   	pop    %edx
  102b4f:	40                   	inc    %eax
  102b50:	59                   	pop    %ecx
  102b51:	0f 84 5e f6 ff ff    	je     1021b5 <z_prf+0x52>
					clen--;
  102b57:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
  102b5a:	8b 4d 90             	mov    -0x70(%ebp),%ecx
				} while (c != '.');
  102b5d:	8a 55 b4             	mov    -0x4c(%ebp),%dl
  102b60:	29 ce                	sub    %ecx,%esi
  102b62:	80 fa 2e             	cmp    $0x2e,%dl
  102b65:	75 d4                	jne    102b3b <z_prf+0x9d8>
				clen -= zero.postdot;
				while (zero.postdot-- > 0) {
  102b67:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
  102b6a:	85 db                	test   %ebx,%ebx
  102b6c:	7e 1b                	jle    102b89 <z_prf+0xa26>
					PUTC('0');
  102b6e:	ff 75 a8             	pushl  -0x58(%ebp)
  102b71:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102b74:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  102b77:	6a 30                	push   $0x30
  102b79:	ff d0                	call   *%eax
  102b7b:	59                   	pop    %ecx
  102b7c:	4b                   	dec    %ebx
  102b7d:	5f                   	pop    %edi
  102b7e:	40                   	inc    %eax
  102b7f:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  102b82:	75 e6                	jne    102b6a <z_prf+0xa07>
  102b84:	e9 2c f6 ff ff       	jmp    1021b5 <z_prf+0x52>
				clen -= zero.postdot;
  102b89:	2b 75 a4             	sub    -0x5c(%ebp),%esi
					c = *cptr++;
  102b8c:	89 cf                	mov    %ecx,%edi
				clen -= zero.postdot;
  102b8e:	89 f3                	mov    %esi,%ebx
				}
			}
			if (zero.trail) {
  102b90:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  102b94:	74 56                	je     102bec <z_prf+0xa89>
				c = *cptr;
  102b96:	8a 07                	mov    (%edi),%al
				while (isdigit((int)c) || c == '.') {
  102b98:	89 fe                	mov    %edi,%esi
  102b9a:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
  102b9d:	29 f2                	sub    %esi,%edx
  102b9f:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  102ba2:	0f be d0             	movsbl %al,%edx
  102ba5:	8d 4a d0             	lea    -0x30(%edx),%ecx
  102ba8:	83 f9 09             	cmp    $0x9,%ecx
  102bab:	77 17                	ja     102bc4 <z_prf+0xa61>
					PUTC(c);
  102bad:	ff 75 a8             	pushl  -0x58(%ebp)
  102bb0:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102bb3:	52                   	push   %edx
  102bb4:	ff d0                	call   *%eax
  102bb6:	59                   	pop    %ecx
  102bb7:	40                   	inc    %eax
  102bb8:	5a                   	pop    %edx
  102bb9:	0f 84 f6 f5 ff ff    	je     1021b5 <z_prf+0x52>
					clen--;
					c = *++cptr;
  102bbf:	46                   	inc    %esi
  102bc0:	8a 06                	mov    (%esi),%al
  102bc2:	eb d6                	jmp    102b9a <z_prf+0xa37>
				while (isdigit((int)c) || c == '.') {
  102bc4:	3c 2e                	cmp    $0x2e,%al
  102bc6:	74 e5                	je     102bad <z_prf+0xa4a>
				}
				clen -= zero.trail;
				while (zero.trail-- > 0) {
  102bc8:	8b 5d bc             	mov    -0x44(%ebp),%ebx
  102bcb:	85 db                	test   %ebx,%ebx
  102bcd:	7e 15                	jle    102be4 <z_prf+0xa81>
					PUTC('0');
  102bcf:	ff 75 a8             	pushl  -0x58(%ebp)
  102bd2:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102bd5:	4b                   	dec    %ebx
  102bd6:	6a 30                	push   $0x30
  102bd8:	ff d0                	call   *%eax
  102bda:	5f                   	pop    %edi
  102bdb:	40                   	inc    %eax
  102bdc:	5a                   	pop    %edx
  102bdd:	75 ec                	jne    102bcb <z_prf+0xa68>
  102bdf:	e9 d1 f5 ff ff       	jmp    1021b5 <z_prf+0x52>
				clen -= zero.trail;
  102be4:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
  102be7:	89 f7                	mov    %esi,%edi
  102be9:	2b 5d bc             	sub    -0x44(%ebp),%ebx
  102bec:	89 fe                	mov    %edi,%esi
				}
			}
			while (clen-- > 0) {
  102bee:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
  102bf1:	29 f0                	sub    %esi,%eax
  102bf3:	85 c0                	test   %eax,%eax
  102bf5:	7e 17                	jle    102c0e <z_prf+0xaab>
				PUTC(*cptr++);
  102bf7:	ff 75 a8             	pushl  -0x58(%ebp)
  102bfa:	0f be 06             	movsbl (%esi),%eax
  102bfd:	50                   	push   %eax
  102bfe:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102c01:	ff d0                	call   *%eax
  102c03:	5a                   	pop    %edx
  102c04:	46                   	inc    %esi
  102c05:	59                   	pop    %ecx
  102c06:	40                   	inc    %eax
  102c07:	75 e5                	jne    102bee <z_prf+0xa8b>
  102c09:	e9 a7 f5 ff ff       	jmp    1021b5 <z_prf+0x52>
			count += clen;
  102c0e:	8b 7d 8c             	mov    -0x74(%ebp),%edi
  102c11:	01 7d a0             	add    %edi,-0x60(%ebp)
			}

			/* padding for left justification */
			if (width > 0) {
  102c14:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  102c18:	7e 23                	jle    102c3d <z_prf+0xada>
  102c1a:	8b 5d b8             	mov    -0x48(%ebp),%ebx
				count += width;
				while (width-- > 0) {
  102c1d:	4b                   	dec    %ebx
  102c1e:	83 fb ff             	cmp    $0xffffffff,%ebx
  102c21:	74 14                	je     102c37 <z_prf+0xad4>
					PUTC(' ');
  102c23:	ff 75 a8             	pushl  -0x58(%ebp)
  102c26:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102c29:	6a 20                	push   $0x20
  102c2b:	ff d0                	call   *%eax
  102c2d:	5a                   	pop    %edx
  102c2e:	40                   	inc    %eax
  102c2f:	59                   	pop    %ecx
  102c30:	75 eb                	jne    102c1d <z_prf+0xaba>
  102c32:	e9 7e f5 ff ff       	jmp    1021b5 <z_prf+0x52>
				count += width;
  102c37:	8b 7d b8             	mov    -0x48(%ebp),%edi
  102c3a:	01 7d a0             	add    %edi,-0x60(%ebp)
				continue;
  102c3d:	8b 5d 9c             	mov    -0x64(%ebp),%ebx
  102c40:	e9 4d f5 ff ff       	jmp    102192 <z_prf+0x2f>
		}
	}
	return count;

#undef PUTC
}
  102c45:	8b 45 a0             	mov    -0x60(%ebp),%eax
  102c48:	8d 65 f0             	lea    -0x10(%ebp),%esp
  102c4b:	59                   	pop    %ecx
  102c4c:	5b                   	pop    %ebx
  102c4d:	5e                   	pop    %esi
  102c4e:	5f                   	pop    %edi
  102c4f:	5d                   	pop    %ebp
  102c50:	8d 61 fc             	lea    -0x4(%ecx),%esp
  102c53:	c3                   	ret    

00102c54 <ring_buf_space_get>:
 *
 * @return Ring buffer free space (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return z_ring_buf_custom_space_get(buf->size, buf->head, buf->tail);
  102c54:	8b 10                	mov    (%eax),%edx
  102c56:	8b 48 04             	mov    0x4(%eax),%ecx
  102c59:	8b 40 10             	mov    0x10(%eax),%eax
	if (tail < head) {
  102c5c:	39 d1                	cmp    %edx,%ecx
	return (size - tail) + head - 1U;
  102c5e:	8d 44 02 ff          	lea    -0x1(%edx,%eax,1),%eax
	if (tail < head) {
  102c62:	73 03                	jae    102c67 <ring_buf_space_get+0x13>
		return head - tail - 1U;
  102c64:	8d 42 ff             	lea    -0x1(%edx),%eax
	return (size - tail) + head - 1U;
  102c67:	29 c8                	sub    %ecx,%eax
}
  102c69:	c3                   	ret    

00102c6a <ring_buf_put_claim>:
{
	return val >= max ? (val - max) : val;
}

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
  102c6a:	55                   	push   %ebp
  102c6b:	89 e5                	mov    %esp,%ebp
  102c6d:	57                   	push   %edi
  102c6e:	56                   	push   %esi
  102c6f:	53                   	push   %ebx
  102c70:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t space, trail_size, allocated;

	space = z_ring_buf_custom_space_get(buf->size, buf->head,
  102c73:	8b 53 08             	mov    0x8(%ebx),%edx
  102c76:	8b 0b                	mov    (%ebx),%ecx
  102c78:	8b 73 10             	mov    0x10(%ebx),%esi
	if (tail < head) {
  102c7b:	39 ca                	cmp    %ecx,%edx
  102c7d:	73 03                	jae    102c82 <ring_buf_put_claim+0x18>
		return head - tail - 1U;
  102c7f:	49                   	dec    %ecx
  102c80:	eb 04                	jmp    102c86 <ring_buf_put_claim+0x1c>
	return (size - tail) + head - 1U;
  102c82:	8d 4c 31 ff          	lea    -0x1(%ecx,%esi,1),%ecx
	/* Limit requested size to available size. */
	size = MIN(size, space);
	trail_size = buf->size - buf->misc.byte_mode.tmp_tail;

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
  102c86:	89 f0                	mov    %esi,%eax
  102c88:	29 d1                	sub    %edx,%ecx
  102c8a:	29 d0                	sub    %edx,%eax
  102c8c:	3b 45 10             	cmp    0x10(%ebp),%eax
  102c8f:	76 03                	jbe    102c94 <ring_buf_put_claim+0x2a>
  102c91:	8b 45 10             	mov    0x10(%ebp),%eax
  102c94:	39 c8                	cmp    %ecx,%eax
  102c96:	76 02                	jbe    102c9a <ring_buf_put_claim+0x30>
  102c98:	89 c8                	mov    %ecx,%eax

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
  102c9a:	8b 7b 14             	mov    0x14(%ebx),%edi
  102c9d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102ca0:	01 d7                	add    %edx,%edi
	buf->misc.byte_mode.tmp_tail =
		wrap(buf->misc.byte_mode.tmp_tail + allocated, buf->size);
  102ca2:	01 c2                	add    %eax,%edx
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
  102ca4:	89 39                	mov    %edi,(%ecx)
	return val >= max ? (val - max) : val;
  102ca6:	39 d6                	cmp    %edx,%esi
  102ca8:	77 02                	ja     102cac <ring_buf_put_claim+0x42>
  102caa:	29 f2                	sub    %esi,%edx
	buf->misc.byte_mode.tmp_tail =
  102cac:	89 53 08             	mov    %edx,0x8(%ebx)

	return allocated;
}
  102caf:	5b                   	pop    %ebx
  102cb0:	5e                   	pop    %esi
  102cb1:	5f                   	pop    %edi
  102cb2:	5d                   	pop    %ebp
  102cb3:	c3                   	ret    

00102cb4 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
  102cb4:	55                   	push   %ebp
  102cb5:	89 e5                	mov    %esp,%ebp
  102cb7:	56                   	push   %esi
  102cb8:	53                   	push   %ebx
  102cb9:	8b 75 08             	mov    0x8(%ebp),%esi
  102cbc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (size > ring_buf_space_get(buf)) {
  102cbf:	89 f0                	mov    %esi,%eax
  102cc1:	e8 8e ff ff ff       	call   102c54 <ring_buf_space_get>
  102cc6:	89 c2                	mov    %eax,%edx
  102cc8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  102ccd:	39 da                	cmp    %ebx,%edx
  102ccf:	72 16                	jb     102ce7 <ring_buf_put_finish+0x33>
		return -EINVAL;
	}

	buf->tail = wrap(buf->tail + size, buf->size);
  102cd1:	8b 46 04             	mov    0x4(%esi),%eax
  102cd4:	8b 56 10             	mov    0x10(%esi),%edx
  102cd7:	01 d8                	add    %ebx,%eax
	return val >= max ? (val - max) : val;
  102cd9:	39 c2                	cmp    %eax,%edx
  102cdb:	77 02                	ja     102cdf <ring_buf_put_finish+0x2b>
  102cdd:	29 d0                	sub    %edx,%eax
	buf->tail = wrap(buf->tail + size, buf->size);
  102cdf:	89 46 04             	mov    %eax,0x4(%esi)
	buf->misc.byte_mode.tmp_tail = buf->tail;
  102ce2:	89 46 08             	mov    %eax,0x8(%esi)

	return 0;
  102ce5:	31 c0                	xor    %eax,%eax
}
  102ce7:	5b                   	pop    %ebx
  102ce8:	5e                   	pop    %esi
  102ce9:	5d                   	pop    %ebp
  102cea:	c3                   	ret    

00102ceb <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
  102ceb:	55                   	push   %ebp
  102cec:	89 e5                	mov    %esp,%ebp
  102cee:	57                   	push   %edi
  102cef:	56                   	push   %esi
  102cf0:	53                   	push   %ebx
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
  102cf1:	31 db                	xor    %ebx,%ebx
{
  102cf3:	51                   	push   %ecx
  102cf4:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
  102cf7:	ff 75 10             	pushl  0x10(%ebp)
  102cfa:	8d 45 f0             	lea    -0x10(%ebp),%eax
  102cfd:	50                   	push   %eax
  102cfe:	ff 75 08             	pushl  0x8(%ebp)
  102d01:	e8 64 ff ff ff       	call   102c6a <ring_buf_put_claim>
  102d06:	83 c4 0c             	add    $0xc,%esp
		memcpy(dst, data, partial_size);
  102d09:	50                   	push   %eax
		partial_size = ring_buf_put_claim(buf, &dst, size);
  102d0a:	89 c6                	mov    %eax,%esi
		memcpy(dst, data, partial_size);
  102d0c:	57                   	push   %edi
		total_size += partial_size;
  102d0d:	01 f3                	add    %esi,%ebx
		memcpy(dst, data, partial_size);
  102d0f:	ff 75 f0             	pushl  -0x10(%ebp)
		size -= partial_size;
		data += partial_size;
  102d12:	01 f7                	add    %esi,%edi
		memcpy(dst, data, partial_size);
  102d14:	e8 d3 90 00 00       	call   10bdec <memcpy>
  102d19:	83 c4 0c             	add    $0xc,%esp
	} while (size && partial_size);
  102d1c:	29 75 10             	sub    %esi,0x10(%ebp)
  102d1f:	74 04                	je     102d25 <ring_buf_put+0x3a>
  102d21:	85 f6                	test   %esi,%esi
  102d23:	75 d2                	jne    102cf7 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
  102d25:	53                   	push   %ebx
  102d26:	ff 75 08             	pushl  0x8(%ebp)
  102d29:	e8 86 ff ff ff       	call   102cb4 <ring_buf_put_finish>
  102d2e:	58                   	pop    %eax
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
  102d2f:	89 d8                	mov    %ebx,%eax
	err = ring_buf_put_finish(buf, total_size);
  102d31:	5a                   	pop    %edx
}
  102d32:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102d35:	5b                   	pop    %ebx
  102d36:	5e                   	pop    %esi
  102d37:	5f                   	pop    %edi
  102d38:	5d                   	pop    %ebp
  102d39:	c3                   	ret    

00102d3a <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
  102d3a:	55                   	push   %ebp
  102d3b:	89 e5                	mov    %esp,%ebp
  102d3d:	57                   	push   %edi
  102d3e:	56                   	push   %esi
  102d3f:	53                   	push   %ebx
  102d40:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t space, granted_size, trail_size;

	space = (buf->size - 1) -
		z_ring_buf_custom_space_get(buf->size,
  102d43:	8b 53 0c             	mov    0xc(%ebx),%edx
  102d46:	8b 43 04             	mov    0x4(%ebx),%eax
	space = (buf->size - 1) -
  102d49:	8b 73 10             	mov    0x10(%ebx),%esi
	if (tail < head) {
  102d4c:	39 d0                	cmp    %edx,%eax
		return head - tail - 1U;
  102d4e:	8d 4a ff             	lea    -0x1(%edx),%ecx
	if (tail < head) {
  102d51:	72 04                	jb     102d57 <ring_buf_get_claim+0x1d>
	return (size - tail) + head - 1U;
  102d53:	8d 4c 16 ff          	lea    -0x1(%esi,%edx,1),%ecx
  102d57:	29 c1                	sub    %eax,%ecx
  102d59:	8d 46 ff             	lea    -0x1(%esi),%eax
  102d5c:	29 c8                	sub    %ecx,%eax

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
  102d5e:	89 f1                	mov    %esi,%ecx
  102d60:	29 d1                	sub    %edx,%ecx
  102d62:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  102d65:	76 03                	jbe    102d6a <ring_buf_get_claim+0x30>
  102d67:	8b 4d 10             	mov    0x10(%ebp),%ecx
  102d6a:	39 c8                	cmp    %ecx,%eax
  102d6c:	76 02                	jbe    102d70 <ring_buf_get_claim+0x36>
  102d6e:	89 c8                	mov    %ecx,%eax

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
  102d70:	8b 7b 14             	mov    0x14(%ebx),%edi
  102d73:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102d76:	01 d7                	add    %edx,%edi
	buf->misc.byte_mode.tmp_head =
		wrap(buf->misc.byte_mode.tmp_head + granted_size, buf->size);
  102d78:	01 c2                	add    %eax,%edx
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
  102d7a:	89 39                	mov    %edi,(%ecx)
	return val >= max ? (val - max) : val;
  102d7c:	39 d6                	cmp    %edx,%esi
  102d7e:	77 02                	ja     102d82 <ring_buf_get_claim+0x48>
  102d80:	29 f2                	sub    %esi,%edx
	buf->misc.byte_mode.tmp_head =
  102d82:	89 53 0c             	mov    %edx,0xc(%ebx)

	return granted_size;
}
  102d85:	5b                   	pop    %ebx
  102d86:	5e                   	pop    %esi
  102d87:	5f                   	pop    %edi
  102d88:	5d                   	pop    %ebp
  102d89:	c3                   	ret    

00102d8a <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
  102d8a:	55                   	push   %ebp
  102d8b:	89 e5                	mov    %esp,%ebp
  102d8d:	57                   	push   %edi
  102d8e:	56                   	push   %esi
  102d8f:	8b 75 08             	mov    0x8(%ebp),%esi
  102d92:	53                   	push   %ebx
	uint32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
  102d93:	89 f0                	mov    %esi,%eax
{
  102d95:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	uint32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
  102d98:	e8 b7 fe ff ff       	call   102c54 <ring_buf_space_get>
  102d9d:	8b 7e 10             	mov    0x10(%esi),%edi
  102da0:	8d 57 ff             	lea    -0x1(%edi),%edx
  102da3:	29 c2                	sub    %eax,%edx
  102da5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

	if (size > allocated) {
  102daa:	39 da                	cmp    %ebx,%edx
  102dac:	72 11                	jb     102dbf <ring_buf_get_finish+0x35>
		return -EINVAL;
	}

	buf->head = wrap(buf->head + size, buf->size);
  102dae:	8b 06                	mov    (%esi),%eax
  102db0:	01 d8                	add    %ebx,%eax
	return val >= max ? (val - max) : val;
  102db2:	39 c7                	cmp    %eax,%edi
  102db4:	77 02                	ja     102db8 <ring_buf_get_finish+0x2e>
  102db6:	29 f8                	sub    %edi,%eax
	buf->head = wrap(buf->head + size, buf->size);
  102db8:	89 06                	mov    %eax,(%esi)
	buf->misc.byte_mode.tmp_head = buf->head;
  102dba:	89 46 0c             	mov    %eax,0xc(%esi)

	return 0;
  102dbd:	31 c0                	xor    %eax,%eax
}
  102dbf:	5b                   	pop    %ebx
  102dc0:	5e                   	pop    %esi
  102dc1:	5f                   	pop    %edi
  102dc2:	5d                   	pop    %ebp
  102dc3:	c3                   	ret    

00102dc4 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
  102dc4:	55                   	push   %ebp
  102dc5:	89 e5                	mov    %esp,%ebp
  102dc7:	57                   	push   %edi
  102dc8:	56                   	push   %esi
  102dc9:	53                   	push   %ebx
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
  102dca:	31 db                	xor    %ebx,%ebx
{
  102dcc:	51                   	push   %ecx
  102dcd:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
  102dd0:	ff 75 10             	pushl  0x10(%ebp)
  102dd3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  102dd6:	50                   	push   %eax
  102dd7:	ff 75 08             	pushl  0x8(%ebp)
  102dda:	e8 5b ff ff ff       	call   102d3a <ring_buf_get_claim>
  102ddf:	83 c4 0c             	add    $0xc,%esp
		memcpy(data, src, partial_size);
  102de2:	50                   	push   %eax
		partial_size = ring_buf_get_claim(buf, &src, size);
  102de3:	89 c6                	mov    %eax,%esi
		memcpy(data, src, partial_size);
  102de5:	ff 75 f0             	pushl  -0x10(%ebp)
		total_size += partial_size;
  102de8:	01 f3                	add    %esi,%ebx
		memcpy(data, src, partial_size);
  102dea:	57                   	push   %edi
		size -= partial_size;
		data += partial_size;
  102deb:	01 f7                	add    %esi,%edi
		memcpy(data, src, partial_size);
  102ded:	e8 fa 8f 00 00       	call   10bdec <memcpy>
  102df2:	83 c4 0c             	add    $0xc,%esp
	} while (size && partial_size);
  102df5:	29 75 10             	sub    %esi,0x10(%ebp)
  102df8:	74 04                	je     102dfe <ring_buf_get+0x3a>
  102dfa:	85 f6                	test   %esi,%esi
  102dfc:	75 d2                	jne    102dd0 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
  102dfe:	53                   	push   %ebx
  102dff:	ff 75 08             	pushl  0x8(%ebp)
  102e02:	e8 83 ff ff ff       	call   102d8a <ring_buf_get_finish>
  102e07:	58                   	pop    %eax
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
  102e08:	89 d8                	mov    %ebx,%eax
	err = ring_buf_get_finish(buf, total_size);
  102e0a:	5a                   	pop    %edx
}
  102e0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102e0e:	5b                   	pop    %ebx
  102e0f:	5e                   	pop    %esi
  102e10:	5f                   	pop    %edi
  102e11:	5d                   	pop    %ebp
  102e12:	c3                   	ret    

00102e13 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  102e13:	c3                   	ret    

00102e14 <log_list_init>:
 */

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
  102e14:	55                   	push   %ebp
  102e15:	89 e5                	mov    %esp,%ebp
  102e17:	8b 45 08             	mov    0x8(%ebp),%eax
	list->tail = NULL;
  102e1a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	list->head = NULL;
  102e21:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  102e27:	5d                   	pop    %ebp
  102e28:	c3                   	ret    

00102e29 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
  102e29:	55                   	push   %ebp
  102e2a:	89 e5                	mov    %esp,%ebp
  102e2c:	8b 55 08             	mov    0x8(%ebp),%edx
  102e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (list->head == NULL) {
  102e32:	83 3a 00             	cmpl   $0x0,(%edx)
  102e35:	75 04                	jne    102e3b <log_list_add_tail+0x12>
		list->head = msg;
  102e37:	89 02                	mov    %eax,(%edx)
  102e39:	eb 05                	jmp    102e40 <log_list_add_tail+0x17>
	} else {
		list->tail->next = msg;
  102e3b:	8b 4a 04             	mov    0x4(%edx),%ecx
  102e3e:	89 01                	mov    %eax,(%ecx)
	}

	list->tail = msg;
  102e40:	89 42 04             	mov    %eax,0x4(%edx)
	msg->next = NULL;
  102e43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  102e49:	5d                   	pop    %ebp
  102e4a:	c3                   	ret    

00102e4b <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
  102e4b:	55                   	push   %ebp
  102e4c:	89 e5                	mov    %esp,%ebp
	return list->head;
  102e4e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  102e51:	5d                   	pop    %ebp
	return list->head;
  102e52:	8b 00                	mov    (%eax),%eax
}
  102e54:	c3                   	ret    

00102e55 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
  102e55:	55                   	push   %ebp
  102e56:	89 e5                	mov    %esp,%ebp
  102e58:	8b 55 08             	mov    0x8(%ebp),%edx
	struct log_msg *msg = list->head;
  102e5b:	8b 02                	mov    (%edx),%eax

	if (list->head != NULL) {
  102e5d:	85 c0                	test   %eax,%eax
  102e5f:	74 04                	je     102e65 <log_list_head_get+0x10>
		list->head = list->head->next;
  102e61:	8b 08                	mov    (%eax),%ecx
  102e63:	89 0a                	mov    %ecx,(%edx)
	}

	return msg;
}
  102e65:	5d                   	pop    %ebp
  102e66:	c3                   	ret    

00102e67 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
  102e67:	55                   	push   %ebp
  102e68:	89 e5                	mov    %esp,%ebp
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
  102e6a:	e8 36 0a 00 00       	call   1038a5 <log_msg_chunk_alloc>

	if (msg != NULL) {
  102e6f:	85 c0                	test   %eax,%eax
  102e71:	74 0d                	je     102e80 <z_log_msg_std_alloc+0x19>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
  102e73:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0U;
  102e7a:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
  102e80:	5d                   	pop    %ebp
  102e81:	c3                   	ret    

00102e82 <k_cycle_get_32_wrapper>:

extern uint32_t z_timer_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
  102e82:	e9 7b 7d 00 00       	jmp    10ac02 <z_timer_cycle_get_32>

00102e87 <k_uptime_get_32>:
 *    @option{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
  102e87:	55                   	push   %ebp
  102e88:	89 e5                	mov    %esp,%ebp
	return z_impl_k_uptime_ticks();
  102e8a:	e8 f8 f4 01 00       	call   122387 <z_impl_k_uptime_ticks>
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * (to_hz / from_hz);
  102e8f:	ba 0a 00 00 00       	mov    $0xa,%edx
  102e94:	f7 e2                	mul    %edx
	return (uint32_t)k_uptime_get();
}
  102e96:	5d                   	pop    %ebp
  102e97:	c3                   	ret    

00102e98 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
  102e98:	55                   	push   %ebp
  102e99:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
  102e9b:	6a 00                	push   $0x0
  102e9d:	68 f1 2e 10 00       	push   $0x102ef1
  102ea2:	68 e0 a2 12 00       	push   $0x12a2e0
  102ea7:	e8 bb f5 01 00       	call   122467 <k_timer_init>
  102eac:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  102eaf:	6a 00                	push   $0x0
  102eb1:	6a 00                	push   $0x0
  102eb3:	6a 00                	push   $0x0
  102eb5:	6a 0e                	push   $0xe
  102eb7:	6a 00                	push   $0x0
  102eb9:	6a 00                	push   $0x0
  102ebb:	6a 00                	push   $0x0
  102ebd:	68 7c 36 10 00       	push   $0x10367c
  102ec2:	68 00 03 00 00       	push   $0x300
  102ec7:	68 c0 0c 14 00       	push   $0x140cc0
  102ecc:	68 40 a2 12 00       	push   $0x12a240
  102ed1:	e8 00 ed 01 00       	call   121bd6 <z_impl_k_thread_create>
  102ed6:	83 c4 2c             	add    $0x2c,%esp
	return z_impl_k_thread_name_set(thread_id, value);
  102ed9:	68 6f 4c 12 00       	push   $0x124c6f
  102ede:	68 40 a2 12 00       	push   $0x12a240
  102ee3:	e8 45 eb 01 00       	call   121a2d <z_impl_k_thread_name_set>
  102ee8:	58                   	pop    %eax
	} else {
		log_init();
	}

	return 0;
}
  102ee9:	31 c0                	xor    %eax,%eax
  102eeb:	5a                   	pop    %edx
  102eec:	c9                   	leave  
  102eed:	c3                   	ret    

00102eee <dummy_timestamp>:
  102eee:	31 c0                	xor    %eax,%eax
  102ef0:	c3                   	ret    

00102ef1 <log_process_thread_timer_expiry_fn>:
{
  102ef1:	55                   	push   %ebp
  102ef2:	89 e5                	mov    %esp,%ebp
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  102ef4:	c7 45 08 38 5d 14 00 	movl   $0x145d38,0x8(%ebp)
}
  102efb:	5d                   	pop    %ebp
  102efc:	e9 98 e9 01 00       	jmp    121899 <z_impl_k_sem_give>

00102f01 <z_log_get_s_mask>:
{
  102f01:	55                   	push   %ebp
	uint32_t arg = 0;
  102f02:	31 c9                	xor    %ecx,%ecx
{
  102f04:	89 e5                	mov    %esp,%ebp
  102f06:	57                   	push   %edi
  102f07:	56                   	push   %esi
				mask |= BIT(arg);
  102f08:	bf 01 00 00 00       	mov    $0x1,%edi
{
  102f0d:	53                   	push   %ebx
	uint32_t mask = 0;
  102f0e:	31 f6                	xor    %esi,%esi
	bool arm = false;
  102f10:	31 db                	xor    %ebx,%ebx
	while ((curr = *str++) && arg < nargs) {
  102f12:	ff 45 08             	incl   0x8(%ebp)
  102f15:	8b 45 08             	mov    0x8(%ebp),%eax
  102f18:	3b 4d 0c             	cmp    0xc(%ebp),%ecx
  102f1b:	8a 50 ff             	mov    -0x1(%eax),%dl
  102f1e:	73 32                	jae    102f52 <z_log_get_s_mask+0x51>
  102f20:	84 d2                	test   %dl,%dl
  102f22:	74 2e                	je     102f52 <z_log_get_s_mask+0x51>
		if (curr == '%') {
  102f24:	80 fa 25             	cmp    $0x25,%dl
  102f27:	75 05                	jne    102f2e <z_log_get_s_mask+0x2d>
			arm = !arm;
  102f29:	83 f3 01             	xor    $0x1,%ebx
  102f2c:	eb e4                	jmp    102f12 <z_log_get_s_mask+0x11>
		} else if (arm && isalpha((int)curr)) {
  102f2e:	84 db                	test   %bl,%bl
  102f30:	74 e0                	je     102f12 <z_log_get_s_mask+0x11>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  102f32:	88 d0                	mov    %dl,%al
  102f34:	83 c8 20             	or     $0x20,%eax
  102f37:	0f be c0             	movsbl %al,%eax
  102f3a:	83 e8 61             	sub    $0x61,%eax
  102f3d:	83 f8 19             	cmp    $0x19,%eax
  102f40:	77 d0                	ja     102f12 <z_log_get_s_mask+0x11>
			if (curr == 's') {
  102f42:	80 fa 73             	cmp    $0x73,%dl
  102f45:	75 06                	jne    102f4d <z_log_get_s_mask+0x4c>
				mask |= BIT(arg);
  102f47:	89 f8                	mov    %edi,%eax
  102f49:	d3 e0                	shl    %cl,%eax
  102f4b:	09 c6                	or     %eax,%esi
			arg++;
  102f4d:	41                   	inc    %ecx
			arm = false;
  102f4e:	31 db                	xor    %ebx,%ebx
  102f50:	eb c0                	jmp    102f12 <z_log_get_s_mask+0x11>
}
  102f52:	5b                   	pop    %ebx
  102f53:	89 f0                	mov    %esi,%eax
  102f55:	5e                   	pop    %esi
  102f56:	5f                   	pop    %edi
  102f57:	5d                   	pop    %ebp
  102f58:	c3                   	ret    

00102f59 <log_core_init>:
{
  102f59:	55                   	push   %ebp
  102f5a:	89 e5                	mov    %esp,%ebp
  102f5c:	53                   	push   %ebx
		log_msg_pool_init();
  102f5d:	e8 dc 08 00 00       	call   10383e <log_msg_pool_init>
		log_list_init(&list);
  102f62:	68 e4 ea 12 00       	push   $0x12eae4
  102f67:	e8 a8 fe ff ff       	call   102e14 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
  102f6c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  102f73:	6a 34                	push   $0x34
  102f75:	68 c0 0f 14 00       	push   $0x140fc0
  102f7a:	68 20 a3 12 00       	push   $0x12a320
  102f7f:	e8 25 d9 01 00       	call   1208a9 <k_mem_slab_init>
  102f84:	83 c4 10             	add    $0x10,%esp
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
  102f87:	81 3d 44 5b 14 00 40 	cmpl   $0xf4240,0x145b44
  102f8e:	42 0f 00 
  102f91:	7e 11                	jle    102fa4 <log_core_init+0x4b>
		timestamp_func = k_uptime_get_32;
  102f93:	c7 05 84 5a 14 00 87 	movl   $0x102e87,0x145a84
  102f9a:	2e 10 00 
		freq = 1000;
  102f9d:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  102fa2:	eb 0f                	jmp    102fb3 <log_core_init+0x5a>
		timestamp_func = k_cycle_get_32_wrapper;
  102fa4:	c7 05 84 5a 14 00 82 	movl   $0x102e82,0x145a84
  102fab:	2e 10 00 
		freq = sys_clock_hw_cycles_per_sec();
  102fae:	a1 44 5b 14 00       	mov    0x145b44,%eax
	log_output_timestamp_freq_set(freq);
  102fb3:	50                   	push   %eax
  102fb4:	e8 20 13 00 00       	call   1042d9 <log_output_timestamp_freq_set>
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  102fb9:	ba e0 31 12 00       	mov    $0x1231e0,%edx
  102fbe:	58                   	pop    %eax
  102fbf:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
		for (int i = 0; i < log_sources_count(); i++) {
  102fc5:	31 c0                	xor    %eax,%eax
  102fc7:	c1 ea 03             	shr    $0x3,%edx
  102fca:	39 d0                	cmp    %edx,%eax
  102fcc:	74 20                	je     102fee <log_core_init+0x95>
			LOG_FILTER_SLOT_SET(filters,
  102fce:	8b 0c 85 98 5b 14 00 	mov    0x145b98(,%eax,4),%ecx
  102fd5:	8a 1c c5 b4 30 12 00 	mov    0x1230b4(,%eax,8),%bl
  102fdc:	83 e1 f8             	and    $0xfffffff8,%ecx
  102fdf:	83 e3 07             	and    $0x7,%ebx
  102fe2:	09 d9                	or     %ebx,%ecx
  102fe4:	89 0c 85 98 5b 14 00 	mov    %ecx,0x145b98(,%eax,4)
		for (int i = 0; i < log_sources_count(); i++) {
  102feb:	40                   	inc    %eax
  102fec:	eb dc                	jmp    102fca <log_core_init+0x71>
}
  102fee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102ff1:	c9                   	leave  
  102ff2:	c3                   	ret    

00102ff3 <dropped_notify>:
{
  102ff3:	55                   	push   %ebp
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  102ff4:	31 c0                	xor    %eax,%eax
  102ff6:	89 e5                	mov    %esp,%ebp
  102ff8:	57                   	push   %edi
  102ff9:	56                   	push   %esi
  102ffa:	53                   	push   %ebx
  102ffb:	51                   	push   %ecx
  102ffc:	87 05 d8 ea 12 00    	xchg   %eax,0x12ead8
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
  103002:	bb f0 31 12 00       	mov    $0x1231f0,%ebx
  103007:	be e0 31 12 00       	mov    $0x1231e0,%esi
  10300c:	81 eb e0 31 12 00    	sub    $0x1231e0,%ebx
	for (int i = 0; i < log_backend_count_get(); i++) {
  103012:	31 ff                	xor    %edi,%edi
  103014:	c1 fb 04             	sar    $0x4,%ebx
  103017:	39 df                	cmp    %ebx,%edi
  103019:	7d 24                	jge    10303f <dropped_notify+0x4c>
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  10301b:	8b 56 04             	mov    0x4(%esi),%edx
		if (log_backend_is_active(backend)) {
  10301e:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
  103022:	74 15                	je     103039 <dropped_notify+0x46>
	if (backend->api->dropped != NULL) {
  103024:	8b 16                	mov    (%esi),%edx
  103026:	8b 52 0c             	mov    0xc(%edx),%edx
  103029:	85 d2                	test   %edx,%edx
  10302b:	74 0c                	je     103039 <dropped_notify+0x46>
		backend->api->dropped(backend, cnt);
  10302d:	50                   	push   %eax
  10302e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103031:	56                   	push   %esi
  103032:	ff d2                	call   *%edx
  103034:	58                   	pop    %eax
  103035:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103038:	5a                   	pop    %edx
	for (int i = 0; i < log_backend_count_get(); i++) {
  103039:	47                   	inc    %edi
  10303a:	83 c6 10             	add    $0x10,%esi
  10303d:	eb d8                	jmp    103017 <dropped_notify+0x24>
}
  10303f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103042:	5b                   	pop    %ebx
  103043:	5e                   	pop    %esi
  103044:	5f                   	pop    %edi
  103045:	5d                   	pop    %ebp
  103046:	c3                   	ret    

00103047 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  103047:	f0 ff 05 d8 ea 12 00 	lock incl 0x12ead8
}
  10304e:	c3                   	ret    

0010304f <log_source_name_get>:
{
  10304f:	55                   	push   %ebp
  103050:	b8 e0 31 12 00       	mov    $0x1231e0,%eax
  103055:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10305a:	89 e5                	mov    %esp,%ebp
  10305c:	c1 e8 03             	shr    $0x3,%eax
  10305f:	89 c2                	mov    %eax,%edx
  103061:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103064:	31 c0                	xor    %eax,%eax
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
  103066:	39 d1                	cmp    %edx,%ecx
  103068:	73 07                	jae    103071 <log_source_name_get+0x22>
	return __log_const_start[source_id].name;
  10306a:	8b 04 cd b0 30 12 00 	mov    0x1230b0(,%ecx,8),%eax
}
  103071:	5d                   	pop    %ebp
  103072:	c3                   	ret    

00103073 <z_impl_log_filter_set>:
{
  103073:	55                   	push   %ebp
  103074:	89 e5                	mov    %esp,%ebp
  103076:	57                   	push   %edi
  103077:	56                   	push   %esi
  103078:	8b 45 08             	mov    0x8(%ebp),%eax
  10307b:	53                   	push   %ebx
  10307c:	8b 55 10             	mov    0x10(%ebp),%edx
		if (backend == NULL) {
  10307f:	85 c0                	test   %eax,%eax
  103081:	75 43                	jne    1030c6 <z_impl_log_filter_set+0x53>
	return __log_backends_end - __log_backends_start;
  103083:	be f0 31 12 00       	mov    $0x1231f0,%esi
			for (int i = 0; i < log_backend_count_get(); i++) {
  103088:	31 ff                	xor    %edi,%edi
  10308a:	81 ee e0 31 12 00    	sub    $0x1231e0,%esi
			uint32_t max = 0U;
  103090:	31 db                	xor    %ebx,%ebx
  103092:	c1 fe 04             	sar    $0x4,%esi
			for (int i = 0; i < log_backend_count_get(); i++) {
  103095:	39 f7                	cmp    %esi,%edi
  103097:	0f 8d 84 00 00 00    	jge    103121 <z_impl_log_filter_set+0xae>
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke4(*(uintptr_t *)&backend, *(uintptr_t *)&domain_id, *(uintptr_t *)&src_id, *(uintptr_t *)&level, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, src_id, level);
  10309d:	ff 75 14             	pushl  0x14(%ebp)
  1030a0:	89 f8                	mov    %edi,%eax
  1030a2:	89 55 10             	mov    %edx,0x10(%ebp)
  1030a5:	c1 e0 04             	shl    $0x4,%eax
  1030a8:	52                   	push   %edx
  1030a9:	ff 75 0c             	pushl  0xc(%ebp)
  1030ac:	05 e0 31 12 00       	add    $0x1231e0,%eax
  1030b1:	50                   	push   %eax
  1030b2:	e8 bc ff ff ff       	call   103073 <z_impl_log_filter_set>
  1030b7:	83 c4 10             	add    $0x10,%esp
				max = MAX(current, max);
  1030ba:	8b 55 10             	mov    0x10(%ebp),%edx
  1030bd:	39 c3                	cmp    %eax,%ebx
  1030bf:	73 02                	jae    1030c3 <z_impl_log_filter_set+0x50>
  1030c1:	89 c3                	mov    %eax,%ebx
			for (int i = 0; i < log_backend_count_get(); i++) {
  1030c3:	47                   	inc    %edi
  1030c4:	eb cf                	jmp    103095 <z_impl_log_filter_set+0x22>
		return log_compiled_level_get(src_id);
  1030c6:	0f b6 1c d5 b4 30 12 	movzbl 0x1230b4(,%edx,8),%ebx
  1030cd:	00 
			level = MIN(level, max);
  1030ce:	3b 5d 14             	cmp    0x14(%ebp),%ebx
  1030d1:	76 03                	jbe    1030d6 <z_impl_log_filter_set+0x63>
  1030d3:	8b 5d 14             	mov    0x14(%ebp),%ebx
	return backend->cb->id;
  1030d6:	8b 40 04             	mov    0x4(%eax),%eax
			LOG_FILTER_SLOT_SET(filters,
  1030d9:	89 de                	mov    %ebx,%esi
  1030db:	83 e6 07             	and    $0x7,%esi
  1030de:	0f b6 48 04          	movzbl 0x4(%eax),%ecx
  1030e2:	b8 07 00 00 00       	mov    $0x7,%eax
  1030e7:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
  1030ea:	d3 e0                	shl    %cl,%eax
  1030ec:	f7 d0                	not    %eax
  1030ee:	23 04 95 98 5b 14 00 	and    0x145b98(,%edx,4),%eax
  1030f5:	d3 e6                	shl    %cl,%esi
  1030f7:	09 f0                	or     %esi,%eax
  1030f9:	b9 03 00 00 00       	mov    $0x3,%ecx
	uint32_t max_filter = LOG_LEVEL_NONE;
  1030fe:	31 f6                	xor    %esi,%esi
		uint32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
  103100:	89 c7                	mov    %eax,%edi
  103102:	d3 ef                	shr    %cl,%edi
  103104:	83 e7 07             	and    $0x7,%edi
  103107:	39 fe                	cmp    %edi,%esi
  103109:	73 02                	jae    10310d <z_impl_log_filter_set+0x9a>
  10310b:	89 fe                	mov    %edi,%esi
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
  10310d:	83 c1 03             	add    $0x3,%ecx
  103110:	83 f9 1e             	cmp    $0x1e,%ecx
  103113:	75 eb                	jne    103100 <z_impl_log_filter_set+0x8d>
			LOG_FILTER_SLOT_SET(filters,
  103115:	83 e0 f8             	and    $0xfffffff8,%eax
  103118:	09 f0                	or     %esi,%eax
  10311a:	89 04 95 98 5b 14 00 	mov    %eax,0x145b98(,%edx,4)
}
  103121:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103124:	89 d8                	mov    %ebx,%eax
  103126:	5b                   	pop    %ebx
  103127:	5e                   	pop    %esi
  103128:	5f                   	pop    %edi
  103129:	5d                   	pop    %ebp
  10312a:	c3                   	ret    

0010312b <backend_filter_set>:
{
  10312b:	55                   	push   %ebp
  10312c:	89 e5                	mov    %esp,%ebp
  10312e:	57                   	push   %edi
  10312f:	56                   	push   %esi
  103130:	89 c7                	mov    %eax,%edi
  103132:	53                   	push   %ebx
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  103133:	bb e0 31 12 00       	mov    $0x1231e0,%ebx
  103138:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  10313e:	51                   	push   %ecx
  10313f:	c1 eb 03             	shr    $0x3,%ebx
		for (int i = 0; i < log_sources_count(); i++) {
  103142:	31 f6                	xor    %esi,%esi
  103144:	39 de                	cmp    %ebx,%esi
  103146:	74 16                	je     10315e <backend_filter_set+0x33>
  103148:	52                   	push   %edx
  103149:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10314c:	56                   	push   %esi
  10314d:	46                   	inc    %esi
  10314e:	6a 00                	push   $0x0
  103150:	57                   	push   %edi
  103151:	e8 1d ff ff ff       	call   103073 <z_impl_log_filter_set>
  103156:	83 c4 10             	add    $0x10,%esp
  103159:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10315c:	eb e6                	jmp    103144 <backend_filter_set+0x19>
}
  10315e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103161:	5b                   	pop    %ebx
  103162:	5e                   	pop    %esi
  103163:	5f                   	pop    %edi
  103164:	5d                   	pop    %ebp
  103165:	c3                   	ret    

00103166 <log_backend_enable>:
{
  103166:	55                   	push   %ebp
  103167:	89 e5                	mov    %esp,%ebp
  103169:	53                   	push   %ebx
  10316a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	id += backend - log_backend_get(0);
  10316d:	89 d8                	mov    %ebx,%eax
  10316f:	2d e0 31 12 00       	sub    $0x1231e0,%eax
	backend->cb->id = id;
  103174:	8b 53 04             	mov    0x4(%ebx),%edx
  103177:	c1 f8 04             	sar    $0x4,%eax
  10317a:	40                   	inc    %eax
	log_backend_id_set(backend, id);
  10317b:	88 42 04             	mov    %al,0x4(%edx)
	backend_filter_set(backend, level);
  10317e:	8b 55 10             	mov    0x10(%ebp),%edx
  103181:	89 d8                	mov    %ebx,%eax
  103183:	e8 a3 ff ff ff       	call   10312b <backend_filter_set>
	log_backend_activate(backend, ctx);
  103188:	8b 43 04             	mov    0x4(%ebx),%eax
	backend->cb->ctx = ctx;
  10318b:	8b 55 0c             	mov    0xc(%ebp),%edx
	backend->cb->active = true;
  10318e:	c6 40 05 01          	movb   $0x1,0x5(%eax)
	if (!backend_attached) {
  103192:	80 3d 76 ed 12 00 00 	cmpb   $0x0,0x12ed76
	backend->cb->ctx = ctx;
  103199:	89 10                	mov    %edx,(%eax)
  10319b:	75 0b                	jne    1031a8 <log_backend_enable+0x42>
  10319d:	68 38 5d 14 00       	push   $0x145d38
  1031a2:	e8 f2 e6 01 00       	call   121899 <z_impl_k_sem_give>
  1031a7:	58                   	pop    %eax
	backend_attached = true;
  1031a8:	c6 05 76 ed 12 00 01 	movb   $0x1,0x12ed76
}
  1031af:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1031b2:	c9                   	leave  
  1031b3:	c3                   	ret    

001031b4 <log_init>:
  1031b4:	b8 01 00 00 00       	mov    $0x1,%eax
  1031b9:	f0 0f c1 05 e0 ea 12 	lock xadd %eax,0x12eae0
  1031c0:	00 
	if (atomic_inc(&initialized) != 0) {
  1031c1:	85 c0                	test   %eax,%eax
  1031c3:	75 4b                	jne    103210 <log_init+0x5c>
{
  1031c5:	55                   	push   %ebp
  1031c6:	89 e5                	mov    %esp,%ebp
  1031c8:	57                   	push   %edi
  1031c9:	56                   	push   %esi
	for (i = 0; i < log_backend_count_get(); i++) {
  1031ca:	31 ff                	xor    %edi,%edi
{
  1031cc:	53                   	push   %ebx
	return __log_backends_end - __log_backends_start;
  1031cd:	bb f0 31 12 00       	mov    $0x1231f0,%ebx
  1031d2:	81 eb e0 31 12 00    	sub    $0x1231e0,%ebx
  1031d8:	be e0 31 12 00       	mov    $0x1231e0,%esi
  1031dd:	c1 fb 04             	sar    $0x4,%ebx
	for (i = 0; i < log_backend_count_get(); i++) {
  1031e0:	39 df                	cmp    %ebx,%edi
  1031e2:	7d 24                	jge    103208 <log_init+0x54>
		if (backend->autostart) {
  1031e4:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
  1031e8:	74 18                	je     103202 <log_init+0x4e>
			if (backend->api->init != NULL) {
  1031ea:	8b 06                	mov    (%esi),%eax
  1031ec:	8b 40 14             	mov    0x14(%eax),%eax
  1031ef:	85 c0                	test   %eax,%eax
  1031f1:	74 02                	je     1031f5 <log_init+0x41>
				backend->api->init();
  1031f3:	ff d0                	call   *%eax
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
  1031f5:	6a 04                	push   $0x4
  1031f7:	6a 00                	push   $0x0
  1031f9:	56                   	push   %esi
  1031fa:	e8 67 ff ff ff       	call   103166 <log_backend_enable>
  1031ff:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < log_backend_count_get(); i++) {
  103202:	47                   	inc    %edi
  103203:	83 c6 10             	add    $0x10,%esi
  103206:	eb d8                	jmp    1031e0 <log_init+0x2c>
}
  103208:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10320b:	5b                   	pop    %ebx
  10320c:	5e                   	pop    %esi
  10320d:	5f                   	pop    %edi
  10320e:	5d                   	pop    %ebp
  10320f:	c3                   	ret    
  103210:	c3                   	ret    

00103211 <log_backend_disable>:
{
  103211:	55                   	push   %ebp
  103212:	89 e5                	mov    %esp,%ebp
  103214:	8b 45 08             	mov    0x8(%ebp),%eax
	backend->cb->active = false;
  103217:	8b 50 04             	mov    0x4(%eax),%edx
  10321a:	c6 42 05 00          	movb   $0x0,0x5(%edx)
	backend_filter_set(backend, LOG_LEVEL_NONE);
  10321e:	31 d2                	xor    %edx,%edx
}
  103220:	5d                   	pop    %ebp
	backend_filter_set(backend, LOG_LEVEL_NONE);
  103221:	e9 05 ff ff ff       	jmp    10312b <backend_filter_set>

00103226 <log_filter_get>:
{
  103226:	55                   	push   %ebp
  103227:	89 e5                	mov    %esp,%ebp
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
  103229:	80 7d 14 00          	cmpb   $0x0,0x14(%ebp)
{
  10322d:	8b 45 10             	mov    0x10(%ebp),%eax
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
  103230:	74 1b                	je     10324d <log_filter_get+0x27>
	return backend->cb->id;
  103232:	8b 55 08             	mov    0x8(%ebp),%edx
		return LOG_FILTER_SLOT_GET(filters,
  103235:	8b 04 85 98 5b 14 00 	mov    0x145b98(,%eax,4),%eax
  10323c:	8b 52 04             	mov    0x4(%edx),%edx
  10323f:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  103243:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
  103246:	d3 e8                	shr    %cl,%eax
  103248:	83 e0 07             	and    $0x7,%eax
  10324b:	eb 08                	jmp    103255 <log_filter_get+0x2f>
		return log_compiled_level_get(src_id);
  10324d:	0f b6 04 c5 b4 30 12 	movzbl 0x1230b4(,%eax,8),%eax
  103254:	00 
}
  103255:	5d                   	pop    %ebp
  103256:	c3                   	ret    

00103257 <log_strdup>:
{
  103257:	55                   	push   %ebp
  103258:	89 e5                	mov    %esp,%ebp
  10325a:	53                   	push   %ebx
  10325b:	50                   	push   %eax
  10325c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
  10325f:	81 fb 00 a0 12 00    	cmp    $0x12a000,%ebx
  103265:	73 08                	jae    10326f <log_strdup+0x18>
  103267:	81 fb 00 30 12 00    	cmp    $0x123000,%ebx
  10326d:	73 48                	jae    1032b7 <log_strdup+0x60>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
  10326f:	6a 00                	push   $0x0
  103271:	8d 45 f8             	lea    -0x8(%ebp),%eax
  103274:	6a 00                	push   $0x0
  103276:	50                   	push   %eax
  103277:	68 20 a3 12 00       	push   $0x12a320
  10327c:	e8 8b d6 01 00       	call   12090c <k_mem_slab_alloc>
  103281:	83 c4 10             	add    $0x10,%esp
	if (err != 0) {
  103284:	85 c0                	test   %eax,%eax
  103286:	75 2a                	jne    1032b2 <log_strdup+0x5b>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  103288:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10328b:	b8 01 00 00 00       	mov    $0x1,%eax
  103290:	87 02                	xchg   %eax,(%edx)
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
  103292:	6a 2d                	push   $0x2d
  103294:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103297:	53                   	push   %ebx
  103298:	83 c0 04             	add    $0x4,%eax
  10329b:	50                   	push   %eax
  10329c:	e8 04 8a 00 00       	call   10bca5 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
  1032a1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
  1032a4:	83 c4 0c             	add    $0xc,%esp
	return dup->buf;
  1032a7:	83 c3 04             	add    $0x4,%ebx
	dup->buf[sizeof(dup->buf) - 2] = '~';
  1032aa:	66 c7 43 2d 7e 00    	movw   $0x7e,0x2d(%ebx)
	return dup->buf;
  1032b0:	eb 05                	jmp    1032b7 <log_strdup+0x60>
		return (char *)log_strdup_fail_msg;
  1032b2:	bb 19 49 12 00       	mov    $0x124919,%ebx
}
  1032b7:	89 d8                	mov    %ebx,%eax
  1032b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1032bc:	c9                   	leave  
  1032bd:	c3                   	ret    

001032be <log_is_strdup>:
{
  1032be:	55                   	push   %ebp
  1032bf:	89 e5                	mov    %esp,%ebp
  1032c1:	8b 55 08             	mov    0x8(%ebp),%edx
}
  1032c4:	5d                   	pop    %ebp
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
  1032c5:	85 d2                	test   %edx,%edx
  1032c7:	0f 95 c0             	setne  %al
  1032ca:	81 fa c0 0f 14 00    	cmp    $0x140fc0,%edx
  1032d0:	0f 93 c1             	setae  %cl
  1032d3:	21 c8                	and    %ecx,%eax
  1032d5:	81 fa 90 10 14 00    	cmp    $0x141090,%edx
  1032db:	0f 92 c2             	setb   %dl
  1032de:	21 d0                	and    %edx,%eax
}
  1032e0:	c3                   	ret    

001032e1 <z_impl_log_process>:
{
  1032e1:	55                   	push   %ebp
  1032e2:	89 e5                	mov    %esp,%ebp
  1032e4:	57                   	push   %edi
  1032e5:	56                   	push   %esi
  1032e6:	53                   	push   %ebx
  1032e7:	83 ec 14             	sub    $0x14,%esp
  1032ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1032ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!backend_attached && !bypass) {
  1032f0:	8a 45 ec             	mov    -0x14(%ebp),%al
  1032f3:	0a 05 76 ed 12 00    	or     0x12ed76,%al
  1032f9:	0f 84 aa 01 00 00    	je     1034a9 <z_impl_log_process+0x1c8>

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile ("pushfl; cli; popl %0" : "=g" (key) :: "memory");
  1032ff:	9c                   	pushf  
  103300:	fa                   	cli    
  103301:	5e                   	pop    %esi
	msg = log_list_head_get(&list);
  103302:	68 e4 ea 12 00       	push   $0x12eae4
  103307:	e8 49 fb ff ff       	call   102e55 <log_list_head_get>
  10330c:	5a                   	pop    %edx
  10330d:	89 c3                	mov    %eax,%ebx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10330f:	0f ba e6 09          	bt     $0x9,%esi
  103313:	73 01                	jae    103316 <z_impl_log_process+0x35>
		__asm__ volatile ("sti" ::: "memory");
  103315:	fb                   	sti    
	if (msg != NULL) {
  103316:	85 db                	test   %ebx,%ebx
  103318:	0f 84 67 01 00 00    	je     103485 <z_impl_log_process+0x1a4>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  10331e:	f0 ff 0d dc ea 12 00 	lock decl 0x12eadc
	if (!bypass) {
  103325:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
  103329:	74 0c                	je     103337 <z_impl_log_process+0x56>
	log_msg_put(msg);
  10332b:	53                   	push   %ebx
  10332c:	e8 b5 06 00 00       	call   1039e6 <log_msg_put>
  103331:	5f                   	pop    %edi
}
  103332:	e9 4e 01 00 00       	jmp    103485 <z_impl_log_process+0x1a4>
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
  103337:	80 3d 77 ed 12 00 00 	cmpb   $0x0,0x12ed77
  10333e:	0f 85 e2 00 00 00    	jne    103426 <z_impl_log_process+0x145>
	if (!log_msg_is_std(msg)) {
  103344:	f6 43 08 01          	testb  $0x1,0x8(%ebx)
  103348:	0f 85 d8 00 00 00    	jne    103426 <z_impl_log_process+0x145>
	msg_str = log_msg_str_get(msg);
  10334e:	53                   	push   %ebx
  10334f:	e8 aa 06 00 00       	call   1039fe <log_msg_str_get>
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
  103354:	89 1c 24             	mov    %ebx,(%esp)
	msg_str = log_msg_str_get(msg);
  103357:	89 c7                	mov    %eax,%edi
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
  103359:	e8 78 05 00 00       	call   1038d6 <log_msg_nargs_get>
  10335e:	89 04 24             	mov    %eax,(%esp)
  103361:	57                   	push   %edi
  103362:	e8 9a fb ff ff       	call   102f01 <z_log_get_s_mask>
  103367:	59                   	pop    %ecx
  103368:	5e                   	pop    %esi
  103369:	89 c6                	mov    %eax,%esi
  10336b:	b8 e0 31 12 00       	mov    $0x1231e0,%eax
  103370:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  103375:	c1 e8 03             	shr    $0x3,%eax
  103378:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10337b:	b8 c0 30 12 00       	mov    $0x1230c0,%eax
  103380:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  103385:	c1 e8 03             	shr    $0x3,%eax
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
  103388:	c1 e0 06             	shl    $0x6,%eax
  10338b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	while (mask) {
  10338f:	85 f6                	test   %esi,%esi
  103391:	0f 84 8f 00 00 00    	je     103426 <z_impl_log_process+0x145>
		idx = 31 - __builtin_clz(mask);
  103397:	0f bd c6             	bsr    %esi,%eax
  10339a:	ba 1f 00 00 00       	mov    $0x1f,%edx
  10339f:	83 f0 1f             	xor    $0x1f,%eax
  1033a2:	29 c2                	sub    %eax,%edx
		str = (const char *)log_msg_arg_get(msg, idx);
  1033a4:	52                   	push   %edx
		idx = 31 - __builtin_clz(mask);
  1033a5:	89 55 f0             	mov    %edx,-0x10(%ebp)
		str = (const char *)log_msg_arg_get(msg, idx);
  1033a8:	53                   	push   %ebx
  1033a9:	e8 39 05 00 00       	call   1038e7 <log_msg_arg_get>
  1033ae:	59                   	pop    %ecx
		if (!is_rodata(str) && !log_is_strdup(str) &&
  1033af:	3d 00 30 12 00       	cmp    $0x123000,%eax
		str = (const char *)log_msg_arg_get(msg, idx);
  1033b4:	5a                   	pop    %edx
  1033b5:	89 c2                	mov    %eax,%edx
		if (!is_rodata(str) && !log_is_strdup(str) &&
  1033b7:	72 07                	jb     1033c0 <z_impl_log_process+0xdf>
  1033b9:	3d 00 a0 12 00       	cmp    $0x12a000,%eax
  1033be:	72 55                	jb     103415 <z_impl_log_process+0x134>
  1033c0:	52                   	push   %edx
  1033c1:	89 55 e0             	mov    %edx,-0x20(%ebp)
  1033c4:	e8 f5 fe ff ff       	call   1032be <log_is_strdup>
  1033c9:	5a                   	pop    %edx
  1033ca:	fe c8                	dec    %al
  1033cc:	74 47                	je     103415 <z_impl_log_process+0x134>
  1033ce:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1033d1:	81 fa 19 49 12 00    	cmp    $0x124919,%edx
  1033d7:	74 3c                	je     103415 <z_impl_log_process+0x134>
	return msg->hdr.ids.source_id;
  1033d9:	66 8b 43 0a          	mov    0xa(%ebx),%ax
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
  1033dd:	31 d2                	xor    %edx,%edx
  1033df:	66 c1 e8 06          	shr    $0x6,%ax
  1033e3:	0f b7 c0             	movzwl %ax,%eax
  1033e6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  1033e9:	73 07                	jae    1033f2 <z_impl_log_process+0x111>
	return __log_const_start[source_id].name;
  1033eb:	8b 14 c5 b0 30 12 00 	mov    0x1230b0(,%eax,8),%edx
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
  1033f2:	f6 05 a0 5b 14 00 07 	testb  $0x7,0x145ba0
  1033f9:	74 1a                	je     103415 <z_impl_log_process+0x134>
  1033fb:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
  1033ff:	83 c8 01             	or     $0x1,%eax
  103402:	50                   	push   %eax
  103403:	57                   	push   %edi
  103404:	52                   	push   %edx
  103405:	ff 75 f0             	pushl  -0x10(%ebp)
  103408:	68 33 49 12 00       	push   $0x124933
  10340d:	e8 e7 01 00 00       	call   1035f9 <log_3>
  103412:	83 c4 14             	add    $0x14,%esp
		mask &= ~BIT(idx);
  103415:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  10341a:	8a 4d f0             	mov    -0x10(%ebp),%cl
  10341d:	d3 c0                	rol    %cl,%eax
  10341f:	21 c6                	and    %eax,%esi
  103421:	e9 69 ff ff ff       	jmp    10338f <z_impl_log_process+0xae>
	return __log_backends_end - __log_backends_start;
  103426:	b8 f0 31 12 00       	mov    $0x1231f0,%eax
  10342b:	be e0 31 12 00       	mov    $0x1231e0,%esi
  103430:	2d e0 31 12 00       	sub    $0x1231e0,%eax
  103435:	31 ff                	xor    %edi,%edi
  103437:	c1 f8 04             	sar    $0x4,%eax
  10343a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for (int i = 0; i < log_backend_count_get(); i++) {
  10343d:	3b 7d f0             	cmp    -0x10(%ebp),%edi
  103440:	0f 8d e5 fe ff ff    	jge    10332b <z_impl_log_process+0x4a>
			if (log_backend_is_active(backend) &&
  103446:	8b 4e 04             	mov    0x4(%esi),%ecx
  103449:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
  10344d:	74 30                	je     10347f <z_impl_log_process+0x19e>
  10344f:	66 8b 43 0a          	mov    0xa(%ebx),%ax
	return msg->hdr.ids.level;
  103453:	8a 53 0a             	mov    0xa(%ebx),%dl
	return msg->hdr.ids.source_id;
  103456:	66 c1 e8 06          	shr    $0x6,%ax
	return msg->hdr.ids.level;
  10345a:	83 e2 07             	and    $0x7,%edx
		return LOG_FILTER_SLOT_GET(filters,
  10345d:	0f b6 49 04          	movzbl 0x4(%ecx),%ecx
	return msg->hdr.ids.source_id;
  103461:	0f b7 c0             	movzwl %ax,%eax
  103464:	8d 0c 49             	lea    (%ecx,%ecx,2),%ecx
  103467:	8b 04 85 98 5b 14 00 	mov    0x145b98(,%eax,4),%eax
  10346e:	d3 e8                	shr    %cl,%eax
  103470:	83 e0 07             	and    $0x7,%eax
			if (log_backend_is_active(backend) &&
  103473:	39 c2                	cmp    %eax,%edx
  103475:	77 08                	ja     10347f <z_impl_log_process+0x19e>
	backend->api->put(backend, msg);
  103477:	8b 06                	mov    (%esi),%eax
  103479:	53                   	push   %ebx
  10347a:	56                   	push   %esi
  10347b:	ff 10                	call   *(%eax)
  10347d:	59                   	pop    %ecx
  10347e:	58                   	pop    %eax
		for (int i = 0; i < log_backend_count_get(); i++) {
  10347f:	47                   	inc    %edi
  103480:	83 c6 10             	add    $0x10,%esi
  103483:	eb b8                	jmp    10343d <z_impl_log_process+0x15c>
	if (!bypass && dropped_cnt) {
  103485:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
  103489:	75 0e                	jne    103499 <z_impl_log_process+0x1b8>
  10348b:	83 3d d8 ea 12 00 00 	cmpl   $0x0,0x12ead8
  103492:	74 05                	je     103499 <z_impl_log_process+0x1b8>
		dropped_notify();
  103494:	e8 5a fb ff ff       	call   102ff3 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
  103499:	68 e4 ea 12 00       	push   $0x12eae4
  10349e:	e8 a8 f9 ff ff       	call   102e4b <log_list_head_peek>
  1034a3:	5a                   	pop    %edx
  1034a4:	85 c0                	test   %eax,%eax
  1034a6:	0f 95 c0             	setne  %al
}
  1034a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1034ac:	5b                   	pop    %ebx
  1034ad:	5e                   	pop    %esi
  1034ae:	5f                   	pop    %edi
  1034af:	5d                   	pop    %ebp
  1034b0:	c3                   	ret    

001034b1 <msg_finalize>:
{
  1034b1:	55                   	push   %ebp
  1034b2:	89 e5                	mov    %esp,%ebp
  1034b4:	56                   	push   %esi
  1034b5:	53                   	push   %ebx
	msg->hdr.ids = src_level;
  1034b6:	66 89 50 0a          	mov    %dx,0xa(%eax)
{
  1034ba:	89 c3                	mov    %eax,%ebx
	msg->hdr.timestamp = timestamp_func();
  1034bc:	ff 15 84 5a 14 00    	call   *0x145a84
  1034c2:	89 43 0c             	mov    %eax,0xc(%ebx)
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  1034c5:	f0 ff 05 dc ea 12 00 	lock incl 0x12eadc
  1034cc:	9c                   	pushf  
  1034cd:	fa                   	cli    
  1034ce:	5e                   	pop    %esi
	log_list_add_tail(&list, msg);
  1034cf:	53                   	push   %ebx
  1034d0:	68 e4 ea 12 00       	push   $0x12eae4
  1034d5:	e8 4f f9 ff ff       	call   102e29 <log_list_add_tail>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1034da:	0f ba e6 09          	bt     $0x9,%esi
  1034de:	59                   	pop    %ecx
  1034df:	5b                   	pop    %ebx
  1034e0:	73 01                	jae    1034e3 <msg_finalize+0x32>
		__asm__ volatile ("sti" ::: "memory");
  1034e2:	fb                   	sti    
	if (panic_mode) {
  1034e3:	80 3d 77 ed 12 00 00 	cmpb   $0x0,0x12ed77
  1034ea:	74 14                	je     103500 <msg_finalize+0x4f>
  1034ec:	9c                   	pushf  
  1034ed:	fa                   	cli    
  1034ee:	5b                   	pop    %ebx
	return z_impl_log_process(bypass);
  1034ef:	6a 00                	push   $0x0
  1034f1:	e8 eb fd ff ff       	call   1032e1 <z_impl_log_process>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1034f6:	0f ba e3 09          	bt     $0x9,%ebx
  1034fa:	5a                   	pop    %edx
  1034fb:	73 49                	jae    103546 <msg_finalize+0x95>
		__asm__ volatile ("sti" ::: "memory");
  1034fd:	fb                   	sti    
  1034fe:	eb 46                	jmp    103546 <msg_finalize+0x95>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
  103500:	83 3d d4 ea 12 00 00 	cmpl   $0x0,0x12ead4
  103507:	74 3d                	je     103546 <msg_finalize+0x95>
  103509:	a1 dc ea 12 00       	mov    0x12eadc,%eax
  10350e:	83 f8 01             	cmp    $0x1,%eax
  103511:	75 17                	jne    10352a <msg_finalize+0x79>
	z_impl_k_timer_start(timer, duration, period);
  103513:	6a 00                	push   $0x0
  103515:	6a 00                	push   $0x0
  103517:	6a 00                	push   $0x0
  103519:	6a 64                	push   $0x64
  10351b:	68 e0 a2 12 00       	push   $0x12a2e0
  103520:	e8 86 ef 01 00       	call   1224ab <z_impl_k_timer_start>
  103525:	83 c4 14             	add    $0x14,%esp
  103528:	eb 1c                	jmp    103546 <msg_finalize+0x95>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
  10352a:	83 f8 0a             	cmp    $0xa,%eax
  10352d:	75 17                	jne    103546 <msg_finalize+0x95>
	z_impl_k_timer_stop(timer);
  10352f:	68 e0 a2 12 00       	push   $0x12a2e0
  103534:	e8 42 f0 01 00       	call   12257b <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
  103539:	c7 04 24 38 5d 14 00 	movl   $0x145d38,(%esp)
  103540:	e8 54 e3 01 00       	call   121899 <z_impl_k_sem_give>
  103545:	58                   	pop    %eax
}
  103546:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103549:	5b                   	pop    %ebx
  10354a:	5e                   	pop    %esi
  10354b:	5d                   	pop    %ebp
  10354c:	c3                   	ret    

0010354d <log_0>:
{
  10354d:	55                   	push   %ebp
  10354e:	89 e5                	mov    %esp,%ebp
  103550:	53                   	push   %ebx
  103551:	53                   	push   %ebx
  103552:	8b 55 0c             	mov    0xc(%ebp),%edx
  103555:	8b 5d 08             	mov    0x8(%ebp),%ebx
  103558:	89 55 f8             	mov    %edx,-0x8(%ebp)
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
  10355b:	e8 07 f9 ff ff       	call   102e67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  103560:	85 c0                	test   %eax,%eax
  103562:	74 0e                	je     103572 <log_0+0x25>
		msg->str = str;
  103564:	89 58 10             	mov    %ebx,0x10(%eax)
		msg_finalize(msg, src_level);
  103567:	8b 55 f8             	mov    -0x8(%ebp),%edx
}
  10356a:	59                   	pop    %ecx
  10356b:	5b                   	pop    %ebx
  10356c:	5d                   	pop    %ebp
		msg_finalize(msg, src_level);
  10356d:	e9 3f ff ff ff       	jmp    1034b1 <msg_finalize>
}
  103572:	58                   	pop    %eax
  103573:	5b                   	pop    %ebx
  103574:	5d                   	pop    %ebp
  103575:	c3                   	ret    

00103576 <log_1>:
{
  103576:	55                   	push   %ebp
  103577:	89 e5                	mov    %esp,%ebp
  103579:	57                   	push   %edi
  10357a:	56                   	push   %esi
  10357b:	53                   	push   %ebx
  10357c:	8b 7d 08             	mov    0x8(%ebp),%edi
  10357f:	8b 75 0c             	mov    0xc(%ebp),%esi
  103582:	8b 5d 10             	mov    0x10(%ebp),%ebx
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
  103585:	e8 dd f8 ff ff       	call   102e67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  10358a:	85 c0                	test   %eax,%eax
  10358c:	74 1d                	je     1035ab <log_1+0x35>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
  10358e:	8a 50 09             	mov    0x9(%eax),%dl
		msg->str = str;
  103591:	89 78 10             	mov    %edi,0x10(%eax)
		msg->hdr.params.std.nargs = 1U;
  103594:	83 e2 0f             	and    $0xf,%edx
		msg->payload.single.args[0] = arg1;
  103597:	89 70 14             	mov    %esi,0x14(%eax)
		msg->hdr.params.std.nargs = 1U;
  10359a:	83 ca 10             	or     $0x10,%edx
  10359d:	88 50 09             	mov    %dl,0x9(%eax)
		msg_finalize(msg, src_level);
  1035a0:	89 da                	mov    %ebx,%edx
}
  1035a2:	5b                   	pop    %ebx
  1035a3:	5e                   	pop    %esi
  1035a4:	5f                   	pop    %edi
  1035a5:	5d                   	pop    %ebp
		msg_finalize(msg, src_level);
  1035a6:	e9 06 ff ff ff       	jmp    1034b1 <msg_finalize>
}
  1035ab:	5b                   	pop    %ebx
  1035ac:	5e                   	pop    %esi
  1035ad:	5f                   	pop    %edi
  1035ae:	5d                   	pop    %ebp
  1035af:	c3                   	ret    

001035b0 <log_2>:
{
  1035b0:	55                   	push   %ebp
  1035b1:	89 e5                	mov    %esp,%ebp
  1035b3:	57                   	push   %edi
  1035b4:	56                   	push   %esi
  1035b5:	53                   	push   %ebx
  1035b6:	53                   	push   %ebx
  1035b7:	8b 45 14             	mov    0x14(%ebp),%eax
  1035ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1035bd:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1035c0:	8b 75 10             	mov    0x10(%ebp),%esi
  1035c3:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
  1035c7:	e8 9b f8 ff ff       	call   102e67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  1035cc:	85 c0                	test   %eax,%eax
  1035ce:	74 23                	je     1035f3 <log_2+0x43>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
  1035d0:	8a 50 09             	mov    0x9(%eax),%dl
		msg->str = str;
  1035d3:	89 58 10             	mov    %ebx,0x10(%eax)
		msg->hdr.params.std.nargs = 2U;
  1035d6:	83 e2 0f             	and    $0xf,%edx
		msg->payload.single.args[0] = arg1;
  1035d9:	89 78 14             	mov    %edi,0x14(%eax)
		msg->hdr.params.std.nargs = 2U;
  1035dc:	83 ca 20             	or     $0x20,%edx
		msg->payload.single.args[1] = arg2;
  1035df:	89 70 18             	mov    %esi,0x18(%eax)
		msg->hdr.params.std.nargs = 2U;
  1035e2:	88 50 09             	mov    %dl,0x9(%eax)
		msg_finalize(msg, src_level);
  1035e5:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
}
  1035e9:	59                   	pop    %ecx
  1035ea:	5b                   	pop    %ebx
  1035eb:	5e                   	pop    %esi
  1035ec:	5f                   	pop    %edi
  1035ed:	5d                   	pop    %ebp
		msg_finalize(msg, src_level);
  1035ee:	e9 be fe ff ff       	jmp    1034b1 <msg_finalize>
}
  1035f3:	58                   	pop    %eax
  1035f4:	5b                   	pop    %ebx
  1035f5:	5e                   	pop    %esi
  1035f6:	5f                   	pop    %edi
  1035f7:	5d                   	pop    %ebp
  1035f8:	c3                   	ret    

001035f9 <log_3>:
{
  1035f9:	55                   	push   %ebp
  1035fa:	89 e5                	mov    %esp,%ebp
  1035fc:	57                   	push   %edi
  1035fd:	56                   	push   %esi
  1035fe:	53                   	push   %ebx
  1035ff:	83 ec 08             	sub    $0x8,%esp
  103602:	8b 55 08             	mov    0x8(%ebp),%edx
  103605:	8b 45 18             	mov    0x18(%ebp),%eax
  103608:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10360b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10360e:	8b 75 10             	mov    0x10(%ebp),%esi
  103611:	8b 5d 14             	mov    0x14(%ebp),%ebx
  103614:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
  103618:	e8 4a f8 ff ff       	call   102e67 <z_log_msg_std_alloc>

	if (msg != NULL) {
  10361d:	85 c0                	test   %eax,%eax
  10361f:	74 2a                	je     10364b <log_3+0x52>
		msg->str = str;
  103621:	8b 55 ec             	mov    -0x14(%ebp),%edx
		msg->hdr.params.std.nargs = 3U;
		msg->payload.single.args[0] = arg1;
  103624:	89 78 14             	mov    %edi,0x14(%eax)
		msg->str = str;
  103627:	89 50 10             	mov    %edx,0x10(%eax)
		msg->hdr.params.std.nargs = 3U;
  10362a:	8a 50 09             	mov    0x9(%eax),%dl
  10362d:	83 e2 0f             	and    $0xf,%edx
		msg->payload.single.args[1] = arg2;
  103630:	89 70 18             	mov    %esi,0x18(%eax)
		msg->hdr.params.std.nargs = 3U;
  103633:	83 ca 30             	or     $0x30,%edx
		msg->payload.single.args[2] = arg3;
  103636:	89 58 1c             	mov    %ebx,0x1c(%eax)
		msg->hdr.params.std.nargs = 3U;
  103639:	88 50 09             	mov    %dl,0x9(%eax)
		msg_finalize(msg, src_level);
  10363c:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
}
  103640:	59                   	pop    %ecx
  103641:	5b                   	pop    %ebx
  103642:	5b                   	pop    %ebx
  103643:	5e                   	pop    %esi
  103644:	5f                   	pop    %edi
  103645:	5d                   	pop    %ebp
		msg_finalize(msg, src_level);
  103646:	e9 66 fe ff ff       	jmp    1034b1 <msg_finalize>
}
  10364b:	58                   	pop    %eax
  10364c:	5a                   	pop    %edx
  10364d:	5b                   	pop    %ebx
  10364e:	5e                   	pop    %esi
  10364f:	5f                   	pop    %edi
  103650:	5d                   	pop    %ebp
  103651:	c3                   	ret    

00103652 <log_n>:
{
  103652:	55                   	push   %ebp
  103653:	89 e5                	mov    %esp,%ebp
  103655:	50                   	push   %eax
		struct log_msg *msg = log_msg_create_n(str, args, narg);
  103656:	ff 75 10             	pushl  0x10(%ebp)
  103659:	ff 75 0c             	pushl  0xc(%ebp)
  10365c:	ff 75 08             	pushl  0x8(%ebp)
{
  10365f:	8b 55 14             	mov    0x14(%ebp),%edx
  103662:	89 55 fc             	mov    %edx,-0x4(%ebp)
		struct log_msg *msg = log_msg_create_n(str, args, narg);
  103665:	e8 9f 03 00 00       	call   103a09 <log_msg_create_n>
  10366a:	83 c4 0c             	add    $0xc,%esp
		if (msg == NULL) {
  10366d:	85 c0                	test   %eax,%eax
  10366f:	74 09                	je     10367a <log_n+0x28>
		msg_finalize(msg, src_level);
  103671:	8b 55 fc             	mov    -0x4(%ebp),%edx
}
  103674:	c9                   	leave  
		msg_finalize(msg, src_level);
  103675:	e9 37 fe ff ff       	jmp    1034b1 <msg_finalize>
}
  10367a:	c9                   	leave  
  10367b:	c3                   	ret    

0010367c <log_process_thread_func>:
{
  10367c:	55                   	push   %ebp
  10367d:	89 e5                	mov    %esp,%ebp
	log_init();
  10367f:	e8 30 fb ff ff       	call   1031b4 <log_init>
	return z_impl_k_current_get();
  103684:	e8 c8 e1 01 00       	call   121851 <z_impl_k_current_get>
	proc_tid = process_tid;
  103689:	a3 d4 ea 12 00       	mov    %eax,0x12ead4
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
  10368e:	85 c0                	test   %eax,%eax
  103690:	74 14                	je     1036a6 <log_process_thread_func+0x2a>
	    process_tid &&
  103692:	83 3d dc ea 12 00 09 	cmpl   $0x9,0x12eadc
  103699:	7e 0b                	jle    1036a6 <log_process_thread_func+0x2a>
	z_impl_k_sem_give(sem);
  10369b:	68 38 5d 14 00       	push   $0x145d38
  1036a0:	e8 f4 e1 01 00       	call   121899 <z_impl_k_sem_give>
  1036a5:	59                   	pop    %ecx
  1036a6:	6a 00                	push   $0x0
  1036a8:	e8 34 fc ff ff       	call   1032e1 <z_impl_log_process>
  1036ad:	5a                   	pop    %edx
		if (log_process(false) == false) {
  1036ae:	84 c0                	test   %al,%al
  1036b0:	75 f4                	jne    1036a6 <log_process_thread_func+0x2a>
	return z_impl_k_sem_take(sem, timeout);
  1036b2:	6a ff                	push   $0xffffffff
  1036b4:	6a ff                	push   $0xffffffff
  1036b6:	68 38 5d 14 00       	push   $0x145d38
  1036bb:	e8 32 e2 01 00       	call   1218f2 <z_impl_k_sem_take>
  1036c0:	83 c4 0c             	add    $0xc,%esp
  1036c3:	eb e1                	jmp    1036a6 <log_process_thread_func+0x2a>

001036c5 <z_impl_log_panic>:
	if (panic_mode) {
  1036c5:	80 3d 77 ed 12 00 00 	cmpb   $0x0,0x12ed77
  1036cc:	75 55                	jne    103723 <z_impl_log_panic+0x5e>
{
  1036ce:	55                   	push   %ebp
  1036cf:	89 e5                	mov    %esp,%ebp
  1036d1:	57                   	push   %edi
  1036d2:	56                   	push   %esi
	for (int i = 0; i < log_backend_count_get(); i++) {
  1036d3:	31 ff                	xor    %edi,%edi
{
  1036d5:	53                   	push   %ebx
	log_init();
  1036d6:	e8 d9 fa ff ff       	call   1031b4 <log_init>
	return __log_backends_end - __log_backends_start;
  1036db:	bb f0 31 12 00       	mov    $0x1231f0,%ebx
  1036e0:	be e0 31 12 00       	mov    $0x1231e0,%esi
  1036e5:	81 eb e0 31 12 00    	sub    $0x1231e0,%ebx
  1036eb:	c1 fb 04             	sar    $0x4,%ebx
	for (int i = 0; i < log_backend_count_get(); i++) {
  1036ee:	39 df                	cmp    %ebx,%edi
  1036f0:	7d 16                	jge    103708 <z_impl_log_panic+0x43>
	return backend->cb->active;
  1036f2:	8b 46 04             	mov    0x4(%esi),%eax
		if (log_backend_is_active(backend)) {
  1036f5:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
  1036f9:	74 07                	je     103702 <z_impl_log_panic+0x3d>
	backend->api->panic(backend);
  1036fb:	8b 06                	mov    (%esi),%eax
  1036fd:	56                   	push   %esi
  1036fe:	ff 50 10             	call   *0x10(%eax)
  103701:	59                   	pop    %ecx
	for (int i = 0; i < log_backend_count_get(); i++) {
  103702:	47                   	inc    %edi
  103703:	83 c6 10             	add    $0x10,%esi
  103706:	eb e6                	jmp    1036ee <z_impl_log_panic+0x29>
  103708:	6a 00                	push   $0x0
  10370a:	e8 d2 fb ff ff       	call   1032e1 <z_impl_log_process>
  10370f:	5a                   	pop    %edx
		while (log_process(false) == true) {
  103710:	84 c0                	test   %al,%al
  103712:	75 f4                	jne    103708 <z_impl_log_panic+0x43>
	panic_mode = true;
  103714:	c6 05 77 ed 12 00 01 	movb   $0x1,0x12ed77
}
  10371b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10371e:	5b                   	pop    %ebx
  10371f:	5e                   	pop    %esi
  103720:	5f                   	pop    %edi
  103721:	5d                   	pop    %ebp
  103722:	c3                   	ret    
  103723:	c3                   	ret    

00103724 <log_free>:
{
  103724:	55                   	push   %ebp
  103725:	89 e5                	mov    %esp,%ebp
  103727:	51                   	push   %ecx
  103728:	8b 45 08             	mov    0x8(%ebp),%eax
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
  10372b:	8d 50 fc             	lea    -0x4(%eax),%edx
  10372e:	89 55 fc             	mov    %edx,-0x4(%ebp)
	if (atomic_dec(&dup->refcount) == 1) {
  103731:	f0 ff 48 fc          	lock decl -0x4(%eax)
  103735:	75 10                	jne    103747 <log_free+0x23>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
  103737:	8d 45 fc             	lea    -0x4(%ebp),%eax
  10373a:	50                   	push   %eax
  10373b:	68 20 a3 12 00       	push   $0x12a320
  103740:	e8 35 d2 01 00       	call   12097a <k_mem_slab_free>
  103745:	58                   	pop    %eax
  103746:	5a                   	pop    %edx
}
  103747:	c9                   	leave  
  103748:	c3                   	ret    

00103749 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
  103749:	55                   	push   %ebp
  10374a:	89 e5                	mov    %esp,%ebp
  10374c:	57                   	push   %edi
  10374d:	56                   	push   %esi
  10374e:	53                   	push   %ebx
  10374f:	89 d3                	mov    %edx,%ebx
  103751:	83 ec 08             	sub    $0x8,%esp
  103754:	8b 7d 0c             	mov    0xc(%ebp),%edi
  103757:	89 7d f0             	mov    %edi,-0x10(%ebp)
  10375a:	8a 55 f0             	mov    -0x10(%ebp),%dl
  10375d:	88 55 ef             	mov    %dl,-0x11(%ebp)
	uint32_t available_len = msg->hdr.params.hexdump.length;
  103760:	8b 50 08             	mov    0x8(%eax),%edx
  103763:	66 c1 ea 02          	shr    $0x2,%dx
  103767:	0f b7 d2             	movzwl %dx,%edx
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
  10376a:	3b 55 08             	cmp    0x8(%ebp),%edx
  10376d:	77 0b                	ja     10377a <log_msg_hexdump_data_op+0x31>
		*length = 0;
  10376f:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		return;
  103775:	e9 bc 00 00 00       	jmp    103836 <log_msg_hexdump_data_op+0xed>
	}

	if ((offset + *length) > available_len) {
  10377a:	8b 75 08             	mov    0x8(%ebp),%esi
  10377d:	03 31                	add    (%ecx),%esi
  10377f:	39 d6                	cmp    %edx,%esi
  103781:	76 07                	jbe    10378a <log_msg_hexdump_data_op+0x41>
		*length = available_len - offset;
  103783:	89 d6                	mov    %edx,%esi
  103785:	2b 75 08             	sub    0x8(%ebp),%esi
  103788:	89 31                	mov    %esi,(%ecx)
	}

	req_len = *length;
  10378a:	8b 31                	mov    (%ecx),%esi

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
  10378c:	83 fa 0c             	cmp    $0xc,%edx
  10378f:	76 13                	jbe    1037a4 <log_msg_hexdump_data_op+0x5b>
		head_data = msg->payload.single.bytes;
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
  103791:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
		cont = msg->payload.ext.next;
  103795:	8b 78 14             	mov    0x14(%eax),%edi
	if (offset < chunk_len) {
  103798:	77 3f                	ja     1037d9 <log_msg_hexdump_data_op+0x90>
		head_data = msg->payload.ext.data.bytes;
  10379a:	83 c0 18             	add    $0x18,%eax
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
  10379d:	ba 08 00 00 00       	mov    $0x8,%edx
  1037a2:	eb 05                	jmp    1037a9 <log_msg_hexdump_data_op+0x60>
		head_data = msg->payload.single.bytes;
  1037a4:	83 c0 14             	add    $0x14,%eax
	struct log_msg_cont *cont = NULL;
  1037a7:	31 ff                	xor    %edi,%edi
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
  1037a9:	89 f1                	mov    %esi,%ecx
  1037ab:	39 d6                	cmp    %edx,%esi
  1037ad:	76 02                	jbe    1037b1 <log_msg_hexdump_data_op+0x68>
  1037af:	89 d1                	mov    %edx,%ecx

		if (put_op) {
  1037b1:	03 45 08             	add    0x8(%ebp),%eax
  1037b4:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  1037b8:	74 08                	je     1037c2 <log_msg_hexdump_data_op+0x79>
			(void)memcpy(&head_data[offset], data, cpy_len);
  1037ba:	51                   	push   %ecx
  1037bb:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1037be:	53                   	push   %ebx
  1037bf:	50                   	push   %eax
  1037c0:	eb 06                	jmp    1037c8 <log_msg_hexdump_data_op+0x7f>
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
  1037c2:	51                   	push   %ecx
  1037c3:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1037c6:	50                   	push   %eax
  1037c7:	53                   	push   %ebx
  1037c8:	e8 1f 86 00 00       	call   10bdec <memcpy>
  1037cd:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1037d0:	83 c4 0c             	add    $0xc,%esp
		}

		req_len -= cpy_len;
  1037d3:	29 ce                	sub    %ecx,%esi
		data += cpy_len;
  1037d5:	01 cb                	add    %ecx,%ebx
  1037d7:	eb 4f                	jmp    103828 <log_msg_hexdump_data_op+0xdf>
	} else {
		offset -= chunk_len;
  1037d9:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		chunk_len = HEXDUMP_BYTES_CONT_MSG;
		if (cont == NULL) {
			cont = msg->payload.ext.next;
		}

		while (offset >= chunk_len) {
  1037dd:	83 7d 08 1b          	cmpl   $0x1b,0x8(%ebp)
  1037e1:	76 45                	jbe    103828 <log_msg_hexdump_data_op+0xdf>
			cont = cont->next;
			offset -= chunk_len;
  1037e3:	83 6d 08 1c          	subl   $0x1c,0x8(%ebp)
			cont = cont->next;
  1037e7:	8b 3f                	mov    (%edi),%edi
			offset -= chunk_len;
  1037e9:	eb f2                	jmp    1037dd <log_msg_hexdump_data_op+0x94>
		}
	}

	while ((req_len > 0) && (cont != NULL)) {
  1037eb:	85 ff                	test   %edi,%edi
  1037ed:	74 47                	je     103836 <log_msg_hexdump_data_op+0xed>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
  1037ef:	ba 1c 00 00 00       	mov    $0x1c,%edx
  1037f4:	2b 55 08             	sub    0x8(%ebp),%edx
  1037f7:	39 f2                	cmp    %esi,%edx
  1037f9:	76 02                	jbe    1037fd <log_msg_hexdump_data_op+0xb4>
  1037fb:	89 f2                	mov    %esi,%edx

		if (put_op) {
  1037fd:	8b 45 08             	mov    0x8(%ebp),%eax
  103800:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  103804:	8d 44 07 04          	lea    0x4(%edi,%eax,1),%eax
  103808:	74 24                	je     10382e <log_msg_hexdump_data_op+0xe5>
			(void)memcpy(&cont->payload.bytes[offset],
  10380a:	52                   	push   %edx
  10380b:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10380e:	53                   	push   %ebx
  10380f:	50                   	push   %eax
				     data, cpy_len);
		} else {
			(void)memcpy(data, &cont->payload.bytes[offset],
  103810:	e8 d7 85 00 00       	call   10bdec <memcpy>
  103815:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103818:	83 c4 0c             	add    $0xc,%esp
				     cpy_len);
		}

		offset = 0;
		cont = cont->next;
  10381b:	8b 3f                	mov    (%edi),%edi
		req_len -= cpy_len;
  10381d:	29 d6                	sub    %edx,%esi
		data += cpy_len;
  10381f:	01 d3                	add    %edx,%ebx
		offset = 0;
  103821:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
	while ((req_len > 0) && (cont != NULL)) {
  103828:	85 f6                	test   %esi,%esi
  10382a:	75 bf                	jne    1037eb <log_msg_hexdump_data_op+0xa2>
  10382c:	eb 08                	jmp    103836 <log_msg_hexdump_data_op+0xed>
			(void)memcpy(data, &cont->payload.bytes[offset],
  10382e:	52                   	push   %edx
  10382f:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103832:	50                   	push   %eax
  103833:	53                   	push   %ebx
  103834:	eb da                	jmp    103810 <log_msg_hexdump_data_op+0xc7>
	}
}
  103836:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103839:	5b                   	pop    %ebx
  10383a:	5e                   	pop    %esi
  10383b:	5f                   	pop    %edi
  10383c:	5d                   	pop    %ebp
  10383d:	c3                   	ret    

0010383e <log_msg_pool_init>:
{
  10383e:	55                   	push   %ebp
  10383f:	89 e5                	mov    %esp,%ebp
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
  103841:	6a 20                	push   $0x20
  103843:	6a 20                	push   $0x20
  103845:	68 90 10 14 00       	push   $0x141090
  10384a:	68 60 a3 12 00       	push   $0x12a360
  10384f:	e8 55 d0 01 00       	call   1208a9 <k_mem_slab_init>
  103854:	83 c4 10             	add    $0x10,%esp
}
  103857:	c9                   	leave  
  103858:	c3                   	ret    

00103859 <log_msg_get>:
{
  103859:	55                   	push   %ebp
  10385a:	89 e5                	mov    %esp,%ebp
  10385c:	8b 45 08             	mov    0x8(%ebp),%eax
  10385f:	f0 ff 40 04          	lock incl 0x4(%eax)
}
  103863:	5d                   	pop    %ebp
  103864:	c3                   	ret    

00103865 <log_msg_no_space_handle>:
{
  103865:	55                   	push   %ebp
  103866:	89 e5                	mov    %esp,%ebp
  103868:	53                   	push   %ebx
  103869:	51                   	push   %ecx
	union log_msg_chunk *msg = NULL;
  10386a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  103871:	6a 01                	push   $0x1
  103873:	e8 69 fa ff ff       	call   1032e1 <z_impl_log_process>
  103878:	5a                   	pop    %edx
  103879:	88 c3                	mov    %al,%bl
			log_dropped();
  10387b:	e8 c7 f7 ff ff       	call   103047 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
  103880:	6a 00                	push   $0x0
  103882:	6a 00                	push   $0x0
  103884:	8d 45 f8             	lea    -0x8(%ebp),%eax
  103887:	50                   	push   %eax
  103888:	68 60 a3 12 00       	push   $0x12a360
  10388d:	e8 7a d0 01 00       	call   12090c <k_mem_slab_alloc>
  103892:	83 c4 10             	add    $0x10,%esp
		} while ((err != 0) && more);
  103895:	85 c0                	test   %eax,%eax
  103897:	74 04                	je     10389d <log_msg_no_space_handle+0x38>
  103899:	84 db                	test   %bl,%bl
  10389b:	75 d4                	jne    103871 <log_msg_no_space_handle+0xc>
}
  10389d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1038a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1038a3:	c9                   	leave  
  1038a4:	c3                   	ret    

001038a5 <log_msg_chunk_alloc>:
{
  1038a5:	55                   	push   %ebp
  1038a6:	89 e5                	mov    %esp,%ebp
  1038a8:	50                   	push   %eax
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
  1038a9:	6a 00                	push   $0x0
  1038ab:	6a 00                	push   $0x0
  1038ad:	8d 45 fc             	lea    -0x4(%ebp),%eax
  1038b0:	50                   	push   %eax
	union log_msg_chunk *msg = NULL;
  1038b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
  1038b8:	68 60 a3 12 00       	push   $0x12a360
  1038bd:	e8 4a d0 01 00       	call   12090c <k_mem_slab_alloc>
  1038c2:	83 c4 10             	add    $0x10,%esp
	if (err != 0) {
  1038c5:	85 c0                	test   %eax,%eax
  1038c7:	74 08                	je     1038d1 <log_msg_chunk_alloc+0x2c>
		msg = log_msg_no_space_handle();
  1038c9:	e8 97 ff ff ff       	call   103865 <log_msg_no_space_handle>
  1038ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1038d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1038d4:	c9                   	leave  
  1038d5:	c3                   	ret    

001038d6 <log_msg_nargs_get>:
{
  1038d6:	55                   	push   %ebp
  1038d7:	89 e5                	mov    %esp,%ebp
	return msg->hdr.params.std.nargs;
  1038d9:	8b 45 08             	mov    0x8(%ebp),%eax
}
  1038dc:	5d                   	pop    %ebp
	return msg->hdr.params.std.nargs;
  1038dd:	8a 40 09             	mov    0x9(%eax),%al
  1038e0:	c0 e8 04             	shr    $0x4,%al
  1038e3:	0f b6 c0             	movzbl %al,%eax
}
  1038e6:	c3                   	ret    

001038e7 <log_msg_arg_get>:
{
  1038e7:	55                   	push   %ebp
		return 0;
  1038e8:	31 d2                	xor    %edx,%edx
{
  1038ea:	89 e5                	mov    %esp,%ebp
  1038ec:	56                   	push   %esi
  1038ed:	53                   	push   %ebx
  1038ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1038f1:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (arg_idx >= msg->hdr.params.std.nargs) {
  1038f4:	8a 59 09             	mov    0x9(%ecx),%bl
  1038f7:	c0 eb 04             	shr    $0x4,%bl
  1038fa:	0f b6 f3             	movzbl %bl,%esi
  1038fd:	39 c6                	cmp    %eax,%esi
  1038ff:	76 2c                	jbe    10392d <log_msg_arg_get+0x46>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
  103901:	80 fb 03             	cmp    $0x3,%bl
  103904:	77 06                	ja     10390c <log_msg_arg_get+0x25>
		arg = msg->payload.single.args[arg_idx];
  103906:	8b 54 81 14          	mov    0x14(%ecx,%eax,4),%edx
  10390a:	eb 21                	jmp    10392d <log_msg_arg_get+0x46>
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
  10390c:	83 f8 01             	cmp    $0x1,%eax
  10390f:	77 06                	ja     103917 <log_msg_arg_get+0x30>
		return msg->payload.ext.data.args[arg_idx];
  103911:	8b 54 81 18          	mov    0x18(%ecx,%eax,4),%edx
  103915:	eb 16                	jmp    10392d <log_msg_arg_get+0x46>
	cont = msg->payload.ext.next;
  103917:	8b 51 14             	mov    0x14(%ecx),%edx
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
  10391a:	83 e8 02             	sub    $0x2,%eax
	while (arg_idx >= ARGS_CONT_MSG) {
  10391d:	83 f8 06             	cmp    $0x6,%eax
  103920:	76 07                	jbe    103929 <log_msg_arg_get+0x42>
		arg_idx -= ARGS_CONT_MSG;
  103922:	83 e8 07             	sub    $0x7,%eax
		cont = cont->next;
  103925:	8b 12                	mov    (%edx),%edx
  103927:	eb f4                	jmp    10391d <log_msg_arg_get+0x36>
	return cont->payload.args[arg_idx];
  103929:	8b 54 82 04          	mov    0x4(%edx,%eax,4),%edx
}
  10392d:	5b                   	pop    %ebx
  10392e:	89 d0                	mov    %edx,%eax
  103930:	5e                   	pop    %esi
  103931:	5d                   	pop    %ebp
  103932:	c3                   	ret    

00103933 <msg_free>:
{
  103933:	55                   	push   %ebp
  103934:	89 e5                	mov    %esp,%ebp
  103936:	57                   	push   %edi
  103937:	56                   	push   %esi
  103938:	53                   	push   %ebx
  103939:	83 ec 0c             	sub    $0xc,%esp
  10393c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return msg->hdr.params.std.nargs;
  10393f:	8a 58 09             	mov    0x9(%eax),%bl
  103942:	66 8b 40 08          	mov    0x8(%eax),%ax
  103946:	c0 eb 04             	shr    $0x4,%bl
  103949:	0f b6 db             	movzbl %bl,%ebx
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
  10394c:	f7 d0                	not    %eax
  10394e:	83 e0 01             	and    $0x1,%eax
	if (log_msg_is_std(msg) && nargs) {
  103951:	85 db                	test   %ebx,%ebx
  103953:	74 4c                	je     1039a1 <msg_free+0x6e>
  103955:	84 c0                	test   %al,%al
  103957:	74 48                	je     1039a1 <msg_free+0x6e>
		uint32_t smask = 0;
  103959:	31 ff                	xor    %edi,%edi
		for (i = 0; i < nargs; i++) {
  10395b:	31 f6                	xor    %esi,%esi
			void *buf = (void *)log_msg_arg_get(msg, i);
  10395d:	56                   	push   %esi
  10395e:	ff 75 ec             	pushl  -0x14(%ebp)
  103961:	e8 81 ff ff ff       	call   1038e7 <log_msg_arg_get>
  103966:	5a                   	pop    %edx
  103967:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10396a:	59                   	pop    %ecx
			if (log_is_strdup(buf)) {
  10396b:	50                   	push   %eax
  10396c:	e8 4d f9 ff ff       	call   1032be <log_is_strdup>
  103971:	5a                   	pop    %edx
  103972:	84 c0                	test   %al,%al
  103974:	74 26                	je     10399c <msg_free+0x69>
				if (smask == 0) {
  103976:	85 ff                	test   %edi,%edi
  103978:	75 14                	jne    10398e <msg_free+0x5b>
	return msg->str;
  10397a:	8b 45 ec             	mov    -0x14(%ebp),%eax
					smask = z_log_get_s_mask(
  10397d:	53                   	push   %ebx
  10397e:	ff 70 10             	pushl  0x10(%eax)
  103981:	e8 7b f5 ff ff       	call   102f01 <z_log_get_s_mask>
  103986:	5a                   	pop    %edx
  103987:	89 c7                	mov    %eax,%edi
  103989:	59                   	pop    %ecx
					if (smask == 0) {
  10398a:	85 c0                	test   %eax,%eax
  10398c:	74 13                	je     1039a1 <msg_free+0x6e>
				if (smask & BIT(i)) {
  10398e:	0f a3 f7             	bt     %esi,%edi
  103991:	73 09                	jae    10399c <msg_free+0x69>
					log_free(buf);
  103993:	ff 75 e8             	pushl  -0x18(%ebp)
  103996:	e8 89 fd ff ff       	call   103724 <log_free>
  10399b:	58                   	pop    %eax
		for (i = 0; i < nargs; i++) {
  10399c:	46                   	inc    %esi
  10399d:	39 de                	cmp    %ebx,%esi
  10399f:	72 bc                	jb     10395d <msg_free+0x2a>
	if (msg->hdr.params.generic.ext == 1) {
  1039a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1039a4:	f6 40 08 02          	testb  $0x2,0x8(%eax)
  1039a8:	74 24                	je     1039ce <msg_free+0x9b>
		cont_free(msg->payload.ext.next);
  1039aa:	8b 40 14             	mov    0x14(%eax),%eax
  1039ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (cont != NULL) {
  1039b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039b3:	85 c0                	test   %eax,%eax
  1039b5:	74 17                	je     1039ce <msg_free+0x9b>
		next = cont->next;
  1039b7:	8b 18                	mov    (%eax),%ebx
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
  1039b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1039bc:	50                   	push   %eax
  1039bd:	68 60 a3 12 00       	push   $0x12a360
  1039c2:	e8 b3 cf 01 00       	call   12097a <k_mem_slab_free>
  1039c7:	59                   	pop    %ecx
		cont = next;
  1039c8:	89 5d f0             	mov    %ebx,-0x10(%ebp)
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
  1039cb:	5e                   	pop    %esi
		cont = next;
  1039cc:	eb e2                	jmp    1039b0 <msg_free+0x7d>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
  1039ce:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1039d1:	50                   	push   %eax
  1039d2:	68 60 a3 12 00       	push   $0x12a360
  1039d7:	e8 9e cf 01 00       	call   12097a <k_mem_slab_free>
  1039dc:	58                   	pop    %eax
  1039dd:	5a                   	pop    %edx
}
  1039de:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1039e1:	5b                   	pop    %ebx
  1039e2:	5e                   	pop    %esi
  1039e3:	5f                   	pop    %edi
  1039e4:	5d                   	pop    %ebp
  1039e5:	c3                   	ret    

001039e6 <log_msg_put>:
{
  1039e6:	55                   	push   %ebp
  1039e7:	89 e5                	mov    %esp,%ebp
  1039e9:	8b 45 08             	mov    0x8(%ebp),%eax
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  1039ec:	f0 ff 48 04          	lock decl 0x4(%eax)
	if (msg->hdr.ref_cnt == 0) {
  1039f0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  1039f4:	75 06                	jne    1039fc <log_msg_put+0x16>
}
  1039f6:	5d                   	pop    %ebp
		msg_free(msg);
  1039f7:	e9 37 ff ff ff       	jmp    103933 <msg_free>
}
  1039fc:	5d                   	pop    %ebp
  1039fd:	c3                   	ret    

001039fe <log_msg_str_get>:
{
  1039fe:	55                   	push   %ebp
  1039ff:	89 e5                	mov    %esp,%ebp
	return msg->str;
  103a01:	8b 45 08             	mov    0x8(%ebp),%eax
}
  103a04:	5d                   	pop    %ebp
	return msg->str;
  103a05:	8b 40 10             	mov    0x10(%eax),%eax
}
  103a08:	c3                   	ret    

00103a09 <log_msg_create_n>:
{
  103a09:	55                   	push   %ebp
  103a0a:	89 e5                	mov    %esp,%ebp
  103a0c:	57                   	push   %edi
  103a0d:	56                   	push   %esi
  103a0e:	53                   	push   %ebx
  103a0f:	83 ec 0c             	sub    $0xc,%esp
  103a12:	8b 75 10             	mov    0x10(%ebp),%esi
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
  103a15:	e8 8b fe ff ff       	call   1038a5 <log_msg_chunk_alloc>
  103a1a:	89 c3                	mov    %eax,%ebx
	if (msg != NULL) {
  103a1c:	85 c0                	test   %eax,%eax
  103a1e:	0f 84 e7 00 00 00    	je     103b0b <log_msg_create_n+0x102>
		msg->hdr.ref_cnt = 1;
  103a24:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		msg->hdr.params.raw = 0U;
  103a2b:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
  103a31:	83 fe 03             	cmp    $0x3,%esi
  103a34:	77 40                	ja     103a76 <log_msg_create_n+0x6d>
		msg->str = str;
  103a36:	8b 45 08             	mov    0x8(%ebp),%eax
		msg->hdr.params.std.nargs = nargs;
  103a39:	89 f2                	mov    %esi,%edx
  103a3b:	c1 e2 04             	shl    $0x4,%edx
		msg->str = str;
  103a3e:	89 43 10             	mov    %eax,0x10(%ebx)
		msg->hdr.params.std.nargs = nargs;
  103a41:	8a 43 09             	mov    0x9(%ebx),%al
  103a44:	83 e0 0f             	and    $0xf,%eax
  103a47:	09 d0                	or     %edx,%eax
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
  103a49:	83 fe 03             	cmp    $0x3,%esi
		msg->hdr.params.std.nargs = nargs;
  103a4c:	88 43 09             	mov    %al,0x9(%ebx)
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
  103a4f:	76 65                	jbe    103ab6 <log_msg_create_n+0xad>
	struct log_msg_cont *cont = msg->payload.ext.next;
  103a51:	8b 43 14             	mov    0x14(%ebx),%eax
		(void)memcpy(msg->payload.ext.data.args, args,
  103a54:	6a 08                	push   $0x8
  103a56:	ff 75 0c             	pushl  0xc(%ebp)
	struct log_msg_cont *cont = msg->payload.ext.next;
  103a59:	89 45 f0             	mov    %eax,-0x10(%ebp)
		(void)memcpy(msg->payload.ext.data.args, args,
  103a5c:	8d 43 18             	lea    0x18(%ebx),%eax
  103a5f:	50                   	push   %eax
  103a60:	e8 87 83 00 00       	call   10bdec <memcpy>
		args += LOG_MSG_NARGS_HEAD_CHUNK;
  103a65:	8b 45 0c             	mov    0xc(%ebp),%eax
		(void)memcpy(msg->payload.ext.data.args, args,
  103a68:	83 c4 0c             	add    $0xc,%esp
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
  103a6b:	8d 56 fe             	lea    -0x2(%esi),%edx
		args += LOG_MSG_NARGS_HEAD_CHUNK;
  103a6e:	8d 78 08             	lea    0x8(%eax),%edi
	while (nargs != 0U) {
  103a71:	e9 87 00 00 00       	jmp    103afd <log_msg_create_n+0xf4>
	msg->hdr.params.generic.ext = 1;
  103a76:	66 c7 40 08 02 00    	movw   $0x2,0x8(%eax)
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
  103a7c:	8d 7e fe             	lea    -0x2(%esi),%edi
	next = &msg->payload.ext.next;
  103a7f:	8d 48 14             	lea    0x14(%eax),%ecx
	*next = NULL;
  103a82:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	while (n > 0) {
  103a89:	85 ff                	test   %edi,%edi
  103a8b:	7e a9                	jle    103a36 <log_msg_create_n+0x2d>
  103a8d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
  103a90:	e8 10 fe ff ff       	call   1038a5 <log_msg_chunk_alloc>
		if (cont == NULL) {
  103a95:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103a98:	85 c0                	test   %eax,%eax
  103a9a:	75 0b                	jne    103aa7 <log_msg_create_n+0x9e>
			msg_free(msg);
  103a9c:	89 d8                	mov    %ebx,%eax
			return NULL;
  103a9e:	31 db                	xor    %ebx,%ebx
			msg_free(msg);
  103aa0:	e8 8e fe ff ff       	call   103933 <msg_free>
	if (msg != NULL) {
  103aa5:	eb 64                	jmp    103b0b <log_msg_create_n+0x102>
		*next = cont;
  103aa7:	89 01                	mov    %eax,(%ecx)
		cont->next = NULL;
  103aa9:	83 ef 07             	sub    $0x7,%edi
  103aac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		next = &cont->next;
  103ab2:	89 c1                	mov    %eax,%ecx
		n -= ARGS_CONT_MSG;
  103ab4:	eb d3                	jmp    103a89 <log_msg_create_n+0x80>
		(void)memcpy(msg->payload.single.args, args,
  103ab6:	c1 e6 02             	shl    $0x2,%esi
  103ab9:	8d 43 14             	lea    0x14(%ebx),%eax
  103abc:	56                   	push   %esi
  103abd:	ff 75 0c             	pushl  0xc(%ebp)
  103ac0:	50                   	push   %eax
  103ac1:	e8 26 83 00 00       	call   10bdec <memcpy>
  103ac6:	83 c4 0c             	add    $0xc,%esp
	while (nargs != 0U) {
  103ac9:	eb 40                	jmp    103b0b <log_msg_create_n+0x102>
		(void)memcpy(cont->payload.args, args,
  103acb:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  103ad2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103ad5:	51                   	push   %ecx
  103ad6:	83 c0 04             	add    $0x4,%eax
  103ad9:	57                   	push   %edi
  103ada:	89 55 e8             	mov    %edx,-0x18(%ebp)
  103add:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103ae0:	50                   	push   %eax
  103ae1:	e8 06 83 00 00       	call   10bdec <memcpy>
		cont = cont->next;
  103ae6:	8b 45 f0             	mov    -0x10(%ebp),%eax
		args += cpy_args;
  103ae9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	while (nargs != 0U) {
  103aec:	8b 55 e8             	mov    -0x18(%ebp),%edx
		(void)memcpy(cont->payload.args, args,
  103aef:	83 c4 0c             	add    $0xc,%esp
		args += cpy_args;
  103af2:	01 cf                	add    %ecx,%edi
		cont = cont->next;
  103af4:	8b 00                	mov    (%eax),%eax
	while (nargs != 0U) {
  103af6:	29 f2                	sub    %esi,%edx
		cont = cont->next;
  103af8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (nargs != 0U) {
  103afb:	74 0e                	je     103b0b <log_msg_create_n+0x102>
		uint32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
  103afd:	89 d6                	mov    %edx,%esi
  103aff:	83 fa 07             	cmp    $0x7,%edx
  103b02:	76 c7                	jbe    103acb <log_msg_create_n+0xc2>
  103b04:	be 07 00 00 00       	mov    $0x7,%esi
  103b09:	eb c0                	jmp    103acb <log_msg_create_n+0xc2>
}
  103b0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103b0e:	89 d8                	mov    %ebx,%eax
  103b10:	5b                   	pop    %ebx
  103b11:	5e                   	pop    %esi
  103b12:	5f                   	pop    %edi
  103b13:	5d                   	pop    %ebp
  103b14:	c3                   	ret    

00103b15 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
  103b15:	55                   	push   %ebp
  103b16:	89 e5                	mov    %esp,%ebp
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  103b18:	8b 4d 14             	mov    0x14(%ebp),%ecx
{
  103b1b:	8b 45 08             	mov    0x8(%ebp),%eax
  103b1e:	8b 55 0c             	mov    0xc(%ebp),%edx
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  103b21:	89 4d 08             	mov    %ecx,0x8(%ebp)
  103b24:	8b 4d 10             	mov    0x10(%ebp),%ecx
  103b27:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
  103b2e:	5d                   	pop    %ebp
	log_msg_hexdump_data_op(msg, data, length, offset, false);
  103b2f:	e9 15 fc ff ff       	jmp    103749 <log_msg_hexdump_data_op>

00103b34 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
  103b34:	55                   	push   %ebp
  103b35:	89 e5                	mov    %esp,%ebp
  103b37:	57                   	push   %edi
  103b38:	56                   	push   %esi
  103b39:	89 d7                	mov    %edx,%edi
  103b3b:	53                   	push   %ebx
  103b3c:	89 c6                	mov    %eax,%esi
  103b3e:	89 cb                	mov    %ecx,%ebx
	int processed;

	do {
		processed = outf(buf, len, ctx);
  103b40:	ff 75 08             	pushl  0x8(%ebp)
  103b43:	53                   	push   %ebx
  103b44:	57                   	push   %edi
  103b45:	ff d6                	call   *%esi
  103b47:	83 c4 0c             	add    $0xc,%esp
		len -= processed;
		buf += processed;
  103b4a:	01 c7                	add    %eax,%edi
	} while (len != 0);
  103b4c:	29 c3                	sub    %eax,%ebx
  103b4e:	75 f0                	jne    103b40 <buffer_write+0xc>
}
  103b50:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103b53:	5b                   	pop    %ebx
  103b54:	5e                   	pop    %esi
  103b55:	5f                   	pop    %edi
  103b56:	5d                   	pop    %ebp
  103b57:	c3                   	ret    

00103b58 <print_formatted>:
{
  103b58:	55                   	push   %ebp
  103b59:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  103b5b:	8d 45 10             	lea    0x10(%ebp),%eax
	z_vprintk(out_func, (void *)log_output, fmt, args);
  103b5e:	50                   	push   %eax
  103b5f:	ff 75 0c             	pushl  0xc(%ebp)
  103b62:	ff 75 08             	pushl  0x8(%ebp)
  103b65:	68 dc 40 10 00       	push   $0x1040dc
  103b6a:	e8 58 d4 ff ff       	call   100fc7 <z_vprintk>
  103b6f:	83 c4 10             	add    $0x10,%esp
}
  103b72:	31 c0                	xor    %eax,%eax
  103b74:	c9                   	leave  
  103b75:	c3                   	ret    

00103b76 <std_print>:
	}
}

static void std_print(struct log_msg *msg,
		      const struct log_output *log_output)
{
  103b76:	55                   	push   %ebp
  103b77:	89 e5                	mov    %esp,%ebp
  103b79:	57                   	push   %edi
  103b7a:	56                   	push   %esi
  103b7b:	89 d6                	mov    %edx,%esi
  103b7d:	53                   	push   %ebx
  103b7e:	83 ec 0c             	sub    $0xc,%esp
  103b81:	89 45 f0             	mov    %eax,-0x10(%ebp)
	const char *str = log_msg_str_get(msg);
  103b84:	50                   	push   %eax
  103b85:	e8 74 fe ff ff       	call   1039fe <log_msg_str_get>
  103b8a:	5b                   	pop    %ebx
  103b8b:	89 c7                	mov    %eax,%edi
	uint32_t nargs = log_msg_nargs_get(msg);
  103b8d:	ff 75 f0             	pushl  -0x10(%ebp)
  103b90:	e8 41 fd ff ff       	call   1038d6 <log_msg_nargs_get>
	uint32_t *args = alloca(sizeof(uint32_t)*nargs);
	int i;

	for (i = 0; i < nargs; i++) {
  103b95:	31 c9                	xor    %ecx,%ecx
	uint32_t nargs = log_msg_nargs_get(msg);
  103b97:	5a                   	pop    %edx
  103b98:	89 c2                	mov    %eax,%edx
	uint32_t *args = alloca(sizeof(uint32_t)*nargs);
  103b9a:	8d 04 85 0c 00 00 00 	lea    0xc(,%eax,4),%eax
  103ba1:	29 c4                	sub    %eax,%esp
  103ba3:	8d 5c 24 0f          	lea    0xf(%esp),%ebx
  103ba7:	83 e3 f0             	and    $0xfffffff0,%ebx
	for (i = 0; i < nargs; i++) {
  103baa:	39 d1                	cmp    %edx,%ecx
  103bac:	74 1d                	je     103bcb <std_print+0x55>
		args[i] = log_msg_arg_get(msg, i);
  103bae:	51                   	push   %ecx
  103baf:	89 55 e8             	mov    %edx,-0x18(%ebp)
  103bb2:	ff 75 f0             	pushl  -0x10(%ebp)
  103bb5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103bb8:	e8 2a fd ff ff       	call   1038e7 <log_msg_arg_get>
  103bbd:	5a                   	pop    %edx
	for (i = 0; i < nargs; i++) {
  103bbe:	8b 55 e8             	mov    -0x18(%ebp),%edx
		args[i] = log_msg_arg_get(msg, i);
  103bc1:	59                   	pop    %ecx
  103bc2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103bc5:	89 04 8b             	mov    %eax,(%ebx,%ecx,4)
	for (i = 0; i < nargs; i++) {
  103bc8:	41                   	inc    %ecx
  103bc9:	eb df                	jmp    103baa <std_print+0x34>
	}

	switch (log_msg_nargs_get(msg)) {
  103bcb:	ff 75 f0             	pushl  -0x10(%ebp)
  103bce:	e8 03 fd ff ff       	call   1038d6 <log_msg_nargs_get>
  103bd3:	59                   	pop    %ecx
  103bd4:	83 f8 0f             	cmp    $0xf,%eax
  103bd7:	0f 87 44 02 00 00    	ja     103e21 <std_print+0x2ab>
  103bdd:	ff 24 85 58 3f 12 00 	jmp    *0x123f58(,%eax,4)
	case 0:
		print_formatted(log_output, str);
  103be4:	57                   	push   %edi
  103be5:	56                   	push   %esi
  103be6:	e8 6d ff ff ff       	call   103b58 <print_formatted>
  103beb:	58                   	pop    %eax
  103bec:	5a                   	pop    %edx
		break;
  103bed:	e9 2f 02 00 00       	jmp    103e21 <std_print+0x2ab>
	case 1:
		print_formatted(log_output, str, args[0]);
  103bf2:	ff 33                	pushl  (%ebx)
  103bf4:	57                   	push   %edi
  103bf5:	56                   	push   %esi
  103bf6:	e8 5d ff ff ff       	call   103b58 <print_formatted>
  103bfb:	83 c4 0c             	add    $0xc,%esp
		break;
  103bfe:	e9 1e 02 00 00       	jmp    103e21 <std_print+0x2ab>
	case 2:
		print_formatted(log_output, str, args[0], args[1]);
  103c03:	ff 73 04             	pushl  0x4(%ebx)
  103c06:	ff 33                	pushl  (%ebx)
  103c08:	57                   	push   %edi
  103c09:	56                   	push   %esi
  103c0a:	e8 49 ff ff ff       	call   103b58 <print_formatted>
  103c0f:	83 c4 10             	add    $0x10,%esp
		break;
  103c12:	e9 0a 02 00 00       	jmp    103e21 <std_print+0x2ab>
	case 3:
		print_formatted(log_output, str, args[0], args[1], args[2]);
  103c17:	ff 73 08             	pushl  0x8(%ebx)
  103c1a:	ff 73 04             	pushl  0x4(%ebx)
  103c1d:	ff 33                	pushl  (%ebx)
  103c1f:	57                   	push   %edi
  103c20:	56                   	push   %esi
  103c21:	e8 32 ff ff ff       	call   103b58 <print_formatted>
  103c26:	83 c4 14             	add    $0x14,%esp
		break;
  103c29:	e9 f3 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 4:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103c2e:	ff 73 0c             	pushl  0xc(%ebx)
  103c31:	ff 73 08             	pushl  0x8(%ebx)
  103c34:	ff 73 04             	pushl  0x4(%ebx)
  103c37:	ff 33                	pushl  (%ebx)
  103c39:	57                   	push   %edi
  103c3a:	56                   	push   %esi
  103c3b:	e8 18 ff ff ff       	call   103b58 <print_formatted>
  103c40:	83 c4 18             	add    $0x18,%esp
				args[3]);
		break;
  103c43:	e9 d9 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 5:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103c48:	ff 73 10             	pushl  0x10(%ebx)
  103c4b:	ff 73 0c             	pushl  0xc(%ebx)
  103c4e:	ff 73 08             	pushl  0x8(%ebx)
  103c51:	ff 73 04             	pushl  0x4(%ebx)
  103c54:	ff 33                	pushl  (%ebx)
  103c56:	57                   	push   %edi
  103c57:	56                   	push   %esi
  103c58:	e8 fb fe ff ff       	call   103b58 <print_formatted>
  103c5d:	83 c4 1c             	add    $0x1c,%esp
				args[3], args[4]);
		break;
  103c60:	e9 bc 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 6:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103c65:	ff 73 14             	pushl  0x14(%ebx)
  103c68:	ff 73 10             	pushl  0x10(%ebx)
  103c6b:	ff 73 0c             	pushl  0xc(%ebx)
  103c6e:	ff 73 08             	pushl  0x8(%ebx)
  103c71:	ff 73 04             	pushl  0x4(%ebx)
  103c74:	ff 33                	pushl  (%ebx)
  103c76:	57                   	push   %edi
  103c77:	56                   	push   %esi
  103c78:	e8 db fe ff ff       	call   103b58 <print_formatted>
  103c7d:	83 c4 20             	add    $0x20,%esp
				args[3], args[4], args[5]);
		break;
  103c80:	e9 9c 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 7:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103c85:	ff 73 18             	pushl  0x18(%ebx)
  103c88:	ff 73 14             	pushl  0x14(%ebx)
  103c8b:	ff 73 10             	pushl  0x10(%ebx)
  103c8e:	ff 73 0c             	pushl  0xc(%ebx)
  103c91:	ff 73 08             	pushl  0x8(%ebx)
  103c94:	ff 73 04             	pushl  0x4(%ebx)
  103c97:	ff 33                	pushl  (%ebx)
  103c99:	57                   	push   %edi
  103c9a:	56                   	push   %esi
  103c9b:	e8 b8 fe ff ff       	call   103b58 <print_formatted>
  103ca0:	83 c4 24             	add    $0x24,%esp
				args[3], args[4], args[5], args[6]);
		break;
  103ca3:	e9 79 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 8:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103ca8:	ff 73 1c             	pushl  0x1c(%ebx)
  103cab:	ff 73 18             	pushl  0x18(%ebx)
  103cae:	ff 73 14             	pushl  0x14(%ebx)
  103cb1:	ff 73 10             	pushl  0x10(%ebx)
  103cb4:	ff 73 0c             	pushl  0xc(%ebx)
  103cb7:	ff 73 08             	pushl  0x8(%ebx)
  103cba:	ff 73 04             	pushl  0x4(%ebx)
  103cbd:	ff 33                	pushl  (%ebx)
  103cbf:	57                   	push   %edi
  103cc0:	56                   	push   %esi
  103cc1:	e8 92 fe ff ff       	call   103b58 <print_formatted>
  103cc6:	83 c4 28             	add    $0x28,%esp
				args[3], args[4], args[5], args[6], args[7]);
		break;
  103cc9:	e9 53 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 9:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103cce:	ff 73 20             	pushl  0x20(%ebx)
  103cd1:	ff 73 1c             	pushl  0x1c(%ebx)
  103cd4:	ff 73 18             	pushl  0x18(%ebx)
  103cd7:	ff 73 14             	pushl  0x14(%ebx)
  103cda:	ff 73 10             	pushl  0x10(%ebx)
  103cdd:	ff 73 0c             	pushl  0xc(%ebx)
  103ce0:	ff 73 08             	pushl  0x8(%ebx)
  103ce3:	ff 73 04             	pushl  0x4(%ebx)
  103ce6:	ff 33                	pushl  (%ebx)
  103ce8:	57                   	push   %edi
  103ce9:	56                   	push   %esi
  103cea:	e8 69 fe ff ff       	call   103b58 <print_formatted>
  103cef:	83 c4 2c             	add    $0x2c,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8]);
		break;
  103cf2:	e9 2a 01 00 00       	jmp    103e21 <std_print+0x2ab>
	case 10:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103cf7:	ff 73 24             	pushl  0x24(%ebx)
  103cfa:	ff 73 20             	pushl  0x20(%ebx)
  103cfd:	ff 73 1c             	pushl  0x1c(%ebx)
  103d00:	ff 73 18             	pushl  0x18(%ebx)
  103d03:	ff 73 14             	pushl  0x14(%ebx)
  103d06:	ff 73 10             	pushl  0x10(%ebx)
  103d09:	ff 73 0c             	pushl  0xc(%ebx)
  103d0c:	ff 73 08             	pushl  0x8(%ebx)
  103d0f:	ff 73 04             	pushl  0x4(%ebx)
  103d12:	ff 33                	pushl  (%ebx)
  103d14:	57                   	push   %edi
  103d15:	56                   	push   %esi
  103d16:	e8 3d fe ff ff       	call   103b58 <print_formatted>
  103d1b:	83 c4 30             	add    $0x30,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9]);
		break;
  103d1e:	e9 fe 00 00 00       	jmp    103e21 <std_print+0x2ab>
	case 11:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103d23:	ff 73 28             	pushl  0x28(%ebx)
  103d26:	ff 73 24             	pushl  0x24(%ebx)
  103d29:	ff 73 20             	pushl  0x20(%ebx)
  103d2c:	ff 73 1c             	pushl  0x1c(%ebx)
  103d2f:	ff 73 18             	pushl  0x18(%ebx)
  103d32:	ff 73 14             	pushl  0x14(%ebx)
  103d35:	ff 73 10             	pushl  0x10(%ebx)
  103d38:	ff 73 0c             	pushl  0xc(%ebx)
  103d3b:	ff 73 08             	pushl  0x8(%ebx)
  103d3e:	ff 73 04             	pushl  0x4(%ebx)
  103d41:	ff 33                	pushl  (%ebx)
  103d43:	57                   	push   %edi
  103d44:	56                   	push   %esi
  103d45:	e8 0e fe ff ff       	call   103b58 <print_formatted>
  103d4a:	83 c4 34             	add    $0x34,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10]);
		break;
  103d4d:	e9 cf 00 00 00       	jmp    103e21 <std_print+0x2ab>
	case 12:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103d52:	ff 73 2c             	pushl  0x2c(%ebx)
  103d55:	ff 73 28             	pushl  0x28(%ebx)
  103d58:	ff 73 24             	pushl  0x24(%ebx)
  103d5b:	ff 73 20             	pushl  0x20(%ebx)
  103d5e:	ff 73 1c             	pushl  0x1c(%ebx)
  103d61:	ff 73 18             	pushl  0x18(%ebx)
  103d64:	ff 73 14             	pushl  0x14(%ebx)
  103d67:	ff 73 10             	pushl  0x10(%ebx)
  103d6a:	ff 73 0c             	pushl  0xc(%ebx)
  103d6d:	ff 73 08             	pushl  0x8(%ebx)
  103d70:	ff 73 04             	pushl  0x4(%ebx)
  103d73:	ff 33                	pushl  (%ebx)
  103d75:	57                   	push   %edi
  103d76:	56                   	push   %esi
  103d77:	e8 dc fd ff ff       	call   103b58 <print_formatted>
  103d7c:	83 c4 38             	add    $0x38,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11]);
		break;
  103d7f:	e9 9d 00 00 00       	jmp    103e21 <std_print+0x2ab>
	case 13:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103d84:	ff 73 30             	pushl  0x30(%ebx)
  103d87:	ff 73 2c             	pushl  0x2c(%ebx)
  103d8a:	ff 73 28             	pushl  0x28(%ebx)
  103d8d:	ff 73 24             	pushl  0x24(%ebx)
  103d90:	ff 73 20             	pushl  0x20(%ebx)
  103d93:	ff 73 1c             	pushl  0x1c(%ebx)
  103d96:	ff 73 18             	pushl  0x18(%ebx)
  103d99:	ff 73 14             	pushl  0x14(%ebx)
  103d9c:	ff 73 10             	pushl  0x10(%ebx)
  103d9f:	ff 73 0c             	pushl  0xc(%ebx)
  103da2:	ff 73 08             	pushl  0x8(%ebx)
  103da5:	ff 73 04             	pushl  0x4(%ebx)
  103da8:	ff 33                	pushl  (%ebx)
  103daa:	57                   	push   %edi
  103dab:	56                   	push   %esi
  103dac:	e8 a7 fd ff ff       	call   103b58 <print_formatted>
  103db1:	83 c4 3c             	add    $0x3c,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12]);
		break;
  103db4:	eb 6b                	jmp    103e21 <std_print+0x2ab>
	case 14:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103db6:	ff 73 34             	pushl  0x34(%ebx)
  103db9:	ff 73 30             	pushl  0x30(%ebx)
  103dbc:	ff 73 2c             	pushl  0x2c(%ebx)
  103dbf:	ff 73 28             	pushl  0x28(%ebx)
  103dc2:	ff 73 24             	pushl  0x24(%ebx)
  103dc5:	ff 73 20             	pushl  0x20(%ebx)
  103dc8:	ff 73 1c             	pushl  0x1c(%ebx)
  103dcb:	ff 73 18             	pushl  0x18(%ebx)
  103dce:	ff 73 14             	pushl  0x14(%ebx)
  103dd1:	ff 73 10             	pushl  0x10(%ebx)
  103dd4:	ff 73 0c             	pushl  0xc(%ebx)
  103dd7:	ff 73 08             	pushl  0x8(%ebx)
  103dda:	ff 73 04             	pushl  0x4(%ebx)
  103ddd:	ff 33                	pushl  (%ebx)
  103ddf:	57                   	push   %edi
  103de0:	56                   	push   %esi
  103de1:	e8 72 fd ff ff       	call   103b58 <print_formatted>
  103de6:	83 c4 40             	add    $0x40,%esp
				args[3], args[4], args[5], args[6],  args[7],
				args[8], args[9], args[10], args[11], args[12],
				args[13]);
		break;
  103de9:	eb 36                	jmp    103e21 <std_print+0x2ab>
	case 15:
		print_formatted(log_output, str, args[0], args[1], args[2],
  103deb:	ff 73 38             	pushl  0x38(%ebx)
  103dee:	ff 73 34             	pushl  0x34(%ebx)
  103df1:	ff 73 30             	pushl  0x30(%ebx)
  103df4:	ff 73 2c             	pushl  0x2c(%ebx)
  103df7:	ff 73 28             	pushl  0x28(%ebx)
  103dfa:	ff 73 24             	pushl  0x24(%ebx)
  103dfd:	ff 73 20             	pushl  0x20(%ebx)
  103e00:	ff 73 1c             	pushl  0x1c(%ebx)
  103e03:	ff 73 18             	pushl  0x18(%ebx)
  103e06:	ff 73 14             	pushl  0x14(%ebx)
  103e09:	ff 73 10             	pushl  0x10(%ebx)
  103e0c:	ff 73 0c             	pushl  0xc(%ebx)
  103e0f:	ff 73 08             	pushl  0x8(%ebx)
  103e12:	ff 73 04             	pushl  0x4(%ebx)
  103e15:	ff 33                	pushl  (%ebx)
  103e17:	57                   	push   %edi
  103e18:	56                   	push   %esi
  103e19:	e8 3a fd ff ff       	call   103b58 <print_formatted>
  103e1e:	83 c4 44             	add    $0x44,%esp
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
	}
}
  103e21:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103e24:	5b                   	pop    %ebx
  103e25:	5e                   	pop    %esi
  103e26:	5f                   	pop    %edi
  103e27:	5d                   	pop    %ebp
  103e28:	c3                   	ret    

00103e29 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *log_output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, uint16_t source_id)
{
  103e29:	55                   	push   %ebp
  103e2a:	89 e5                	mov    %esp,%ebp
  103e2c:	57                   	push   %edi
  103e2d:	56                   	push   %esi
  103e2e:	89 d7                	mov    %edx,%edi
  103e30:	53                   	push   %ebx
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
  103e31:	89 d3                	mov    %edx,%ebx
{
  103e33:	83 ec 1c             	sub    $0x1c,%esp
  103e36:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  103e39:	8b 4d 10             	mov    0x10(%ebp),%ecx
  103e3c:	8b 75 0c             	mov    0xc(%ebp),%esi
  103e3f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  103e42:	89 d1                	mov    %edx,%ecx
  103e44:	83 e1 08             	and    $0x8,%ecx
{
  103e47:	89 75 ec             	mov    %esi,-0x14(%ebp)
	if (stamp) {
  103e4a:	83 e3 02             	and    $0x2,%ebx
{
  103e4d:	8b 75 14             	mov    0x14(%ebp),%esi
  103e50:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103e53:	89 75 dc             	mov    %esi,-0x24(%ebp)
  103e56:	8b 45 08             	mov    0x8(%ebp),%eax
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  103e59:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	if (stamp) {
  103e5c:	74 7b                	je     103ed9 <prefix_print+0xb0>
	if (!format) {
  103e5e:	f6 c2 44             	test   $0x44,%dl
  103e61:	75 13                	jne    103e76 <prefix_print+0x4d>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
  103e63:	50                   	push   %eax
  103e64:	68 84 49 12 00       	push   $0x124984
  103e69:	ff 75 f0             	pushl  -0x10(%ebp)
  103e6c:	e8 e7 fc ff ff       	call   103b58 <print_formatted>
  103e71:	83 c4 0c             	add    $0xc,%esp
  103e74:	eb 61                	jmp    103ed7 <prefix_print+0xae>
	} else if (freq != 0U) {
  103e76:	8b 35 f0 ea 12 00    	mov    0x12eaf0,%esi
		length = 0;
  103e7c:	31 db                	xor    %ebx,%ebx
	} else if (freq != 0U) {
  103e7e:	85 f6                	test   %esi,%esi
  103e80:	74 57                	je     103ed9 <prefix_print+0xb0>
		timestamp /= timestamp_div;
  103e82:	31 d2                	xor    %edx,%edx
  103e84:	b9 10 0e 00 00       	mov    $0xe10,%ecx
  103e89:	f7 35 ec ea 12 00    	divl   0x12eaec
  103e8f:	31 d2                	xor    %edx,%edx
  103e91:	f7 f6                	div    %esi
  103e93:	89 d3                	mov    %edx,%ebx
		seconds -= hours * 3600U;
  103e95:	31 d2                	xor    %edx,%edx
		ms = (remainder * 1000U) / freq;
  103e97:	69 db e8 03 00 00    	imul   $0x3e8,%ebx,%ebx
  103e9d:	f7 f1                	div    %ecx
  103e9f:	89 55 d8             	mov    %edx,-0x28(%ebp)
  103ea2:	89 c1                	mov    %eax,%ecx
  103ea4:	31 d2                	xor    %edx,%edx
  103ea6:	89 d8                	mov    %ebx,%eax
  103ea8:	f7 f6                	div    %esi
  103eaa:	89 c3                	mov    %eax,%ebx
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  103eac:	69 c2 e8 03 00 00    	imul   $0x3e8,%edx,%eax
  103eb2:	31 d2                	xor    %edx,%edx
  103eb4:	f7 f6                	div    %esi
			length = print_formatted(log_output,
  103eb6:	50                   	push   %eax
  103eb7:	31 d2                	xor    %edx,%edx
  103eb9:	53                   	push   %ebx
  103eba:	8b 45 d8             	mov    -0x28(%ebp),%eax
  103ebd:	bb 3c 00 00 00       	mov    $0x3c,%ebx
  103ec2:	f7 f3                	div    %ebx
  103ec4:	52                   	push   %edx
  103ec5:	50                   	push   %eax
  103ec6:	51                   	push   %ecx
  103ec7:	68 8d 49 12 00       	push   $0x12498d
  103ecc:	ff 75 f0             	pushl  -0x10(%ebp)
  103ecf:	e8 84 fc ff ff       	call   103b58 <print_formatted>
  103ed4:	83 c4 1c             	add    $0x1c,%esp
  103ed7:	89 c3                	mov    %eax,%ebx
			log_output, "%s - - - - ",
			log_output->control_block->hostname ?
			log_output->control_block->hostname :
			"zephyr");
	} else {
		color_prefix(log_output, colors_on, level);
  103ed9:	0f b6 75 ec          	movzbl -0x14(%ebp),%esi
	if (color) {
  103edd:	83 e7 01             	and    $0x1,%edi
  103ee0:	74 21                	je     103f03 <prefix_print+0xda>
		const char *log_color = start && (colors[level] != NULL) ?
  103ee2:	8b 04 b5 b8 3f 12 00 	mov    0x123fb8(,%esi,4),%eax
  103ee9:	85 c0                	test   %eax,%eax
  103eeb:	75 05                	jne    103ef2 <prefix_print+0xc9>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  103eed:	b8 76 49 12 00       	mov    $0x124976,%eax
		print_formatted(log_output, "%s", log_color);
  103ef2:	50                   	push   %eax
  103ef3:	68 f8 4e 12 00       	push   $0x124ef8
  103ef8:	ff 75 f0             	pushl  -0x10(%ebp)
  103efb:	e8 58 fc ff ff       	call   103b58 <print_formatted>
  103f00:	83 c4 0c             	add    $0xc,%esp
	}

	length += ids_print(log_output, level_on, func_on,
  103f03:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  103f07:	0f b6 7d e0          	movzbl -0x20(%ebp),%edi
	if (level_on) {
  103f0b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
	int total = 0;
  103f0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	if (level_on) {
  103f16:	74 20                	je     103f38 <prefix_print+0x10f>
		total += print_formatted(log_output, "<%s> ", severity[level]);
  103f18:	ff 34 b5 cc 3f 12 00 	pushl  0x123fcc(,%esi,4)
  103f1f:	89 55 e8             	mov    %edx,-0x18(%ebp)
  103f22:	68 a9 49 12 00       	push   $0x1249a9
  103f27:	ff 75 f0             	pushl  -0x10(%ebp)
  103f2a:	e8 29 fc ff ff       	call   103b58 <print_formatted>
  103f2f:	83 c4 0c             	add    $0xc,%esp
  103f32:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103f35:	8b 55 e8             	mov    -0x18(%ebp),%edx
	total += print_formatted(log_output,
  103f38:	52                   	push   %edx
  103f39:	57                   	push   %edi
  103f3a:	e8 10 f1 ff ff       	call   10304f <log_source_name_get>
  103f3f:	5a                   	pop    %edx
  103f40:	bf 7b 49 12 00       	mov    $0x12497b,%edi
  103f45:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  103f49:	59                   	pop    %ecx
  103f4a:	74 13                	je     103f5f <prefix_print+0x136>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
  103f4c:	ba 01 00 00 00       	mov    $0x1,%edx
  103f51:	89 f1                	mov    %esi,%ecx
  103f53:	d3 e2                	shl    %cl,%edx
				(func_on &&
  103f55:	80 e2 10             	and    $0x10,%dl
  103f58:	74 05                	je     103f5f <prefix_print+0x136>
	total += print_formatted(log_output,
  103f5a:	bf 80 49 12 00       	mov    $0x124980,%edi
  103f5f:	50                   	push   %eax
  103f60:	57                   	push   %edi
  103f61:	ff 75 f0             	pushl  -0x10(%ebp)
  103f64:	e8 ef fb ff ff       	call   103b58 <print_formatted>
  103f69:	83 c4 0c             	add    $0xc,%esp
  103f6c:	03 45 ec             	add    -0x14(%ebp),%eax
			domain_id, source_id, level);

	return length;
}
  103f6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
	length += ids_print(log_output, level_on, func_on,
  103f72:	01 d8                	add    %ebx,%eax
}
  103f74:	5b                   	pop    %ebx
  103f75:	5e                   	pop    %esi
  103f76:	5f                   	pop    %edi
  103f77:	5d                   	pop    %ebp
  103f78:	c3                   	ret    

00103f79 <hexdump_line_print>:
{
  103f79:	55                   	push   %ebp
  103f7a:	89 e5                	mov    %esp,%ebp
  103f7c:	57                   	push   %edi
  103f7d:	56                   	push   %esi
  103f7e:	89 d7                	mov    %edx,%edi
  103f80:	53                   	push   %ebx
  103f81:	53                   	push   %ebx
  103f82:	89 c3                	mov    %eax,%ebx
  103f84:	8b 45 0c             	mov    0xc(%ebp),%eax
  103f87:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  103f8a:	a8 10                	test   $0x10,%al
  103f8c:	75 18                	jne    103fa6 <hexdump_line_print+0x2d>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  103f8e:	a8 20                	test   $0x20,%al
  103f90:	74 07                	je     103f99 <hexdump_line_print+0x20>
		print_formatted(ctx, "\n");
  103f92:	68 01 4e 12 00       	push   $0x124e01
  103f97:	eb 05                	jmp    103f9e <hexdump_line_print+0x25>
		print_formatted(ctx, "\r\n");
  103f99:	68 0c 4a 12 00       	push   $0x124a0c
  103f9e:	53                   	push   %ebx
  103f9f:	e8 b4 fb ff ff       	call   103b58 <print_formatted>
  103fa4:	58                   	pop    %eax
  103fa5:	5a                   	pop    %edx
{
  103fa6:	31 f6                	xor    %esi,%esi
	for (int i = 0; i < prefix_offset; i++) {
  103fa8:	3b 75 08             	cmp    0x8(%ebp),%esi
  103fab:	7d 10                	jge    103fbd <hexdump_line_print+0x44>
		print_formatted(log_output, " ");
  103fad:	68 b7 49 12 00       	push   $0x1249b7
	for (int i = 0; i < prefix_offset; i++) {
  103fb2:	46                   	inc    %esi
		print_formatted(log_output, " ");
  103fb3:	53                   	push   %ebx
  103fb4:	e8 9f fb ff ff       	call   103b58 <print_formatted>
  103fb9:	59                   	pop    %ecx
  103fba:	58                   	pop    %eax
	for (int i = 0; i < prefix_offset; i++) {
  103fbb:	eb eb                	jmp    103fa8 <hexdump_line_print+0x2f>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  103fbd:	31 f6                	xor    %esi,%esi
		if (i < length) {
  103fbf:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  103fc2:	73 15                	jae    103fd9 <hexdump_line_print+0x60>
			print_formatted(log_output, "%02x ", data[i]);
  103fc4:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
  103fc8:	50                   	push   %eax
  103fc9:	68 af 49 12 00       	push   $0x1249af
  103fce:	53                   	push   %ebx
  103fcf:	e8 84 fb ff ff       	call   103b58 <print_formatted>
  103fd4:	83 c4 0c             	add    $0xc,%esp
  103fd7:	eb 0d                	jmp    103fe6 <hexdump_line_print+0x6d>
			print_formatted(log_output, "   ");
  103fd9:	68 b5 49 12 00       	push   $0x1249b5
  103fde:	53                   	push   %ebx
  103fdf:	e8 74 fb ff ff       	call   103b58 <print_formatted>
  103fe4:	59                   	pop    %ecx
  103fe5:	58                   	pop    %eax
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  103fe6:	46                   	inc    %esi
  103fe7:	83 fe 10             	cmp    $0x10,%esi
  103fea:	74 17                	je     104003 <hexdump_line_print+0x8a>
		if (i > 0 && !(i % 8)) {
  103fec:	f7 c6 07 00 00 00    	test   $0x7,%esi
  103ff2:	75 cb                	jne    103fbf <hexdump_line_print+0x46>
			print_formatted(log_output, " ");
  103ff4:	68 b7 49 12 00       	push   $0x1249b7
  103ff9:	53                   	push   %ebx
  103ffa:	e8 59 fb ff ff       	call   103b58 <print_formatted>
  103fff:	58                   	pop    %eax
  104000:	5a                   	pop    %edx
  104001:	eb bc                	jmp    103fbf <hexdump_line_print+0x46>
	print_formatted(log_output, "|");
  104003:	68 b9 49 12 00       	push   $0x1249b9
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  104008:	31 f6                	xor    %esi,%esi
	print_formatted(log_output, "|");
  10400a:	53                   	push   %ebx
  10400b:	e8 48 fb ff ff       	call   103b58 <print_formatted>
  104010:	58                   	pop    %eax
  104011:	5a                   	pop    %edx
		if (i < length) {
  104012:	39 75 f0             	cmp    %esi,-0x10(%ebp)
  104015:	76 22                	jbe    104039 <hexdump_line_print+0xc0>
			      isprint((int)c) ? c : '.');
  104017:	0f be 04 37          	movsbl (%edi,%esi,1),%eax
	return (int)((((unsigned)c) >= ' ') &&
  10401b:	8d 50 e0             	lea    -0x20(%eax),%edx
			print_formatted(log_output, "%c",
  10401e:	83 fa 5e             	cmp    $0x5e,%edx
  104021:	76 05                	jbe    104028 <hexdump_line_print+0xaf>
  104023:	b8 2e 00 00 00       	mov    $0x2e,%eax
  104028:	50                   	push   %eax
  104029:	68 cd 50 12 00       	push   $0x1250cd
  10402e:	53                   	push   %ebx
  10402f:	e8 24 fb ff ff       	call   103b58 <print_formatted>
  104034:	83 c4 0c             	add    $0xc,%esp
  104037:	eb 0d                	jmp    104046 <hexdump_line_print+0xcd>
			print_formatted(log_output, " ");
  104039:	68 b7 49 12 00       	push   $0x1249b7
  10403e:	53                   	push   %ebx
  10403f:	e8 14 fb ff ff       	call   103b58 <print_formatted>
  104044:	58                   	pop    %eax
  104045:	5a                   	pop    %edx
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  104046:	46                   	inc    %esi
  104047:	83 fe 10             	cmp    $0x10,%esi
  10404a:	74 17                	je     104063 <hexdump_line_print+0xea>
		if (i > 0 && !(i % 8)) {
  10404c:	f7 c6 07 00 00 00    	test   $0x7,%esi
  104052:	75 be                	jne    104012 <hexdump_line_print+0x99>
			print_formatted(log_output, " ");
  104054:	68 b7 49 12 00       	push   $0x1249b7
  104059:	53                   	push   %ebx
  10405a:	e8 f9 fa ff ff       	call   103b58 <print_formatted>
  10405f:	59                   	pop    %ecx
  104060:	58                   	pop    %eax
  104061:	eb af                	jmp    104012 <hexdump_line_print+0x99>
}
  104063:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104066:	5b                   	pop    %ebx
  104067:	5e                   	pop    %esi
  104068:	5f                   	pop    %edi
  104069:	5d                   	pop    %ebp
  10406a:	c3                   	ret    

0010406b <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  uint32_t flags, uint8_t level)
{
  10406b:	55                   	push   %ebp
  10406c:	89 e5                	mov    %esp,%ebp
  10406e:	56                   	push   %esi
  10406f:	53                   	push   %ebx
  104070:	89 d6                	mov    %edx,%esi
  104072:	89 c3                	mov    %eax,%ebx
	if (color) {
  104074:	83 e2 01             	and    $0x1,%edx
  104077:	74 13                	je     10408c <postfix_print+0x21>
		print_formatted(log_output, "%s", log_color);
  104079:	68 76 49 12 00       	push   $0x124976
  10407e:	68 f8 4e 12 00       	push   $0x124ef8
  104083:	50                   	push   %eax
  104084:	e8 cf fa ff ff       	call   103b58 <print_formatted>
  104089:	83 c4 0c             	add    $0xc,%esp
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  10408c:	f7 c6 10 00 00 00    	test   $0x10,%esi
  104092:	75 19                	jne    1040ad <postfix_print+0x42>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  104094:	83 e6 20             	and    $0x20,%esi
  104097:	74 07                	je     1040a0 <postfix_print+0x35>
		print_formatted(ctx, "\n");
  104099:	68 01 4e 12 00       	push   $0x124e01
  10409e:	eb 05                	jmp    1040a5 <postfix_print+0x3a>
		print_formatted(ctx, "\r\n");
  1040a0:	68 0c 4a 12 00       	push   $0x124a0c
  1040a5:	53                   	push   %ebx
  1040a6:	e8 ad fa ff ff       	call   103b58 <print_formatted>
  1040ab:	58                   	pop    %eax
  1040ac:	5a                   	pop    %edx
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
  1040ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1040b0:	5b                   	pop    %ebx
  1040b1:	5e                   	pop    %esi
  1040b2:	5d                   	pop    %ebp
  1040b3:	c3                   	ret    

001040b4 <log_output_flush>:
{
  1040b4:	55                   	push   %ebp
  1040b5:	89 e5                	mov    %esp,%ebp
  1040b7:	53                   	push   %ebx
  1040b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
		     log_output->control_block->ctx);
  1040bb:	8b 43 04             	mov    0x4(%ebx),%eax
	buffer_write(log_output->func, log_output->buf,
  1040be:	8b 53 08             	mov    0x8(%ebx),%edx
  1040c1:	ff 70 04             	pushl  0x4(%eax)
  1040c4:	8b 08                	mov    (%eax),%ecx
  1040c6:	8b 03                	mov    (%ebx),%eax
  1040c8:	e8 67 fa ff ff       	call   103b34 <buffer_write>
  1040cd:	58                   	pop    %eax
	log_output->control_block->offset = 0;
  1040ce:	8b 43 04             	mov    0x4(%ebx),%eax
}
  1040d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	log_output->control_block->offset = 0;
  1040d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  1040da:	c9                   	leave  
  1040db:	c3                   	ret    

001040dc <out_func>:
{
  1040dc:	55                   	push   %ebp
  1040dd:	89 e5                	mov    %esp,%ebp
  1040df:	53                   	push   %ebx
  1040e0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (out_ctx->control_block->offset == out_ctx->size) {
  1040e3:	8b 43 04             	mov    0x4(%ebx),%eax
  1040e6:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  1040e9:	39 08                	cmp    %ecx,(%eax)
  1040eb:	75 07                	jne    1040f4 <out_func+0x18>
		log_output_flush(out_ctx);
  1040ed:	53                   	push   %ebx
  1040ee:	e8 c1 ff ff ff       	call   1040b4 <log_output_flush>
  1040f3:	58                   	pop    %eax
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  1040f4:	8b 43 04             	mov    0x4(%ebx),%eax
  1040f7:	ba 01 00 00 00       	mov    $0x1,%edx
  1040fc:	f0 0f c1 10          	lock xadd %edx,(%eax)
	out_ctx->buf[idx] = (uint8_t)c;
  104100:	8b 43 08             	mov    0x8(%ebx),%eax
  104103:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104106:	88 0c 10             	mov    %cl,(%eax,%edx,1)
}
  104109:	31 c0                	xor    %eax,%eax
  10410b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10410e:	c9                   	leave  
  10410f:	c3                   	ret    

00104110 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    uint32_t flags)
{
  104110:	55                   	push   %ebp
  104111:	89 e5                	mov    %esp,%ebp
  104113:	57                   	push   %edi
  104114:	56                   	push   %esi
  104115:	53                   	push   %ebx
  104116:	83 ec 1c             	sub    $0x1c,%esp
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
  104119:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
{
  104120:	8b 7d 0c             	mov    0xc(%ebp),%edi
  104123:	8b 75 08             	mov    0x8(%ebp),%esi
	return msg->hdr.ids.level;
  104126:	8a 47 0a             	mov    0xa(%edi),%al
  104129:	66 8b 4f 08          	mov    0x8(%edi),%cx
			0 : prefix_print(log_output, flags, std_msg, timestamp,
  10412d:	88 c3                	mov    %al,%bl
  10412f:	80 e3 07             	and    $0x7,%bl
  104132:	88 5d dc             	mov    %bl,-0x24(%ebp)
  104135:	74 2f                	je     104166 <log_output_msg_process+0x56>
	return msg->hdr.ids.domain_id;
  104137:	c0 e8 03             	shr    $0x3,%al
	return msg->hdr.ids.source_id;
  10413a:	66 8b 57 0a          	mov    0xa(%edi),%dx
  10413e:	66 c1 ea 06          	shr    $0x6,%dx
  104142:	83 e0 07             	and    $0x7,%eax
  104145:	0f b7 d2             	movzwl %dx,%edx
  104148:	52                   	push   %edx
  104149:	8b 55 10             	mov    0x10(%ebp),%edx
  10414c:	50                   	push   %eax
  10414d:	0f b6 c3             	movzbl %bl,%eax
  104150:	50                   	push   %eax
  104151:	89 f0                	mov    %esi,%eax
  104153:	ff 77 0c             	pushl  0xc(%edi)
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
  104156:	f7 d1                	not    %ecx
  104158:	83 e1 01             	and    $0x1,%ecx
  10415b:	e8 c9 fc ff ff       	call   103e29 <prefix_print>
  104160:	83 c4 10             	add    $0x10,%esp
  104163:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104166:	8a 5f 08             	mov    0x8(%edi),%bl
  104169:	f7 d3                	not    %ebx
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
  10416b:	80 e3 01             	and    $0x1,%bl
  10416e:	74 18                	je     104188 <log_output_msg_process+0x78>
		std_print(msg, log_output);
  104170:	89 f2                	mov    %esi,%edx
  104172:	89 f8                	mov    %edi,%eax
  104174:	e8 fd f9 ff ff       	call   103b76 <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
  104179:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
  10417d:	0f 84 c4 00 00 00    	je     104247 <log_output_msg_process+0x137>
  104183:	e9 b1 00 00 00       	jmp    104239 <log_output_msg_process+0x129>
	} else if (raw_string) {
  104188:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
  10418c:	75 5b                	jne    1041e9 <log_output_msg_process+0xd9>
	size_t offset = 0;
  10418e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		length = log_output->size;
  104195:	8b 46 0c             	mov    0xc(%esi),%eax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  104198:	ff 75 dc             	pushl  -0x24(%ebp)
		length = log_output->size;
  10419b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  10419e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  1041a1:	50                   	push   %eax
  1041a2:	ff 76 08             	pushl  0x8(%esi)
  1041a5:	57                   	push   %edi
  1041a6:	e8 6a f9 ff ff       	call   103b15 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
  1041ab:	8b 56 04             	mov    0x4(%esi),%edx
  1041ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
  1041b1:	83 c4 10             	add    $0x10,%esp
		if (length != 0) {
  1041b4:	85 c0                	test   %eax,%eax
		log_output->control_block->offset = length;
  1041b6:	89 02                	mov    %eax,(%edx)
		if (length != 0) {
  1041b8:	74 0b                	je     1041c5 <log_output_msg_process+0xb5>
			eol = (log_output->buf[length - 1] == '\n');
  1041ba:	8b 56 08             	mov    0x8(%esi),%edx
  1041bd:	80 7c 02 ff 0a       	cmpb   $0xa,-0x1(%edx,%eax,1)
  1041c2:	0f 94 c3             	sete   %bl
		log_output_flush(log_output);
  1041c5:	56                   	push   %esi
  1041c6:	e8 e9 fe ff ff       	call   1040b4 <log_output_flush>
  1041cb:	58                   	pop    %eax
		offset += length;
  1041cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1041cf:	01 45 dc             	add    %eax,-0x24(%ebp)
	} while (length > 0);
  1041d2:	85 c0                	test   %eax,%eax
  1041d4:	75 bf                	jne    104195 <log_output_msg_process+0x85>
	if (eol) {
  1041d6:	84 db                	test   %bl,%bl
  1041d8:	74 6d                	je     104247 <log_output_msg_process+0x137>
		print_formatted(log_output, "\r");
  1041da:	68 bb 49 12 00       	push   $0x1249bb
  1041df:	56                   	push   %esi
  1041e0:	e8 73 f9 ff ff       	call   103b58 <print_formatted>
  1041e5:	5b                   	pop    %ebx
  1041e6:	5f                   	pop    %edi
	if (!raw_string) {
  1041e7:	eb 5e                	jmp    104247 <log_output_msg_process+0x137>
	print_formatted(log_output, "%s", log_msg_str_get(msg));
  1041e9:	57                   	push   %edi
  1041ea:	e8 0f f8 ff ff       	call   1039fe <log_msg_str_get>
  1041ef:	89 04 24             	mov    %eax,(%esp)
  1041f2:	68 f8 4e 12 00       	push   $0x124ef8
  1041f7:	56                   	push   %esi
	uint32_t offset = 0U;
  1041f8:	31 db                	xor    %ebx,%ebx
	print_formatted(log_output, "%s", log_msg_str_get(msg));
  1041fa:	e8 59 f9 ff ff       	call   103b58 <print_formatted>
  1041ff:	83 c4 0c             	add    $0xc,%esp
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  104202:	53                   	push   %ebx
  104203:	8d 45 e0             	lea    -0x20(%ebp),%eax
  104206:	50                   	push   %eax
  104207:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  10420a:	52                   	push   %edx
		length = sizeof(buf);
  10420b:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  104212:	57                   	push   %edi
  104213:	e8 fd f8 ff ff       	call   103b15 <log_msg_hexdump_data_get>
		if (length) {
  104218:	8b 4d e0             	mov    -0x20(%ebp),%ecx
		log_msg_hexdump_data_get(msg, buf, &length, offset);
  10421b:	83 c4 10             	add    $0x10,%esp
		if (length) {
  10421e:	85 c9                	test   %ecx,%ecx
  104220:	74 17                	je     104239 <log_output_msg_process+0x129>
			hexdump_line_print(log_output, buf, length,
  104222:	ff 75 10             	pushl  0x10(%ebp)
  104225:	ff 75 d8             	pushl  -0x28(%ebp)
  104228:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  10422b:	89 f0                	mov    %esi,%eax
  10422d:	e8 47 fd ff ff       	call   103f79 <hexdump_line_print>
  104232:	5a                   	pop    %edx
			offset += length;
  104233:	03 5d e0             	add    -0x20(%ebp),%ebx
			hexdump_line_print(log_output, buf, length,
  104236:	59                   	pop    %ecx
		length = sizeof(buf);
  104237:	eb c9                	jmp    104202 <log_output_msg_process+0xf2>
		postfix_print(log_output, flags, level);
  104239:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
  10423d:	8b 55 10             	mov    0x10(%ebp),%edx
  104240:	89 f0                	mov    %esi,%eax
  104242:	e8 24 fe ff ff       	call   10406b <postfix_print>
	}

	log_output_flush(log_output);
  104247:	56                   	push   %esi
  104248:	e8 67 fe ff ff       	call   1040b4 <log_output_flush>
  10424d:	58                   	pop    %eax
}
  10424e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104251:	5b                   	pop    %ebx
  104252:	5e                   	pop    %esi
  104253:	5f                   	pop    %edi
  104254:	5d                   	pop    %ebp
  104255:	c3                   	ret    

00104256 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, uint32_t cnt)
{
  104256:	55                   	push   %ebp
  104257:	89 e5                	mov    %esp,%ebp
  104259:	57                   	push   %edi
  10425a:	56                   	push   %esi
  10425b:	53                   	push   %ebx
  10425c:	83 ec 0c             	sub    $0xc,%esp
  10425f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
  104262:	8b 03                	mov    (%ebx),%eax
  104264:	89 45 e8             	mov    %eax,-0x18(%ebp)

	cnt = MIN(cnt, 9999);
  104267:	8b 45 0c             	mov    0xc(%ebp),%eax
  10426a:	3d 0f 27 00 00       	cmp    $0x270f,%eax
  10426f:	76 05                	jbe    104276 <log_output_dropped_process+0x20>
  104271:	b8 0f 27 00 00       	mov    $0x270f,%eax
	len = snprintk(buf, sizeof(buf), "%d", cnt);
  104276:	50                   	push   %eax
  104277:	8d 7d ef             	lea    -0x11(%ebp),%edi
  10427a:	68 62 61 12 00       	push   $0x126162
  10427f:	6a 05                	push   $0x5
  104281:	57                   	push   %edi
  104282:	e8 78 d0 ff ff       	call   1012ff <snprintk>
  104287:	89 c6                	mov    %eax,%esi

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
  104289:	8b 43 04             	mov    0x4(%ebx),%eax
	len = snprintk(buf, sizeof(buf), "%d", cnt);
  10428c:	83 c4 10             	add    $0x10,%esp
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
  10428f:	b9 04 00 00 00       	mov    $0x4,%ecx
  104294:	ff 70 04             	pushl  0x4(%eax)
  104297:	ba b0 3f 12 00       	mov    $0x123fb0,%edx
  10429c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10429f:	e8 90 f8 ff ff       	call   103b34 <buffer_write>
  1042a4:	58                   	pop    %eax
		     log_output->control_block->ctx);
	buffer_write(outf, buf, len, log_output->control_block->ctx);
  1042a5:	8b 43 04             	mov    0x4(%ebx),%eax
  1042a8:	89 f1                	mov    %esi,%ecx
  1042aa:	89 fa                	mov    %edi,%edx
  1042ac:	ff 70 04             	pushl  0x4(%eax)
  1042af:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1042b2:	e8 7d f8 ff ff       	call   103b34 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
  1042b7:	8b 43 04             	mov    0x4(%ebx),%eax
	buffer_write(outf, buf, len, log_output->control_block->ctx);
  1042ba:	5a                   	pop    %edx
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
  1042bb:	b9 17 00 00 00       	mov    $0x17,%ecx
  1042c0:	ff 70 04             	pushl  0x4(%eax)
  1042c3:	ba 98 3f 12 00       	mov    $0x123f98,%edx
  1042c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1042cb:	e8 64 f8 ff ff       	call   103b34 <buffer_write>
  1042d0:	59                   	pop    %ecx
		     log_output->control_block->ctx);
}
  1042d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1042d4:	5b                   	pop    %ebx
  1042d5:	5e                   	pop    %esi
  1042d6:	5f                   	pop    %edi
  1042d7:	5d                   	pop    %ebp
  1042d8:	c3                   	ret    

001042d9 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
  1042d9:	55                   	push   %ebp
	timestamp_div = 1U;
  1042da:	c7 05 ec ea 12 00 01 	movl   $0x1,0x12eaec
  1042e1:	00 00 00 
{
  1042e4:	89 e5                	mov    %esp,%ebp
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  1042e6:	31 c9                	xor    %ecx,%ecx
  1042e8:	ba 01 00 00 00       	mov    $0x1,%edx
{
  1042ed:	8b 45 08             	mov    0x8(%ebp),%eax
	while (frequency > 1000000) {
  1042f0:	3d 40 42 0f 00       	cmp    $0xf4240,%eax
  1042f5:	76 08                	jbe    1042ff <log_output_timestamp_freq_set+0x26>
		frequency /= 2U;
  1042f7:	d1 e8                	shr    %eax
		timestamp_div *= 2U;
  1042f9:	01 d2                	add    %edx,%edx
  1042fb:	b1 01                	mov    $0x1,%cl
  1042fd:	eb f1                	jmp    1042f0 <log_output_timestamp_freq_set+0x17>
  1042ff:	84 c9                	test   %cl,%cl
  104301:	74 06                	je     104309 <log_output_timestamp_freq_set+0x30>
  104303:	89 15 ec ea 12 00    	mov    %edx,0x12eaec
	}

	freq = frequency;
  104309:	a3 f0 ea 12 00       	mov    %eax,0x12eaf0
}
  10430e:	5d                   	pop    %ebp
  10430f:	c3                   	ret    

00104310 <severity_lvl_get>:
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
}


static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
  104310:	55                   	push   %ebp
  104311:	31 d2                	xor    %edx,%edx
  104313:	89 e5                	mov    %esp,%ebp
  104315:	8b 45 0c             	mov    0xc(%ebp),%eax
  104318:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
  10431b:	83 f9 04             	cmp    $0x4,%ecx
	entry->handler = NULL;
  10431e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	entry->help  = NULL;
  104325:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	entry->subcmd = &dsub_module_name;
  10432c:	c7 40 08 14 40 12 00 	movl   $0x124014,0x8(%eax)
					severity_lvls_sorted[idx] : NULL;
  104333:	77 07                	ja     10433c <severity_lvl_get+0x2c>
  104335:	8b 14 8d 1c 40 12 00 	mov    0x12401c(,%ecx,4),%edx
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
  10433c:	89 10                	mov    %edx,(%eax)
}
  10433e:	5d                   	pop    %ebp
  10433f:	c3                   	ret    

00104340 <log_halt>:

static int log_halt(const struct shell *shell,
		    const struct log_backend *backend,
		    size_t argc,
		    char **argv)
{
  104340:	55                   	push   %ebp
  104341:	89 e5                	mov    %esp,%ebp
	backend->cb->active = false;
  104343:	8b 45 0c             	mov    0xc(%ebp),%eax
  104346:	8b 40 04             	mov    0x4(%eax),%eax
  104349:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	log_backend_deactivate(backend);
	return 0;
}
  10434d:	31 c0                	xor    %eax,%eax
  10434f:	5d                   	pop    %ebp
  104350:	c3                   	ret    

00104351 <log_go>:

static int log_go(const struct shell *shell,
		  const struct log_backend *backend,
		  size_t argc,
		  char **argv)
{
  104351:	55                   	push   %ebp
  104352:	89 e5                	mov    %esp,%ebp
	backend->cb->active = true;
  104354:	8b 45 0c             	mov    0xc(%ebp),%eax
  104357:	8b 40 04             	mov    0x4(%eax),%eax
  10435a:	c6 40 05 01          	movb   $0x1,0x5(%eax)
	log_backend_activate(backend, backend->cb->ctx);
	return 0;
}
  10435e:	31 c0                	xor    %eax,%eax
  104360:	5d                   	pop    %ebp
  104361:	c3                   	ret    

00104362 <backend_name_get>:
	SHELL_CMD(status, NULL, "Logger status", cmd_log_backend_status),
	SHELL_SUBCMD_SET_END
);

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
  104362:	55                   	push   %ebp
	return __log_backends_end - __log_backends_start;
  104363:	ba f0 31 12 00       	mov    $0x1231f0,%edx
  104368:	89 e5                	mov    %esp,%ebp
  10436a:	81 ea e0 31 12 00    	sub    $0x1231e0,%edx
  104370:	c1 fa 04             	sar    $0x4,%edx
  104373:	8b 45 0c             	mov    0xc(%ebp),%eax
  104376:	8b 4d 08             	mov    0x8(%ebp),%ecx
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
	entry->syntax  = NULL;

	if (idx < log_backend_count_get()) {
  104379:	39 ca                	cmp    %ecx,%edx
	entry->handler = NULL;
  10437b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	entry->help  = NULL;
  104382:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	entry->subcmd = &sub_log_backend;
  104389:	c7 40 08 04 40 12 00 	movl   $0x124004,0x8(%eax)
	entry->syntax  = NULL;
  104390:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (idx < log_backend_count_get()) {
  104396:	76 0b                	jbe    1043a3 <backend_name_get+0x41>
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
  104398:	c1 e1 04             	shl    $0x4,%ecx
  10439b:	8b 91 e8 31 12 00    	mov    0x1231e8(%ecx),%edx
  1043a1:	89 10                	mov    %edx,(%eax)
	}
}
  1043a3:	5d                   	pop    %ebp
  1043a4:	c3                   	ret    

001043a5 <cmd_log_backends_list>:
{
  1043a5:	55                   	push   %ebp
  1043a6:	89 e5                	mov    %esp,%ebp
  1043a8:	57                   	push   %edi
  1043a9:	56                   	push   %esi
	for (int i = 0; i < backend_count; i++) {
  1043aa:	31 ff                	xor    %edi,%edi
{
  1043ac:	53                   	push   %ebx
  1043ad:	bb f0 31 12 00       	mov    $0x1231f0,%ebx
  1043b2:	81 eb e0 31 12 00    	sub    $0x1231e0,%ebx
  1043b8:	be e0 31 12 00       	mov    $0x1231e0,%esi
  1043bd:	c1 fb 04             	sar    $0x4,%ebx
	for (int i = 0; i < backend_count; i++) {
  1043c0:	39 df                	cmp    %ebx,%edi
  1043c2:	7d 34                	jge    1043f8 <cmd_log_backends_list+0x53>
			      backend->cb->id);
  1043c4:	8b 56 04             	mov    0x4(%esi),%edx
		shell_fprintf(shell, SHELL_NORMAL,
  1043c7:	b8 dd 49 12 00       	mov    $0x1249dd,%eax
  1043cc:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  1043d0:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
  1043d4:	75 05                	jne    1043db <cmd_log_backends_list+0x36>
  1043d6:	b8 e5 49 12 00       	mov    $0x1249e5,%eax
  1043db:	51                   	push   %ecx
	for (int i = 0; i < backend_count; i++) {
  1043dc:	47                   	inc    %edi
		shell_fprintf(shell, SHELL_NORMAL,
  1043dd:	50                   	push   %eax
  1043de:	83 c6 10             	add    $0x10,%esi
  1043e1:	ff 76 f8             	pushl  -0x8(%esi)
  1043e4:	68 ee 49 12 00       	push   $0x1249ee
  1043e9:	6a 00                	push   $0x0
  1043eb:	ff 75 08             	pushl  0x8(%ebp)
  1043ee:	e8 2c 1c 00 00       	call   10601f <shell_fprintf>
  1043f3:	83 c4 18             	add    $0x18,%esp
	for (int i = 0; i < backend_count; i++) {
  1043f6:	eb c8                	jmp    1043c0 <cmd_log_backends_list+0x1b>
}
  1043f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1043fb:	31 c0                	xor    %eax,%eax
  1043fd:	5b                   	pop    %ebx
  1043fe:	5e                   	pop    %esi
  1043ff:	5f                   	pop    %edi
  104400:	5d                   	pop    %ebp
  104401:	c3                   	ret    

00104402 <log_status>:
{
  104402:	55                   	push   %ebp
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
  104403:	b8 e0 31 12 00       	mov    $0x1231e0,%eax
  104408:	89 e5                	mov    %esp,%ebp
  10440a:	57                   	push   %edi
  10440b:	56                   	push   %esi
  10440c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  104411:	c1 e8 03             	shr    $0x3,%eax
  104414:	53                   	push   %ebx
  104415:	83 ec 0c             	sub    $0xc,%esp
  104418:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10441b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10441e:	8b 75 08             	mov    0x8(%ebp),%esi
	return backend->cb->active;
  104421:	8b 47 04             	mov    0x4(%edi),%eax
	if (!log_backend_is_active(backend)) {
  104424:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
  104428:	75 10                	jne    10443a <log_status+0x38>
		shell_warn(shell, "Logs are halted!");
  10442a:	68 0f 4a 12 00       	push   $0x124a0f
  10442f:	6a 04                	push   $0x4
  104431:	56                   	push   %esi
  104432:	e8 e8 1b 00 00       	call   10601f <shell_fprintf>
  104437:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
  10443a:	68 21 4a 12 00       	push   $0x124a21
	for (i = 0U; i < modules_cnt; i++) {
  10443f:	31 db                	xor    %ebx,%ebx
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
  104441:	68 2d 4a 12 00       	push   $0x124a2d
  104446:	6a 00                	push   $0x0
  104448:	56                   	push   %esi
  104449:	e8 d1 1b 00 00       	call   10601f <shell_fprintf>
  10444e:	83 c4 10             	add    $0x10,%esp
	shell_fprintf(shell, SHELL_NORMAL,
  104451:	68 4b 4a 12 00       	push   $0x124a4b
  104456:	6a 00                	push   $0x0
  104458:	56                   	push   %esi
  104459:	e8 c1 1b 00 00       	call   10601f <shell_fprintf>
  10445e:	83 c4 0c             	add    $0xc,%esp
	for (i = 0U; i < modules_cnt; i++) {
  104461:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  104464:	74 5c                	je     1044c2 <log_status+0xc0>
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
  104466:	6a 01                	push   $0x1
  104468:	53                   	push   %ebx
  104469:	6a 00                	push   $0x0
  10446b:	57                   	push   %edi
  10446c:	e8 b5 ed ff ff       	call   103226 <log_filter_get>
  104471:	83 c4 10             	add    $0x10,%esp
  104474:	89 45 ec             	mov    %eax,-0x14(%ebp)
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
  104477:	6a 00                	push   $0x0
  104479:	53                   	push   %ebx
  10447a:	6a 00                	push   $0x0
  10447c:	57                   	push   %edi
  10447d:	e8 a4 ed ff ff       	call   103226 <log_filter_get>
  104482:	83 c4 10             	add    $0x10,%esp
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
  104485:	8b 55 ec             	mov    -0x14(%ebp),%edx
  104488:	8b 0c 85 30 40 12 00 	mov    0x124030(,%eax,4),%ecx
  10448f:	53                   	push   %ebx
  104490:	8b 14 95 30 40 12 00 	mov    0x124030(,%edx,4),%edx
  104497:	6a 00                	push   $0x0
  104499:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10449c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10449f:	e8 ab eb ff ff       	call   10304f <log_source_name_get>
  1044a4:	5a                   	pop    %edx
  1044a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1044a8:	59                   	pop    %ecx
  1044a9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1044ac:	51                   	push   %ecx
	for (i = 0U; i < modules_cnt; i++) {
  1044ad:	43                   	inc    %ebx
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
  1044ae:	52                   	push   %edx
  1044af:	50                   	push   %eax
  1044b0:	68 88 4a 12 00       	push   $0x124a88
  1044b5:	6a 00                	push   $0x0
  1044b7:	56                   	push   %esi
  1044b8:	e8 62 1b 00 00       	call   10601f <shell_fprintf>
  1044bd:	83 c4 18             	add    $0x18,%esp
	for (i = 0U; i < modules_cnt; i++) {
  1044c0:	eb 9f                	jmp    104461 <log_status+0x5f>
}
  1044c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1044c5:	31 c0                	xor    %eax,%eax
  1044c7:	5b                   	pop    %ebx
  1044c8:	5e                   	pop    %esi
  1044c9:	5f                   	pop    %edi
  1044ca:	5d                   	pop    %ebp
  1044cb:	c3                   	ret    

001044cc <module_name_get>:
{
  1044cc:	55                   	push   %ebp
  1044cd:	89 e5                	mov    %esp,%ebp
  1044cf:	53                   	push   %ebx
  1044d0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	entry->handler = NULL;
  1044d3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	entry->help  = NULL;
  1044da:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	entry->subcmd = &dsub_module_name;
  1044e1:	c7 43 08 14 40 12 00 	movl   $0x124014,0x8(%ebx)
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
  1044e8:	ff 75 08             	pushl  0x8(%ebp)
  1044eb:	6a 00                	push   $0x0
  1044ed:	e8 5d eb ff ff       	call   10304f <log_source_name_get>
  1044f2:	5a                   	pop    %edx
  1044f3:	59                   	pop    %ecx
  1044f4:	89 03                	mov    %eax,(%ebx)
}
  1044f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1044f9:	c9                   	leave  
  1044fa:	c3                   	ret    

001044fb <shell_backend_cmd_execute>:
{
  1044fb:	55                   	push   %ebp
  1044fc:	89 e5                	mov    %esp,%ebp
  1044fe:	57                   	push   %edi
  1044ff:	56                   	push   %esi
  104500:	89 cf                	mov    %ecx,%edi
  104502:	53                   	push   %ebx
  104503:	83 ec 18             	sub    $0x18,%esp
  104506:	89 55 e8             	mov    %edx,-0x18(%ebp)
	char const *name = argv[-1];
  104509:	8b 71 fc             	mov    -0x4(%ecx),%esi
{
  10450c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	size_t slen = strlen(name);
  10450f:	56                   	push   %esi
  104510:	e8 07 78 00 00       	call   10bd1c <strlen>
  104515:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return __log_backends_end - __log_backends_start;
  104518:	b8 f0 31 12 00       	mov    $0x1231f0,%eax
  10451d:	2d e0 31 12 00       	sub    $0x1231e0,%eax
  104522:	5a                   	pop    %edx
  104523:	c1 f8 04             	sar    $0x4,%eax
	for (int i = 0; i < log_backend_count_get(); i++) {
  104526:	31 d2                	xor    %edx,%edx
  104528:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10452b:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
  10452e:	7d 42                	jge    104572 <shell_backend_cmd_execute+0x77>
		if (strncmp(name, backend->name, slen) == 0) {
  104530:	ff 75 ec             	pushl  -0x14(%ebp)
  104533:	89 d1                	mov    %edx,%ecx
  104535:	89 55 dc             	mov    %edx,-0x24(%ebp)
  104538:	c1 e1 04             	shl    $0x4,%ecx
  10453b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10453e:	ff b1 e8 31 12 00    	pushl  0x1231e8(%ecx)
  104544:	56                   	push   %esi
  104545:	e8 05 78 00 00       	call   10bd4f <strncmp>
  10454a:	83 c4 0c             	add    $0xc,%esp
  10454d:	89 c3                	mov    %eax,%ebx
  10454f:	85 c0                	test   %eax,%eax
  104551:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  104554:	74 06                	je     10455c <shell_backend_cmd_execute+0x61>
	for (int i = 0; i < log_backend_count_get(); i++) {
  104556:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104559:	42                   	inc    %edx
  10455a:	eb cf                	jmp    10452b <shell_backend_cmd_execute+0x30>
		func(shell, backend, argc, argv);
  10455c:	57                   	push   %edi
	return &__log_backends_start[idx];
  10455d:	8d b1 e0 31 12 00    	lea    0x1231e0(%ecx),%esi
  104563:	ff 75 e8             	pushl  -0x18(%ebp)
  104566:	56                   	push   %esi
  104567:	ff 75 f0             	pushl  -0x10(%ebp)
  10456a:	ff 55 08             	call   *0x8(%ebp)
  10456d:	83 c4 10             	add    $0x10,%esp
	return 0;
  104570:	eb 18                	jmp    10458a <shell_backend_cmd_execute+0x8f>
		shell_error(shell, "Invalid backend: %s", name);
  104572:	56                   	push   %esi
		return -ENOEXEC;
  104573:	bb f8 ff ff ff       	mov    $0xfffffff8,%ebx
		shell_error(shell, "Invalid backend: %s", name);
  104578:	68 9c 4a 12 00       	push   $0x124a9c
  10457d:	6a 02                	push   $0x2
  10457f:	ff 75 f0             	pushl  -0x10(%ebp)
  104582:	e8 98 1a 00 00       	call   10601f <shell_fprintf>
  104587:	83 c4 10             	add    $0x10,%esp
}
  10458a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10458d:	89 d8                	mov    %ebx,%eax
  10458f:	5b                   	pop    %ebx
  104590:	5e                   	pop    %esi
  104591:	5f                   	pop    %edi
  104592:	5d                   	pop    %ebp
  104593:	c3                   	ret    

00104594 <cmd_log_backend_status>:
{
  104594:	55                   	push   %ebp
  104595:	89 e5                	mov    %esp,%ebp
	shell_backend_cmd_execute(shell, argc, argv, log_status);
  104597:	68 02 44 10 00       	push   $0x104402
  10459c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10459f:	8b 55 0c             	mov    0xc(%ebp),%edx
  1045a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1045a5:	e8 51 ff ff ff       	call   1044fb <shell_backend_cmd_execute>
  1045aa:	58                   	pop    %eax
}
  1045ab:	31 c0                	xor    %eax,%eax
  1045ad:	c9                   	leave  
  1045ae:	c3                   	ret    

001045af <cmd_log_backend_halt>:
{
  1045af:	55                   	push   %ebp
  1045b0:	89 e5                	mov    %esp,%ebp
  1045b2:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
  1045b5:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1045b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1045bb:	c7 45 08 40 43 10 00 	movl   $0x104340,0x8(%ebp)
}
  1045c2:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
  1045c3:	e9 33 ff ff ff       	jmp    1044fb <shell_backend_cmd_execute>

001045c8 <cmd_log_backend_go>:
{
  1045c8:	55                   	push   %ebp
  1045c9:	89 e5                	mov    %esp,%ebp
  1045cb:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
  1045ce:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1045d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  1045d4:	c7 45 08 51 43 10 00 	movl   $0x104351,0x8(%ebp)
}
  1045db:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
  1045dc:	e9 1a ff ff ff       	jmp    1044fb <shell_backend_cmd_execute>

001045e1 <cmd_log_backend_enable>:
{
  1045e1:	55                   	push   %ebp
  1045e2:	89 e5                	mov    %esp,%ebp
  1045e4:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
  1045e7:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1045ea:	8b 55 0c             	mov    0xc(%ebp),%edx
  1045ed:	c7 45 08 a3 47 10 00 	movl   $0x1047a3,0x8(%ebp)
}
  1045f4:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
  1045f5:	e9 01 ff ff ff       	jmp    1044fb <shell_backend_cmd_execute>

001045fa <cmd_log_backend_disable>:
{
  1045fa:	55                   	push   %ebp
  1045fb:	89 e5                	mov    %esp,%ebp
  1045fd:	8b 45 08             	mov    0x8(%ebp),%eax
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
  104600:	8b 4d 10             	mov    0x10(%ebp),%ecx
  104603:	8b 55 0c             	mov    0xc(%ebp),%edx
  104606:	c7 45 08 42 48 10 00 	movl   $0x104842,0x8(%ebp)
}
  10460d:	5d                   	pop    %ebp
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
  10460e:	e9 e8 fe ff ff       	jmp    1044fb <shell_backend_cmd_execute>

00104613 <shell_state_precheck>:
	if (shell->log_backend->control_block->state
  104613:	8b 50 1c             	mov    0x1c(%eax),%edx
  104616:	8b 52 0c             	mov    0xc(%edx),%edx
  104619:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  10461d:	75 17                	jne    104636 <shell_state_precheck+0x23>
{
  10461f:	55                   	push   %ebp
  104620:	89 e5                	mov    %esp,%ebp
		shell_error(shell, "Shell log backend not initialized.");
  104622:	68 b1 4a 12 00       	push   $0x124ab1
  104627:	6a 02                	push   $0x2
  104629:	50                   	push   %eax
  10462a:	e8 f0 19 00 00       	call   10601f <shell_fprintf>
  10462f:	83 c4 0c             	add    $0xc,%esp
  104632:	31 c0                	xor    %eax,%eax
}
  104634:	c9                   	leave  
  104635:	c3                   	ret    
	return true;
  104636:	b0 01                	mov    $0x1,%al
}
  104638:	c3                   	ret    

00104639 <cmd_log_self_halt>:
{
  104639:	55                   	push   %ebp
  10463a:	89 e5                	mov    %esp,%ebp
  10463c:	53                   	push   %ebx
  10463d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  104640:	89 d8                	mov    %ebx,%eax
  104642:	e8 cc ff ff ff       	call   104613 <shell_state_precheck>
  104647:	84 c0                	test   %al,%al
  104649:	74 0c                	je     104657 <cmd_log_self_halt+0x1e>
	return log_halt(shell, shell->log_backend->backend, argc, argv);
  10464b:	8b 43 1c             	mov    0x1c(%ebx),%eax
	log_backend_deactivate(backend);
  10464e:	8b 00                	mov    (%eax),%eax
	backend->cb->active = false;
  104650:	8b 40 04             	mov    0x4(%eax),%eax
  104653:	c6 40 05 00          	movb   $0x0,0x5(%eax)
}
  104657:	5b                   	pop    %ebx
  104658:	31 c0                	xor    %eax,%eax
  10465a:	5d                   	pop    %ebp
  10465b:	c3                   	ret    

0010465c <cmd_log_self_go>:
{
  10465c:	55                   	push   %ebp
  10465d:	89 e5                	mov    %esp,%ebp
  10465f:	53                   	push   %ebx
  104660:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  104663:	89 d8                	mov    %ebx,%eax
  104665:	e8 a9 ff ff ff       	call   104613 <shell_state_precheck>
  10466a:	84 c0                	test   %al,%al
  10466c:	74 0c                	je     10467a <cmd_log_self_go+0x1e>
	return log_go(shell, shell->log_backend->backend, argc, argv);
  10466e:	8b 43 1c             	mov    0x1c(%ebx),%eax
	log_backend_activate(backend, backend->cb->ctx);
  104671:	8b 00                	mov    (%eax),%eax
	backend->cb->active = true;
  104673:	8b 40 04             	mov    0x4(%eax),%eax
  104676:	c6 40 05 01          	movb   $0x1,0x5(%eax)
}
  10467a:	5b                   	pop    %ebx
  10467b:	31 c0                	xor    %eax,%eax
  10467d:	5d                   	pop    %ebp
  10467e:	c3                   	ret    

0010467f <cmd_log_self_status>:
{
  10467f:	55                   	push   %ebp
  104680:	89 e5                	mov    %esp,%ebp
  104682:	53                   	push   %ebx
  104683:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  104686:	89 d8                	mov    %ebx,%eax
  104688:	e8 86 ff ff ff       	call   104613 <shell_state_precheck>
  10468d:	84 c0                	test   %al,%al
  10468f:	74 14                	je     1046a5 <cmd_log_self_status+0x26>
	log_status(shell, shell->log_backend->backend, argc, argv);
  104691:	ff 75 10             	pushl  0x10(%ebp)
  104694:	ff 75 0c             	pushl  0xc(%ebp)
  104697:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10469a:	ff 30                	pushl  (%eax)
  10469c:	53                   	push   %ebx
  10469d:	e8 60 fd ff ff       	call   104402 <log_status>
  1046a2:	83 c4 10             	add    $0x10,%esp
}
  1046a5:	31 c0                	xor    %eax,%eax
  1046a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1046aa:	c9                   	leave  
  1046ab:	c3                   	ret    

001046ac <filters_set>:
{
  1046ac:	55                   	push   %ebp
  1046ad:	89 e5                	mov    %esp,%ebp
  1046af:	57                   	push   %edi
  1046b0:	56                   	push   %esi
  1046b1:	89 ce                	mov    %ecx,%esi
  1046b3:	53                   	push   %ebx
  1046b4:	83 ec 14             	sub    $0x14,%esp
  1046b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1046ba:	b8 e0 31 12 00       	mov    $0x1231e0,%eax
  1046bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1046c2:	2d b0 30 12 00       	sub    $0x1230b0,%eax
	int cnt = all ? log_sources_count() : argc;
  1046c7:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1046ca:	c1 e8 03             	shr    $0x3,%eax
  1046cd:	85 c9                	test   %ecx,%ecx
  1046cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1046d2:	75 03                	jne    1046d7 <filters_set+0x2b>
  1046d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (!backend->cb->active) {
  1046d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1046da:	8b 40 04             	mov    0x4(%eax),%eax
  1046dd:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
  1046e1:	75 12                	jne    1046f5 <filters_set+0x49>
		shell_warn(shell, "Backend not active.");
  1046e3:	68 d5 4a 12 00       	push   $0x124ad5
  1046e8:	6a 04                	push   $0x4
  1046ea:	ff 75 f0             	pushl  -0x10(%ebp)
  1046ed:	e8 2d 19 00 00       	call   10601f <shell_fprintf>
  1046f2:	83 c4 0c             	add    $0xc,%esp
	for (i = 0U; i < modules_cnt; i++) {
  1046f5:	31 db                	xor    %ebx,%ebx
	for (i = 0; i < cnt; i++) {
  1046f7:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
  1046fa:	0f 8d 9b 00 00 00    	jge    10479b <filters_set+0xef>
		id = all ? i : module_id_get(argv[i]);
  104700:	89 da                	mov    %ebx,%edx
  104702:	85 f6                	test   %esi,%esi
  104704:	74 4b                	je     104751 <filters_set+0xa5>
  104706:	8b 45 08             	mov    0x8(%ebp),%eax
	for (i = 0U; i < modules_cnt; i++) {
  104709:	31 d2                	xor    %edx,%edx
		id = all ? i : module_id_get(argv[i]);
  10470b:	8b 3c 98             	mov    (%eax,%ebx,4),%edi
	for (i = 0U; i < modules_cnt; i++) {
  10470e:	39 55 ec             	cmp    %edx,-0x14(%ebp)
  104711:	74 23                	je     104736 <filters_set+0x8a>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
  104713:	52                   	push   %edx
  104714:	89 55 e0             	mov    %edx,-0x20(%ebp)
  104717:	6a 00                	push   $0x0
  104719:	e8 31 e9 ff ff       	call   10304f <log_source_name_get>
  10471e:	5a                   	pop    %edx
  10471f:	59                   	pop    %ecx
		if (strncmp(tmp_name, name, 64) == 0) {
  104720:	6a 40                	push   $0x40
  104722:	57                   	push   %edi
  104723:	50                   	push   %eax
  104724:	e8 26 76 00 00       	call   10bd4f <strncmp>
  104729:	83 c4 0c             	add    $0xc,%esp
  10472c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10472f:	85 c0                	test   %eax,%eax
  104731:	74 1e                	je     104751 <filters_set+0xa5>
	for (i = 0U; i < modules_cnt; i++) {
  104733:	42                   	inc    %edx
  104734:	eb d8                	jmp    10470e <filters_set+0x62>
			shell_error(shell, "%s: unknown source name.", argv[i]);
  104736:	8b 45 08             	mov    0x8(%ebp),%eax
  104739:	ff 34 98             	pushl  (%eax,%ebx,4)
  10473c:	68 00 4b 12 00       	push   $0x124b00
  104741:	6a 02                	push   $0x2
  104743:	ff 75 f0             	pushl  -0x10(%ebp)
  104746:	e8 d4 18 00 00       	call   10601f <shell_fprintf>
  10474b:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < cnt; i++) {
  10474e:	43                   	inc    %ebx
  10474f:	eb a6                	jmp    1046f7 <filters_set+0x4b>
	return z_impl_log_filter_set(backend, domain_id, src_id, level);
  104751:	ff 75 0c             	pushl  0xc(%ebp)
  104754:	52                   	push   %edx
  104755:	6a 00                	push   $0x0
  104757:	ff 75 e4             	pushl  -0x1c(%ebp)
  10475a:	e8 14 e9 ff ff       	call   103073 <z_impl_log_filter_set>
  10475f:	83 c4 10             	add    $0x10,%esp
  104762:	89 c7                	mov    %eax,%edi
			if (set_lvl != level) {
  104764:	39 45 0c             	cmp    %eax,0xc(%ebp)
  104767:	74 e5                	je     10474e <filters_set+0xa2>
						CONFIG_LOG_DOMAIN_ID, i) :
  104769:	85 f6                	test   %esi,%esi
  10476b:	75 0c                	jne    104779 <filters_set+0xcd>
					log_source_name_get(
  10476d:	53                   	push   %ebx
  10476e:	6a 00                	push   $0x0
  104770:	e8 da e8 ff ff       	call   10304f <log_source_name_get>
  104775:	5a                   	pop    %edx
  104776:	59                   	pop    %ecx
  104777:	eb 06                	jmp    10477f <filters_set+0xd3>
						CONFIG_LOG_DOMAIN_ID, i) :
  104779:	8b 45 08             	mov    0x8(%ebp),%eax
  10477c:	8b 04 98             	mov    (%eax,%ebx,4),%eax
				shell_warn(shell, "%s: level set to %s.",
  10477f:	ff 34 bd 30 40 12 00 	pushl  0x124030(,%edi,4)
  104786:	50                   	push   %eax
  104787:	68 ea 4a 12 00       	push   $0x124aea
  10478c:	6a 04                	push   $0x4
  10478e:	ff 75 f0             	pushl  -0x10(%ebp)
  104791:	e8 89 18 00 00       	call   10601f <shell_fprintf>
  104796:	83 c4 14             	add    $0x14,%esp
  104799:	eb b3                	jmp    10474e <filters_set+0xa2>
}
  10479b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10479e:	5b                   	pop    %ebx
  10479f:	5e                   	pop    %esi
  1047a0:	5f                   	pop    %edi
  1047a1:	5d                   	pop    %ebp
  1047a2:	c3                   	ret    

001047a3 <log_enable>:
{
  1047a3:	55                   	push   %ebp
  1047a4:	89 e5                	mov    %esp,%ebp
  1047a6:	57                   	push   %edi
  1047a7:	56                   	push   %esi
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
  1047a8:	31 ff                	xor    %edi,%edi
	severity_level = severity_level_get(argv[1]);
  1047aa:	8b 45 14             	mov    0x14(%ebp),%eax
{
  1047ad:	53                   	push   %ebx
	severity_level = severity_level_get(argv[1]);
  1047ae:	8b 70 04             	mov    0x4(%eax),%esi
		if (strncmp(str, severity_lvls[i], 4) == 0) {
  1047b1:	6a 04                	push   $0x4
  1047b3:	ff 34 bd 30 40 12 00 	pushl  0x124030(,%edi,4)
  1047ba:	56                   	push   %esi
  1047bb:	e8 8f 75 00 00       	call   10bd4f <strncmp>
  1047c0:	83 c4 0c             	add    $0xc,%esp
  1047c3:	89 c3                	mov    %eax,%ebx
  1047c5:	85 c0                	test   %eax,%eax
  1047c7:	74 25                	je     1047ee <log_enable+0x4b>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
  1047c9:	47                   	inc    %edi
  1047ca:	83 ff 05             	cmp    $0x5,%edi
  1047cd:	75 e2                	jne    1047b1 <log_enable+0xe>
		shell_error(shell, "Invalid severity: %s", argv[1]);
  1047cf:	8b 45 14             	mov    0x14(%ebp),%eax
  1047d2:	bb f8 ff ff ff       	mov    $0xfffffff8,%ebx
  1047d7:	ff 70 04             	pushl  0x4(%eax)
  1047da:	68 1a 4b 12 00       	push   $0x124b1a
  1047df:	6a 02                	push   $0x2
  1047e1:	ff 75 08             	pushl  0x8(%ebp)
  1047e4:	e8 36 18 00 00       	call   10601f <shell_fprintf>
  1047e9:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  1047ec:	eb 1b                	jmp    104809 <log_enable+0x66>
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
  1047ee:	8b 45 10             	mov    0x10(%ebp),%eax
  1047f1:	57                   	push   %edi
  1047f2:	8b 55 0c             	mov    0xc(%ebp),%edx
  1047f5:	8d 48 fe             	lea    -0x2(%eax),%ecx
  1047f8:	8b 45 14             	mov    0x14(%ebp),%eax
  1047fb:	8d 70 08             	lea    0x8(%eax),%esi
  1047fe:	8b 45 08             	mov    0x8(%ebp),%eax
  104801:	56                   	push   %esi
  104802:	e8 a5 fe ff ff       	call   1046ac <filters_set>
  104807:	58                   	pop    %eax
  104808:	5a                   	pop    %edx
}
  104809:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10480c:	89 d8                	mov    %ebx,%eax
  10480e:	5b                   	pop    %ebx
  10480f:	5e                   	pop    %esi
  104810:	5f                   	pop    %edi
  104811:	5d                   	pop    %ebp
  104812:	c3                   	ret    

00104813 <cmd_log_self_enable>:
{
  104813:	55                   	push   %ebp
  104814:	89 e5                	mov    %esp,%ebp
  104816:	53                   	push   %ebx
  104817:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  10481a:	89 d8                	mov    %ebx,%eax
  10481c:	e8 f2 fd ff ff       	call   104613 <shell_state_precheck>
  104821:	88 c2                	mov    %al,%dl
  104823:	31 c0                	xor    %eax,%eax
  104825:	84 d2                	test   %dl,%dl
  104827:	74 14                	je     10483d <cmd_log_self_enable+0x2a>
	return log_enable(shell, shell->log_backend->backend, argc, argv);
  104829:	ff 75 10             	pushl  0x10(%ebp)
  10482c:	ff 75 0c             	pushl  0xc(%ebp)
  10482f:	8b 43 1c             	mov    0x1c(%ebx),%eax
  104832:	ff 30                	pushl  (%eax)
  104834:	53                   	push   %ebx
  104835:	e8 69 ff ff ff       	call   1047a3 <log_enable>
  10483a:	83 c4 10             	add    $0x10,%esp
}
  10483d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104840:	c9                   	leave  
  104841:	c3                   	ret    

00104842 <log_disable>:
{
  104842:	55                   	push   %ebp
  104843:	89 e5                	mov    %esp,%ebp
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
  104845:	6a 00                	push   $0x0
  104847:	8b 45 10             	mov    0x10(%ebp),%eax
  10484a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10484d:	8d 48 ff             	lea    -0x1(%eax),%ecx
  104850:	8b 45 14             	mov    0x14(%ebp),%eax
  104853:	83 c0 04             	add    $0x4,%eax
  104856:	50                   	push   %eax
  104857:	8b 45 08             	mov    0x8(%ebp),%eax
  10485a:	e8 4d fe ff ff       	call   1046ac <filters_set>
  10485f:	58                   	pop    %eax
  104860:	5a                   	pop    %edx
}
  104861:	31 c0                	xor    %eax,%eax
  104863:	c9                   	leave  
  104864:	c3                   	ret    

00104865 <cmd_log_self_disable>:
{
  104865:	55                   	push   %ebp
  104866:	89 e5                	mov    %esp,%ebp
  104868:	53                   	push   %ebx
  104869:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!shell_state_precheck(shell)) {
  10486c:	89 d8                	mov    %ebx,%eax
  10486e:	e8 a0 fd ff ff       	call   104613 <shell_state_precheck>
  104873:	88 c2                	mov    %al,%dl
  104875:	31 c0                	xor    %eax,%eax
  104877:	84 d2                	test   %dl,%dl
  104879:	74 14                	je     10488f <cmd_log_self_disable+0x2a>
	return log_disable(shell, shell->log_backend->backend, argc, argv);
  10487b:	ff 75 10             	pushl  0x10(%ebp)
  10487e:	ff 75 0c             	pushl  0xc(%ebp)
  104881:	8b 43 1c             	mov    0x1c(%ebx),%eax
  104884:	ff 30                	pushl  (%eax)
  104886:	53                   	push   %ebx
  104887:	e8 b6 ff ff ff       	call   104842 <log_disable>
  10488c:	83 c4 10             	add    $0x10,%esp
}
  10488f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104892:	c9                   	leave  
  104893:	c3                   	ret    

00104894 <cmd_kernel_version>:
#include <device.h>
#include <drivers/timer/system_timer.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
  104894:	55                   	push   %ebp
  104895:	89 e5                	mov    %esp,%ebp
	uint32_t version = sys_kernel_version_get();
  104897:	e8 d5 d4 01 00       	call   121d71 <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
  10489c:	0f b6 d4             	movzbl %ah,%edx
  10489f:	52                   	push   %edx
  1048a0:	89 c2                	mov    %eax,%edx
  1048a2:	c1 ea 10             	shr    $0x10,%edx
  1048a5:	0f b6 d2             	movzbl %dl,%edx
  1048a8:	c1 e8 18             	shr    $0x18,%eax
  1048ab:	52                   	push   %edx
  1048ac:	50                   	push   %eax
  1048ad:	68 c1 4c 12 00       	push   $0x124cc1
  1048b2:	6a 00                	push   $0x0
  1048b4:	ff 75 08             	pushl  0x8(%ebp)
  1048b7:	e8 63 17 00 00       	call   10601f <shell_fprintf>
  1048bc:	83 c4 18             	add    $0x18,%esp
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
  1048bf:	31 c0                	xor    %eax,%eax
  1048c1:	c9                   	leave  
  1048c2:	c3                   	ret    

001048c3 <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
  1048c3:	55                   	push   %ebp
  1048c4:	89 e5                	mov    %esp,%ebp
	return z_impl_k_uptime_ticks();
  1048c6:	e8 bc da 01 00       	call   122387 <z_impl_k_uptime_ticks>
  1048cb:	ba 0a 00 00 00       	mov    $0xa,%edx
  1048d0:	f7 e2                	mul    %edx
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
  1048d2:	50                   	push   %eax
  1048d3:	68 da 4c 12 00       	push   $0x124cda
  1048d8:	6a 00                	push   $0x0
  1048da:	ff 75 08             	pushl  0x8(%ebp)
  1048dd:	e8 3d 17 00 00       	call   10601f <shell_fprintf>
  1048e2:	83 c4 10             	add    $0x10,%esp
	return 0;
}
  1048e5:	31 c0                	xor    %eax,%eax
  1048e7:	c9                   	leave  
  1048e8:	c3                   	ret    

001048e9 <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
  1048e9:	55                   	push   %ebp
  1048ea:	89 e5                	mov    %esp,%ebp
  1048ec:	53                   	push   %ebx
  1048ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", z_clock_elapsed());
  1048f0:	e8 e9 62 00 00       	call   10abde <z_clock_elapsed>
  1048f5:	50                   	push   %eax
  1048f6:	68 e9 4c 12 00       	push   $0x124ce9
  1048fb:	6a 00                	push   $0x0
  1048fd:	53                   	push   %ebx
  1048fe:	e8 1c 17 00 00       	call   10601f <shell_fprintf>
  104903:	83 c4 10             	add    $0x10,%esp
	shell_print(shell, "Threads:");
  104906:	68 08 4d 12 00       	push   $0x124d08
  10490b:	6a 00                	push   $0x0
  10490d:	53                   	push   %ebx
  10490e:	e8 0c 17 00 00       	call   10601f <shell_fprintf>
  104913:	83 c4 0c             	add    $0xc,%esp
	k_thread_foreach(shell_tdata_dump, (void *)shell);
  104916:	53                   	push   %ebx
  104917:	68 89 49 10 00       	push   $0x104989
  10491c:	e8 4e d0 01 00       	call   12196f <k_thread_foreach>
  104921:	58                   	pop    %eax
	return 0;
}
  104922:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	k_thread_foreach(shell_tdata_dump, (void *)shell);
  104925:	5a                   	pop    %edx
}
  104926:	31 c0                	xor    %eax,%eax
  104928:	c9                   	leave  
  104929:	c3                   	ret    

0010492a <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
  10492a:	55                   	push   %ebp
  10492b:	89 e5                	mov    %esp,%ebp
  10492d:	53                   	push   %ebx
  10492e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *buf;
	size_t size, unused = 0;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
  104931:	53                   	push   %ebx
  104932:	68 84 4a 10 00       	push   $0x104a84
  104937:	e8 33 d0 01 00       	call   12196f <k_thread_foreach>
  10493c:	58                   	pop    %eax
	size_t size, unused = 0;
  10493d:	31 c0                	xor    %eax,%eax
	k_thread_foreach(shell_stack_dump, (void *)shell);
  10493f:	5a                   	pop    %edx
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		for (size_t i = 0; i < size; i++) {
			if (buf[i] == 0xAAU) {
  104940:	80 b8 ec 4b 14 00 aa 	cmpb   $0xaa,0x144bec(%eax)
  104947:	75 08                	jne    104951 <cmd_kernel_stacks+0x27>
				unused++;
  104949:	40                   	inc    %eax
		for (size_t i = 0; i < size; i++) {
  10494a:	3d 00 08 00 00       	cmp    $0x800,%eax
  10494f:	75 ef                	jne    104940 <cmd_kernel_stacks+0x16>
			} else {
				break;
			}
		}

		shell_print(shell,
  104951:	ba 00 08 00 00       	mov    $0x800,%edx
  104956:	29 c2                	sub    %eax,%edx
  104958:	6b ca 64             	imul   $0x64,%edx,%ecx
  10495b:	c1 e9 0b             	shr    $0xb,%ecx
  10495e:	51                   	push   %ecx
  10495f:	68 00 08 00 00       	push   $0x800
  104964:	52                   	push   %edx
  104965:	50                   	push   %eax
  104966:	68 00 08 00 00       	push   $0x800
  10496b:	6a 00                	push   $0x0
  10496d:	68 ec 4b 14 00       	push   $0x144bec
  104972:	68 12 4d 12 00       	push   $0x124d12
  104977:	6a 00                	push   $0x0
  104979:	53                   	push   %ebx
  10497a:	e8 a0 16 00 00       	call   10601f <shell_fprintf>
  10497f:	83 c4 28             	add    $0x28,%esp
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
  104982:	31 c0                	xor    %eax,%eax
  104984:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104987:	c9                   	leave  
  104988:	c3                   	ret    

00104989 <shell_tdata_dump>:
{
  104989:	55                   	push   %ebp
  10498a:	89 e5                	mov    %esp,%ebp
  10498c:	57                   	push   %edi
  10498d:	56                   	push   %esi
  10498e:	53                   	push   %ebx
  10498f:	83 ec 08             	sub    $0x8,%esp
  104992:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104995:	8b 75 0c             	mov    0xc(%ebp),%esi
	size_t size = thread->stack_info.size;
  104998:	8b bb 84 00 00 00    	mov    0x84(%ebx),%edi
	tname = k_thread_name_get(thread);
  10499e:	53                   	push   %ebx
  10499f:	e8 b6 d0 01 00       	call   121a5a <k_thread_name_get>
  1049a4:	5a                   	pop    %edx
	shell_print(shell, "%s%p %-10s",
  1049a5:	85 c0                	test   %eax,%eax
  1049a7:	ba 58 4d 12 00       	mov    $0x124d58,%edx
  1049ac:	74 02                	je     1049b0 <shell_tdata_dump+0x27>
  1049ae:	89 c2                	mov    %eax,%edx
  1049b0:	89 55 ec             	mov    %edx,-0x14(%ebp)
	return z_impl_k_current_get();
  1049b3:	e8 99 ce 01 00       	call   121851 <z_impl_k_current_get>
  1049b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1049bb:	89 c1                	mov    %eax,%ecx
  1049bd:	b8 5b 4d 12 00       	mov    $0x124d5b,%eax
  1049c2:	39 cb                	cmp    %ecx,%ebx
  1049c4:	74 05                	je     1049cb <shell_tdata_dump+0x42>
  1049c6:	b8 b7 49 12 00       	mov    $0x1249b7,%eax
  1049cb:	52                   	push   %edx
  1049cc:	53                   	push   %ebx
  1049cd:	50                   	push   %eax
  1049ce:	68 5d 4d 12 00       	push   $0x124d5d
  1049d3:	6a 00                	push   $0x0
  1049d5:	56                   	push   %esi
  1049d6:	e8 44 16 00 00       	call   10601f <shell_fprintf>
  1049db:	83 c4 18             	add    $0x18,%esp
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %d",
  1049de:	ff 73 28             	pushl  0x28(%ebx)
  1049e1:	ff 73 24             	pushl  0x24(%ebx)
  1049e4:	0f be 43 0e          	movsbl 0xe(%ebx),%eax
  1049e8:	50                   	push   %eax
  1049e9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  1049ed:	50                   	push   %eax
  1049ee:	68 69 4d 12 00       	push   $0x124d69
  1049f3:	6a 00                	push   $0x0
  1049f5:	56                   	push   %esi
  1049f6:	e8 24 16 00 00       	call   10601f <shell_fprintf>
  1049fb:	83 c4 1c             	add    $0x1c,%esp
	shell_print(shell, "\tstate: %s", k_thread_state_str(thread));
  1049fe:	53                   	push   %ebx
  1049ff:	e8 61 d0 01 00       	call   121a65 <k_thread_state_str>
  104a04:	89 04 24             	mov    %eax,(%esp)
  104a07:	68 93 4d 12 00       	push   $0x124d93
  104a0c:	6a 00                	push   $0x0
  104a0e:	56                   	push   %esi
  104a0f:	e8 0b 16 00 00       	call   10601f <shell_fprintf>
  104a14:	83 c4 10             	add    $0x10,%esp
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
  104a17:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104a1a:	50                   	push   %eax
  104a1b:	53                   	push   %ebx
  104a1c:	e8 cc d2 01 00       	call   121ced <z_impl_k_thread_stack_space_get>
  104a21:	5a                   	pop    %edx
	if (ret) {
  104a22:	85 c0                	test   %eax,%eax
  104a24:	59                   	pop    %ecx
  104a25:	74 13                	je     104a3a <shell_tdata_dump+0xb1>
		shell_print(shell,
  104a27:	50                   	push   %eax
  104a28:	68 9f 4d 12 00       	push   $0x124d9f
  104a2d:	6a 00                	push   $0x0
  104a2f:	56                   	push   %esi
  104a30:	e8 ea 15 00 00       	call   10601f <shell_fprintf>
  104a35:	83 c4 10             	add    $0x10,%esp
  104a38:	eb 23                	jmp    104a5d <shell_tdata_dump+0xd4>
		pcnt = ((size - unused) * 100U) / size;
  104a3a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104a3d:	89 fb                	mov    %edi,%ebx
  104a3f:	29 cb                	sub    %ecx,%ebx
  104a41:	31 d2                	xor    %edx,%edx
  104a43:	6b c3 64             	imul   $0x64,%ebx,%eax
  104a46:	f7 f7                	div    %edi
		shell_print(shell,
  104a48:	50                   	push   %eax
  104a49:	57                   	push   %edi
  104a4a:	53                   	push   %ebx
  104a4b:	51                   	push   %ecx
  104a4c:	57                   	push   %edi
  104a4d:	68 cc 4d 12 00       	push   $0x124dcc
  104a52:	6a 00                	push   $0x0
  104a54:	56                   	push   %esi
  104a55:	e8 c5 15 00 00       	call   10601f <shell_fprintf>
  104a5a:	83 c4 20             	add    $0x20,%esp
}
  104a5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104a60:	5b                   	pop    %ebx
  104a61:	5e                   	pop    %esi
  104a62:	5f                   	pop    %edi
  104a63:	5d                   	pop    %ebp
  104a64:	c3                   	ret    

00104a65 <cmd_kernel_cycles>:
{
  104a65:	55                   	push   %ebp
  104a66:	89 e5                	mov    %esp,%ebp
	return z_timer_cycle_get_32();
  104a68:	e8 95 61 00 00       	call   10ac02 <z_timer_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
  104a6d:	50                   	push   %eax
  104a6e:	68 03 4e 12 00       	push   $0x124e03
  104a73:	6a 00                	push   $0x0
  104a75:	ff 75 08             	pushl  0x8(%ebp)
  104a78:	e8 a2 15 00 00       	call   10601f <shell_fprintf>
  104a7d:	83 c4 10             	add    $0x10,%esp
}
  104a80:	31 c0                	xor    %eax,%eax
  104a82:	c9                   	leave  
  104a83:	c3                   	ret    

00104a84 <shell_stack_dump>:
{
  104a84:	55                   	push   %ebp
  104a85:	89 e5                	mov    %esp,%ebp
  104a87:	57                   	push   %edi
  104a88:	56                   	push   %esi
  104a89:	53                   	push   %ebx
  104a8a:	83 ec 08             	sub    $0x8,%esp
  104a8d:	8b 75 08             	mov    0x8(%ebp),%esi
	size_t size = thread->stack_info.size;
  104a90:	8b 9e 84 00 00 00    	mov    0x84(%esi),%ebx
  104a96:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104a99:	50                   	push   %eax
  104a9a:	56                   	push   %esi
  104a9b:	e8 4d d2 01 00       	call   121ced <z_impl_k_thread_stack_space_get>
  104aa0:	5f                   	pop    %edi
	if (ret) {
  104aa1:	85 c0                	test   %eax,%eax
  104aa3:	5a                   	pop    %edx
  104aa4:	74 15                	je     104abb <shell_stack_dump+0x37>
		shell_print(shell,
  104aa6:	50                   	push   %eax
  104aa7:	68 9f 4d 12 00       	push   $0x124d9f
  104aac:	6a 00                	push   $0x0
  104aae:	ff 75 0c             	pushl  0xc(%ebp)
  104ab1:	e8 69 15 00 00       	call   10601f <shell_fprintf>
  104ab6:	83 c4 10             	add    $0x10,%esp
		return;
  104ab9:	eb 3e                	jmp    104af9 <shell_stack_dump+0x75>
	tname = k_thread_name_get((struct k_thread *)thread);
  104abb:	56                   	push   %esi
  104abc:	e8 99 cf 01 00       	call   121a5a <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
  104ac1:	8b 7d f0             	mov    -0x10(%ebp),%edi
	tname = k_thread_name_get((struct k_thread *)thread);
  104ac4:	89 c1                	mov    %eax,%ecx
	pcnt = ((size - unused) * 100U) / size;
  104ac6:	89 d8                	mov    %ebx,%eax
	tname = k_thread_name_get((struct k_thread *)thread);
  104ac8:	5a                   	pop    %edx
	pcnt = ((size - unused) * 100U) / size;
  104ac9:	29 f8                	sub    %edi,%eax
  104acb:	31 d2                	xor    %edx,%edx
  104acd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104ad0:	6b c0 64             	imul   $0x64,%eax,%eax
  104ad3:	f7 f3                	div    %ebx
	shell_print((const struct shell *)user_data,
  104ad5:	85 c9                	test   %ecx,%ecx
  104ad7:	75 05                	jne    104ade <shell_stack_dump+0x5a>
  104ad9:	b9 58 4d 12 00       	mov    $0x124d58,%ecx
  104ade:	50                   	push   %eax
  104adf:	53                   	push   %ebx
  104ae0:	ff 75 ec             	pushl  -0x14(%ebp)
  104ae3:	57                   	push   %edi
  104ae4:	53                   	push   %ebx
  104ae5:	51                   	push   %ecx
  104ae6:	56                   	push   %esi
  104ae7:	68 19 4e 12 00       	push   $0x124e19
  104aec:	6a 00                	push   $0x0
  104aee:	ff 75 0c             	pushl  0xc(%ebp)
  104af1:	e8 29 15 00 00       	call   10601f <shell_fprintf>
  104af6:	83 c4 28             	add    $0x28,%esp
}
  104af9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104afc:	5b                   	pop    %ebx
  104afd:	5e                   	pop    %esi
  104afe:	5f                   	pop    %edi
  104aff:	5d                   	pop    %ebp
  104b00:	c3                   	ret    

00104b01 <cmd_device_list>:
	return 0;
}

static int cmd_device_list(const struct shell *shell,
			      size_t argc, char **argv)
{
  104b01:	55                   	push   %ebp
  104b02:	89 e5                	mov    %esp,%ebp
  104b04:	56                   	push   %esi
  104b05:	53                   	push   %ebx
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");

	for (dev = __device_start; dev != __device_end; dev++) {
  104b06:	bb 54 5b 14 00       	mov    $0x145b54,%ebx
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  104b0b:	68 ec 4e 12 00       	push   $0x124eec
{
  104b10:	8b 75 08             	mov    0x8(%ebp),%esi
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
  104b13:	6a 00                	push   $0x0
  104b15:	56                   	push   %esi
  104b16:	e8 04 15 00 00       	call   10601f <shell_fprintf>
  104b1b:	83 c4 0c             	add    $0xc,%esp
	for (dev = __device_start; dev != __device_end; dev++) {
  104b1e:	81 fb 94 5b 14 00    	cmp    $0x145b94,%ebx
  104b24:	74 32                	je     104b58 <cmd_device_list+0x57>
		if (!z_device_ready(dev)) {
  104b26:	53                   	push   %ebx
  104b27:	e8 ba b8 01 00       	call   1203e6 <z_device_ready>
  104b2c:	5a                   	pop    %edx
  104b2d:	84 c0                	test   %al,%al
  104b2f:	74 22                	je     104b53 <cmd_device_list+0x52>
			continue;
		}

		shell_fprintf(shell, SHELL_NORMAL, "- %s", dev->name);
  104b31:	ff 33                	pushl  (%ebx)
  104b33:	68 f6 4e 12 00       	push   $0x124ef6
  104b38:	6a 00                	push   $0x0
  104b3a:	56                   	push   %esi
  104b3b:	e8 df 14 00 00       	call   10601f <shell_fprintf>
  104b40:	83 c4 10             	add    $0x10,%esp
		if (!err) {
			shell_fprintf(shell, SHELL_NORMAL, " (%s)",
				      device_pm_state_str(state));
		}
#endif /* CONFIG_DEVICE_POWER_MANAGEMENT */
		shell_fprintf(shell, SHELL_NORMAL, "\n");
  104b43:	68 01 4e 12 00       	push   $0x124e01
  104b48:	6a 00                	push   $0x0
  104b4a:	56                   	push   %esi
  104b4b:	e8 cf 14 00 00       	call   10601f <shell_fprintf>
  104b50:	83 c4 0c             	add    $0xc,%esp
	for (dev = __device_start; dev != __device_end; dev++) {
  104b53:	83 c3 10             	add    $0x10,%ebx
  104b56:	eb c6                	jmp    104b1e <cmd_device_list+0x1d>
	}

	return 0;
}
  104b58:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104b5b:	31 c0                	xor    %eax,%eax
  104b5d:	5b                   	pop    %ebx
  104b5e:	5e                   	pop    %esi
  104b5f:	5d                   	pop    %ebp
  104b60:	c3                   	ret    

00104b61 <device_get_config_level>:
{
  104b61:	55                   	push   %ebp
  104b62:	89 e5                	mov    %esp,%ebp
  104b64:	57                   	push   %edi
  104b65:	56                   	push   %esi
  104b66:	89 c7                	mov    %eax,%edi
  104b68:	53                   	push   %ebx
  104b69:	89 d6                	mov    %edx,%esi
  104b6b:	51                   	push   %ecx
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  104b6c:	8b 1c 95 7c 40 12 00 	mov    0x12407c(,%edx,4),%ebx
	bool devices = false;
  104b73:	31 d2                	xor    %edx,%edx
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  104b75:	39 1c b5 80 40 12 00 	cmp    %ebx,0x124080(,%esi,4)
  104b7c:	76 30                	jbe    104bae <device_get_config_level+0x4d>
  104b7e:	88 55 f3             	mov    %dl,-0xd(%ebp)
		if (z_device_ready(dev)) {
  104b81:	53                   	push   %ebx
  104b82:	e8 5f b8 01 00       	call   1203e6 <z_device_ready>
  104b87:	5a                   	pop    %edx
  104b88:	84 c0                	test   %al,%al
  104b8a:	8a 55 f3             	mov    -0xd(%ebp),%dl
  104b8d:	74 1a                	je     104ba9 <device_get_config_level+0x48>
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n", dev->name);
  104b8f:	ff 33                	pushl  (%ebx)
  104b91:	88 45 f3             	mov    %al,-0xd(%ebp)
  104b94:	68 fb 4e 12 00       	push   $0x124efb
  104b99:	6a 00                	push   $0x0
  104b9b:	57                   	push   %edi
  104b9c:	e8 7e 14 00 00       	call   10601f <shell_fprintf>
			devices = true;
  104ba1:	8a 45 f3             	mov    -0xd(%ebp),%al
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n", dev->name);
  104ba4:	83 c4 10             	add    $0x10,%esp
			devices = true;
  104ba7:	88 c2                	mov    %al,%dl
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
  104ba9:	83 c3 10             	add    $0x10,%ebx
  104bac:	eb c7                	jmp    104b75 <device_get_config_level+0x14>
}
  104bae:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104bb1:	88 d0                	mov    %dl,%al
  104bb3:	5b                   	pop    %ebx
  104bb4:	5e                   	pop    %esi
  104bb5:	5f                   	pop    %edi
  104bb6:	5d                   	pop    %ebp
  104bb7:	c3                   	ret    

00104bb8 <cmd_device_levels>:
{
  104bb8:	55                   	push   %ebp
  104bb9:	89 e5                	mov    %esp,%ebp
  104bbb:	53                   	push   %ebx
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
  104bbc:	68 01 4f 12 00       	push   $0x124f01
{
  104bc1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
  104bc4:	6a 00                	push   $0x0
  104bc6:	53                   	push   %ebx
  104bc7:	e8 53 14 00 00       	call   10601f <shell_fprintf>
  104bcc:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
  104bcf:	ba 02 00 00 00       	mov    $0x2,%edx
  104bd4:	89 d8                	mov    %ebx,%eax
  104bd6:	e8 86 ff ff ff       	call   104b61 <device_get_config_level>
	if (ret == false) {
  104bdb:	84 c0                	test   %al,%al
  104bdd:	75 10                	jne    104bef <cmd_device_levels+0x37>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  104bdf:	68 0f 4f 12 00       	push   $0x124f0f
  104be4:	6a 00                	push   $0x0
  104be6:	53                   	push   %ebx
  104be7:	e8 33 14 00 00       	call   10601f <shell_fprintf>
  104bec:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
  104bef:	68 17 4f 12 00       	push   $0x124f17
  104bf4:	6a 00                	push   $0x0
  104bf6:	53                   	push   %ebx
  104bf7:	e8 23 14 00 00       	call   10601f <shell_fprintf>
  104bfc:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
  104bff:	ba 03 00 00 00       	mov    $0x3,%edx
  104c04:	89 d8                	mov    %ebx,%eax
  104c06:	e8 56 ff ff ff       	call   104b61 <device_get_config_level>
	if (ret == false) {
  104c0b:	84 c0                	test   %al,%al
  104c0d:	75 10                	jne    104c1f <cmd_device_levels+0x67>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  104c0f:	68 0f 4f 12 00       	push   $0x124f0f
  104c14:	6a 00                	push   $0x0
  104c16:	53                   	push   %ebx
  104c17:	e8 03 14 00 00       	call   10601f <shell_fprintf>
  104c1c:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
  104c1f:	68 25 4f 12 00       	push   $0x124f25
  104c24:	6a 00                	push   $0x0
  104c26:	53                   	push   %ebx
  104c27:	e8 f3 13 00 00       	call   10601f <shell_fprintf>
  104c2c:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
  104c2f:	31 d2                	xor    %edx,%edx
  104c31:	89 d8                	mov    %ebx,%eax
  104c33:	e8 29 ff ff ff       	call   104b61 <device_get_config_level>
	if (ret == false) {
  104c38:	84 c0                	test   %al,%al
  104c3a:	75 10                	jne    104c4c <cmd_device_levels+0x94>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  104c3c:	68 0f 4f 12 00       	push   $0x124f0f
  104c41:	6a 00                	push   $0x0
  104c43:	53                   	push   %ebx
  104c44:	e8 d6 13 00 00       	call   10601f <shell_fprintf>
  104c49:	83 c4 0c             	add    $0xc,%esp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
  104c4c:	68 34 4f 12 00       	push   $0x124f34
  104c51:	6a 00                	push   $0x0
  104c53:	53                   	push   %ebx
  104c54:	e8 c6 13 00 00       	call   10601f <shell_fprintf>
  104c59:	83 c4 0c             	add    $0xc,%esp
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
  104c5c:	ba 01 00 00 00       	mov    $0x1,%edx
  104c61:	89 d8                	mov    %ebx,%eax
  104c63:	e8 f9 fe ff ff       	call   104b61 <device_get_config_level>
	if (ret == false) {
  104c68:	84 c0                	test   %al,%al
  104c6a:	75 10                	jne    104c7c <cmd_device_levels+0xc4>
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
  104c6c:	68 0f 4f 12 00       	push   $0x124f0f
  104c71:	6a 00                	push   $0x0
  104c73:	53                   	push   %ebx
  104c74:	e8 a6 13 00 00       	call   10601f <shell_fprintf>
  104c79:	83 c4 0c             	add    $0xc,%esp
}
  104c7c:	31 c0                	xor    %eax,%eax
  104c7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104c81:	c9                   	leave  
  104c82:	c3                   	ret    

00104c83 <shell_signal_handle>:

static void shell_signal_handle(const struct shell *shell,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
  104c83:	c1 e2 04             	shl    $0x4,%edx
{
  104c86:	55                   	push   %ebp
  104c87:	89 e5                	mov    %esp,%ebp
  104c89:	57                   	push   %edi
  104c8a:	56                   	push   %esi
  104c8b:	89 ce                	mov    %ecx,%esi
  104c8d:	53                   	push   %ebx
  104c8e:	89 c3                	mov    %eax,%ebx
  104c90:	83 ec 08             	sub    $0x8,%esp
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
  104c93:	8b 40 08             	mov    0x8(%eax),%eax
  104c96:	8d bc 10 68 02 00 00 	lea    0x268(%eax,%edx,1),%edi
		arch_syscall_invoke3(*(uintptr_t *)&signal, *(uintptr_t *)&signaled, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(signal, signaled, result);
  104c9d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104ca0:	50                   	push   %eax
  104ca1:	8d 45 ec             	lea    -0x14(%ebp),%eax
  104ca4:	50                   	push   %eax
  104ca5:	57                   	push   %edi
  104ca6:	e8 d3 dd 01 00       	call   122a7e <z_impl_k_poll_signal_check>
  104cab:	83 c4 0c             	add    $0xc,%esp
	int set;
	int res;

	k_poll_signal_check(signal, &set, &res);

	if (set) {
  104cae:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  104cb2:	74 0b                	je     104cbf <shell_signal_handle+0x3c>
 */
__syscall void k_poll_signal_reset(struct k_poll_signal *signal);

static inline void z_impl_k_poll_signal_reset(struct k_poll_signal *signal)
{
	signal->signaled = 0U;
  104cb4:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
		k_poll_signal_reset(signal);
		handler(shell);
  104cbb:	53                   	push   %ebx
  104cbc:	ff d6                	call   *%esi
  104cbe:	58                   	pop    %eax
	}
}
  104cbf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104cc2:	5b                   	pop    %ebx
  104cc3:	5e                   	pop    %esi
  104cc4:	5f                   	pop    %edi
  104cc5:	5d                   	pop    %ebp
  104cc6:	c3                   	ret    

00104cc7 <kill_handler>:

static void kill_handler(const struct shell *shell)
{
  104cc7:	55                   	push   %ebp
  104cc8:	89 e5                	mov    %esp,%ebp
  104cca:	53                   	push   %ebx
  104ccb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (flag_processing_get(shell)) {
  104cce:	8b 43 08             	mov    0x8(%ebx),%eax
	shell->ctx->internal.flags.echo = val ? 1 : 0;
}

static inline bool flag_processing_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.processing == 1;
  104cd1:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
  104cd7:	a8 08                	test   $0x8,%al
  104cd9:	75 2b                	jne    104d06 <kill_handler+0x3f>
		shell_log_backend_disable(shell->log_backend);
  104cdb:	ff 73 1c             	pushl  0x1c(%ebx)
  104cde:	e8 91 31 00 00       	call   107e74 <shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
  104ce3:	8b 43 04             	mov    0x4(%ebx),%eax
  104ce6:	8b 10                	mov    (%eax),%edx
  104ce8:	89 04 24             	mov    %eax,(%esp)
  104ceb:	ff 52 04             	call   *0x4(%edx)
  104cee:	5a                   	pop    %edx
	if (err != 0) {
  104cef:	85 c0                	test   %eax,%eax
  104cf1:	75 13                	jne    104d06 <kill_handler+0x3f>
	shell_history_purge(shell->history);
  104cf3:	ff 73 0c             	pushl  0xc(%ebx)
  104cf6:	e8 17 2e 00 00       	call   107b12 <shell_history_purge>
  104cfb:	58                   	pop    %eax
	shell->ctx->state = state;
  104cfc:	8b 43 08             	mov    0x8(%ebx),%eax
  104cff:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	return z_impl_k_current_get();
  104d06:	e8 46 cb 01 00       	call   121851 <z_impl_k_current_get>
	(void)instance_uninit(shell);
	k_thread_abort(k_current_get());
}
  104d0b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	z_impl_k_thread_abort(thread);
  104d0e:	89 45 08             	mov    %eax,0x8(%ebp)
  104d11:	c9                   	leave  
  104d12:	e9 20 d0 01 00       	jmp    121d37 <z_impl_k_thread_abort>

00104d17 <k_mutex_unlock>:
{
  104d17:	55                   	push   %ebp
  104d18:	89 e5                	mov    %esp,%ebp
	return z_impl_k_mutex_unlock(mutex);
  104d1a:	50                   	push   %eax
  104d1b:	e8 ae bf 01 00       	call   120cce <z_impl_k_mutex_unlock>
  104d20:	5a                   	pop    %edx
}
  104d21:	c9                   	leave  
  104d22:	c3                   	ret    

00104d23 <shell_strlen>:
void shell_multiline_data_calc(struct shell_multiline_cons *cons,
				   uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
  104d23:	85 c0                	test   %eax,%eax
  104d25:	74 0c                	je     104d33 <shell_strlen+0x10>
{
  104d27:	55                   	push   %ebp
  104d28:	89 e5                	mov    %esp,%ebp
	return str == NULL ? 0U : (uint16_t)strlen(str);
  104d2a:	50                   	push   %eax
  104d2b:	e8 ec 6f 00 00       	call   10bd1c <strlen>
  104d30:	5a                   	pop    %edx
}
  104d31:	c9                   	leave  
  104d32:	c3                   	ret    
	return str == NULL ? 0U : (uint16_t)strlen(str);
  104d33:	31 c0                	xor    %eax,%eax
}
  104d35:	c3                   	ret    

00104d36 <shell_raw_fprintf>:
{
  104d36:	55                   	push   %ebp
  104d37:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  104d39:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  104d3c:	50                   	push   %eax
  104d3d:	ff 75 0c             	pushl  0xc(%ebp)
  104d40:	ff 75 08             	pushl  0x8(%ebp)
  104d43:	e8 4f 14 00 00       	call   106197 <shell_fprintf_fmt>
  104d48:	83 c4 0c             	add    $0xc,%esp
}
  104d4b:	c9                   	leave  
  104d4c:	c3                   	ret    

00104d4d <shell_internal_help_print>:
{
  104d4d:	55                   	push   %ebp
  104d4e:	89 e5                	mov    %esp,%ebp
  104d50:	53                   	push   %ebx
  104d51:	89 c3                	mov    %eax,%ebx
	shell_help_cmd_print(shell, &shell->ctx->active_cmd);
  104d53:	8b 40 08             	mov    0x8(%eax),%eax
  104d56:	83 c0 0c             	add    $0xc,%eax
  104d59:	50                   	push   %eax
  104d5a:	53                   	push   %ebx
  104d5b:	e8 4d 28 00 00       	call   1075ad <shell_help_cmd_print>
  104d60:	58                   	pop    %eax
	shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
  104d61:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_help_cmd_print(shell, &shell->ctx->active_cmd);
  104d64:	5a                   	pop    %edx
	shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
  104d65:	83 c0 0c             	add    $0xc,%eax
  104d68:	68 92 4f 12 00       	push   $0x124f92
  104d6d:	50                   	push   %eax
  104d6e:	53                   	push   %ebx
  104d6f:	e8 4d 27 00 00       	call   1074c1 <shell_help_subcmd_print>
  104d74:	83 c4 0c             	add    $0xc,%esp
}
  104d77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104d7a:	c9                   	leave  
  104d7b:	c3                   	ret    

00104d7c <state_set.constprop.0>:
static inline void state_set(const struct shell *shell, enum shell_state state)
  104d7c:	55                   	push   %ebp
  104d7d:	89 e5                	mov    %esp,%ebp
  104d7f:	53                   	push   %ebx
  104d80:	89 c3                	mov    %eax,%ebx
	shell->ctx->state = state;
  104d82:	8b 40 08             	mov    0x8(%eax),%eax
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
  104d85:	c6 40 46 00          	movb   $0x0,0x46(%eax)
	shell->ctx->state = state;
  104d89:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
	shell->ctx->cmd_buff_len = 0;
  104d90:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
		if (flag_print_noinit_get(shell)) {
  104d97:	8b 43 08             	mov    0x8(%ebx),%eax
	shell->ctx->internal.flags.last_nl = val;
}

static inline bool flag_print_noinit_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.print_noinit == 1;
  104d9a:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
  104da0:	0f ba e0 10          	bt     $0x10,%eax
  104da4:	73 29                	jae    104dcf <state_set.constprop.0+0x53>
			shell_internal_fprintf(shell, SHELL_WARNING, "%s",
  104da6:	68 a0 4f 12 00       	push   $0x124fa0
  104dab:	68 f8 4e 12 00       	push   $0x124ef8
  104db0:	6a 04                	push   $0x4
  104db2:	53                   	push   %ebx
  104db3:	e8 60 1f 00 00       	call   106d18 <shell_internal_fprintf>
}

static inline void flag_print_noinit_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.print_noinit = val ? 1 : 0;
  104db8:	8b 53 08             	mov    0x8(%ebx),%edx
  104dbb:	83 c4 10             	add    $0x10,%esp
  104dbe:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  104dc4:	25 ff ff fe ff       	and    $0xfffeffff,%eax
  104dc9:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
		shell_print_prompt_and_cmd(shell);
  104dcf:	53                   	push   %ebx
  104dd0:	e8 5c 22 00 00       	call   107031 <shell_print_prompt_and_cmd>
  104dd5:	58                   	pop    %eax
}
  104dd6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104dd9:	c9                   	leave  
  104dda:	c3                   	ret    

00104ddb <transport_evt_handler>:
{
  104ddb:	55                   	push   %ebp
  104ddc:	89 e5                	mov    %esp,%ebp
	signal = (evt_type == SHELL_TRANSPORT_EVT_RX_RDY) ?
  104dde:	8b 45 0c             	mov    0xc(%ebp),%eax
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
  104de1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104de5:	8b 50 08             	mov    0x8(%eax),%edx
  104de8:	8d 82 68 02 00 00    	lea    0x268(%edx),%eax
  104dee:	74 06                	je     104df6 <transport_evt_handler+0x1b>
  104df0:	8d 82 98 02 00 00    	lea    0x298(%edx),%eax
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
  104df6:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  104dfd:	89 45 08             	mov    %eax,0x8(%ebp)
}
  104e00:	5d                   	pop    %ebp
  104e01:	e9 90 dc 01 00       	jmp    122a96 <z_impl_k_poll_signal_raise>

00104e06 <k_mutex_lock.constprop.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
  104e06:	55                   	push   %ebp
  104e07:	89 e5                	mov    %esp,%ebp
  104e09:	53                   	push   %ebx
	return z_impl_k_mutex_lock(mutex, timeout);
  104e0a:	51                   	push   %ecx
  104e0b:	52                   	push   %edx
  104e0c:	50                   	push   %eax
  104e0d:	e8 be bd 01 00       	call   120bd0 <z_impl_k_mutex_lock>
  104e12:	83 c4 0c             	add    $0xc,%esp
}
  104e15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104e18:	c9                   	leave  
  104e19:	c3                   	ret    

00104e1a <shell_log_process>:
{
  104e1a:	55                   	push   %ebp
  104e1b:	89 e5                	mov    %esp,%ebp
  104e1d:	57                   	push   %edi
  104e1e:	56                   	push   %esi
  104e1f:	53                   	push   %ebx
  104e20:	83 ec 08             	sub    $0x8,%esp
	int signaled = 0;
  104e23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  104e2a:	8b 5d 08             	mov    0x8(%ebp),%ebx
			shell_cmd_line_erase(shell);
  104e2d:	53                   	push   %ebx
  104e2e:	e8 c4 1c 00 00       	call   106af7 <shell_cmd_line_erase>
  104e33:	59                   	pop    %ecx
			processed = shell_log_backend_process(shell->log_backend);
  104e34:	ff 73 1c             	pushl  0x1c(%ebx)
  104e37:	e8 6b 30 00 00       	call   107ea7 <shell_log_backend_process>
  104e3c:	89 c6                	mov    %eax,%esi
		struct k_poll_signal *signal =
  104e3e:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_print_prompt_and_cmd(shell);
  104e41:	89 1c 24             	mov    %ebx,(%esp)
		struct k_poll_signal *signal =
  104e44:	8d b8 68 02 00 00    	lea    0x268(%eax),%edi
		shell_print_prompt_and_cmd(shell);
  104e4a:	e8 e2 21 00 00       	call   107031 <shell_print_prompt_and_cmd>
  104e4f:	58                   	pop    %eax
		if (shell->ctx->cmd_buff_len) {
  104e50:	8b 43 08             	mov    0x8(%ebx),%eax
  104e53:	66 83 78 40 00       	cmpw   $0x0,0x40(%eax)
  104e58:	74 0b                	je     104e65 <shell_log_process+0x4b>
	return z_impl_k_sleep(timeout);
  104e5a:	6a 00                	push   $0x0
  104e5c:	6a 02                	push   $0x2
  104e5e:	e8 b0 c9 01 00       	call   121813 <z_impl_k_sleep>
  104e63:	58                   	pop    %eax
  104e64:	5a                   	pop    %edx
	z_impl_k_poll_signal_check(signal, signaled, result);
  104e65:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104e68:	50                   	push   %eax
  104e69:	8d 45 ec             	lea    -0x14(%ebp),%eax
  104e6c:	50                   	push   %eax
  104e6d:	57                   	push   %edi
  104e6e:	e8 0b dc 01 00       	call   122a7e <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
  104e73:	89 f0                	mov    %esi,%eax
  104e75:	83 c4 0c             	add    $0xc,%esp
  104e78:	84 c0                	test   %al,%al
  104e7a:	74 06                	je     104e82 <shell_log_process+0x68>
  104e7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  104e80:	74 ab                	je     104e2d <shell_log_process+0x13>
}
  104e82:	8d 65 f4             	lea    -0xc(%ebp),%esp
  104e85:	5b                   	pop    %ebx
  104e86:	5e                   	pop    %esi
  104e87:	5f                   	pop    %edi
  104e88:	5d                   	pop    %ebp
  104e89:	c3                   	ret    

00104e8a <history_handle>:
{
  104e8a:	55                   	push   %ebp
  104e8b:	89 e5                	mov    %esp,%ebp
  104e8d:	56                   	push   %esi
  104e8e:	53                   	push   %ebx
  104e8f:	89 d6                	mov    %edx,%esi
  104e91:	53                   	push   %ebx
  104e92:	89 c3                	mov    %eax,%ebx
	if (flag_history_exit_get(shell)) {
  104e94:	8b 40 08             	mov    0x8(%eax),%eax
	return shell->ctx->internal.flags.history_exit == 1;
  104e97:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  104e9d:	80 e2 40             	and    $0x40,%dl
  104ea0:	74 19                	je     104ebb <history_handle+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  104ea2:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  104ea8:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  104eab:	83 e2 bf             	and    $0xffffffbf,%edx
  104eae:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
		shell_history_mode_exit(shell->history);
  104eb4:	51                   	push   %ecx
  104eb5:	e8 ce 2b 00 00       	call   107a88 <shell_history_mode_exit>
  104eba:	59                   	pop    %ecx
	if (!shell_history_active(shell->history)) {
  104ebb:	8b 43 0c             	mov    0xc(%ebx),%eax
  104ebe:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  104ec2:	75 37                	jne    104efb <history_handle+0x71>
		if (up) {
  104ec4:	89 f0                	mov    %esi,%eax
  104ec6:	84 c0                	test   %al,%al
  104ec8:	0f 84 ac 00 00 00    	je     104f7a <history_handle+0xf0>
			uint16_t cmd_len = shell_strlen(shell->ctx->cmd_buff);
  104ece:	8b 43 08             	mov    0x8(%ebx),%eax
  104ed1:	83 c0 46             	add    $0x46,%eax
  104ed4:	e8 4a fe ff ff       	call   104d23 <shell_strlen>
			if (cmd_len) {
  104ed9:	66 85 c0             	test   %ax,%ax
  104edc:	8b 43 08             	mov    0x8(%ebx),%eax
  104edf:	74 13                	je     104ef4 <history_handle+0x6a>
				       shell->ctx->cmd_buff);
  104ee1:	8d 50 46             	lea    0x46(%eax),%edx
				strcpy(shell->ctx->temp_buff,
  104ee4:	05 46 01 00 00       	add    $0x146,%eax
  104ee9:	52                   	push   %edx
  104eea:	50                   	push   %eax
  104eeb:	e8 91 6d 00 00       	call   10bc81 <strcpy>
  104ef0:	58                   	pop    %eax
  104ef1:	5a                   	pop    %edx
  104ef2:	eb 07                	jmp    104efb <history_handle+0x71>
				shell->ctx->temp_buff[0] = '\0';
  104ef4:	c6 80 46 01 00 00 00 	movb   $0x0,0x146(%eax)
	history_mode = shell_history_get(shell->history, up,
  104efb:	8d 45 f6             	lea    -0xa(%ebp),%eax
  104efe:	50                   	push   %eax
					 shell->ctx->cmd_buff, &len);
  104eff:	8b 43 08             	mov    0x8(%ebx),%eax
  104f02:	83 c0 46             	add    $0x46,%eax
	history_mode = shell_history_get(shell->history, up,
  104f05:	50                   	push   %eax
  104f06:	89 f0                	mov    %esi,%eax
  104f08:	0f b6 f0             	movzbl %al,%esi
  104f0b:	56                   	push   %esi
  104f0c:	ff 73 0c             	pushl  0xc(%ebx)
  104f0f:	e8 83 2b 00 00       	call   107a97 <shell_history_get>
  104f14:	83 c4 10             	add    $0x10,%esp
	if (!history_mode) {
  104f17:	84 c0                	test   %al,%al
  104f19:	75 24                	jne    104f3f <history_handle+0xb5>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  104f1b:	8b 43 08             	mov    0x8(%ebx),%eax
  104f1e:	8d 90 46 01 00 00    	lea    0x146(%eax),%edx
  104f24:	83 c0 46             	add    $0x46,%eax
  104f27:	52                   	push   %edx
  104f28:	50                   	push   %eax
  104f29:	e8 53 6d 00 00       	call   10bc81 <strcpy>
		len = shell_strlen(shell->ctx->cmd_buff);
  104f2e:	8b 43 08             	mov    0x8(%ebx),%eax
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  104f31:	5a                   	pop    %edx
		len = shell_strlen(shell->ctx->cmd_buff);
  104f32:	83 c0 46             	add    $0x46,%eax
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
  104f35:	59                   	pop    %ecx
		len = shell_strlen(shell->ctx->cmd_buff);
  104f36:	e8 e8 fd ff ff       	call   104d23 <shell_strlen>
  104f3b:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	shell_op_cursor_home_move(shell);
  104f3f:	53                   	push   %ebx
  104f40:	e8 22 1b 00 00       	call   106a67 <shell_op_cursor_home_move>
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  104f45:	c7 04 24 5c 41 12 00 	movl   $0x12415c,(%esp)
  104f4c:	68 f8 4e 12 00       	push   $0x124ef8
  104f51:	ff 73 14             	pushl  0x14(%ebx)
  104f54:	e8 dd fd ff ff       	call   104d36 <shell_raw_fprintf>
  104f59:	83 c4 0c             	add    $0xc,%esp
	shell_print_cmd(shell);
  104f5c:	53                   	push   %ebx
  104f5d:	e8 e9 1b 00 00       	call   106b4b <shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
  104f62:	8b 43 08             	mov    0x8(%ebx),%eax
  104f65:	66 8b 55 f6          	mov    -0xa(%ebp),%dx
  104f69:	66 89 50 42          	mov    %dx,0x42(%eax)
	shell->ctx->cmd_buff_len = len;
  104f6d:	66 89 50 40          	mov    %dx,0x40(%eax)
	shell_op_cond_next_line(shell);
  104f71:	89 1c 24             	mov    %ebx,(%esp)
  104f74:	e8 f0 18 00 00       	call   106869 <shell_op_cond_next_line>
  104f79:	58                   	pop    %eax
}
  104f7a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  104f7d:	5b                   	pop    %ebx
  104f7e:	5e                   	pop    %esi
  104f7f:	5d                   	pop    %ebp
  104f80:	c3                   	ret    

00104f81 <execute>:
{
  104f81:	55                   	push   %ebp
  104f82:	89 e5                	mov    %esp,%ebp
  104f84:	57                   	push   %edi
  104f85:	56                   	push   %esi
  104f86:	53                   	push   %ebx
  104f87:	89 c3                	mov    %eax,%ebx
  104f89:	81 ec 88 00 00 00    	sub    $0x88,%esp
	size_t cmd_lvl = 0;
  104f8f:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
	const struct shell_static_entry *parent = shell->ctx->selected_cmd;
  104f96:	8b 40 08             	mov    0x8(%eax),%eax
	size_t argc = 0, args_left = SIZE_MAX;
  104f99:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
	char *cmd_buf = shell->ctx->cmd_buff;
  104fa0:	83 c0 46             	add    $0x46,%eax
	const struct shell_static_entry *parent = shell->ctx->selected_cmd;
  104fa3:	8b 48 da             	mov    -0x26(%eax),%ecx
	shell_op_cursor_end_move(shell);
  104fa6:	53                   	push   %ebx
	const struct shell_static_entry *parent = shell->ctx->selected_cmd;
  104fa7:	89 4d 8c             	mov    %ecx,-0x74(%ebp)
	char *cmd_buf = shell->ctx->cmd_buff;
  104faa:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
	shell_op_cursor_end_move(shell);
  104fb0:	e8 cd 1a 00 00       	call   106a82 <shell_op_cursor_end_move>
	if (!shell_cursor_in_empty_line(shell)) {
  104fb5:	89 1c 24             	mov    %ebx,(%esp)
  104fb8:	e8 73 18 00 00       	call   106830 <shell_cursor_in_empty_line>
  104fbd:	5a                   	pop    %edx
  104fbe:	84 c0                	test   %al,%al
  104fc0:	75 0f                	jne    104fd1 <execute+0x50>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  104fc2:	68 01 4e 12 00       	push   $0x124e01
  104fc7:	ff 73 14             	pushl  0x14(%ebx)
  104fca:	e8 67 fd ff ff       	call   104d36 <shell_raw_fprintf>
  104fcf:	5e                   	pop    %esi
  104fd0:	5f                   	pop    %edi
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
  104fd1:	6a 14                	push   $0x14
  104fd3:	8b 43 08             	mov    0x8(%ebx),%eax
  104fd6:	6a 00                	push   $0x0
  104fd8:	83 c0 0c             	add    $0xc,%eax
  104fdb:	50                   	push   %eax
  104fdc:	e8 7a 6e 00 00       	call   10be5b <memset>
  104fe1:	83 c4 0c             	add    $0xc,%esp
	shell_cmd_trim(shell);
  104fe4:	53                   	push   %ebx
  104fe5:	e8 e1 16 00 00       	call   1066cb <shell_cmd_trim>
		    shell->ctx->cmd_buff_len);
  104fea:	8b 43 08             	mov    0x8(%ebx),%eax
	history_put(shell, shell->ctx->cmd_buff,
  104fed:	83 c0 46             	add    $0x46,%eax
  104ff0:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
	shell_history_put(shell->history, line, length);
  104ff4:	89 14 24             	mov    %edx,(%esp)
  104ff7:	50                   	push   %eax
  104ff8:	ff 73 0c             	pushl  0xc(%ebx)
  104ffb:	e8 2f 2b 00 00       	call   107b2f <shell_history_put>
  105000:	83 c4 0c             	add    $0xc,%esp
		shell_wildcard_prepare(shell);
  105003:	53                   	push   %ebx
  105004:	e8 0b 30 00 00       	call   108014 <shell_wildcard_prepare>
	if (parent != NULL) {
  105009:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
		shell_wildcard_prepare(shell);
  10500d:	59                   	pop    %ecx
	if (parent != NULL) {
  10500e:	0f 84 90 00 00 00    	je     1050a4 <execute+0x123>
		argv[0] = parent->syntax;
  105014:	8b 45 8c             	mov    -0x74(%ebp),%eax
  105017:	8b 00                	mov    (%eax),%eax
  105019:	89 45 c0             	mov    %eax,-0x40(%ebp)
		argv[1] = cmd_buf;
  10501c:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
  105022:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if (entry->handler) {
  105025:	8b 45 8c             	mov    -0x74(%ebp),%eax
  105028:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  10502c:	74 43                	je     105071 <execute+0xf0>
  10502e:	8b 45 90             	mov    -0x70(%ebp),%eax
		*active_cmd = *entry;
  105031:	b9 05 00 00 00       	mov    $0x5,%ecx
  105036:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  10503c:	8b 43 08             	mov    0x8(%ebx),%eax
  10503f:	8b 75 8c             	mov    -0x74(%ebp),%esi
	size_t argc = 0, args_left = SIZE_MAX;
  105042:	c7 45 84 ff ff ff ff 	movl   $0xffffffff,-0x7c(%ebp)
		*active_cmd = *entry;
  105049:	8d 78 0c             	lea    0xc(%eax),%edi
		if ((entry->subcmd == NULL)
  10504c:	8b 45 8c             	mov    -0x74(%ebp),%eax
		*active_cmd = *entry;
  10504f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		if ((entry->subcmd == NULL)
  105051:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  105055:	75 2b                	jne    105082 <execute+0x101>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
  105057:	80 78 11 fe          	cmpb   $0xfe,0x11(%eax)
  10505b:	75 25                	jne    105082 <execute+0x101>
			*args_left = entry->args.mandatory - 1;
  10505d:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  105061:	48                   	dec    %eax
  105062:	89 45 84             	mov    %eax,-0x7c(%ebp)
			*lvl = *lvl + 1;
  105065:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  10506b:	40                   	inc    %eax
  10506c:	89 45 90             	mov    %eax,-0x70(%ebp)
  10506f:	eb 11                	jmp    105082 <execute+0x101>
	size_t argc = 0, args_left = SIZE_MAX;
  105071:	c7 45 84 ff ff ff ff 	movl   $0xffffffff,-0x7c(%ebp)
	size_t cmd_with_handler_lvl = 0;
  105078:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
  10507f:	00 00 00 
	if (entry->help) {
  105082:	8b 45 8c             	mov    -0x74(%ebp),%eax
  105085:	8b 40 04             	mov    0x4(%eax),%eax
  105088:	85 c0                	test   %eax,%eax
  10508a:	74 10                	je     10509c <execute+0x11b>
		*help_entry = *entry;
  10508c:	8d 7d ac             	lea    -0x54(%ebp),%edi
  10508f:	b9 05 00 00 00       	mov    $0x5,%ecx
  105094:	8b 75 8c             	mov    -0x74(%ebp),%esi
  105097:	89 45 80             	mov    %eax,-0x80(%ebp)
  10509a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		cmd_lvl++;
  10509c:	ff 45 90             	incl   -0x70(%ebp)
		argvp = &argv[1];
  10509f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  1050a2:	eb 1b                	jmp    1050bf <execute+0x13e>
		help_entry.help = NULL;
  1050a4:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
	size_t argc = 0, args_left = SIZE_MAX;
  1050ab:	c7 45 84 ff ff ff ff 	movl   $0xffffffff,-0x7c(%ebp)
	size_t cmd_with_handler_lvl = 0;
  1050b2:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
  1050b9:	00 00 00 
		argvp = &argv[0];
  1050bc:	8d 45 c0             	lea    -0x40(%ebp),%eax
  1050bf:	89 45 88             	mov    %eax,-0x78(%ebp)
				continue;
  1050c2:	c6 85 78 ff ff ff 00 	movb   $0x0,-0x88(%ebp)
  1050c9:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
  1050d0:	31 d2                	xor    %edx,%edx
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
  1050d2:	83 7d 94 01          	cmpl   $0x1,-0x6c(%ebp)
  1050d6:	8b 45 90             	mov    -0x70(%ebp),%eax
  1050d9:	75 0f                	jne    1050ea <execute+0x169>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
  1050db:	83 7d 90 0b          	cmpl   $0xb,-0x70(%ebp)
  1050df:	0f 87 3e 02 00 00    	ja     105323 <execute+0x3a2>
  1050e5:	e9 4e 02 00 00       	jmp    105338 <execute+0x3b7>
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
  1050ea:	83 f8 0b             	cmp    $0xb,%eax
  1050ed:	0f 96 c0             	setbe  %al
		&& args_left > 0) {
  1050f0:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
  1050f4:	0f 95 c1             	setne  %cl
  1050f7:	20 c8                	and    %cl,%al
  1050f9:	89 c6                	mov    %eax,%esi
  1050fb:	74 de                	je     1050db <execute+0x15a>
		quote = shell_make_argv(&argc, argvp, cmd_buf, 2);
  1050fd:	6a 02                	push   $0x2
  1050ff:	8d 45 94             	lea    -0x6c(%ebp),%eax
  105102:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  105108:	ff 75 88             	pushl  -0x78(%ebp)
  10510b:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  105111:	50                   	push   %eax
  105112:	e8 a5 11 00 00       	call   1062bc <shell_make_argv>
		cmd_buf = (char *)argvp[1];
  105117:	8b 4d 88             	mov    -0x78(%ebp),%ecx
		quote = shell_make_argv(&argc, argvp, cmd_buf, 2);
  10511a:	83 c4 10             	add    $0x10,%esp
		if (argc == 0) {
  10511d:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
		cmd_buf = (char *)argvp[1];
  105123:	8b 79 04             	mov    0x4(%ecx),%edi
		if (argc == 0) {
  105126:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
		cmd_buf = (char *)argvp[1];
  105129:	89 bd 70 ff ff ff    	mov    %edi,-0x90(%ebp)
		if (argc == 0) {
  10512f:	85 c9                	test   %ecx,%ecx
  105131:	74 1b                	je     10514e <execute+0x1cd>
		} else if ((argc == 1) && (quote != 0)) {
  105133:	84 c0                	test   %al,%al
  105135:	74 21                	je     105158 <execute+0x1d7>
  105137:	49                   	dec    %ecx
  105138:	75 1e                	jne    105158 <execute+0x1d7>
			shell_internal_fprintf(shell, SHELL_ERROR,
  10513a:	0f be c0             	movsbl %al,%eax
  10513d:	50                   	push   %eax
  10513e:	68 e4 4f 12 00       	push   $0x124fe4
  105143:	6a 02                	push   $0x2
  105145:	53                   	push   %ebx
  105146:	e8 cd 1b 00 00       	call   106d18 <shell_internal_fprintf>
  10514b:	83 c4 10             	add    $0x10,%esp
			return -ENOEXEC;
  10514e:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  105153:	e9 08 03 00 00       	jmp    105460 <execute+0x4df>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  105158:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
  10515c:	0f 84 aa 00 00 00    	je     10520c <execute+0x28b>
		    (!strcmp(argvp[0], "-h") ||
  105162:	8b 45 88             	mov    -0x78(%ebp),%eax
  105165:	68 f8 4f 12 00       	push   $0x124ff8
  10516a:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  105170:	ff 30                	pushl  (%eax)
  105172:	e8 b8 6b 00 00       	call   10bd2f <strcmp>
  105177:	5f                   	pop    %edi
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  105178:	85 c0                	test   %eax,%eax
		    (!strcmp(argvp[0], "-h") ||
  10517a:	5a                   	pop    %edx
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
  10517b:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
  105181:	75 17                	jne    10519a <execute+0x219>
			if (help_entry.help) {
  105183:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
  105187:	74 34                	je     1051bd <execute+0x23c>
				shell->ctx->active_cmd = help_entry;
  105189:	8b 45 80             	mov    -0x80(%ebp),%eax
  10518c:	89 45 b0             	mov    %eax,-0x50(%ebp)
  10518f:	8b 43 08             	mov    0x8(%ebx),%eax
  105192:	8d 78 0c             	lea    0xc(%eax),%edi
  105195:	e9 0e 02 00 00       	jmp    1053a8 <execute+0x427>
		     !strcmp(argvp[0], "--help"))) {
  10519a:	8b 45 88             	mov    -0x78(%ebp),%eax
  10519d:	68 fb 4f 12 00       	push   $0x124ffb
  1051a2:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  1051a8:	ff 30                	pushl  (%eax)
  1051aa:	e8 80 6b 00 00       	call   10bd2f <strcmp>
  1051af:	5a                   	pop    %edx
		    (!strcmp(argvp[0], "-h") ||
  1051b0:	85 c0                	test   %eax,%eax
		     !strcmp(argvp[0], "--help"))) {
  1051b2:	59                   	pop    %ecx
		    (!strcmp(argvp[0], "-h") ||
  1051b3:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
  1051b9:	75 0c                	jne    1051c7 <execute+0x246>
  1051bb:	eb c6                	jmp    105183 <execute+0x202>
			shell_internal_fprintf(shell, SHELL_ERROR,
  1051bd:	68 02 50 12 00       	push   $0x125002
  1051c2:	e9 97 00 00 00       	jmp    10525e <execute+0x2dd>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
  1051c7:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
  1051cb:	74 3f                	je     10520c <execute+0x28b>
			status = shell_wildcard_process(shell, entry,
  1051cd:	8b 45 88             	mov    -0x78(%ebp),%eax
  1051d0:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  1051d6:	ff 30                	pushl  (%eax)
  1051d8:	52                   	push   %edx
  1051d9:	53                   	push   %ebx
  1051da:	e8 a0 2e 00 00       	call   10807f <shell_wildcard_process>
  1051df:	83 c4 0c             	add    $0xc,%esp
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
  1051e2:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
  1051e8:	83 f8 02             	cmp    $0x2,%eax
  1051eb:	0f 84 ea fe ff ff    	je     1050db <execute+0x15a>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
  1051f1:	83 f8 03             	cmp    $0x3,%eax
  1051f4:	74 16                	je     10520c <execute+0x28b>
				wildcard_found = true;
  1051f6:	89 f0                	mov    %esi,%eax
				++cmd_lvl;
  1051f8:	ff 45 90             	incl   -0x70(%ebp)
				wildcard_found = true;
  1051fb:	88 85 77 ff ff ff    	mov    %al,-0x89(%ebp)
				continue;
  105201:	8b b5 78 ff ff ff    	mov    -0x88(%ebp),%esi
  105207:	e9 0a 01 00 00       	jmp    105316 <execute+0x395>
		if (has_last_handler == false) {
  10520c:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
  105213:	75 16                	jne    10522b <execute+0x2aa>
			entry = shell_find_cmd(parent, argvp[0], &dloc);
  105215:	8d 45 98             	lea    -0x68(%ebp),%eax
  105218:	50                   	push   %eax
  105219:	8b 45 88             	mov    -0x78(%ebp),%eax
  10521c:	ff 30                	pushl  (%eax)
  10521e:	ff 75 8c             	pushl  -0x74(%ebp)
  105221:	e8 4e 13 00 00       	call   106574 <shell_find_cmd>
  105226:	83 c4 0c             	add    $0xc,%esp
  105229:	89 c2                	mov    %eax,%edx
		argvp++;
  10522b:	83 45 88 04          	addl   $0x4,-0x78(%ebp)
		args_left--;
  10522f:	ff 4d 84             	decl   -0x7c(%ebp)
		if (entry) {
  105232:	85 d2                	test   %edx,%edx
  105234:	0f 84 88 00 00 00    	je     1052c2 <execute+0x341>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
  10523a:	80 bd 77 ff ff ff 00 	cmpb   $0x0,-0x89(%ebp)
  105241:	74 2b                	je     10526e <execute+0x2ed>
  105243:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  105247:	74 61                	je     1052aa <execute+0x329>
		shell_op_cursor_end_move(shell);
  105249:	53                   	push   %ebx
  10524a:	e8 33 18 00 00       	call   106a82 <shell_op_cursor_end_move>
		shell_op_cond_next_line(shell);
  10524f:	89 1c 24             	mov    %ebx,(%esp)
  105252:	e8 12 16 00 00       	call   106869 <shell_op_cond_next_line>
		shell_internal_fprintf(shell, SHELL_ERROR,
  105257:	c7 04 24 20 50 12 00 	movl   $0x125020,(%esp)
  10525e:	6a 02                	push   $0x2
  105260:	53                   	push   %ebx
  105261:	e8 b2 1a 00 00       	call   106d18 <shell_internal_fprintf>
  105266:	83 c4 0c             	add    $0xc,%esp
		return false;
  105269:	e9 e0 fe ff ff       	jmp    10514e <execute+0x1cd>
	if (entry->handler) {
  10526e:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  105272:	74 36                	je     1052aa <execute+0x329>
  105274:	8b 45 90             	mov    -0x70(%ebp),%eax
		*active_cmd = *entry;
  105277:	b9 05 00 00 00       	mov    $0x5,%ecx
  10527c:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  105282:	8b 43 08             	mov    0x8(%ebx),%eax
  105285:	89 d6                	mov    %edx,%esi
  105287:	8d 78 0c             	lea    0xc(%eax),%edi
  10528a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		if ((entry->subcmd == NULL)
  10528c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  105290:	75 18                	jne    1052aa <execute+0x329>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
  105292:	80 7a 11 fe          	cmpb   $0xfe,0x11(%edx)
  105296:	75 12                	jne    1052aa <execute+0x329>
			*args_left = entry->args.mandatory - 1;
  105298:	0f b6 42 10          	movzbl 0x10(%edx),%eax
  10529c:	48                   	dec    %eax
  10529d:	89 45 84             	mov    %eax,-0x7c(%ebp)
			*lvl = *lvl + 1;
  1052a0:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  1052a6:	40                   	inc    %eax
  1052a7:	89 45 90             	mov    %eax,-0x70(%ebp)
	if (entry->help) {
  1052aa:	8b 42 04             	mov    0x4(%edx),%eax
  1052ad:	85 c0                	test   %eax,%eax
  1052af:	74 4d                	je     1052fe <execute+0x37d>
		*help_entry = *entry;
  1052b1:	8d 7d ac             	lea    -0x54(%ebp),%edi
  1052b4:	b9 05 00 00 00       	mov    $0x5,%ecx
  1052b9:	89 d6                	mov    %edx,%esi
  1052bb:	89 45 80             	mov    %eax,-0x80(%ebp)
  1052be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  1052c0:	eb 3c                	jmp    1052fe <execute+0x37d>
			if (cmd_lvl == 0 &&
  1052c2:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
  1052c6:	75 3f                	jne    105307 <execute+0x386>

void shell_cmd_trim(const struct shell *shell);

static inline bool shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
  1052c8:	8b 43 08             	mov    0x8(%ebx),%eax
  1052cb:	8b 40 20             	mov    0x20(%eax),%eax
  1052ce:	85 c0                	test   %eax,%eax
  1052d0:	74 06                	je     1052d8 <execute+0x357>
				(!shell_in_select_mode(shell) ||
  1052d2:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  1052d6:	75 2f                	jne    105307 <execute+0x386>
				shell_internal_fprintf(shell, SHELL_ERROR,
  1052d8:	68 4f 50 12 00       	push   $0x12504f
  1052dd:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
  1052e3:	ff 75 c0             	pushl  -0x40(%ebp)
  1052e6:	68 a1 69 12 00       	push   $0x1269a1
  1052eb:	6a 02                	push   $0x2
  1052ed:	53                   	push   %ebx
  1052ee:	e8 25 1a 00 00       	call   106d18 <shell_internal_fprintf>
  1052f3:	83 c4 14             	add    $0x14,%esp
  1052f6:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
  1052fc:	eb 09                	jmp    105307 <execute+0x386>
  1052fe:	8b b5 78 ff ff ff    	mov    -0x88(%ebp),%esi
  105304:	89 55 8c             	mov    %edx,-0x74(%ebp)
		if (args_left || (argc == 2)) {
  105307:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
  10530b:	75 06                	jne    105313 <execute+0x392>
  10530d:	83 7d 94 02          	cmpl   $0x2,-0x6c(%ebp)
  105311:	75 03                	jne    105316 <execute+0x395>
			cmd_lvl++;
  105313:	ff 45 90             	incl   -0x70(%ebp)
				continue;
  105316:	89 f0                	mov    %esi,%eax
  105318:	88 85 78 ff ff ff    	mov    %al,-0x88(%ebp)
  10531e:	e9 af fd ff ff       	jmp    1050d2 <execute+0x151>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
  105323:	83 7d 94 02          	cmpl   $0x2,-0x6c(%ebp)
  105327:	75 0f                	jne    105338 <execute+0x3b7>
		shell_internal_fprintf(shell, SHELL_ERROR,
  105329:	68 63 50 12 00       	push   $0x125063
  10532e:	68 74 69 12 00       	push   $0x126974
  105333:	e9 0b fe ff ff       	jmp    105143 <execute+0x1c2>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
  105338:	80 bd 77 ff ff ff 00 	cmpb   $0x0,-0x89(%ebp)
  10533f:	74 3b                	je     10537c <execute+0x3fb>
		shell_wildcard_finalize(shell);
  105341:	53                   	push   %ebx
  105342:	e8 83 2e 00 00       	call   1081ca <shell_wildcard_finalize>
				      shell->ctx->cmd_buff,
  105347:	8b 43 08             	mov    0x8(%ebx),%eax
		(void)shell_make_argv(&cmd_lvl,
  10534a:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
				      &argv[shell->ctx->selected_cmd ? 1 : 0],
  105351:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
				      shell->ctx->cmd_buff,
  105355:	8d 50 46             	lea    0x46(%eax),%edx
				      &argv[shell->ctx->selected_cmd ? 1 : 0],
  105358:	0f 95 c0             	setne  %al
  10535b:	0f b6 c0             	movzbl %al,%eax
		(void)shell_make_argv(&cmd_lvl,
  10535e:	52                   	push   %edx
  10535f:	8d 44 85 c0          	lea    -0x40(%ebp,%eax,4),%eax
  105363:	50                   	push   %eax
  105364:	8d 45 90             	lea    -0x70(%ebp),%eax
  105367:	50                   	push   %eax
  105368:	e8 4f 0f 00 00       	call   1062bc <shell_make_argv>
		if (shell->ctx->selected_cmd) {
  10536d:	8b 43 08             	mov    0x8(%ebx),%eax
		(void)shell_make_argv(&cmd_lvl,
  105370:	83 c4 10             	add    $0x10,%esp
		if (shell->ctx->selected_cmd) {
  105373:	83 78 20 00          	cmpl   $0x0,0x20(%eax)
  105377:	74 03                	je     10537c <execute+0x3fb>
			cmd_lvl++;
  105379:	ff 45 90             	incl   -0x70(%ebp)
	argv[cmd_lvl] = NULL;
  10537c:	8b 75 90             	mov    -0x70(%ebp),%esi
	if (shell->ctx->active_cmd.handler == NULL) {
  10537f:	8b 7b 08             	mov    0x8(%ebx),%edi
	argv[cmd_lvl] = NULL;
  105382:	c7 44 b5 c0 00 00 00 	movl   $0x0,-0x40(%ebp,%esi,4)
  105389:	00 
	if (shell->ctx->active_cmd.handler == NULL) {
  10538a:	83 7f 18 00          	cmpl   $0x0,0x18(%edi)
  10538e:	75 33                	jne    1053c3 <execute+0x442>
			if (help_entry->help == NULL) {
  105390:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
  105394:	0f 84 b4 fd ff ff    	je     10514e <execute+0x1cd>
			if (help_entry->help != shell->ctx->active_cmd.help) {
  10539a:	8b 45 80             	mov    -0x80(%ebp),%eax
  10539d:	3b 47 10             	cmp    0x10(%edi),%eax
  1053a0:	74 10                	je     1053b2 <execute+0x431>
				shell->ctx->active_cmd = *help_entry;
  1053a2:	89 45 b0             	mov    %eax,-0x50(%ebp)
  1053a5:	83 c7 0c             	add    $0xc,%edi
  1053a8:	8d 75 ac             	lea    -0x54(%ebp),%esi
  1053ab:	b9 05 00 00 00       	mov    $0x5,%ecx
  1053b0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			shell_internal_help_print(shell);
  1053b2:	89 d8                	mov    %ebx,%eax
			return SHELL_CMD_HELP_PRINTED;
  1053b4:	be 01 00 00 00       	mov    $0x1,%esi
			shell_internal_help_print(shell);
  1053b9:	e8 8f f9 ff ff       	call   104d4d <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
  1053be:	e9 9d 00 00 00       	jmp    105460 <execute+0x4df>
	if (shell->ctx->active_cmd.args.mandatory) {
  1053c3:	0f b6 47 1c          	movzbl 0x1c(%edi),%eax
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
  1053c7:	2b b5 7c ff ff ff    	sub    -0x84(%ebp),%esi
	if (shell->ctx->active_cmd.args.mandatory) {
  1053cd:	84 c0                	test   %al,%al
  1053cf:	74 3b                	je     10540c <execute+0x48b>
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
  1053d1:	8a 57 1d             	mov    0x1d(%edi),%dl
				UINT16_MAX : opt8;
  1053d4:	b9 ff ff 00 00       	mov    $0xffff,%ecx
  1053d9:	80 fa ff             	cmp    $0xff,%dl
  1053dc:	74 03                	je     1053e1 <execute+0x460>
  1053de:	0f b6 ca             	movzbl %dl,%ecx
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
  1053e1:	39 c6                	cmp    %eax,%esi
  1053e3:	72 06                	jb     1053eb <execute+0x46a>
  1053e5:	01 c8                	add    %ecx,%eax
	if (!arg_cnt_ok) {
  1053e7:	39 c6                	cmp    %eax,%esi
  1053e9:	76 21                	jbe    10540c <execute+0x48b>
		shell_internal_fprintf(shell, SHELL_ERROR,
  1053eb:	ff 77 0c             	pushl  0xc(%edi)
		return -EINVAL;
  1053ee:	be ea ff ff ff       	mov    $0xffffffea,%esi
		shell_internal_fprintf(shell, SHELL_ERROR,
  1053f3:	68 87 50 12 00       	push   $0x125087
  1053f8:	6a 02                	push   $0x2
  1053fa:	53                   	push   %ebx
  1053fb:	e8 18 19 00 00       	call   106d18 <shell_internal_fprintf>
  105400:	83 c4 10             	add    $0x10,%esp
			shell_internal_help_print(shell);
  105403:	89 d8                	mov    %ebx,%eax
  105405:	e8 43 f9 ff ff       	call   104d4d <shell_internal_help_print>
	if (!ret_val) {
  10540a:	eb 54                	jmp    105460 <execute+0x4df>
	shell->ctx->internal.flags.cmd_ctx = val ? 1 : 0;
  10540c:	8b 87 64 02 00 00    	mov    0x264(%edi),%eax
  105412:	0c 80                	or     $0x80,%al
  105414:	89 87 64 02 00 00    	mov    %eax,0x264(%edi)
		k_mutex_unlock(&shell->ctx->wr_mtx);
  10541a:	8d 87 f8 02 00 00    	lea    0x2f8(%edi),%eax
  105420:	e8 f2 f8 ff ff       	call   104d17 <k_mutex_unlock>
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
  105425:	8b bd 7c ff ff ff    	mov    -0x84(%ebp),%edi
  10542b:	8d 54 bd c0          	lea    -0x40(%ebp,%edi,4),%edx
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
  10542f:	8b 43 08             	mov    0x8(%ebx),%eax
  105432:	52                   	push   %edx
  105433:	56                   	push   %esi
  105434:	53                   	push   %ebx
  105435:	ff 50 18             	call   *0x18(%eax)
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105438:	83 ca ff             	or     $0xffffffff,%edx
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
  10543b:	89 c6                	mov    %eax,%esi
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  10543d:	8b 43 08             	mov    0x8(%ebx),%eax
  105440:	89 d1                	mov    %edx,%ecx
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
  105442:	83 c4 0c             	add    $0xc,%esp
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105445:	05 f8 02 00 00       	add    $0x2f8,%eax
  10544a:	e8 b7 f9 ff ff       	call   104e06 <k_mutex_lock.constprop.0>
  10544f:	8b 53 08             	mov    0x8(%ebx),%edx
  105452:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  105458:	24 7f                	and    $0x7f,%al
  10545a:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
}
  105460:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105463:	89 f0                	mov    %esi,%eax
  105465:	5b                   	pop    %ebx
  105466:	5e                   	pop    %esi
  105467:	5f                   	pop    %edi
  105468:	5d                   	pop    %ebp
  105469:	c3                   	ret    

0010546a <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
  10546a:	55                   	push   %ebp
  10546b:	89 e5                	mov    %esp,%ebp
  10546d:	57                   	push   %edi
  10546e:	56                   	push   %esi
  10546f:	53                   	push   %ebx
  105470:	81 ec a8 00 00 00    	sub    $0xa8,%esp
  105476:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  105479:	8b 43 08             	mov    0x8(%ebx),%eax
  10547c:	f0 83 88 64 02 00 00 	lock orl $0x8,0x264(%eax)
  105483:	08 
	internal.flags.processing = 1U;

	(void)atomic_or((atomic_t *)&shell->ctx->internal.value,
			internal.value);

	switch (shell->ctx->state) {
  105484:	8b 43 08             	mov    0x8(%ebx),%eax
  105487:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
  10548b:	0f 85 3c 08 00 00    	jne    105ccd <shell_process+0x863>
	size_t count = 0;
  105491:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
  105498:	00 00 00 
		(void)shell->iface->api->read(shell->iface, &data,
  10549b:	8b 43 04             	mov    0x4(%ebx),%eax
  10549e:	8d 8d 78 ff ff ff    	lea    -0x88(%ebp),%ecx
  1054a4:	8b 10                	mov    (%eax),%edx
  1054a6:	51                   	push   %ecx
  1054a7:	6a 01                	push   $0x1
  1054a9:	8d 8d 77 ff ff ff    	lea    -0x89(%ebp),%ecx
  1054af:	51                   	push   %ecx
  1054b0:	50                   	push   %eax
  1054b1:	ff 52 10             	call   *0x10(%edx)
  1054b4:	83 c4 10             	add    $0x10,%esp
		if (count == 0) {
  1054b7:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
  1054be:	0f 84 09 08 00 00    	je     105ccd <shell_process+0x863>
		if (ascii_filter(data) != 0) {
  1054c4:	8a 95 77 ff ff ff    	mov    -0x89(%ebp),%dl
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
  1054ca:	84 d2                	test   %dl,%dl
  1054cc:	78 cd                	js     10549b <shell_process+0x31>
		switch (shell->ctx->receive_state) {
  1054ce:	8b 43 08             	mov    0x8(%ebx),%eax
  1054d1:	8b 78 08             	mov    0x8(%eax),%edi
  1054d4:	83 ff 01             	cmp    $0x1,%edi
  1054d7:	0f 84 56 07 00 00    	je     105c33 <shell_process+0x7c9>
  1054dd:	83 ff 02             	cmp    $0x2,%edi
  1054e0:	0f 84 85 07 00 00    	je     105c6b <shell_process+0x801>
  1054e6:	85 ff                	test   %edi,%edi
  1054e8:	0f 85 d3 07 00 00    	jne    105cc1 <shell_process+0x857>
	if ((data != '\r') && (data != '\n')) {
  1054ee:	80 fa 0d             	cmp    $0xd,%dl
  1054f1:	74 0e                	je     105501 <shell_process+0x97>
  1054f3:	80 fa 0a             	cmp    $0xa,%dl
  1054f6:	74 09                	je     105501 <shell_process+0x97>
	shell->ctx->internal.flags.last_nl = val;
  1054f8:	c6 80 65 02 00 00 00 	movb   $0x0,0x265(%eax)
		return false;
  1054ff:	eb 5a                	jmp    10555b <shell_process+0xf1>
	return shell->ctx->internal.flags.last_nl;
  105501:	8a 88 65 02 00 00    	mov    0x265(%eax),%cl
	if ((flag_last_nl_get(shell) == 0U) ||
  105507:	84 c9                	test   %cl,%cl
  105509:	74 0a                	je     105515 <shell_process+0xab>
  10550b:	8a 88 65 02 00 00    	mov    0x265(%eax),%cl
  105511:	38 ca                	cmp    %cl,%dl
  105513:	75 46                	jne    10555b <shell_process+0xf1>
				if (!shell->ctx->cmd_buff_len) {
  105515:	66 83 78 40 00       	cmpw   $0x0,0x40(%eax)
	shell->ctx->internal.flags.last_nl = val;
  10551a:	88 90 65 02 00 00    	mov    %dl,0x265(%eax)
  105520:	75 2d                	jne    10554f <shell_process+0xe5>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  105522:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105528:	83 e2 bf             	and    $0xffffffbf,%edx
  10552b:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	shell_history_mode_exit(shell->history);
  105531:	ff 73 0c             	pushl  0xc(%ebx)
  105534:	e8 4f 25 00 00       	call   107a88 <shell_history_mode_exit>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  105539:	c7 04 24 01 4e 12 00 	movl   $0x124e01,(%esp)
  105540:	ff 73 14             	pushl  0x14(%ebx)
  105543:	e8 ee f7 ff ff       	call   104d36 <shell_raw_fprintf>
  105548:	59                   	pop    %ecx
  105549:	5e                   	pop    %esi
}
  10554a:	e9 09 06 00 00       	jmp    105b58 <shell_process+0x6ee>
					(void)execute(shell);
  10554f:	89 d8                	mov    %ebx,%eax
  105551:	e8 2b fa ff ff       	call   104f81 <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
  105556:	e9 fd 05 00 00       	jmp    105b58 <shell_process+0x6ee>
			switch (data) {
  10555b:	80 fa 09             	cmp    $0x9,%dl
  10555e:	74 37                	je     105597 <shell_process+0x12d>
  105560:	7f 16                	jg     105578 <shell_process+0x10e>
  105562:	84 d2                	test   %dl,%dl
  105564:	0f 84 31 ff ff ff    	je     10549b <shell_process+0x31>
  10556a:	80 fa 08             	cmp    $0x8,%dl
  10556d:	0f 84 e1 04 00 00    	je     105a54 <shell_process+0x5ea>
  105573:	e9 4d 05 00 00       	jmp    105ac5 <shell_process+0x65b>
  105578:	80 fa 1b             	cmp    $0x1b,%dl
  10557b:	74 0e                	je     10558b <shell_process+0x121>
  10557d:	80 fa 7f             	cmp    $0x7f,%dl
  105580:	0f 84 ee 04 00 00    	je     105a74 <shell_process+0x60a>
  105586:	e9 3a 05 00 00       	jmp    105ac5 <shell_process+0x65b>
	shell->ctx->receive_state = state;
  10558b:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
}
  105592:	e9 04 ff ff ff       	jmp    10549b <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1;
  105597:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
				if (flag_echo_get(shell)) {
  10559d:	80 e2 04             	and    $0x4,%dl
  1055a0:	0f 84 f5 fe ff ff    	je     10549b <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  1055a6:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  1055ac:	83 ca 40             	or     $0x40,%edx
  1055af:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	if (compl_space == 0U) {
  1055b5:	66 81 78 40 ff 00    	cmpw   $0xff,0x40(%eax)
  1055bb:	0f 84 da fe ff ff    	je     10549b <shell_process+0x31>
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
  1055c1:	0f b7 50 42          	movzwl 0x42(%eax),%edx
  1055c5:	52                   	push   %edx
  1055c6:	8d 50 46             	lea    0x46(%eax),%edx
  1055c9:	52                   	push   %edx
  1055ca:	05 46 01 00 00       	add    $0x146,%eax
  1055cf:	50                   	push   %eax
  1055d0:	e8 17 68 00 00       	call   10bdec <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  1055d5:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
  1055d8:	83 c4 0c             	add    $0xc,%esp
	(void)shell_make_argv(argc, *argv, shell->ctx->temp_buff,
  1055db:	05 46 01 00 00       	add    $0x146,%eax
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
  1055e0:	0f b7 90 fc fe ff ff 	movzwl -0x104(%eax),%edx
  1055e7:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
	(void)shell_make_argv(argc, *argv, shell->ctx->temp_buff,
  1055eb:	6a 0c                	push   $0xc
  1055ed:	50                   	push   %eax
  1055ee:	8d 45 c0             	lea    -0x40(%ebp),%eax
  1055f1:	50                   	push   %eax
  1055f2:	8d 45 80             	lea    -0x80(%ebp),%eax
  1055f5:	50                   	push   %eax
  1055f6:	e8 c1 0c 00 00       	call   1062bc <shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
  1055fb:	8b 45 80             	mov    -0x80(%ebp),%eax
	(void)shell_make_argv(argc, *argv, shell->ctx->temp_buff,
  1055fe:	83 c4 10             	add    $0x10,%esp
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
  105601:	83 f8 0c             	cmp    $0xc,%eax
  105604:	0f 87 91 fe ff ff    	ja     10549b <shell_process+0x31>
	(*argv)[*argc] = NULL;
  10560a:	c7 44 85 c0 00 00 00 	movl   $0x0,-0x40(%ebp,%eax,4)
  105611:	00 
	int space = isspace((int)shell->ctx->cmd_buff[
  105612:	8b 53 08             	mov    0x8(%ebx),%edx
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  105615:	85 c0                	test   %eax,%eax
  105617:	74 1d                	je     105636 <shell_process+0x1cc>
						shell->ctx->cmd_buff_pos - 1]);
  105619:	0f b7 4a 42          	movzwl 0x42(%edx),%ecx
	int space = isspace((int)shell->ctx->cmd_buff[
  10561d:	0f be 74 0a 45       	movsbl 0x45(%edx,%ecx,1),%esi
  105622:	89 f1                	mov    %esi,%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  105624:	83 ee 09             	sub    $0x9,%esi
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
  105627:	83 fe 04             	cmp    $0x4,%esi
  10562a:	76 20                	jbe    10564c <shell_process+0x1e2>
  10562c:	80 f9 20             	cmp    $0x20,%cl
  10562f:	74 1b                	je     10564c <shell_process+0x1e2>
  105631:	83 f8 01             	cmp    $0x1,%eax
  105634:	75 15                	jne    10564b <shell_process+0x1e1>
		*cmd = shell->ctx->selected_cmd;
  105636:	8b 42 20             	mov    0x20(%edx),%eax
		*complete_arg_idx = SHELL_CMD_ROOT_LVL;
  105639:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
  105640:	00 00 00 
		*cmd = shell->ctx->selected_cmd;
  105643:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
	if (tab_possible == false) {
  105649:	eb 2c                	jmp    105677 <shell_process+0x20d>
	search_argc = space ? *argc : *argc - 1;
  10564b:	48                   	dec    %eax
	*cmd = shell_get_last_command(shell->ctx->selected_cmd, search_argc,
  10564c:	6a 00                	push   $0x0
  10564e:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
  105651:	51                   	push   %ecx
  105652:	8d 8d 7c ff ff ff    	lea    -0x84(%ebp),%ecx
  105658:	51                   	push   %ecx
  105659:	8d 4d c0             	lea    -0x40(%ebp),%ecx
  10565c:	51                   	push   %ecx
  10565d:	50                   	push   %eax
  10565e:	ff 72 20             	pushl  0x20(%edx)
  105661:	e8 46 0f 00 00       	call   1065ac <shell_get_last_command>
  105666:	83 c4 18             	add    $0x18,%esp
  105669:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
	if ((*cmd == NULL) && (search_argc != 0)) {
  10566f:	85 c0                	test   %eax,%eax
  105671:	0f 84 24 fe ff ff    	je     10549b <shell_process+0x31>
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
  105677:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  10567d:	8b 74 85 c0          	mov    -0x40(%ebp,%eax,4),%esi
	size_t incompl_cmd_len = shell_strlen(incompl_cmd);
  105681:	89 f0                	mov    %esi,%eax
  105683:	e8 9b f6 ff ff       	call   104d23 <shell_strlen>
	*cnt = 0;
  105688:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
  10568f:	00 00 00 
	size_t incompl_cmd_len = shell_strlen(incompl_cmd);
  105692:	0f b7 c0             	movzwl %ax,%eax
  105695:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
	size_t first = 0;
  10569b:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
  1056a2:	00 00 00 
	*longest = 0U;
  1056a5:	66 c7 85 60 ff ff ff 	movw   $0x0,-0xa0(%ebp)
  1056ac:	00 00 
	while ((candidate = shell_cmd_get(cmd, idx, &dloc)) != NULL) {
  1056ae:	8d 45 ac             	lea    -0x54(%ebp),%eax
  1056b1:	50                   	push   %eax
  1056b2:	57                   	push   %edi
  1056b3:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  1056b9:	e8 5b 0e 00 00       	call   106519 <shell_cmd_get>
  1056be:	83 c4 0c             	add    $0xc,%esp
  1056c1:	89 c2                	mov    %eax,%edx
  1056c3:	85 c0                	test   %eax,%eax
  1056c5:	74 55                	je     10571c <shell_process+0x2b2>
	return (strncmp(candidate, str, len) == 0) ? true : false;
  1056c7:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  1056cd:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
  1056d3:	56                   	push   %esi
  1056d4:	ff 32                	pushl  (%edx)
  1056d6:	e8 74 66 00 00       	call   10bd4f <strncmp>
  1056db:	83 c4 0c             	add    $0xc,%esp
		if (is_candidate) {
  1056de:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
  1056e4:	85 c0                	test   %eax,%eax
  1056e6:	75 31                	jne    105719 <shell_process+0x2af>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
  1056e8:	ff 32                	pushl  (%edx)
  1056ea:	e8 2d 66 00 00       	call   10bd1c <strlen>
  1056ef:	5a                   	pop    %edx
  1056f0:	0f b7 95 60 ff ff ff 	movzwl -0xa0(%ebp),%edx
  1056f7:	39 c2                	cmp    %eax,%edx
  1056f9:	73 02                	jae    1056fd <shell_process+0x293>
  1056fb:	89 c2                	mov    %eax,%edx
			if (*cnt == 0) {
  1056fd:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
  105704:	66 89 95 60 ff ff ff 	mov    %dx,-0xa0(%ebp)
			if (*cnt == 0) {
  10570b:	75 06                	jne    105713 <shell_process+0x2a9>
				*first_idx = idx;
  10570d:	89 bd 68 ff ff ff    	mov    %edi,-0x98(%ebp)
			(*cnt)++;
  105713:	ff 85 6c ff ff ff    	incl   -0x94(%ebp)
		idx++;
  105719:	47                   	inc    %edi
  10571a:	eb 92                	jmp    1056ae <shell_process+0x244>
	if (cnt == 1) {
  10571c:	83 bd 6c ff ff ff 01 	cmpl   $0x1,-0x94(%ebp)
  105723:	0f 85 b3 00 00 00    	jne    1057dc <shell_process+0x372>
		autocomplete(shell, cmd, argv[arg_idx], first);
  105729:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
	uint16_t arg_len = shell_strlen(arg);
  10572f:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
  105733:	e8 eb f5 ff ff       	call   104d23 <shell_strlen>
  105738:	0f b7 f0             	movzwl %ax,%esi
	match = shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
  10573b:	8b 43 08             	mov    0x8(%ebx),%eax
  10573e:	83 c0 0c             	add    $0xc,%eax
  105741:	50                   	push   %eax
  105742:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
  105748:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  10574e:	e8 c6 0d 00 00       	call   106519 <shell_cmd_get>
  105753:	83 c4 0c             	add    $0xc,%esp
  105756:	89 c7                	mov    %eax,%edi
	cmd_len = shell_strlen(match->syntax);
  105758:	8b 00                	mov    (%eax),%eax
  10575a:	e8 c4 f5 ff ff       	call   104d23 <shell_strlen>
	if (cmd_len != arg_len) {
  10575f:	66 39 c6             	cmp    %ax,%si
  105762:	74 12                	je     105776 <shell_process+0x30c>
					   cmd_len - arg_len);
  105764:	29 f0                	sub    %esi,%eax
		shell_op_completion_insert(shell,
  105766:	03 37                	add    (%edi),%esi
  105768:	0f b7 c0             	movzwl %ax,%eax
  10576b:	50                   	push   %eax
  10576c:	56                   	push   %esi
  10576d:	53                   	push   %ebx
  10576e:	e8 26 18 00 00       	call   106f99 <shell_op_completion_insert>
  105773:	83 c4 0c             	add    $0xc,%esp
	if (!isspace((int) shell->ctx->cmd_buff[
  105776:	8b 43 08             	mov    0x8(%ebx),%eax
					shell->ctx->cmd_buff_pos])) {
  105779:	0f b7 50 42          	movzwl 0x42(%eax),%edx
	if (!isspace((int) shell->ctx->cmd_buff[
  10577d:	0f be 54 10 46       	movsbl 0x46(%eax,%edx,1),%edx
  105782:	89 d1                	mov    %edx,%ecx
  105784:	83 ea 09             	sub    $0x9,%edx
  105787:	83 fa 04             	cmp    $0x4,%edx
  10578a:	76 41                	jbe    1057cd <shell_process+0x363>
  10578c:	80 f9 20             	cmp    $0x20,%cl
  10578f:	74 3c                	je     1057cd <shell_process+0x363>
	return shell->ctx->internal.flags.insert_mode == 1;
  105791:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
		if (flag_insert_mode_get(shell)) {
  105797:	80 e2 01             	and    $0x1,%dl
  10579a:	74 2a                	je     1057c6 <shell_process+0x35c>
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
  10579c:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  1057a2:	83 e2 fe             	and    $0xfffffffe,%edx
  1057a5:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
			shell_op_char_insert(shell, ' ');
  1057ab:	6a 20                	push   $0x20
  1057ad:	53                   	push   %ebx
  1057ae:	e8 60 17 00 00       	call   106f13 <shell_op_char_insert>
  1057b3:	8b 53 08             	mov    0x8(%ebx),%edx
  1057b6:	5f                   	pop    %edi
  1057b7:	58                   	pop    %eax
  1057b8:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  1057be:	83 c8 01             	or     $0x1,%eax
  1057c1:	e9 62 04 00 00       	jmp    105c28 <shell_process+0x7be>
			shell_op_char_insert(shell, ' ');
  1057c6:	6a 20                	push   $0x20
  1057c8:	e9 13 03 00 00       	jmp    105ae0 <shell_process+0x676>
		shell_op_cursor_move(shell, 1);
  1057cd:	6a 01                	push   $0x1
  1057cf:	53                   	push   %ebx
  1057d0:	e8 46 11 00 00       	call   10691b <shell_op_cursor_move>
  1057d5:	59                   	pop    %ecx
  1057d6:	5e                   	pop    %esi
  1057d7:	e9 bf fc ff ff       	jmp    10549b <shell_process+0x31>
	} else if (cnt > 1) {
  1057dc:	0f 86 b9 fc ff ff    	jbe    10549b <shell_process+0x31>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
  1057e2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  1057e8:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
  1057ec:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
	size_t str_len = shell_strlen(str);
  1057f2:	e8 2c f5 ff ff       	call   104d23 <shell_strlen>
  1057f7:	0f b7 c0             	movzwl %ax,%eax
  1057fa:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		shell->ctx->vt100_ctx.printed_cmd = 0;
  105800:	8b 43 08             	mov    0x8(%ebx),%eax
  105803:	66 c7 40 3c 00 00    	movw   $0x0,0x3c(%eax)
  105809:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  10580f:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  105815:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
  10581b:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
		match = shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
  105821:	8b 43 08             	mov    0x8(%ebx),%eax
  105824:	83 c0 0c             	add    $0xc,%eax
  105827:	50                   	push   %eax
  105828:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
  10582e:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  105834:	e8 e0 0c 00 00       	call   106519 <shell_cmd_get>
		idx++;
  105839:	ff 85 5c ff ff ff    	incl   -0xa4(%ebp)
		match = shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
  10583f:	83 c4 0c             	add    $0xc,%esp
  105842:	89 c6                	mov    %eax,%esi
		if (str && match->syntax &&
  105844:	83 bd 64 ff ff ff 00 	cmpl   $0x0,-0x9c(%ebp)
  10584b:	75 14                	jne    105861 <shell_process+0x3f7>
		tab_item_print(shell, match->syntax, longest);
  10584d:	8b 3e                	mov    (%esi),%edi
	if (option == NULL) {
  10584f:	85 ff                	test   %edi,%edi
  105851:	75 2f                	jne    105882 <shell_process+0x418>
		shell->ctx->vt100_ctx.printed_cmd = 0;
  105853:	8b 43 08             	mov    0x8(%ebx),%eax
  105856:	66 c7 40 3c 00 00    	movw   $0x0,0x3c(%eax)
		return;
  10585c:	e9 cf 00 00 00       	jmp    105930 <shell_process+0x4c6>
		if (str && match->syntax &&
  105861:	8b 00                	mov    (%eax),%eax
  105863:	85 c0                	test   %eax,%eax
  105865:	74 e6                	je     10584d <shell_process+0x3e3>
	return (strncmp(candidate, str, len) == 0) ? true : false;
  105867:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
  10586d:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  105873:	50                   	push   %eax
  105874:	e8 d6 64 00 00       	call   10bd4f <strncmp>
  105879:	83 c4 0c             	add    $0xc,%esp
		if (str && match->syntax &&
  10587c:	85 c0                	test   %eax,%eax
  10587e:	74 cd                	je     10584d <shell_process+0x3e3>
  105880:	eb 9f                	jmp    105821 <shell_process+0x3b7>
	longest_option += shell_strlen(tab);
  105882:	b8 b6 49 12 00       	mov    $0x1249b6,%eax
  105887:	e8 97 f4 ff ff       	call   104d23 <shell_strlen>
  10588c:	03 85 60 ff ff ff    	add    -0xa0(%ebp),%eax
  105892:	66 89 85 5a ff ff ff 	mov    %ax,-0xa6(%ebp)
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
  105899:	8b 43 08             	mov    0x8(%ebx),%eax
  10589c:	0f b7 40 2e          	movzwl 0x2e(%eax),%eax
  1058a0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
			- shell_strlen(tab)) / longest_option;
  1058a6:	b8 b6 49 12 00       	mov    $0x1249b6,%eax
  1058ab:	e8 73 f4 ff ff       	call   104d23 <shell_strlen>
  1058b0:	0f b7 f0             	movzwl %ax,%esi
	diff = longest_option - shell_strlen(option);
  1058b3:	89 f8                	mov    %edi,%eax
  1058b5:	e8 69 f4 ff ff       	call   104d23 <shell_strlen>
  1058ba:	66 8b 8d 5a ff ff ff 	mov    -0xa6(%ebp),%cx
  1058c1:	29 c1                	sub    %eax,%ecx
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  1058c3:	8b 43 08             	mov    0x8(%ebx),%eax
	diff = longest_option - shell_strlen(option);
  1058c6:	66 89 8d 58 ff ff ff 	mov    %cx,-0xa8(%ebp)
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  1058cd:	8b 48 3c             	mov    0x3c(%eax),%ecx
  1058d0:	8d 51 01             	lea    0x1(%ecx),%edx
  1058d3:	66 89 50 3c          	mov    %dx,0x3c(%eax)
			- shell_strlen(tab)) / longest_option;
  1058d7:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
  1058dd:	29 f0                	sub    %esi,%eax
  1058df:	0f b7 b5 5a ff ff ff 	movzwl -0xa6(%ebp),%esi
  1058e6:	99                   	cltd   
  1058e7:	f7 fe                	idiv   %esi
  1058e9:	89 c6                	mov    %eax,%esi
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
  1058eb:	31 d2                	xor    %edx,%edx
  1058ed:	89 c8                	mov    %ecx,%eax
  1058ef:	66 f7 f6             	div    %si
  1058f2:	66 85 d2             	test   %dx,%dx
  1058f5:	75 18                	jne    10590f <shell_process+0x4a5>
		shell_internal_fprintf(shell, SHELL_OPTION, "\n%s%s", tab,
  1058f7:	57                   	push   %edi
  1058f8:	68 b6 49 12 00       	push   $0x1249b6
  1058fd:	68 a2 50 12 00       	push   $0x1250a2
  105902:	6a 07                	push   $0x7
  105904:	53                   	push   %ebx
  105905:	e8 0e 14 00 00       	call   106d18 <shell_internal_fprintf>
  10590a:	83 c4 14             	add    $0x14,%esp
  10590d:	eb 11                	jmp    105920 <shell_process+0x4b6>
		shell_internal_fprintf(shell, SHELL_OPTION, "%s", option);
  10590f:	57                   	push   %edi
  105910:	68 f8 4e 12 00       	push   $0x124ef8
  105915:	6a 07                	push   $0x7
  105917:	53                   	push   %ebx
  105918:	e8 fb 13 00 00       	call   106d18 <shell_internal_fprintf>
  10591d:	83 c4 10             	add    $0x10,%esp
	shell_op_cursor_horiz_move(shell, diff);
  105920:	0f b7 85 58 ff ff ff 	movzwl -0xa8(%ebp),%eax
  105927:	50                   	push   %eax
  105928:	53                   	push   %ebx
  105929:	e8 d3 0e 00 00       	call   106801 <shell_op_cursor_horiz_move>
  10592e:	58                   	pop    %eax
  10592f:	5a                   	pop    %edx
	while (cnt) {
  105930:	ff 8d 54 ff ff ff    	decl   -0xac(%ebp)
  105936:	0f 85 e5 fe ff ff    	jne    105821 <shell_process+0x3b7>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  10593c:	68 01 4e 12 00       	push   $0x124e01
  105941:	ff 73 14             	pushl  0x14(%ebx)
  105944:	e8 ed f3 ff ff       	call   104d36 <shell_raw_fprintf>
  105949:	5e                   	pop    %esi
  10594a:	5f                   	pop    %edi
	shell_print_prompt_and_cmd(shell);
  10594b:	53                   	push   %ebx
  10594c:	e8 e0 16 00 00       	call   107031 <shell_print_prompt_and_cmd>
  105951:	58                   	pop    %eax
		partial_autocomplete(shell, cmd, argv[arg_idx], first, cnt);
  105952:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
	uint16_t arg_len = shell_strlen(arg);
  105958:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
  10595c:	e8 c2 f3 ff ff       	call   104d23 <shell_strlen>
  105961:	66 89 85 64 ff ff ff 	mov    %ax,-0x9c(%ebp)
	uint16_t common = common_beginning_find(shell, cmd, &completion, first,
  105968:	0f b7 c0             	movzwl %ax,%eax
  10596b:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
	size_t idx = first + 1;
  105971:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
  105977:	8d 78 01             	lea    0x1(%eax),%edi
	match = shell_cmd_get(cmd, first, &dynamic_entry);
  10597a:	8d 45 98             	lea    -0x68(%ebp),%eax
  10597d:	50                   	push   %eax
  10597e:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
  105984:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  10598a:	e8 8a 0b 00 00       	call   106519 <shell_cmd_get>
  10598f:	83 c4 0c             	add    $0xc,%esp
	strncpy(shell->ctx->temp_buff, match->syntax,
  105992:	68 ff 00 00 00       	push   $0xff
	match = shell_cmd_get(cmd, first, &dynamic_entry);
  105997:	89 c6                	mov    %eax,%esi
	strncpy(shell->ctx->temp_buff, match->syntax,
  105999:	ff 30                	pushl  (%eax)
  10599b:	8b 43 08             	mov    0x8(%ebx),%eax
  10599e:	05 46 01 00 00       	add    $0x146,%eax
  1059a3:	50                   	push   %eax
  1059a4:	e8 fc 62 00 00       	call   10bca5 <strncpy>
	*str = match->syntax;
  1059a9:	8b 06                	mov    (%esi),%eax
	strncpy(shell->ctx->temp_buff, match->syntax,
  1059ab:	83 c4 0c             	add    $0xc,%esp
	*str = match->syntax;
  1059ae:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
	uint16_t common = UINT16_MAX;
  1059b4:	83 ce ff             	or     $0xffffffff,%esi
		match2 = shell_cmd_get(cmd, idx++, &dynamic_entry2);
  1059b7:	8d 47 01             	lea    0x1(%edi),%eax
  1059ba:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  1059c0:	8d 45 ac             	lea    -0x54(%ebp),%eax
  1059c3:	50                   	push   %eax
  1059c4:	57                   	push   %edi
  1059c5:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  1059cb:	e8 49 0b 00 00       	call   106519 <shell_cmd_get>
  1059d0:	83 c4 0c             	add    $0xc,%esp
		if (match2 == NULL) {
  1059d3:	85 c0                	test   %eax,%eax
  1059d5:	74 51                	je     105a28 <shell_process+0x5be>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
  1059d7:	8b 08                	mov    (%eax),%ecx
  1059d9:	8b 7b 08             	mov    0x8(%ebx),%edi
	size_t common = 0;
  1059dc:	31 c0                	xor    %eax,%eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  1059de:	8a 94 07 46 01 00 00 	mov    0x146(%edi,%eax,1),%dl
  1059e5:	38 14 01             	cmp    %dl,(%ecx,%eax,1)
  1059e8:	75 0c                	jne    1059f6 <shell_process+0x58c>
  1059ea:	84 d2                	test   %dl,%dl
  1059ec:	74 08                	je     1059f6 <shell_process+0x58c>
		common++;
  1059ee:	40                   	inc    %eax
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  1059ef:	3d ff ff 00 00       	cmp    $0xffff,%eax
  1059f4:	75 e8                	jne    1059de <shell_process+0x574>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
  1059f6:	66 83 bd 64 ff ff ff 	cmpw   $0x0,-0x9c(%ebp)
  1059fd:	00 
  1059fe:	74 08                	je     105a08 <shell_process+0x59e>
  105a00:	39 85 60 ff ff ff    	cmp    %eax,-0xa0(%ebp)
  105a06:	7f 18                	jg     105a20 <shell_process+0x5b6>
			common = (curr_common < common) ? curr_common : common;
  105a08:	0f b7 f6             	movzwl %si,%esi
			--cnt;
  105a0b:	ff 8d 6c ff ff ff    	decl   -0x94(%ebp)
			common = (curr_common < common) ? curr_common : common;
  105a11:	39 c6                	cmp    %eax,%esi
  105a13:	7e 02                	jle    105a17 <shell_process+0x5ad>
  105a15:	89 c6                	mov    %eax,%esi
	while (cnt > 1) {
  105a17:	83 bd 6c ff ff ff 01 	cmpl   $0x1,-0x94(%ebp)
  105a1e:	74 08                	je     105a28 <shell_process+0x5be>
		match2 = shell_cmd_get(cmd, idx++, &dynamic_entry2);
  105a20:	8b bd 5c ff ff ff    	mov    -0xa4(%ebp),%edi
  105a26:	eb 8f                	jmp    1059b7 <shell_process+0x54d>
	if (common) {
  105a28:	66 85 f6             	test   %si,%si
  105a2b:	0f 84 6a fa ff ff    	je     10549b <shell_process+0x31>
					   common - arg_len);
  105a31:	2b b5 64 ff ff ff    	sub    -0x9c(%ebp),%esi
		shell_op_completion_insert(shell, &completion[arg_len],
  105a37:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
  105a3e:	0f b7 f6             	movzwl %si,%esi
  105a41:	03 85 68 ff ff ff    	add    -0x98(%ebp),%eax
  105a47:	56                   	push   %esi
  105a48:	50                   	push   %eax
  105a49:	53                   	push   %ebx
  105a4a:	e8 4a 15 00 00       	call   106f99 <shell_op_completion_insert>
  105a4f:	e9 b9 01 00 00       	jmp    105c0d <shell_process+0x7a3>
	return shell->ctx->internal.flags.echo == 1;
  105a54:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
				if (flag_echo_get(shell)) {
  105a5a:	80 e2 04             	and    $0x4,%dl
  105a5d:	0f 84 38 fa ff ff    	je     10549b <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  105a63:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105a69:	83 ca 40             	or     $0x40,%edx
  105a6c:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
					shell_op_char_backspace(shell);
  105a72:	eb 28                	jmp    105a9c <shell_process+0x632>
	return shell->ctx->internal.flags.echo == 1;
  105a74:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
				if (flag_echo_get(shell)) {
  105a7a:	80 e2 04             	and    $0x4,%dl
  105a7d:	0f 84 18 fa ff ff    	je     10549b <shell_process+0x31>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  105a83:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105a89:	83 ca 40             	or     $0x40,%edx
  105a8c:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	return shell->ctx->internal.flags.mode_delete == 1;
  105a92:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
					if (flag_mode_delete_get(shell)) {
  105a98:	a8 20                	test   $0x20,%al
  105a9a:	74 1d                	je     105ab9 <shell_process+0x64f>
						shell_op_char_backspace(shell);
  105a9c:	53                   	push   %ebx
  105a9d:	e8 5c 15 00 00       	call   106ffe <shell_op_char_backspace>
  105aa2:	eb 1b                	jmp    105abf <shell_process+0x655>
	shell->ctx->receive_state = state;
  105aa4:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	return shell->ctx->internal.flags.echo == 1;
  105aab:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
				if (flag_echo_get(shell)) {
  105ab1:	a8 04                	test   $0x4,%al
  105ab3:	0f 84 e2 f9 ff ff    	je     10549b <shell_process+0x31>
						shell_op_char_delete(shell);
  105ab9:	53                   	push   %ebx
  105aba:	e8 ed 14 00 00       	call   106fac <shell_op_char_delete>
  105abf:	59                   	pop    %ecx
  105ac0:	e9 d6 f9 ff ff       	jmp    10549b <shell_process+0x31>
		if (ascii_filter(data) != 0) {
  105ac5:	0f be ca             	movsbl %dl,%ecx
	return (int)((((unsigned)c) >= ' ') &&
  105ac8:	8d 71 e0             	lea    -0x20(%ecx),%esi
				if (isprint((int) data)) {
  105acb:	83 fe 5e             	cmp    $0x5e,%esi
  105ace:	77 1b                	ja     105aeb <shell_process+0x681>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  105ad0:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105ad6:	83 ca 40             	or     $0x40,%edx
  105ad9:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
					shell_op_char_insert(shell, data);
  105adf:	51                   	push   %ecx
  105ae0:	53                   	push   %ebx
  105ae1:	e8 2d 14 00 00       	call   106f13 <shell_op_char_insert>
  105ae6:	e9 ea fc ff ff       	jmp    1057d5 <shell_process+0x36b>
	return shell->ctx->internal.flags.echo == 1;
  105aeb:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
				} else if (flag_echo_get(shell)) {
  105af1:	a8 04                	test   $0x4,%al
  105af3:	0f 84 a2 f9 ff ff    	je     10549b <shell_process+0x31>
	switch (data) {
  105af9:	4a                   	dec    %edx
  105afa:	80 fa 16             	cmp    $0x16,%dl
  105afd:	0f 87 98 f9 ff ff    	ja     10549b <shell_process+0x31>
  105b03:	0f b6 d2             	movzbl %dl,%edx
  105b06:	ff 24 95 90 40 12 00 	jmp    *0x124090(,%edx,4)
	shell->ctx->receive_state = state;
  105b0d:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
		shell_op_cursor_home_move(shell);
  105b14:	53                   	push   %ebx
  105b15:	e8 4d 0f 00 00       	call   106a67 <shell_op_cursor_home_move>
  105b1a:	eb a3                	jmp    105abf <shell_process+0x655>
		shell_op_left_arrow(shell);
  105b1c:	53                   	push   %ebx
  105b1d:	e8 7c 0f 00 00       	call   106a9e <shell_op_left_arrow>
  105b22:	eb 9b                	jmp    105abf <shell_process+0x655>
		shell_op_cursor_end_move(shell);
  105b24:	53                   	push   %ebx
  105b25:	e8 58 0f 00 00       	call   106a82 <shell_op_cursor_end_move>
		if (!shell_cursor_in_empty_line(shell)) {
  105b2a:	89 1c 24             	mov    %ebx,(%esp)
  105b2d:	e8 fe 0c 00 00       	call   106830 <shell_cursor_in_empty_line>
  105b32:	5a                   	pop    %edx
  105b33:	84 c0                	test   %al,%al
  105b35:	75 0f                	jne    105b46 <shell_process+0x6dc>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  105b37:	68 01 4e 12 00       	push   $0x124e01
  105b3c:	ff 73 14             	pushl  0x14(%ebx)
  105b3f:	e8 f2 f1 ff ff       	call   104d36 <shell_raw_fprintf>
  105b44:	5e                   	pop    %esi
  105b45:	5f                   	pop    %edi
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  105b46:	8b 53 08             	mov    0x8(%ebx),%edx
  105b49:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  105b4f:	83 c8 40             	or     $0x40,%eax
  105b52:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
		state_set(shell, SHELL_STATE_ACTIVE);
  105b58:	89 d8                	mov    %ebx,%eax
  105b5a:	e8 1d f2 ff ff       	call   104d7c <state_set.constprop.0>
		break;
  105b5f:	e9 37 f9 ff ff       	jmp    10549b <shell_process+0x31>
	shell->ctx->receive_state = state;
  105b64:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
		shell_op_cursor_end_move(shell);
  105b6b:	53                   	push   %ebx
  105b6c:	e8 11 0f 00 00       	call   106a82 <shell_op_cursor_end_move>
  105b71:	e9 49 ff ff ff       	jmp    105abf <shell_process+0x655>
		shell_op_right_arrow(shell);
  105b76:	53                   	push   %ebx
  105b77:	e8 3e 0f 00 00       	call   106aba <shell_op_right_arrow>
  105b7c:	e9 3e ff ff ff       	jmp    105abf <shell_process+0x655>
		shell_op_delete_from_cursor(shell);
  105b81:	53                   	push   %ebx
  105b82:	e8 51 0f 00 00       	call   106ad8 <shell_op_delete_from_cursor>
  105b87:	e9 33 ff ff ff       	jmp    105abf <shell_process+0x655>
		SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  105b8c:	68 68 41 12 00       	push   $0x124168
  105b91:	68 f8 4e 12 00       	push   $0x124ef8
  105b96:	ff 73 14             	pushl  0x14(%ebx)
  105b99:	e8 98 f1 ff ff       	call   104d36 <shell_raw_fprintf>
  105b9e:	83 c4 0c             	add    $0xc,%esp
		SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
  105ba1:	68 60 41 12 00       	push   $0x124160
  105ba6:	68 f8 4e 12 00       	push   $0x124ef8
  105bab:	ff 73 14             	pushl  0x14(%ebx)
  105bae:	e8 83 f1 ff ff       	call   104d36 <shell_raw_fprintf>
  105bb3:	83 c4 0c             	add    $0xc,%esp
		shell_print_prompt_and_cmd(shell);
  105bb6:	53                   	push   %ebx
  105bb7:	e8 75 14 00 00       	call   107031 <shell_print_prompt_and_cmd>
  105bbc:	e9 fe fe ff ff       	jmp    105abf <shell_process+0x655>
		history_handle(shell, false);
  105bc1:	31 d2                	xor    %edx,%edx
  105bc3:	eb 05                	jmp    105bca <shell_process+0x760>
		history_handle(shell, true);
  105bc5:	ba 01 00 00 00       	mov    $0x1,%edx
  105bca:	89 d8                	mov    %ebx,%eax
  105bcc:	e8 b9 f2 ff ff       	call   104e8a <history_handle>
		break;
  105bd1:	e9 c5 f8 ff ff       	jmp    10549b <shell_process+0x31>
		shell_op_cursor_home_move(shell);
  105bd6:	53                   	push   %ebx
  105bd7:	e8 8b 0e 00 00       	call   106a67 <shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
  105bdc:	8b 43 08             	mov    0x8(%ebx),%eax
  105bdf:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
  105be5:	c6 40 46 00          	movb   $0x0,0x46(%eax)
  105be9:	83 ca 40             	or     $0x40,%edx
	shell->ctx->cmd_buff_len = 0;
  105bec:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  105bf3:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  105bf9:	c7 04 24 5c 41 12 00 	movl   $0x12415c,(%esp)
  105c00:	68 f8 4e 12 00       	push   $0x124ef8
  105c05:	ff 73 14             	pushl  0x14(%ebx)
  105c08:	e8 29 f1 ff ff       	call   104d36 <shell_raw_fprintf>
  105c0d:	83 c4 0c             	add    $0xc,%esp
}
  105c10:	e9 86 f8 ff ff       	jmp    10549b <shell_process+0x31>
		shell_op_word_remove(shell);
  105c15:	53                   	push   %ebx
  105c16:	e8 17 11 00 00       	call   106d32 <shell_op_word_remove>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
  105c1b:	8b 53 08             	mov    0x8(%ebx),%edx
  105c1e:	59                   	pop    %ecx
  105c1f:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  105c25:	83 c8 40             	or     $0x40,%eax
  105c28:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
}
  105c2e:	e9 68 f8 ff ff       	jmp    10549b <shell_process+0x31>
			if (data == '[') {
  105c33:	80 fa 5b             	cmp    $0x5b,%dl
  105c36:	75 0c                	jne    105c44 <shell_process+0x7da>
	shell->ctx->receive_state = state;
  105c38:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
}
  105c3f:	e9 57 f8 ff ff       	jmp    10549b <shell_process+0x31>
	return shell->ctx->internal.flags.echo == 1;
  105c44:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
			} else if (flag_echo_get(shell)) {
  105c4a:	a8 04                	test   $0x4,%al
  105c4c:	74 18                	je     105c66 <shell_process+0x7fc>
	if (data == SHELL_VT100_ASCII_ALT_B) {
  105c4e:	80 fa 62             	cmp    $0x62,%dl
  105c51:	75 04                	jne    105c57 <shell_process+0x7ed>
		shell_op_cursor_word_move(shell, -1);
  105c53:	6a ff                	push   $0xffffffff
  105c55:	eb 07                	jmp    105c5e <shell_process+0x7f4>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
  105c57:	80 fa 66             	cmp    $0x66,%dl
  105c5a:	75 0a                	jne    105c66 <shell_process+0x7fc>
		shell_op_cursor_word_move(shell, 1);
  105c5c:	6a 01                	push   $0x1
  105c5e:	53                   	push   %ebx
  105c5f:	e8 3d 0d 00 00       	call   1069a1 <shell_op_cursor_word_move>
  105c64:	58                   	pop    %eax
  105c65:	5a                   	pop    %edx
	shell->ctx->receive_state = state;
  105c66:	8b 43 08             	mov    0x8(%ebx),%eax
  105c69:	eb 56                	jmp    105cc1 <shell_process+0x857>
  105c6b:	8b 88 64 02 00 00    	mov    0x264(%eax),%ecx
  105c71:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			if (!flag_echo_get(shell)) {
  105c78:	80 e1 04             	and    $0x4,%cl
  105c7b:	0f 84 1a f8 ff ff    	je     10549b <shell_process+0x31>
			switch (data) {
  105c81:	83 ea 31             	sub    $0x31,%edx
  105c84:	80 fa 1b             	cmp    $0x1b,%dl
  105c87:	0f 87 0e f8 ff ff    	ja     10549b <shell_process+0x31>
  105c8d:	0f b6 d2             	movzbl %dl,%edx
  105c90:	ff 24 95 ec 40 12 00 	jmp    *0x1240ec(,%edx,4)
	shell->ctx->receive_state = state;
  105c97:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
	return shell->ctx->internal.flags.insert_mode == 1;
  105c9e:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
				flag_insert_mode_set(shell, !status);
  105ca4:	f7 d2                	not    %edx
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
  105ca6:	89 d1                	mov    %edx,%ecx
  105ca8:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105cae:	83 e1 01             	and    $0x1,%ecx
  105cb1:	83 e2 fe             	and    $0xfffffffe,%edx
  105cb4:	09 ca                	or     %ecx,%edx
  105cb6:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
}
  105cbc:	e9 da f7 ff ff       	jmp    10549b <shell_process+0x31>
	shell->ctx->receive_state = state;
  105cc1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
  105cc8:	e9 ce f7 ff ff       	jmp    10549b <shell_process+0x31>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  105ccd:	8b 43 08             	mov    0x8(%ebx),%eax
  105cd0:	f0 83 a0 64 02 00 00 	lock andl $0xfffffff7,0x264(%eax)
  105cd7:	f7 

	internal.value = 0xFFFFFFFF;
	internal.flags.processing = 0U;
	(void)atomic_and((atomic_t *)&shell->ctx->internal.value,
			 internal.value);
}
  105cd8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105cdb:	5b                   	pop    %ebx
  105cdc:	5e                   	pop    %esi
  105cdd:	5f                   	pop    %edi
  105cde:	5d                   	pop    %ebp
  105cdf:	c3                   	ret    

00105ce0 <shell_init>:
{
  105ce0:	55                   	push   %ebp
  105ce1:	89 e5                	mov    %esp,%ebp
  105ce3:	57                   	push   %edi
  105ce4:	56                   	push   %esi
  105ce5:	53                   	push   %ebx
  105ce6:	51                   	push   %ecx
  105ce7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  105cea:	68 18 03 00 00       	push   $0x318
  105cef:	6a 00                	push   $0x0
{
  105cf1:	8b 45 14             	mov    0x14(%ebp),%eax
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  105cf4:	ff 73 08             	pushl  0x8(%ebx)
{
  105cf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  105cfa:	e8 5c 61 00 00       	call   10be5b <memset>
	shell->ctx->prompt = shell->default_prompt;
  105cff:	8b 43 08             	mov    0x8(%ebx),%eax
  105d02:	8b 13                	mov    (%ebx),%edx
	memset(shell->ctx, 0, sizeof(*shell->ctx));
  105d04:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->prompt = shell->default_prompt;
  105d07:	89 10                	mov    %edx,(%eax)
	shell_history_init(shell->history);
  105d09:	ff 73 0c             	pushl  0xc(%ebx)
  105d0c:	e8 70 1f 00 00       	call   107c81 <shell_history_init>
	k_mutex_init(&shell->ctx->wr_mtx);
  105d11:	8b 43 08             	mov    0x8(%ebx),%eax
  105d14:	05 f8 02 00 00       	add    $0x2f8,%eax
	return z_impl_k_mutex_init(mutex);
  105d19:	bf a8 02 00 00       	mov    $0x2a8,%edi
  105d1e:	89 04 24             	mov    %eax,(%esp)
  105d21:	e8 80 ae 01 00       	call   120ba6 <z_impl_k_mutex_init>
  105d26:	5e                   	pop    %esi
  105d27:	be 68 02 00 00       	mov    $0x268,%esi
		k_poll_signal_init(&shell->ctx->signals[i]);
  105d2c:	8b 53 08             	mov    0x8(%ebx),%edx
  105d2f:	01 f2                	add    %esi,%edx
	z_impl_k_poll_signal_init(signal);
  105d31:	52                   	push   %edx
  105d32:	e8 33 cd 01 00       	call   122a6a <z_impl_k_poll_signal_init>
				  &shell->ctx->signals[i]);
  105d37:	8b 53 08             	mov    0x8(%ebx),%edx
  105d3a:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
		k_poll_event_init(&shell->ctx->events[i],
  105d3d:	01 fa                	add    %edi,%edx
  105d3f:	89 0c 24             	mov    %ecx,(%esp)
  105d42:	6a 00                	push   $0x0
  105d44:	6a 01                	push   $0x1
  105d46:	83 c6 10             	add    $0x10,%esi
  105d49:	52                   	push   %edx
  105d4a:	83 c7 14             	add    $0x14,%edi
  105d4d:	e8 f2 cb 01 00       	call   122944 <k_poll_event_init>
  105d52:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < SHELL_SIGNALS; i++) {
  105d55:	81 fe a8 02 00 00    	cmp    $0x2a8,%esi
  105d5b:	75 cf                	jne    105d2c <shell_init+0x4c>
		shell->stats->log_lost_cnt = 0;
  105d5d:	8b 43 18             	mov    0x18(%ebx),%eax
  105d60:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
  105d66:	8b 43 08             	mov    0x8(%ebx),%eax
  105d69:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
	shell->ctx->vt100_ctx.cons.terminal_hei =
  105d6f:	c7 40 2c 18 00 50 00 	movl   $0x500018,0x2c(%eax)
  105d76:	83 ca 10             	or     $0x10,%edx
  105d79:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	shell->ctx->internal.flags.echo = val ? 1 : 0;
  105d7f:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105d85:	83 ca 04             	or     $0x4,%edx
  105d88:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
  105d8e:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105d94:	83 ca 20             	or     $0x20,%edx
  105d97:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	shell->ctx->vt100_ctx.cons.name_len = shell_strlen(shell->ctx->prompt);
  105d9d:	8b 00                	mov    (%eax),%eax
  105d9f:	e8 7f ef ff ff       	call   104d23 <shell_strlen>
  105da4:	89 c2                	mov    %eax,%edx
  105da6:	8b 43 08             	mov    0x8(%ebx),%eax
  105da9:	88 50 30             	mov    %dl,0x30(%eax)
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
  105dac:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105db2:	83 ca 02             	or     $0x2,%edx
  105db5:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	int ret = shell->iface->api->init(shell->iface, p_config,
  105dbb:	8b 43 04             	mov    0x4(%ebx),%eax
  105dbe:	8b 10                	mov    (%eax),%edx
  105dc0:	53                   	push   %ebx
  105dc1:	68 db 4d 10 00       	push   $0x104ddb
  105dc6:	ff 75 0c             	pushl  0xc(%ebp)
  105dc9:	50                   	push   %eax
  105dca:	ff 12                	call   *(%edx)
  105dcc:	83 c4 10             	add    $0x10,%esp
  105dcf:	89 c7                	mov    %eax,%edi
	if (ret == 0) {
  105dd1:	85 c0                	test   %eax,%eax
  105dd3:	75 4a                	jne    105e1f <shell_init+0x13f>
	shell->ctx->state = state;
  105dd5:	8b 43 08             	mov    0x8(%ebx),%eax
	k_tid_t tid = k_thread_create(shell->thread,
  105dd8:	8b 53 2c             	mov    0x2c(%ebx),%edx
	shell->ctx->state = state;
  105ddb:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	k_tid_t tid = k_thread_create(shell->thread,
  105de2:	8b 43 28             	mov    0x28(%ebx),%eax
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  105de5:	6a 00                	push   $0x0
  105de7:	6a 00                	push   $0x0
  105de9:	6a 00                	push   $0x0
  105deb:	6a 0e                	push   $0xe
  105ded:	ff 75 18             	pushl  0x18(%ebp)
  105df0:	0f b6 75 f0          	movzbl -0x10(%ebp),%esi
  105df4:	56                   	push   %esi
  105df5:	53                   	push   %ebx
  105df6:	68 83 5e 10 00       	push   $0x105e83
  105dfb:	68 00 08 00 00       	push   $0x800
  105e00:	52                   	push   %edx
  105e01:	50                   	push   %eax
  105e02:	e8 cf bd 01 00       	call   121bd6 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
  105e07:	8b 53 08             	mov    0x8(%ebx),%edx
  105e0a:	83 c4 2c             	add    $0x2c,%esp
  105e0d:	89 82 14 03 00 00    	mov    %eax,0x314(%edx)
	k_thread_name_set(tid, shell->thread_name);
  105e13:	8b 53 24             	mov    0x24(%ebx),%edx
	return z_impl_k_thread_name_set(thread_id, value);
  105e16:	52                   	push   %edx
  105e17:	50                   	push   %eax
  105e18:	e8 10 bc 01 00       	call   121a2d <z_impl_k_thread_name_set>
  105e1d:	58                   	pop    %eax
  105e1e:	5a                   	pop    %edx
}
  105e1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105e22:	89 f8                	mov    %edi,%eax
  105e24:	5b                   	pop    %ebx
  105e25:	5e                   	pop    %esi
  105e26:	5f                   	pop    %edi
  105e27:	5d                   	pop    %ebp
  105e28:	c3                   	ret    

00105e29 <shell_start>:
{
  105e29:	55                   	push   %ebp
  105e2a:	ba dd ff ff ff       	mov    $0xffffffdd,%edx
  105e2f:	89 e5                	mov    %esp,%ebp
  105e31:	53                   	push   %ebx
  105e32:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
  105e35:	8b 43 08             	mov    0x8(%ebx),%eax
  105e38:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  105e3c:	75 3e                	jne    105e7c <shell_start+0x53>
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105e3e:	83 ca ff             	or     $0xffffffff,%edx
  105e41:	05 f8 02 00 00       	add    $0x2f8,%eax
  105e46:	89 d1                	mov    %edx,%ecx
  105e48:	e8 b9 ef ff ff       	call   104e06 <k_mutex_lock.constprop.0>
		shell_vt100_color_set(shell, SHELL_NORMAL);
  105e4d:	6a 00                	push   $0x0
  105e4f:	53                   	push   %ebx
  105e50:	e8 a6 0d 00 00       	call   106bfb <shell_vt100_color_set>
  105e55:	58                   	pop    %eax
  105e56:	5a                   	pop    %edx
	shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
  105e57:	68 00 4e 12 00       	push   $0x124e00
  105e5c:	ff 73 14             	pushl  0x14(%ebx)
  105e5f:	e8 d2 ee ff ff       	call   104d36 <shell_raw_fprintf>
  105e64:	59                   	pop    %ecx
  105e65:	58                   	pop    %eax
	state_set(shell, SHELL_STATE_ACTIVE);
  105e66:	89 d8                	mov    %ebx,%eax
  105e68:	e8 0f ef ff ff       	call   104d7c <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
  105e6d:	8b 43 08             	mov    0x8(%ebx),%eax
  105e70:	05 f8 02 00 00       	add    $0x2f8,%eax
  105e75:	e8 9d ee ff ff       	call   104d17 <k_mutex_unlock>
	return 0;
  105e7a:	31 d2                	xor    %edx,%edx
}
  105e7c:	89 d0                	mov    %edx,%eax
  105e7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  105e81:	c9                   	leave  
  105e82:	c3                   	ret    

00105e83 <shell_thread>:
{
  105e83:	55                   	push   %ebp
  105e84:	89 e5                	mov    %esp,%ebp
  105e86:	57                   	push   %edi
  105e87:	56                   	push   %esi
  105e88:	53                   	push   %ebx
  105e89:	8b 5d 08             	mov    0x8(%ebp),%ebx
  105e8c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  105e8f:	8b 75 10             	mov    0x10(%ebp),%esi
	err = shell->iface->api->enable(shell->iface, false);
  105e92:	8b 43 04             	mov    0x4(%ebx),%eax
  105e95:	8b 10                	mov    (%eax),%edx
  105e97:	6a 00                	push   $0x0
  105e99:	50                   	push   %eax
  105e9a:	ff 52 08             	call   *0x8(%edx)
  105e9d:	59                   	pop    %ecx
  105e9e:	5a                   	pop    %edx
	if (err != 0) {
  105e9f:	85 c0                	test   %eax,%eax
  105ea1:	0f 85 d5 00 00 00    	jne    105f7c <shell_thread+0xf9>
	if (log_backend && IS_ENABLED(CONFIG_SHELL_LOG_BACKEND)) {
  105ea7:	85 ff                	test   %edi,%edi
  105ea9:	74 0d                	je     105eb8 <shell_thread+0x35>
		shell_log_backend_enable(shell->log_backend, (void *)shell,
  105eab:	56                   	push   %esi
  105eac:	53                   	push   %ebx
  105ead:	ff 73 1c             	pushl  0x1c(%ebx)
  105eb0:	e8 86 1f 00 00       	call   107e3b <shell_log_backend_enable>
  105eb5:	83 c4 0c             	add    $0xc,%esp
	err = shell_start(shell);
  105eb8:	53                   	push   %ebx
  105eb9:	e8 6b ff ff ff       	call   105e29 <shell_start>
  105ebe:	5a                   	pop    %edx
	if (err != 0) {
  105ebf:	85 c0                	test   %eax,%eax
  105ec1:	0f 85 b5 00 00 00    	jne    105f7c <shell_thread+0xf9>
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
  105ec7:	8b 43 08             	mov    0x8(%ebx),%eax
  105eca:	05 a8 02 00 00       	add    $0x2a8,%eax
	return z_impl_k_poll(events, num_events, timeout);
  105ecf:	6a ff                	push   $0xffffffff
  105ed1:	6a ff                	push   $0xffffffff
  105ed3:	6a 03                	push   $0x3
  105ed5:	50                   	push   %eax
  105ed6:	e8 a0 ca 01 00       	call   12297b <z_impl_k_poll>
  105edb:	83 c4 10             	add    $0x10,%esp
  105ede:	89 c6                	mov    %eax,%esi
		if (err != 0) {
  105ee0:	85 c0                	test   %eax,%eax
  105ee2:	8b 43 08             	mov    0x8(%ebx),%eax
  105ee5:	74 34                	je     105f1b <shell_thread+0x98>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105ee7:	83 ca ff             	or     $0xffffffff,%edx
  105eea:	05 f8 02 00 00       	add    $0x2f8,%eax
  105eef:	89 d1                	mov    %edx,%ecx
  105ef1:	e8 10 ef ff ff       	call   104e06 <k_mutex_lock.constprop.0>
			shell_internal_fprintf(shell, SHELL_ERROR,
  105ef6:	56                   	push   %esi
  105ef7:	68 a8 50 12 00       	push   $0x1250a8
  105efc:	6a 02                	push   $0x2
  105efe:	53                   	push   %ebx
  105eff:	e8 14 0e 00 00       	call   106d18 <shell_internal_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
  105f04:	8b 43 08             	mov    0x8(%ebx),%eax
			shell_internal_fprintf(shell, SHELL_ERROR,
  105f07:	83 c4 10             	add    $0x10,%esp
}
  105f0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
			k_mutex_unlock(&shell->ctx->wr_mtx);
  105f0d:	05 f8 02 00 00       	add    $0x2f8,%eax
}
  105f12:	5b                   	pop    %ebx
  105f13:	5e                   	pop    %esi
  105f14:	5f                   	pop    %edi
  105f15:	5d                   	pop    %ebp
			k_mutex_unlock(&shell->ctx->wr_mtx);
  105f16:	e9 fc ed ff ff       	jmp    104d17 <k_mutex_unlock>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105f1b:	83 ca ff             	or     $0xffffffff,%edx
  105f1e:	05 f8 02 00 00       	add    $0x2f8,%eax
  105f23:	89 d1                	mov    %edx,%ecx
  105f25:	e8 dc ee ff ff       	call   104e06 <k_mutex_lock.constprop.0>
		if (shell->iface->api->update) {
  105f2a:	8b 53 04             	mov    0x4(%ebx),%edx
  105f2d:	8b 02                	mov    (%edx),%eax
  105f2f:	8b 40 14             	mov    0x14(%eax),%eax
  105f32:	85 c0                	test   %eax,%eax
  105f34:	74 04                	je     105f3a <shell_thread+0xb7>
			shell->iface->api->update(shell->iface);
  105f36:	52                   	push   %edx
  105f37:	ff d0                	call   *%eax
  105f39:	58                   	pop    %eax
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
  105f3a:	89 d8                	mov    %ebx,%eax
  105f3c:	b9 c7 4c 10 00       	mov    $0x104cc7,%ecx
  105f41:	ba 02 00 00 00       	mov    $0x2,%edx
  105f46:	e8 38 ed ff ff       	call   104c83 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
  105f4b:	31 d2                	xor    %edx,%edx
  105f4d:	89 d8                	mov    %ebx,%eax
  105f4f:	b9 6a 54 10 00       	mov    $0x10546a,%ecx
  105f54:	e8 2a ed ff ff       	call   104c83 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
  105f59:	89 d8                	mov    %ebx,%eax
  105f5b:	b9 1a 4e 10 00       	mov    $0x104e1a,%ecx
  105f60:	ba 01 00 00 00       	mov    $0x1,%edx
  105f65:	e8 19 ed ff ff       	call   104c83 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
  105f6a:	8b 43 08             	mov    0x8(%ebx),%eax
  105f6d:	05 f8 02 00 00       	add    $0x2f8,%eax
  105f72:	e8 a0 ed ff ff       	call   104d17 <k_mutex_unlock>
  105f77:	e9 4b ff ff ff       	jmp    105ec7 <shell_thread+0x44>
}
  105f7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105f7f:	5b                   	pop    %ebx
  105f80:	5e                   	pop    %esi
  105f81:	5f                   	pop    %edi
  105f82:	5d                   	pop    %ebp
  105f83:	c3                   	ret    

00105f84 <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
  105f84:	55                   	push   %ebp
  105f85:	89 e5                	mov    %esp,%ebp
  105f87:	57                   	push   %edi
  105f88:	56                   	push   %esi
  105f89:	53                   	push   %ebx
  105f8a:	53                   	push   %ebx
  105f8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  105f8e:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f91:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105f94:	8b 75 10             	mov    0x10(%ebp),%esi
	__ASSERT_NO_MSG(shell->ctx);
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(shell) != SHELL_STATE_ACTIVE) {
  105f97:	8b 43 08             	mov    0x8(%ebx),%eax
{
  105f9a:	8b 7d 14             	mov    0x14(%ebp),%edi
	if (state_get(shell) != SHELL_STATE_ACTIVE) {
  105f9d:	83 78 04 02          	cmpl   $0x2,0x4(%eax)
  105fa1:	74 1a                	je     105fbd <shell_vfprintf+0x39>
	shell->ctx->internal.flags.print_noinit = val ? 1 : 0;
  105fa3:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  105fa9:	81 ca 00 00 01 00    	or     $0x10000,%edx
  105faf:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
	if (!flag_cmd_ctx_get(shell)) {
		shell_print_prompt_and_cmd(shell);
	}
	transport_buffer_flush(shell);
	k_mutex_unlock(&shell->ctx->wr_mtx);
}
  105fb5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  105fb8:	5b                   	pop    %ebx
  105fb9:	5e                   	pop    %esi
  105fba:	5f                   	pop    %edi
  105fbb:	5d                   	pop    %ebp
  105fbc:	c3                   	ret    
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
  105fbd:	83 ca ff             	or     $0xffffffff,%edx
  105fc0:	05 f8 02 00 00       	add    $0x2f8,%eax
  105fc5:	89 d1                	mov    %edx,%ecx
  105fc7:	e8 3a ee ff ff       	call   104e06 <k_mutex_lock.constprop.0>
	if (!flag_cmd_ctx_get(shell)) {
  105fcc:	8b 43 08             	mov    0x8(%ebx),%eax
	return shell->ctx->internal.flags.cmd_ctx == 1;
  105fcf:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
  105fd5:	84 c0                	test   %al,%al
  105fd7:	78 07                	js     105fe0 <shell_vfprintf+0x5c>
		shell_cmd_line_erase(shell);
  105fd9:	53                   	push   %ebx
  105fda:	e8 18 0b 00 00       	call   106af7 <shell_cmd_line_erase>
  105fdf:	59                   	pop    %ecx
	shell_internal_vfprintf(shell, color, fmt, args);
  105fe0:	57                   	push   %edi
  105fe1:	56                   	push   %esi
  105fe2:	ff 75 f0             	pushl  -0x10(%ebp)
  105fe5:	53                   	push   %ebx
  105fe6:	e8 bb 0c 00 00       	call   106ca6 <shell_internal_vfprintf>
	if (!flag_cmd_ctx_get(shell)) {
  105feb:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
  105fee:	83 c4 10             	add    $0x10,%esp
  105ff1:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
	if (!flag_cmd_ctx_get(shell)) {
  105ff7:	84 c0                	test   %al,%al
  105ff9:	78 07                	js     106002 <shell_vfprintf+0x7e>
		shell_print_prompt_and_cmd(shell);
  105ffb:	53                   	push   %ebx
  105ffc:	e8 30 10 00 00       	call   107031 <shell_print_prompt_and_cmd>
  106001:	5a                   	pop    %edx
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
  106002:	ff 73 14             	pushl  0x14(%ebx)
  106005:	e8 68 01 00 00       	call   106172 <shell_fprintf_buffer_flush>
  10600a:	58                   	pop    %eax
	k_mutex_unlock(&shell->ctx->wr_mtx);
  10600b:	8b 43 08             	mov    0x8(%ebx),%eax
}
  10600e:	8d 65 f4             	lea    -0xc(%ebp),%esp
	k_mutex_unlock(&shell->ctx->wr_mtx);
  106011:	05 f8 02 00 00       	add    $0x2f8,%eax
}
  106016:	5b                   	pop    %ebx
  106017:	5e                   	pop    %esi
  106018:	5f                   	pop    %edi
  106019:	5d                   	pop    %ebp
	k_mutex_unlock(&shell->ctx->wr_mtx);
  10601a:	e9 f8 ec ff ff       	jmp    104d17 <k_mutex_unlock>

0010601f <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
  10601f:	55                   	push   %ebp
  106020:	89 e5                	mov    %esp,%ebp
	va_list args;

	va_start(args, fmt);
  106022:	8d 45 14             	lea    0x14(%ebp),%eax
	shell_vfprintf(shell, color, fmt, args);
  106025:	50                   	push   %eax
  106026:	ff 75 10             	pushl  0x10(%ebp)
  106029:	ff 75 0c             	pushl  0xc(%ebp)
  10602c:	ff 75 08             	pushl  0x8(%ebp)
  10602f:	e8 50 ff ff ff       	call   105f84 <shell_vfprintf>
  106034:	83 c4 10             	add    $0x10,%esp
	va_end(args);
}
  106037:	c9                   	leave  
  106038:	c3                   	ret    

00106039 <shell_hexdump_line>:

void shell_hexdump_line(const struct shell *shell, unsigned int offset,
			const uint8_t *data, size_t len)
{
  106039:	55                   	push   %ebp
  10603a:	89 e5                	mov    %esp,%ebp
  10603c:	57                   	push   %edi
  10603d:	56                   	push   %esi
	int i;

	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);

	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
  10603e:	31 f6                	xor    %esi,%esi
{
  106040:	53                   	push   %ebx
  106041:	50                   	push   %eax
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  106042:	ff 75 0c             	pushl  0xc(%ebp)
{
  106045:	8b 5d 08             	mov    0x8(%ebp),%ebx
  106048:	8b 45 14             	mov    0x14(%ebp),%eax
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  10604b:	68 bf 50 12 00       	push   $0x1250bf
{
  106050:	8b 7d 10             	mov    0x10(%ebp),%edi
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  106053:	6a 00                	push   $0x0
{
  106055:	89 45 f0             	mov    %eax,-0x10(%ebp)
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
  106058:	53                   	push   %ebx
  106059:	e8 c1 ff ff ff       	call   10601f <shell_fprintf>
  10605e:	83 c4 10             	add    $0x10,%esp
		if (i > 0 && !(i % 8)) {
			shell_fprintf(shell, SHELL_NORMAL, " ");
		}

		if (i < len) {
  106061:	39 75 f0             	cmp    %esi,-0x10(%ebp)
  106064:	76 17                	jbe    10607d <shell_hexdump_line+0x44>
			shell_fprintf(shell, SHELL_NORMAL, "%02x ",
  106066:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
  10606a:	50                   	push   %eax
  10606b:	68 af 49 12 00       	push   $0x1249af
  106070:	6a 00                	push   $0x0
  106072:	53                   	push   %ebx
  106073:	e8 a7 ff ff ff       	call   10601f <shell_fprintf>
  106078:	83 c4 10             	add    $0x10,%esp
  10607b:	eb 10                	jmp    10608d <shell_hexdump_line+0x54>
				      data[i] & 0xFF);
		} else {
			shell_fprintf(shell, SHELL_NORMAL, "   ");
  10607d:	68 b5 49 12 00       	push   $0x1249b5
  106082:	6a 00                	push   $0x0
  106084:	53                   	push   %ebx
  106085:	e8 95 ff ff ff       	call   10601f <shell_fprintf>
  10608a:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
  10608d:	46                   	inc    %esi
  10608e:	83 fe 10             	cmp    $0x10,%esi
  106091:	74 1a                	je     1060ad <shell_hexdump_line+0x74>
		if (i > 0 && !(i % 8)) {
  106093:	f7 c6 07 00 00 00    	test   $0x7,%esi
  106099:	75 c6                	jne    106061 <shell_hexdump_line+0x28>
			shell_fprintf(shell, SHELL_NORMAL, " ");
  10609b:	68 b7 49 12 00       	push   $0x1249b7
  1060a0:	6a 00                	push   $0x0
  1060a2:	53                   	push   %ebx
  1060a3:	e8 77 ff ff ff       	call   10601f <shell_fprintf>
  1060a8:	83 c4 0c             	add    $0xc,%esp
  1060ab:	eb b4                	jmp    106061 <shell_hexdump_line+0x28>
		}
	}

	shell_fprintf(shell, SHELL_NORMAL, "|");
  1060ad:	68 b9 49 12 00       	push   $0x1249b9

	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
  1060b2:	31 f6                	xor    %esi,%esi
	shell_fprintf(shell, SHELL_NORMAL, "|");
  1060b4:	6a 00                	push   $0x0
  1060b6:	53                   	push   %ebx
  1060b7:	e8 63 ff ff ff       	call   10601f <shell_fprintf>
  1060bc:	83 c4 0c             	add    $0xc,%esp
		if (i > 0 && !(i % 8)) {
			shell_fprintf(shell, SHELL_NORMAL, " ");
		}

		if (i < len) {
  1060bf:	39 75 f0             	cmp    %esi,-0x10(%ebp)
  1060c2:	76 24                	jbe    1060e8 <shell_hexdump_line+0xaf>
			char c = data[i];

			shell_fprintf(shell, SHELL_NORMAL, "%c",
				      isprint((int)c) ? c : '.');
  1060c4:	0f be 04 37          	movsbl (%edi,%esi,1),%eax
  1060c8:	8d 50 e0             	lea    -0x20(%eax),%edx
			shell_fprintf(shell, SHELL_NORMAL, "%c",
  1060cb:	83 fa 5e             	cmp    $0x5e,%edx
  1060ce:	76 05                	jbe    1060d5 <shell_hexdump_line+0x9c>
  1060d0:	b8 2e 00 00 00       	mov    $0x2e,%eax
  1060d5:	50                   	push   %eax
  1060d6:	68 cd 50 12 00       	push   $0x1250cd
  1060db:	6a 00                	push   $0x0
  1060dd:	53                   	push   %ebx
  1060de:	e8 3c ff ff ff       	call   10601f <shell_fprintf>
  1060e3:	83 c4 10             	add    $0x10,%esp
  1060e6:	eb 10                	jmp    1060f8 <shell_hexdump_line+0xbf>
		} else {
			shell_fprintf(shell, SHELL_NORMAL, " ");
  1060e8:	68 b7 49 12 00       	push   $0x1249b7
  1060ed:	6a 00                	push   $0x0
  1060ef:	53                   	push   %ebx
  1060f0:	e8 2a ff ff ff       	call   10601f <shell_fprintf>
  1060f5:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
  1060f8:	46                   	inc    %esi
  1060f9:	83 fe 10             	cmp    $0x10,%esi
  1060fc:	74 1a                	je     106118 <shell_hexdump_line+0xdf>
		if (i > 0 && !(i % 8)) {
  1060fe:	f7 c6 07 00 00 00    	test   $0x7,%esi
  106104:	75 b9                	jne    1060bf <shell_hexdump_line+0x86>
			shell_fprintf(shell, SHELL_NORMAL, " ");
  106106:	68 b7 49 12 00       	push   $0x1249b7
  10610b:	6a 00                	push   $0x0
  10610d:	53                   	push   %ebx
  10610e:	e8 0c ff ff ff       	call   10601f <shell_fprintf>
  106113:	83 c4 0c             	add    $0xc,%esp
  106116:	eb a7                	jmp    1060bf <shell_hexdump_line+0x86>
		}
	}

	shell_print(shell, "|");
  106118:	89 5d 08             	mov    %ebx,0x8(%ebp)
  10611b:	c7 45 10 c6 50 12 00 	movl   $0x1250c6,0x10(%ebp)
  106122:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
  106129:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10612c:	5b                   	pop    %ebx
  10612d:	5e                   	pop    %esi
  10612e:	5f                   	pop    %edi
  10612f:	5d                   	pop    %ebp
	shell_print(shell, "|");
  106130:	e9 ea fe ff ff       	jmp    10601f <shell_fprintf>

00106135 <shell_hexdump>:

void shell_hexdump(const struct shell *shell, const uint8_t *data, size_t len)
{
  106135:	55                   	push   %ebp
  106136:	89 e5                	mov    %esp,%ebp
  106138:	57                   	push   %edi
  106139:	56                   	push   %esi
  10613a:	53                   	push   %ebx
	const uint8_t *p = data;
  10613b:	8b 75 0c             	mov    0xc(%ebp),%esi
{
  10613e:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t line_len;

	while (len) {
  106141:	85 db                	test   %ebx,%ebx
  106143:	74 25                	je     10616a <shell_hexdump+0x35>
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
  106145:	89 df                	mov    %ebx,%edi
  106147:	83 fb 10             	cmp    $0x10,%ebx
  10614a:	76 05                	jbe    106151 <shell_hexdump+0x1c>
  10614c:	bf 10 00 00 00       	mov    $0x10,%edi

		shell_hexdump_line(shell, p - data, p, line_len);
  106151:	89 f0                	mov    %esi,%eax
  106153:	57                   	push   %edi
  106154:	2b 45 0c             	sub    0xc(%ebp),%eax
  106157:	56                   	push   %esi
  106158:	50                   	push   %eax

		len -= line_len;
  106159:	29 fb                	sub    %edi,%ebx
		shell_hexdump_line(shell, p - data, p, line_len);
  10615b:	ff 75 08             	pushl  0x8(%ebp)
		p += line_len;
  10615e:	01 fe                	add    %edi,%esi
		shell_hexdump_line(shell, p - data, p, line_len);
  106160:	e8 d4 fe ff ff       	call   106039 <shell_hexdump_line>
  106165:	83 c4 10             	add    $0x10,%esp
		p += line_len;
  106168:	eb d7                	jmp    106141 <shell_hexdump+0xc>
	}
}
  10616a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10616d:	5b                   	pop    %ebx
  10616e:	5e                   	pop    %esi
  10616f:	5f                   	pop    %edi
  106170:	5d                   	pop    %ebp
  106171:	c3                   	ret    

00106172 <shell_fprintf_buffer_flush>:
	}
}


void shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
  106172:	55                   	push   %ebp
  106173:	89 e5                	mov    %esp,%ebp
  106175:	53                   	push   %ebx
  106176:	8b 5d 08             	mov    0x8(%ebp),%ebx
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
  106179:	8b 43 10             	mov    0x10(%ebx),%eax
  10617c:	ff 30                	pushl  (%eax)
  10617e:	ff 33                	pushl  (%ebx)
  106180:	ff 73 0c             	pushl  0xc(%ebx)
  106183:	ff 53 08             	call   *0x8(%ebx)
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
  106186:	8b 43 10             	mov    0x10(%ebx),%eax
  106189:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
  10618f:	83 c4 0c             	add    $0xc,%esp
}
  106192:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  106195:	c9                   	leave  
  106196:	c3                   	ret    

00106197 <shell_fprintf_fmt>:
{
  106197:	55                   	push   %ebp
  106198:	89 e5                	mov    %esp,%ebp
  10619a:	53                   	push   %ebx
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
  10619b:	ff 75 10             	pushl  0x10(%ebp)
  10619e:	ff 75 0c             	pushl  0xc(%ebp)
{
  1061a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
  1061a4:	53                   	push   %ebx
  1061a5:	68 cc 61 10 00       	push   $0x1061cc
  1061aa:	e8 b4 bf ff ff       	call   102163 <z_prf>
	if (sh_fprintf->ctrl_blk->autoflush) {
  1061af:	8b 43 10             	mov    0x10(%ebx),%eax
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
  1061b2:	83 c4 10             	add    $0x10,%esp
	if (sh_fprintf->ctrl_blk->autoflush) {
  1061b5:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
  1061b9:	74 0c                	je     1061c7 <shell_fprintf_fmt+0x30>
		shell_fprintf_buffer_flush(sh_fprintf);
  1061bb:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1061be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1061c1:	c9                   	leave  
		shell_fprintf_buffer_flush(sh_fprintf);
  1061c2:	e9 ab ff ff ff       	jmp    106172 <shell_fprintf_buffer_flush>
}
  1061c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1061ca:	c9                   	leave  
  1061cb:	c3                   	ret    

001061cc <out_func>:
{
  1061cc:	55                   	push   %ebp
  1061cd:	89 e5                	mov    %esp,%ebp
  1061cf:	56                   	push   %esi
  1061d0:	53                   	push   %ebx
  1061d1:	8b 75 0c             	mov    0xc(%ebp),%esi
  1061d4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
  1061d7:	8b 46 0c             	mov    0xc(%esi),%eax
  1061da:	83 78 10 02          	cmpl   $0x2,0x10(%eax)
  1061de:	75 0f                	jne    1061ef <out_func+0x23>
  1061e0:	83 fb 0a             	cmp    $0xa,%ebx
  1061e3:	75 0a                	jne    1061ef <out_func+0x23>
		(void)out_func('\r', ctx);
  1061e5:	56                   	push   %esi
  1061e6:	6a 0d                	push   $0xd
  1061e8:	e8 df ff ff ff       	call   1061cc <out_func>
  1061ed:	5a                   	pop    %edx
  1061ee:	59                   	pop    %ecx
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
  1061ef:	8b 46 10             	mov    0x10(%esi),%eax
  1061f2:	8b 16                	mov    (%esi),%edx
  1061f4:	8b 00                	mov    (%eax),%eax
  1061f6:	88 1c 02             	mov    %bl,(%edx,%eax,1)
	sh_fprintf->ctrl_blk->buffer_cnt++;
  1061f9:	8b 56 10             	mov    0x10(%esi),%edx
  1061fc:	8b 02                	mov    (%edx),%eax
  1061fe:	40                   	inc    %eax
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
  1061ff:	3b 46 04             	cmp    0x4(%esi),%eax
	sh_fprintf->ctrl_blk->buffer_cnt++;
  106202:	89 02                	mov    %eax,(%edx)
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
  106204:	75 07                	jne    10620d <out_func+0x41>
		shell_fprintf_buffer_flush(sh_fprintf);
  106206:	56                   	push   %esi
  106207:	e8 66 ff ff ff       	call   106172 <shell_fprintf_buffer_flush>
  10620c:	58                   	pop    %eax
}
  10620d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106210:	31 c0                	xor    %eax,%eax
  106212:	5b                   	pop    %ebx
  106213:	5e                   	pop    %esi
  106214:	5d                   	pop    %ebp
  106215:	c3                   	ret    

00106216 <shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
  106216:	85 c0                	test   %eax,%eax
  106218:	74 0c                	je     106226 <shell_strlen+0x10>
{
  10621a:	55                   	push   %ebp
  10621b:	89 e5                	mov    %esp,%ebp
	return str == NULL ? 0U : (uint16_t)strlen(str);
  10621d:	50                   	push   %eax
  10621e:	e8 f9 5a 00 00       	call   10bd1c <strlen>
  106223:	5a                   	pop    %edx
}
  106224:	c9                   	leave  
  106225:	c3                   	ret    
	return str == NULL ? 0U : (uint16_t)strlen(str);
  106226:	31 c0                	xor    %eax,%eax
}
  106228:	c3                   	ret    

00106229 <column_span_with_buffer_offsets_get>:
}

int32_t column_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
					  uint16_t offset1,
					  uint16_t offset2)
{
  106229:	55                   	push   %ebp
  10622a:	89 e5                	mov    %esp,%ebp
  10622c:	56                   	push   %esi
  10622d:	53                   	push   %ebx
  10622e:	8b 45 08             	mov    0x8(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  106231:	0f b6 70 0c          	movzbl 0xc(%eax),%esi
  106235:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
	return col_num_with_buffer_offset_get(cons, offset2)
  106239:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  10623d:	01 f0                	add    %esi,%eax
  10623f:	99                   	cltd   
  106240:	f7 fb                	idiv   %ebx
			- col_num_with_buffer_offset_get(cons, offset1);
  106242:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
  106246:	01 f0                	add    %esi,%eax
  106248:	89 d1                	mov    %edx,%ecx
  10624a:	99                   	cltd   
  10624b:	f7 fb                	idiv   %ebx
}
  10624d:	5b                   	pop    %ebx
			- col_num_with_buffer_offset_get(cons, offset1);
  10624e:	89 c8                	mov    %ecx,%eax
}
  106250:	5e                   	pop    %esi
			- col_num_with_buffer_offset_get(cons, offset1);
  106251:	29 d0                	sub    %edx,%eax
}
  106253:	5d                   	pop    %ebp
  106254:	c3                   	ret    

00106255 <row_span_with_buffer_offsets_get>:

int32_t row_span_with_buffer_offsets_get(struct shell_multiline_cons *cons,
				       uint16_t offset1,
				       uint16_t offset2)
{
  106255:	55                   	push   %ebp
  106256:	89 e5                	mov    %esp,%ebp
  106258:	56                   	push   %esi
  106259:	53                   	push   %ebx
  10625a:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  10625d:	0f b6 70 0c          	movzbl 0xc(%eax),%esi
  106261:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
	return line_num_with_buffer_offset_get(cons, offset2)
  106265:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  106269:	01 f0                	add    %esi,%eax
  10626b:	99                   	cltd   
  10626c:	f7 fb                	idiv   %ebx
  10626e:	89 c1                	mov    %eax,%ecx
		- line_num_with_buffer_offset_get(cons, offset1);
  106270:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
  106274:	01 f0                	add    %esi,%eax
  106276:	99                   	cltd   
  106277:	f7 fb                	idiv   %ebx
}
  106279:	5b                   	pop    %ebx
		- line_num_with_buffer_offset_get(cons, offset1);
  10627a:	29 c1                	sub    %eax,%ecx
}
  10627c:	5e                   	pop    %esi
		- line_num_with_buffer_offset_get(cons, offset1);
  10627d:	89 c8                	mov    %ecx,%eax
}
  10627f:	5d                   	pop    %ebp
  106280:	c3                   	ret    

00106281 <shell_multiline_data_calc>:

void shell_multiline_data_calc(struct shell_multiline_cons *cons,
			       uint16_t buff_pos, uint16_t buff_len)
{
  106281:	55                   	push   %ebp
  106282:	89 e5                	mov    %esp,%ebp
  106284:	56                   	push   %esi
  106285:	53                   	push   %ebx
  106286:	8b 4d 08             	mov    0x8(%ebp),%ecx
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  106289:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  10628d:	0f b6 71 0c          	movzbl 0xc(%ecx),%esi
  106291:	0f b7 59 0a          	movzwl 0xa(%ecx),%ebx
  106295:	01 f0                	add    %esi,%eax
  106297:	99                   	cltd   
  106298:	f7 fb                	idiv   %ebx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
  10629a:	40                   	inc    %eax
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  10629b:	42                   	inc    %edx
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
  10629c:	66 89 41 04          	mov    %ax,0x4(%ecx)
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
  1062a0:	66 89 11             	mov    %dx,(%ecx)

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
  1062a3:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  1062a7:	01 f0                	add    %esi,%eax
  1062a9:	99                   	cltd   
  1062aa:	f7 fb                	idiv   %ebx
  1062ac:	40                   	inc    %eax
  1062ad:	66 89 41 06          	mov    %ax,0x6(%ecx)
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
  1062b1:	8d 42 01             	lea    0x1(%edx),%eax
  1062b4:	66 89 41 02          	mov    %ax,0x2(%ecx)
}
  1062b8:	5b                   	pop    %ebx
  1062b9:	5e                   	pop    %esi
  1062ba:	5d                   	pop    %ebp
  1062bb:	c3                   	ret    

001062bc <shell_make_argv>:
	return quote;
}


char shell_make_argv(size_t *argc, const char **argv, char *cmd, uint8_t max_argc)
{
  1062bc:	55                   	push   %ebp
  1062bd:	89 e5                	mov    %esp,%ebp
  1062bf:	57                   	push   %edi
  1062c0:	56                   	push   %esi
  1062c1:	53                   	push   %ebx
  1062c2:	50                   	push   %eax
	char quote = 0;
  1062c3:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
{
  1062c7:	8a 45 14             	mov    0x14(%ebp),%al
  1062ca:	8b 5d 10             	mov    0x10(%ebp),%ebx
  1062cd:	88 45 f1             	mov    %al,-0xf(%ebp)
	char c;

	*argc = 0;
  1062d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1062d3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	do {
		c = *cmd;
  1062d9:	8a 03                	mov    (%ebx),%al
		if (c == '\0') {
  1062db:	84 c0                	test   %al,%al
  1062dd:	0f 84 bf 01 00 00    	je     1064a2 <shell_make_argv+0x1e6>
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  1062e3:	0f be d0             	movsbl %al,%edx
  1062e6:	83 ea 09             	sub    $0x9,%edx
			break;
		}

		if (isspace((int) c)) {
  1062e9:	83 fa 04             	cmp    $0x4,%edx
  1062ec:	76 04                	jbe    1062f2 <shell_make_argv+0x36>
  1062ee:	3c 20                	cmp    $0x20,%al
  1062f0:	75 06                	jne    1062f8 <shell_make_argv+0x3c>
			*cmd++ = '\0';
  1062f2:	c6 03 00             	movb   $0x0,(%ebx)
  1062f5:	43                   	inc    %ebx
			continue;
  1062f6:	eb e1                	jmp    1062d9 <shell_make_argv+0x1d>
		}

		argv[(*argc)++] = cmd;
  1062f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1062fb:	8b 7d 08             	mov    0x8(%ebp),%edi
  1062fe:	8b 10                	mov    (%eax),%edx
  106300:	8d 42 01             	lea    0x1(%edx),%eax
  106303:	89 07                	mov    %eax,(%edi)
  106305:	8b 7d 0c             	mov    0xc(%ebp),%edi
  106308:	89 1c 97             	mov    %ebx,(%edi,%edx,4)
		if (*argc == max_argc) {
  10630b:	0f b6 55 f1          	movzbl -0xf(%ebp),%edx
  10630f:	39 d0                	cmp    %edx,%eax
  106311:	0f 84 8b 01 00 00    	je     1064a2 <shell_make_argv+0x1e6>
	char quote = 0;
  106317:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
		c = *cmd;
  10631b:	8a 13                	mov    (%ebx),%dl
		if (c == '\0') {
  10631d:	84 d2                	test   %dl,%dl
  10631f:	74 b8                	je     1062d9 <shell_make_argv+0x1d>
		if (!quote) {
  106321:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  106325:	75 3e                	jne    106365 <shell_make_argv+0xa9>
			switch (c) {
  106327:	80 fa 27             	cmp    $0x27,%dl
  10632a:	74 18                	je     106344 <shell_make_argv+0x88>
  10632c:	80 fa 5c             	cmp    $0x5c,%dl
  10632f:	74 07                	je     106338 <shell_make_argv+0x7c>
  106331:	80 fa 22             	cmp    $0x22,%dl
  106334:	75 2f                	jne    106365 <shell_make_argv+0xa9>
  106336:	eb 0c                	jmp    106344 <shell_make_argv+0x88>
						shell_strlen(cmd));
  106338:	89 d8                	mov    %ebx,%eax
				memmove(cmd, cmd + 1,
  10633a:	8d 7b 01             	lea    0x1(%ebx),%edi
						shell_strlen(cmd));
  10633d:	e8 d4 fe ff ff       	call   106216 <shell_strlen>
  106342:	eb 71                	jmp    1063b5 <shell_make_argv+0xf9>
						shell_strlen(cmd));
  106344:	89 d8                	mov    %ebx,%eax
  106346:	88 55 f3             	mov    %dl,-0xd(%ebp)
  106349:	e8 c8 fe ff ff       	call   106216 <shell_strlen>
				continue;
  10634e:	89 df                	mov    %ebx,%edi
				memmove(cmd, cmd + 1,
  106350:	0f b7 c0             	movzwl %ax,%eax
  106353:	50                   	push   %eax
  106354:	8d 43 01             	lea    0x1(%ebx),%eax
  106357:	50                   	push   %eax
  106358:	53                   	push   %ebx
  106359:	e8 53 5a 00 00       	call   10bdb1 <memmove>
  10635e:	83 c4 0c             	add    $0xc,%esp
				continue;
  106361:	89 fb                	mov    %edi,%ebx
  106363:	eb b6                	jmp    10631b <shell_make_argv+0x5f>
		if (quote == c) {
  106365:	0f be 4d f3          	movsbl -0xd(%ebp),%ecx
  106369:	0f b6 c2             	movzbl %dl,%eax
  10636c:	39 c1                	cmp    %eax,%ecx
  10636e:	75 20                	jne    106390 <shell_make_argv+0xd4>
			memmove(cmd, cmd + 1, shell_strlen(cmd));
  106370:	89 d8                	mov    %ebx,%eax
			continue;
  106372:	89 df                	mov    %ebx,%edi
			memmove(cmd, cmd + 1, shell_strlen(cmd));
  106374:	e8 9d fe ff ff       	call   106216 <shell_strlen>
  106379:	0f b7 c0             	movzwl %ax,%eax
  10637c:	50                   	push   %eax
  10637d:	8d 43 01             	lea    0x1(%ebx),%eax
  106380:	50                   	push   %eax
  106381:	53                   	push   %ebx
  106382:	e8 2a 5a 00 00       	call   10bdb1 <memmove>
  106387:	83 c4 0c             	add    $0xc,%esp
			quote = 0;
  10638a:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
			continue;
  10638e:	eb d1                	jmp    106361 <shell_make_argv+0xa5>
		if (quote && c == '\\') {
  106390:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  106394:	0f 84 e5 00 00 00    	je     10647f <shell_make_argv+0x1c3>
  10639a:	80 fa 5c             	cmp    $0x5c,%dl
  10639d:	0f 85 dc 00 00 00    	jne    10647f <shell_make_argv+0x1c3>
			char t = *(cmd + 1);
  1063a3:	8a 43 01             	mov    0x1(%ebx),%al
			if (t == quote) {
  1063a6:	8d 7b 01             	lea    0x1(%ebx),%edi
  1063a9:	38 45 f3             	cmp    %al,-0xd(%ebp)
  1063ac:	75 17                	jne    1063c5 <shell_make_argv+0x109>
						shell_strlen(cmd));
  1063ae:	89 d8                	mov    %ebx,%eax
  1063b0:	e8 61 fe ff ff       	call   106216 <shell_strlen>
				memmove(cmd, cmd + 1,
  1063b5:	0f b7 c0             	movzwl %ax,%eax
  1063b8:	50                   	push   %eax
  1063b9:	57                   	push   %edi
  1063ba:	53                   	push   %ebx
  1063bb:	e8 f1 59 00 00       	call   10bdb1 <memmove>
  1063c0:	83 c4 0c             	add    $0xc,%esp
				continue;
  1063c3:	eb 9c                	jmp    106361 <shell_make_argv+0xa5>
			if (t == '0') {
  1063c5:	3c 30                	cmp    $0x30,%al
  1063c7:	75 2c                	jne    1063f5 <shell_make_argv+0x139>
  1063c9:	b9 02 00 00 00       	mov    $0x2,%ecx
				uint8_t v = 0U;
  1063ce:	31 f6                	xor    %esi,%esi
					t = *(cmd + i);
  1063d0:	8a 04 0b             	mov    (%ebx,%ecx,1),%al
  1063d3:	88 4d f2             	mov    %cl,-0xe(%ebp)
					if (t >= '0' && t <= '7') {
  1063d6:	8d 50 d0             	lea    -0x30(%eax),%edx
  1063d9:	80 fa 07             	cmp    $0x7,%dl
  1063dc:	77 11                	ja     1063ef <shell_make_argv+0x133>
						v = (v << 3) | (t - '0');
  1063de:	c1 e6 03             	shl    $0x3,%esi
  1063e1:	41                   	inc    %ecx
  1063e2:	09 d6                	or     %edx,%esi
				for (i = 2U; i < (2 + 3); i++) {
  1063e4:	83 f9 05             	cmp    $0x5,%ecx
  1063e7:	75 e7                	jne    1063d0 <shell_make_argv+0x114>
  1063e9:	c6 45 f2 05          	movb   $0x5,-0xe(%ebp)
  1063ed:	eb 65                	jmp    106454 <shell_make_argv+0x198>
				if (i > 2) {
  1063ef:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  1063f3:	75 5f                	jne    106454 <shell_make_argv+0x198>
			if (t == 'x') {
  1063f5:	3c 78                	cmp    $0x78,%al
  1063f7:	0f 85 9d 00 00 00    	jne    10649a <shell_make_argv+0x1de>
  1063fd:	ba 02 00 00 00       	mov    $0x2,%edx
				uint8_t v = 0U;
  106402:	31 f6                	xor    %esi,%esi
					t = *(cmd + i);
  106404:	8a 04 13             	mov    (%ebx,%edx,1),%al
  106407:	88 55 f2             	mov    %dl,-0xe(%ebp)
					if (t >= '0' && t <= '9') {
  10640a:	8d 48 d0             	lea    -0x30(%eax),%ecx
  10640d:	80 f9 09             	cmp    $0x9,%cl
  106410:	77 07                	ja     106419 <shell_make_argv+0x15d>
						v = (v << 4) | (t - '0');
  106412:	c1 e6 04             	shl    $0x4,%esi
  106415:	09 ce                	or     %ecx,%esi
  106417:	eb 20                	jmp    106439 <shell_make_argv+0x17d>
					} else if ((t >= 'a') &&
  106419:	8d 48 9f             	lea    -0x61(%eax),%ecx
  10641c:	80 f9 05             	cmp    $0x5,%cl
  10641f:	77 08                	ja     106429 <shell_make_argv+0x16d>
						v = (v << 4) | (t - 'a' + 10);
  106421:	c1 e6 04             	shl    $0x4,%esi
  106424:	83 e8 57             	sub    $0x57,%eax
  106427:	eb 0e                	jmp    106437 <shell_make_argv+0x17b>
					} else if ((t >= 'A') && (t <= 'F')) {
  106429:	8d 48 bf             	lea    -0x41(%eax),%ecx
  10642c:	80 f9 05             	cmp    $0x5,%cl
  10642f:	77 18                	ja     106449 <shell_make_argv+0x18d>
						v = (v << 4) | (t - 'A' + 10);
  106431:	c1 e6 04             	shl    $0x4,%esi
  106434:	83 e8 37             	sub    $0x37,%eax
  106437:	09 c6                	or     %eax,%esi
				for (i = 2U; i < (2 + 2); i++) {
  106439:	83 fa 03             	cmp    $0x3,%edx
  10643c:	74 07                	je     106445 <shell_make_argv+0x189>
  10643e:	ba 03 00 00 00       	mov    $0x3,%edx
  106443:	eb bf                	jmp    106404 <shell_make_argv+0x148>
  106445:	b2 04                	mov    $0x4,%dl
  106447:	eb 08                	jmp    106451 <shell_make_argv+0x195>
				if (i > 2) {
  106449:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  10644d:	74 4b                	je     10649a <shell_make_argv+0x1de>
  10644f:	b2 03                	mov    $0x3,%dl
  106451:	88 55 f2             	mov    %dl,-0xe(%ebp)
						shell_strlen(cmd) - (i - 2));
  106454:	89 d8                	mov    %ebx,%eax
  106456:	e8 bb fd ff ff       	call   106216 <shell_strlen>
  10645b:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
  10645f:	0f b7 c0             	movzwl %ax,%eax
  106462:	83 c0 02             	add    $0x2,%eax
  106465:	29 d0                	sub    %edx,%eax
					memmove(cmd, cmd + (i - 1),
  106467:	50                   	push   %eax
  106468:	8d 44 13 ff          	lea    -0x1(%ebx,%edx,1),%eax
  10646c:	50                   	push   %eax
  10646d:	53                   	push   %ebx
  10646e:	e8 3e 59 00 00       	call   10bdb1 <memmove>
					*cmd++ = v;
  106473:	89 f0                	mov    %esi,%eax
					memmove(cmd, cmd + (i - 1),
  106475:	83 c4 0c             	add    $0xc,%esp
					*cmd++ = v;
  106478:	88 03                	mov    %al,(%ebx)
					continue;
  10647a:	e9 e2 fe ff ff       	jmp    106361 <shell_make_argv+0xa5>
		if (!quote && isspace((int) c)) {
  10647f:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  106483:	75 15                	jne    10649a <shell_make_argv+0x1de>
  106485:	8d 50 f7             	lea    -0x9(%eax),%edx
  106488:	83 fa 04             	cmp    $0x4,%edx
  10648b:	0f 86 48 fe ff ff    	jbe    1062d9 <shell_make_argv+0x1d>
  106491:	83 f8 20             	cmp    $0x20,%eax
  106494:	0f 84 3f fe ff ff    	je     1062d9 <shell_make_argv+0x1d>
		cmd += 1;
  10649a:	8d 7b 01             	lea    0x1(%ebx),%edi
  10649d:	e9 bf fe ff ff       	jmp    106361 <shell_make_argv+0xa5>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
  1064a2:	8a 45 f3             	mov    -0xd(%ebp),%al
  1064a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1064a8:	5b                   	pop    %ebx
  1064a9:	5e                   	pop    %esi
  1064aa:	5f                   	pop    %edi
  1064ab:	5d                   	pop    %ebp
  1064ac:	c3                   	ret    

001064ad <shell_pattern_remove>:

void shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
  1064ad:	55                   	push   %ebp
  1064ae:	89 e5                	mov    %esp,%ebp
  1064b0:	57                   	push   %edi
  1064b1:	56                   	push   %esi
  1064b2:	53                   	push   %ebx
  1064b3:	50                   	push   %eax
  1064b4:	8b 5d 10             	mov    0x10(%ebp),%ebx
  1064b7:	8b 55 08             	mov    0x8(%ebp),%edx
	char *pattern_addr = strstr(buff, pattern);
  1064ba:	53                   	push   %ebx
  1064bb:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1064be:	52                   	push   %edx
{
  1064bf:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char *pattern_addr = strstr(buff, pattern);
  1064c2:	e8 61 57 00 00       	call   10bc28 <strstr>
  1064c7:	5a                   	pop    %edx
  1064c8:	89 c6                	mov    %eax,%esi
	uint16_t shift;
	uint16_t pattern_len = shell_strlen(pattern);
  1064ca:	89 d8                	mov    %ebx,%eax
	char *pattern_addr = strstr(buff, pattern);
  1064cc:	59                   	pop    %ecx
	uint16_t pattern_len = shell_strlen(pattern);
  1064cd:	e8 44 fd ff ff       	call   106216 <shell_strlen>

	if (!pattern_addr) {
  1064d2:	85 f6                	test   %esi,%esi
  1064d4:	74 3b                	je     106511 <shell_pattern_remove+0x64>
		return;
	}

	if (pattern_addr > buff) {
  1064d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1064d9:	89 c3                	mov    %eax,%ebx
  1064db:	39 f2                	cmp    %esi,%edx
  1064dd:	73 08                	jae    1064e7 <shell_pattern_remove+0x3a>
		if (*(pattern_addr - 1) == ' ') {
  1064df:	80 7e ff 20          	cmpb   $0x20,-0x1(%esi)
  1064e3:	75 02                	jne    1064e7 <shell_pattern_remove+0x3a>
			pattern_len++; /* space needs to be removed as well */
  1064e5:	43                   	inc    %ebx
			pattern_addr--; /* set pointer to space */
  1064e6:	4e                   	dec    %esi
		}
	}

	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  1064e7:	89 f0                	mov    %esi,%eax
  1064e9:	e8 28 fd ff ff       	call   106216 <shell_strlen>
	*buff_len -= pattern_len;
  1064ee:	66 29 1f             	sub    %bx,(%edi)
	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
  1064f1:	29 d8                	sub    %ebx,%eax
  1064f3:	40                   	inc    %eax

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  1064f4:	89 75 08             	mov    %esi,0x8(%ebp)
  1064f7:	0f b7 db             	movzwl %bx,%ebx
  1064fa:	01 f3                	add    %esi,%ebx
  1064fc:	0f b7 c0             	movzwl %ax,%eax
  1064ff:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  106502:	89 45 10             	mov    %eax,0x10(%ebp)
}
  106505:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106508:	5b                   	pop    %ebx
  106509:	5e                   	pop    %esi
  10650a:	5f                   	pop    %edi
  10650b:	5d                   	pop    %ebp
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
  10650c:	e9 a0 58 00 00       	jmp    10bdb1 <memmove>
}
  106511:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106514:	5b                   	pop    %ebx
  106515:	5e                   	pop    %esi
  106516:	5f                   	pop    %edi
  106517:	5d                   	pop    %ebp
  106518:	c3                   	ret    

00106519 <shell_cmd_get>:

const struct shell_static_entry *shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
  106519:	55                   	push   %ebp
  10651a:	89 e5                	mov    %esp,%ebp
  10651c:	53                   	push   %ebx
  10651d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106520:	8b 55 0c             	mov    0xc(%ebp),%edx
  106523:	8b 45 10             	mov    0x10(%ebp),%eax
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
  106526:	85 c9                	test   %ecx,%ecx
  106528:	75 1a                	jne    106544 <shell_cmd_get+0x2b>
	return ((uint8_t *)__shell_root_cmds_end -
  10652a:	b8 68 32 12 00       	mov    $0x123268,%eax
  10652f:	2d 20 32 12 00       	sub    $0x123220,%eax
			(uint8_t *)__shell_root_cmds_start)/
  106534:	c1 e8 03             	shr    $0x3,%eax
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
  106537:	39 c2                	cmp    %eax,%edx
  106539:	73 29                	jae    106564 <shell_cmd_get+0x4b>
  10653b:	8b 04 d5 24 32 12 00 	mov    0x123224(,%edx,8),%eax
  106542:	eb 2b                	jmp    10656f <shell_cmd_get+0x56>
	}

	__ASSERT_NO_MSG(dloc != NULL);

	if (parent->subcmd) {
  106544:	8b 49 08             	mov    0x8(%ecx),%ecx
  106547:	85 c9                	test   %ecx,%ecx
  106549:	74 19                	je     106564 <shell_cmd_get+0x4b>
		if (parent->subcmd->is_dynamic) {
  10654b:	80 39 00             	cmpb   $0x0,(%ecx)
  10654e:	8b 59 04             	mov    0x4(%ecx),%ebx
  106551:	74 15                	je     106568 <shell_cmd_get+0x4f>
			parent->subcmd->u.dynamic_get(idx, dloc);
  106553:	50                   	push   %eax
  106554:	89 45 10             	mov    %eax,0x10(%ebp)
  106557:	52                   	push   %edx
  106558:	ff d3                	call   *%ebx
  10655a:	58                   	pop    %eax
			if (dloc->syntax != NULL) {
  10655b:	8b 45 10             	mov    0x10(%ebp),%eax
			parent->subcmd->u.dynamic_get(idx, dloc);
  10655e:	5a                   	pop    %edx
			if (dloc->syntax != NULL) {
  10655f:	83 38 00             	cmpl   $0x0,(%eax)
  106562:	75 0b                	jne    10656f <shell_cmd_get+0x56>
	const struct shell_static_entry *res = NULL;
  106564:	31 c0                	xor    %eax,%eax
  106566:	eb 07                	jmp    10656f <shell_cmd_get+0x56>
				res = dloc;
			}
		} else {
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
  106568:	6b c2 14             	imul   $0x14,%edx,%eax
  10656b:	01 d8                	add    %ebx,%eax
  10656d:	eb f0                	jmp    10655f <shell_cmd_get+0x46>
			}
		}
	}

	return res;
}
  10656f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  106572:	c9                   	leave  
  106573:	c3                   	ret    

00106574 <shell_find_cmd>:
 */
const struct shell_static_entry *shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
  106574:	55                   	push   %ebp
  106575:	89 e5                	mov    %esp,%ebp
  106577:	56                   	push   %esi
  106578:	53                   	push   %ebx
	const struct shell_static_entry *entry;
	size_t idx = 0;
  106579:	31 db                	xor    %ebx,%ebx

	while ((entry = shell_cmd_get(parent, idx++, dloc)) != NULL) {
  10657b:	ff 75 10             	pushl  0x10(%ebp)
  10657e:	89 d8                	mov    %ebx,%eax
  106580:	43                   	inc    %ebx
  106581:	50                   	push   %eax
  106582:	ff 75 08             	pushl  0x8(%ebp)
  106585:	e8 8f ff ff ff       	call   106519 <shell_cmd_get>
  10658a:	83 c4 0c             	add    $0xc,%esp
  10658d:	89 c6                	mov    %eax,%esi
  10658f:	85 c0                	test   %eax,%eax
  106591:	74 10                	je     1065a3 <shell_find_cmd+0x2f>
		if (strcmp(cmd_str, entry->syntax) == 0) {
  106593:	ff 36                	pushl  (%esi)
  106595:	ff 75 0c             	pushl  0xc(%ebp)
  106598:	e8 92 57 00 00       	call   10bd2f <strcmp>
  10659d:	5a                   	pop    %edx
  10659e:	85 c0                	test   %eax,%eax
  1065a0:	59                   	pop    %ecx
  1065a1:	75 d8                	jne    10657b <shell_find_cmd+0x7>
			return entry;
		}
	};

	return NULL;
}
  1065a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1065a6:	89 f0                	mov    %esi,%eax
  1065a8:	5b                   	pop    %ebx
  1065a9:	5e                   	pop    %esi
  1065aa:	5d                   	pop    %ebp
  1065ab:	c3                   	ret    

001065ac <shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
  1065ac:	55                   	push   %ebp
  1065ad:	89 e5                	mov    %esp,%ebp
  1065af:	57                   	push   %edi
  1065b0:	56                   	push   %esi
  1065b1:	53                   	push   %ebx
  1065b2:	51                   	push   %ecx
  1065b3:	8b 5d 14             	mov    0x14(%ebp),%ebx
  1065b6:	8a 45 1c             	mov    0x1c(%ebp),%al
  1065b9:	8b 75 10             	mov    0x10(%ebp),%esi
  1065bc:	88 45 f3             	mov    %al,-0xd(%ebp)
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = SHELL_CMD_ROOT_LVL;
  1065bf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

	while (*match_arg < argc) {
  1065c5:	8b 7d 08             	mov    0x8(%ebp),%edi
  1065c8:	8b 03                	mov    (%ebx),%eax
  1065ca:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1065cd:	73 44                	jae    106613 <shell_get_last_command+0x67>

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (shell_wildcard_character_exist(argv[*match_arg])) {
  1065cf:	ff 34 86             	pushl  (%esi,%eax,4)
  1065d2:	e8 00 1a 00 00       	call   107fd7 <shell_wildcard_character_exist>
  1065d7:	5a                   	pop    %edx
  1065d8:	84 c0                	test   %al,%al
  1065da:	74 06                	je     1065e2 <shell_get_last_command+0x36>
				(*match_arg)++;
  1065dc:	ff 03                	incl   (%ebx)
				continue;
  1065de:	89 f8                	mov    %edi,%eax
  1065e0:	eb 2d                	jmp    10660f <shell_get_last_command+0x63>
			}
		}

		prev_entry = entry;
		entry = shell_find_cmd(entry, argv[*match_arg], dloc);
  1065e2:	ff 75 18             	pushl  0x18(%ebp)
  1065e5:	8b 03                	mov    (%ebx),%eax
  1065e7:	ff 34 86             	pushl  (%esi,%eax,4)
  1065ea:	57                   	push   %edi
  1065eb:	e8 84 ff ff ff       	call   106574 <shell_find_cmd>
  1065f0:	83 c4 0c             	add    $0xc,%esp
		if (entry) {
  1065f3:	85 c0                	test   %eax,%eax
  1065f5:	74 1c                	je     106613 <shell_get_last_command+0x67>
			(*match_arg)++;
  1065f7:	8b 13                	mov    (%ebx),%edx
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
  1065f9:	39 45 18             	cmp    %eax,0x18(%ebp)
			(*match_arg)++;
  1065fc:	8d 4a 01             	lea    0x1(%edx),%ecx
  1065ff:	89 0b                	mov    %ecx,(%ebx)
		if (only_static && (entry == dloc)) {
  106601:	75 0c                	jne    10660f <shell_get_last_command+0x63>
  106603:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  106607:	74 06                	je     10660f <shell_get_last_command+0x63>
			(*match_arg)--;
  106609:	89 13                	mov    %edx,(%ebx)
			return NULL;
  10660b:	31 ff                	xor    %edi,%edi
  10660d:	eb 04                	jmp    106613 <shell_get_last_command+0x67>
				continue;
  10660f:	89 c7                	mov    %eax,%edi
  106611:	eb b5                	jmp    1065c8 <shell_get_last_command+0x1c>
		}
	}

	return entry;
}
  106613:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106616:	89 f8                	mov    %edi,%eax
  106618:	5b                   	pop    %ebx
  106619:	5e                   	pop    %esi
  10661a:	5f                   	pop    %edi
  10661b:	5d                   	pop    %ebp
  10661c:	c3                   	ret    

0010661d <shell_spaces_trim>:

	return 0;
}

void shell_spaces_trim(char *str)
{
  10661d:	55                   	push   %ebp
  10661e:	89 e5                	mov    %esp,%ebp
  106620:	57                   	push   %edi
  106621:	56                   	push   %esi
  106622:	53                   	push   %ebx
  106623:	83 ec 10             	sub    $0x10,%esp
  106626:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint16_t len = shell_strlen(str);
  106629:	89 d8                	mov    %ebx,%eax
  10662b:	e8 e6 fb ff ff       	call   106216 <shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
  106630:	85 db                	test   %ebx,%ebx
	uint16_t len = shell_strlen(str);
  106632:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	if (!str) {
  106636:	0f 84 87 00 00 00    	je     1066c3 <shell_spaces_trim+0xa6>
		return;
	}

	for (uint16_t i = 0; i < len - 1; i++) {
  10663c:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	uint16_t shift = 0U;
  106642:	31 f6                	xor    %esi,%esi
	for (uint16_t i = 0; i < len - 1; i++) {
  106644:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  106648:	0f b7 7d f0          	movzwl -0x10(%ebp),%edi
  10664c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10664f:	48                   	dec    %eax
  106650:	39 c7                	cmp    %eax,%edi
  106652:	7d 6f                	jge    1066c3 <shell_spaces_trim+0xa6>
		if (isspace((int)str[i])) {
  106654:	0f be 14 3b          	movsbl (%ebx,%edi,1),%edx
  106658:	89 d0                	mov    %edx,%eax
  10665a:	83 ea 09             	sub    $0x9,%edx
  10665d:	83 fa 04             	cmp    $0x4,%edx
  106660:	76 04                	jbe    106666 <shell_spaces_trim+0x49>
  106662:	3c 20                	cmp    $0x20,%al
  106664:	75 57                	jne    1066bd <shell_spaces_trim+0xa0>
			for (uint16_t j = i + 1; j < len; j++) {
  106666:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106669:	40                   	inc    %eax
  10666a:	0f b7 c0             	movzwl %ax,%eax
  10666d:	66 39 45 f2          	cmp    %ax,-0xe(%ebp)
  106671:	76 4a                	jbe    1066bd <shell_spaces_trim+0xa0>
				if (isspace((int)str[j])) {
  106673:	8d 0c 03             	lea    (%ebx,%eax,1),%ecx
  106676:	8a 14 03             	mov    (%ebx,%eax,1),%dl
  106679:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10667c:	8d 48 01             	lea    0x1(%eax),%ecx
  10667f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  106682:	0f be ca             	movsbl %dl,%ecx
  106685:	83 e9 09             	sub    $0x9,%ecx
  106688:	83 f9 04             	cmp    $0x4,%ecx
  10668b:	76 05                	jbe    106692 <shell_spaces_trim+0x75>
  10668d:	80 fa 20             	cmp    $0x20,%dl
  106690:	75 06                	jne    106698 <shell_spaces_trim+0x7b>
					shift++;
  106692:	46                   	inc    %esi
  106693:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106696:	eb d5                	jmp    10666d <shell_spaces_trim+0x50>
					continue;
				}

				if (shift > 0) {
  106698:	66 85 f6             	test   %si,%si
  10669b:	74 20                	je     1066bd <shell_spaces_trim+0xa0>
					/* +1 for EOS */
					memmove(&str[i + 1],
						&str[j],
						len - j + 1);
  10669d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1066a0:	0f b7 c0             	movzwl %ax,%eax
  1066a3:	42                   	inc    %edx
  1066a4:	29 c2                	sub    %eax,%edx
					memmove(&str[i + 1],
  1066a6:	8d 44 3b 01          	lea    0x1(%ebx,%edi,1),%eax
  1066aa:	52                   	push   %edx
  1066ab:	ff 75 e4             	pushl  -0x1c(%ebp)
  1066ae:	50                   	push   %eax
  1066af:	e8 fd 56 00 00       	call   10bdb1 <memmove>
					len -= shift;
  1066b4:	66 29 75 f2          	sub    %si,-0xe(%ebp)
					memmove(&str[i + 1],
  1066b8:	83 c4 0c             	add    $0xc,%esp
					shift = 0U;
  1066bb:	31 f6                	xor    %esi,%esi
	for (uint16_t i = 0; i < len - 1; i++) {
  1066bd:	66 ff 45 f0          	incw   -0x10(%ebp)
  1066c1:	eb 81                	jmp    106644 <shell_spaces_trim+0x27>

				break;
			}
		}
	}
}
  1066c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1066c6:	5b                   	pop    %ebx
  1066c7:	5e                   	pop    %esi
  1066c8:	5f                   	pop    %edi
  1066c9:	5d                   	pop    %ebp
  1066ca:	c3                   	ret    

001066cb <shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void shell_cmd_trim(const struct shell *shell)
{
  1066cb:	55                   	push   %ebp
  1066cc:	89 e5                	mov    %esp,%ebp
  1066ce:	57                   	push   %edi
  1066cf:	56                   	push   %esi
  1066d0:	53                   	push   %ebx
  1066d1:	83 ec 08             	sub    $0x8,%esp
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
  1066d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1066d7:	8b 58 08             	mov    0x8(%eax),%ebx
	if (buff[0] == '\0') {
  1066da:	80 7b 46 00          	cmpb   $0x0,0x46(%ebx)
  1066de:	8d 43 46             	lea    0x46(%ebx),%eax
  1066e1:	74 73                	je     106756 <shell_cmd_trim+0x8b>
	while (isspace((int) buff[*buff_len - 1U])) {
  1066e3:	0f b7 7b 40          	movzwl 0x40(%ebx),%edi
  1066e7:	89 fa                	mov    %edi,%edx
  1066e9:	0f be 74 38 ff       	movsbl -0x1(%eax,%edi,1),%esi
  1066ee:	89 f1                	mov    %esi,%ecx
  1066f0:	83 ee 09             	sub    $0x9,%esi
  1066f3:	83 fe 04             	cmp    $0x4,%esi
  1066f6:	77 10                	ja     106708 <shell_cmd_trim+0x3d>
		*buff_len -= 1U;
  1066f8:	4a                   	dec    %edx
		if (*buff_len == 0U) {
  1066f9:	66 85 d2             	test   %dx,%dx
		*buff_len -= 1U;
  1066fc:	66 89 53 40          	mov    %dx,0x40(%ebx)
		if (*buff_len == 0U) {
  106700:	75 e1                	jne    1066e3 <shell_cmd_trim+0x18>
			buff[0] = '\0';
  106702:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
			return;
  106706:	eb 4e                	jmp    106756 <shell_cmd_trim+0x8b>
	while (isspace((int) buff[*buff_len - 1U])) {
  106708:	80 f9 20             	cmp    $0x20,%cl
  10670b:	74 eb                	je     1066f8 <shell_cmd_trim+0x2d>
	buff[*buff_len] = '\0';
  10670d:	c6 44 3b 46 00       	movb   $0x0,0x46(%ebx,%edi,1)
	uint16_t i = 0U;
  106712:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	while (isspace((int) buff[i++])) {
  106718:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  10671c:	89 ce                	mov    %ecx,%esi
  10671e:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  106721:	66 ff 45 f2          	incw   -0xe(%ebp)
  106725:	8d 0c 08             	lea    (%eax,%ecx,1),%ecx
  106728:	0f be 39             	movsbl (%ecx),%edi
  10672b:	89 fa                	mov    %edi,%edx
  10672d:	83 ef 09             	sub    $0x9,%edi
  106730:	83 ff 04             	cmp    $0x4,%edi
  106733:	76 e3                	jbe    106718 <shell_cmd_trim+0x4d>
  106735:	80 fa 20             	cmp    $0x20,%dl
  106738:	74 de                	je     106718 <shell_cmd_trim+0x4d>
	if (--i > 0) {
  10673a:	66 85 f6             	test   %si,%si
  10673d:	74 17                	je     106756 <shell_cmd_trim+0x8b>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
  10673f:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  106743:	42                   	inc    %edx
  106744:	2b 55 ec             	sub    -0x14(%ebp),%edx
  106747:	52                   	push   %edx
  106748:	51                   	push   %ecx
  106749:	50                   	push   %eax
  10674a:	e8 62 56 00 00       	call   10bdb1 <memmove>
		*buff_len = *buff_len - i;
  10674f:	66 29 73 40          	sub    %si,0x40(%ebx)
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
  106753:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  106756:	8b 45 08             	mov    0x8(%ebp),%eax
  106759:	8b 40 08             	mov    0x8(%eax),%eax
  10675c:	8b 50 40             	mov    0x40(%eax),%edx
  10675f:	66 89 50 42          	mov    %dx,0x42(%eax)
}
  106763:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106766:	5b                   	pop    %ebx
  106767:	5e                   	pop    %esi
  106768:	5f                   	pop    %edi
  106769:	5d                   	pop    %ebp
  10676a:	c3                   	ret    

0010676b <shell_raw_fprintf>:
{
  10676b:	55                   	push   %ebp
  10676c:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  10676e:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  106771:	50                   	push   %eax
  106772:	ff 75 0c             	pushl  0xc(%ebp)
  106775:	ff 75 08             	pushl  0x8(%ebp)
  106778:	e8 1a fa ff ff       	call   106197 <shell_fprintf_fmt>
  10677d:	83 c4 0c             	add    $0xc,%esp
}
  106780:	c9                   	leave  
  106781:	c3                   	ret    

00106782 <clear_eos.isra.0>:
static inline void clear_eos(const struct shell *shell)
  106782:	55                   	push   %ebp
  106783:	89 e5                	mov    %esp,%ebp
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
  106785:	68 70 41 12 00       	push   $0x124170
  10678a:	68 f8 4e 12 00       	push   $0x124ef8
  10678f:	50                   	push   %eax
  106790:	e8 d6 ff ff ff       	call   10676b <shell_raw_fprintf>
  106795:	83 c4 0c             	add    $0xc,%esp
}
  106798:	c9                   	leave  
  106799:	c3                   	ret    

0010679a <full_line_cmd.isra.0>:
}

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
  10679a:	55                   	push   %ebp
  10679b:	89 e5                	mov    %esp,%ebp
  10679d:	56                   	push   %esi
  10679e:	53                   	push   %ebx
  10679f:	89 c6                	mov    %eax,%esi
{
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
  1067a1:	8b 00                	mov    (%eax),%eax
  1067a3:	0f b7 58 40          	movzwl 0x40(%eax),%ebx
  1067a7:	8b 00                	mov    (%eax),%eax
	return str == NULL ? 0U : (uint16_t)strlen(str);
  1067a9:	85 c0                	test   %eax,%eax
  1067ab:	74 09                	je     1067b6 <full_line_cmd.isra.0+0x1c>
  1067ad:	50                   	push   %eax
  1067ae:	e8 69 55 00 00       	call   10bd1c <strlen>
  1067b3:	5a                   	pop    %edx
  1067b4:	eb 02                	jmp    1067b8 <full_line_cmd.isra.0+0x1e>
  1067b6:	31 c0                	xor    %eax,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  1067b8:	8b 16                	mov    (%esi),%edx
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
  1067ba:	0f b7 c0             	movzwl %ax,%eax
  1067bd:	01 d8                	add    %ebx,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  1067bf:	0f b7 4a 2e          	movzwl 0x2e(%edx),%ecx
  1067c3:	99                   	cltd   
  1067c4:	f7 f9                	idiv   %ecx
  1067c6:	85 d2                	test   %edx,%edx
  1067c8:	0f 94 c0             	sete   %al
}
  1067cb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1067ce:	5b                   	pop    %ebx
  1067cf:	5e                   	pop    %esi
  1067d0:	5d                   	pop    %ebp
  1067d1:	c3                   	ret    

001067d2 <shell_op_cursor_vert_move>:
{
  1067d2:	55                   	push   %ebp
  1067d3:	89 e5                	mov    %esp,%ebp
  1067d5:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (delta != 0) {
  1067d8:	85 c0                	test   %eax,%eax
  1067da:	74 23                	je     1067ff <shell_op_cursor_vert_move+0x2d>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
  1067dc:	0f 9e c2             	setle  %dl
  1067df:	0f b6 d2             	movzbl %dl,%edx
  1067e2:	83 c2 41             	add    $0x41,%edx
  1067e5:	52                   	push   %edx
  1067e6:	99                   	cltd   
  1067e7:	31 d0                	xor    %edx,%eax
  1067e9:	29 d0                	sub    %edx,%eax
  1067eb:	50                   	push   %eax
  1067ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1067ef:	68 c9 50 12 00       	push   $0x1250c9
  1067f4:	ff 70 14             	pushl  0x14(%eax)
  1067f7:	e8 6f ff ff ff       	call   10676b <shell_raw_fprintf>
  1067fc:	83 c4 10             	add    $0x10,%esp
}
  1067ff:	c9                   	leave  
  106800:	c3                   	ret    

00106801 <shell_op_cursor_horiz_move>:
{
  106801:	55                   	push   %ebp
  106802:	89 e5                	mov    %esp,%ebp
  106804:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (delta != 0) {
  106807:	85 c0                	test   %eax,%eax
  106809:	74 23                	je     10682e <shell_op_cursor_horiz_move+0x2d>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
  10680b:	0f 9e c2             	setle  %dl
  10680e:	0f b6 d2             	movzbl %dl,%edx
  106811:	83 c2 43             	add    $0x43,%edx
  106814:	52                   	push   %edx
  106815:	99                   	cltd   
  106816:	31 d0                	xor    %edx,%eax
  106818:	29 d0                	sub    %edx,%eax
  10681a:	50                   	push   %eax
  10681b:	8b 45 08             	mov    0x8(%ebp),%eax
  10681e:	68 c9 50 12 00       	push   $0x1250c9
  106823:	ff 70 14             	pushl  0x14(%eax)
  106826:	e8 40 ff ff ff       	call   10676b <shell_raw_fprintf>
  10682b:	83 c4 10             	add    $0x10,%esp
}
  10682e:	c9                   	leave  
  10682f:	c3                   	ret    

00106830 <shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool shell_cursor_in_empty_line(const struct shell *shell)
{
  106830:	55                   	push   %ebp
  106831:	89 e5                	mov    %esp,%ebp
  106833:	56                   	push   %esi
  106834:	53                   	push   %ebx
  106835:	8b 75 08             	mov    0x8(%ebp),%esi
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
  106838:	8b 46 08             	mov    0x8(%esi),%eax
  10683b:	8b 10                	mov    (%eax),%edx
  10683d:	0f b7 58 42          	movzwl 0x42(%eax),%ebx
  106841:	31 c0                	xor    %eax,%eax
  106843:	85 d2                	test   %edx,%edx
  106845:	74 07                	je     10684e <shell_cursor_in_empty_line+0x1e>
  106847:	52                   	push   %edx
  106848:	e8 cf 54 00 00       	call   10bd1c <strlen>
  10684d:	5a                   	pop    %edx
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  10684e:	8b 56 08             	mov    0x8(%esi),%edx
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
  106851:	0f b7 c0             	movzwl %ax,%eax
  106854:	01 d8                	add    %ebx,%eax
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
  106856:	0f b7 4a 2e          	movzwl 0x2e(%edx),%ecx
  10685a:	99                   	cltd   
  10685b:	f7 f9                	idiv   %ecx
  10685d:	85 d2                	test   %edx,%edx
  10685f:	0f 94 c0             	sete   %al
}
  106862:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106865:	5b                   	pop    %ebx
  106866:	5e                   	pop    %esi
  106867:	5d                   	pop    %ebp
  106868:	c3                   	ret    

00106869 <shell_op_cond_next_line>:

void shell_op_cond_next_line(const struct shell *shell)
{
  106869:	55                   	push   %ebp
  10686a:	89 e5                	mov    %esp,%ebp
  10686c:	53                   	push   %ebx
  10686d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
  106870:	53                   	push   %ebx
  106871:	e8 ba ff ff ff       	call   106830 <shell_cursor_in_empty_line>
  106876:	59                   	pop    %ecx
  106877:	84 c0                	test   %al,%al
  106879:	74 11                	je     10688c <shell_op_cond_next_line+0x23>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  10687b:	68 01 4e 12 00       	push   $0x124e01
  106880:	ff 73 14             	pushl  0x14(%ebx)
  106883:	e8 e3 fe ff ff       	call   10676b <shell_raw_fprintf>
  106888:	58                   	pop    %eax
  106889:	5a                   	pop    %edx
}
  10688a:	eb 0c                	jmp    106898 <shell_op_cond_next_line+0x2f>
  10688c:	8d 43 08             	lea    0x8(%ebx),%eax
  10688f:	e8 06 ff ff ff       	call   10679a <full_line_cmd.isra.0>
  106894:	84 c0                	test   %al,%al
  106896:	75 e3                	jne    10687b <shell_op_cond_next_line+0x12>
		cursor_next_line_move(shell);
	}
}
  106898:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10689b:	c9                   	leave  
  10689c:	c3                   	ret    

0010689d <shell_op_cursor_position_synchronize>:

void shell_op_cursor_position_synchronize(const struct shell *shell)
{
  10689d:	55                   	push   %ebp
  10689e:	89 e5                	mov    %esp,%ebp
  1068a0:	57                   	push   %edi
  1068a1:	56                   	push   %esi
  1068a2:	53                   	push   %ebx
  1068a3:	51                   	push   %ecx
  1068a4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  1068a7:	8b 73 08             	mov    0x8(%ebx),%esi
	bool last_line;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1068aa:	0f b7 46 40          	movzwl 0x40(%esi),%eax
  1068ae:	50                   	push   %eax
  1068af:	0f b7 46 42          	movzwl 0x42(%esi),%eax
  1068b3:	50                   	push   %eax
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  1068b4:	8d 46 24             	lea    0x24(%esi),%eax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1068b7:	50                   	push   %eax
  1068b8:	e8 c4 f9 ff ff       	call   106281 <shell_multiline_data_calc>
				  shell->ctx->cmd_buff_len);
	last_line = (cons->cur_y == cons->cur_y_end);
  1068bd:	66 8b 46 2a          	mov    0x2a(%esi),%ax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  1068c1:	83 c4 0c             	add    $0xc,%esp
	last_line = (cons->cur_y == cons->cur_y_end);
  1068c4:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
  1068c8:	8d 43 08             	lea    0x8(%ebx),%eax
	last_line = (cons->cur_y == cons->cur_y_end);
  1068cb:	66 8b 7e 28          	mov    0x28(%esi),%di
	if (full_line_cmd(shell)) {
  1068cf:	e8 c6 fe ff ff       	call   10679a <full_line_cmd.isra.0>
  1068d4:	84 c0                	test   %al,%al
  1068d6:	74 0f                	je     1068e7 <shell_op_cursor_position_synchronize+0x4a>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  1068d8:	68 01 4e 12 00       	push   $0x124e01
  1068dd:	ff 73 14             	pushl  0x14(%ebx)
  1068e0:	e8 86 fe ff ff       	call   10676b <shell_raw_fprintf>
  1068e5:	58                   	pop    %eax
  1068e6:	5a                   	pop    %edx
		cursor_next_line_move(shell);
	}

	if (last_line) {
  1068e7:	66 3b 7d f2          	cmp    -0xe(%ebp),%di
  1068eb:	74 13                	je     106900 <shell_op_cursor_position_synchronize+0x63>
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
  1068ed:	0f b7 4e 28          	movzwl 0x28(%esi),%ecx
  1068f1:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  1068f5:	29 c8                	sub    %ecx,%eax
  1068f7:	50                   	push   %eax
  1068f8:	53                   	push   %ebx
  1068f9:	e8 d4 fe ff ff       	call   1067d2 <shell_op_cursor_vert_move>
  1068fe:	59                   	pop    %ecx
  1068ff:	5f                   	pop    %edi
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
  106900:	0f b7 56 26          	movzwl 0x26(%esi),%edx
		shell_op_cursor_horiz_move(shell, cons->cur_x -
  106904:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  106908:	29 d0                	sub    %edx,%eax
  10690a:	50                   	push   %eax
  10690b:	53                   	push   %ebx
  10690c:	e8 f0 fe ff ff       	call   106801 <shell_op_cursor_horiz_move>
  106911:	58                   	pop    %eax
  106912:	5a                   	pop    %edx
	}
}
  106913:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106916:	5b                   	pop    %ebx
  106917:	5e                   	pop    %esi
  106918:	5f                   	pop    %edi
  106919:	5d                   	pop    %ebp
  10691a:	c3                   	ret    

0010691b <shell_op_cursor_move>:

void shell_op_cursor_move(const struct shell *shell, int16_t val)
{
  10691b:	55                   	push   %ebp
  10691c:	89 e5                	mov    %esp,%ebp
  10691e:	57                   	push   %edi
  10691f:	56                   	push   %esi
  106920:	53                   	push   %ebx
  106921:	50                   	push   %eax
  106922:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
  106925:	8b 43 08             	mov    0x8(%ebx),%eax
  106928:	83 c0 24             	add    $0x24,%eax
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
	int32_t row_span;
	int32_t col_span;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  10692b:	0f b7 48 1c          	movzwl 0x1c(%eax),%ecx
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
  10692f:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  106933:	51                   	push   %ecx
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
  106934:	89 d7                	mov    %edx,%edi
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  106936:	52                   	push   %edx
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
  106937:	03 7d 0c             	add    0xc(%ebp),%edi
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  10693a:	50                   	push   %eax
  10693b:	e8 41 f9 ff ff       	call   106281 <shell_multiline_data_calc>
				  shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
						    shell->ctx->cmd_buff_pos,
  106940:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
  106943:	83 c4 0c             	add    $0xc,%esp
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
  106946:	0f b7 d7             	movzwl %di,%edx
  106949:	0f b7 48 42          	movzwl 0x42(%eax),%ecx
  10694d:	52                   	push   %edx
  10694e:	83 c0 24             	add    $0x24,%eax
  106951:	51                   	push   %ecx
  106952:	89 55 f0             	mov    %edx,-0x10(%ebp)
  106955:	50                   	push   %eax
  106956:	e8 fa f8 ff ff       	call   106255 <row_span_with_buffer_offsets_get>
  10695b:	83 c4 0c             	add    $0xc,%esp
  10695e:	89 c6                	mov    %eax,%esi
						    new_pos);
	col_span = column_span_with_buffer_offsets_get(
						    &shell->ctx->vt100_ctx.cons,
						    shell->ctx->cmd_buff_pos,
  106960:	8b 43 08             	mov    0x8(%ebx),%eax
	col_span = column_span_with_buffer_offsets_get(
  106963:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106966:	52                   	push   %edx
  106967:	83 c0 24             	add    $0x24,%eax
  10696a:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  10696e:	52                   	push   %edx
  10696f:	50                   	push   %eax
  106970:	e8 b4 f8 ff ff       	call   106229 <column_span_with_buffer_offsets_get>
  106975:	83 c4 0c             	add    $0xc,%esp
  106978:	89 45 f0             	mov    %eax,-0x10(%ebp)
						    new_pos);

	shell_op_cursor_vert_move(shell, -row_span);
  10697b:	f7 de                	neg    %esi
  10697d:	56                   	push   %esi
  10697e:	53                   	push   %ebx
  10697f:	e8 4e fe ff ff       	call   1067d2 <shell_op_cursor_vert_move>
  106984:	5a                   	pop    %edx
	shell_op_cursor_horiz_move(shell, col_span);
  106985:	8b 45 f0             	mov    -0x10(%ebp),%eax
	shell_op_cursor_vert_move(shell, -row_span);
  106988:	59                   	pop    %ecx
	shell_op_cursor_horiz_move(shell, col_span);
  106989:	50                   	push   %eax
  10698a:	53                   	push   %ebx
  10698b:	e8 71 fe ff ff       	call   106801 <shell_op_cursor_horiz_move>
  106990:	5e                   	pop    %esi
  106991:	58                   	pop    %eax
	shell->ctx->cmd_buff_pos = new_pos;
  106992:	8b 43 08             	mov    0x8(%ebx),%eax
  106995:	66 89 78 42          	mov    %di,0x42(%eax)
}
  106999:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10699c:	5b                   	pop    %ebx
  10699d:	5e                   	pop    %esi
  10699e:	5f                   	pop    %edi
  10699f:	5d                   	pop    %ebp
  1069a0:	c3                   	ret    

001069a1 <shell_op_cursor_word_move>:

	return ret;
}

void shell_op_cursor_word_move(const struct shell *shell, int16_t val)
{
  1069a1:	55                   	push   %ebp
  1069a2:	89 e5                	mov    %esp,%ebp
  1069a4:	57                   	push   %edi
  1069a5:	56                   	push   %esi
  1069a6:	be 01 00 00 00       	mov    $0x1,%esi
  1069ab:	53                   	push   %ebx
  1069ac:	83 ec 10             	sub    $0x10,%esp
  1069af:	8b 45 0c             	mov    0xc(%ebp),%eax
	int16_t shift;
	int16_t sign;

	if (val < 0) {
  1069b2:	66 85 c0             	test   %ax,%ax
{
  1069b5:	89 c3                	mov    %eax,%ebx
	if (val < 0) {
  1069b7:	79 05                	jns    1069be <shell_op_cursor_word_move+0x1d>
		val = -val;
  1069b9:	f7 db                	neg    %ebx
		sign = -1;
  1069bb:	83 ce ff             	or     $0xffffffff,%esi
		if (((idx == 0U) && (sign < 0)) ||
  1069be:	89 f0                	mov    %esi,%eax
  1069c0:	66 c1 e8 0f          	shr    $0xf,%ax
  1069c4:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	} else {
		sign = 1;
	}

	while (val--) {
  1069c8:	4b                   	dec    %ebx
  1069c9:	66 83 fb ff          	cmp    $0xffff,%bx
  1069cd:	0f 84 8c 00 00 00    	je     106a5f <shell_op_cursor_word_move+0xbe>
		shift = shift_calc(shell->ctx->cmd_buff,
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
  1069d3:	8b 45 08             	mov    0x8(%ebp),%eax
		if (((idx == 0U) && (sign < 0)) ||
  1069d6:	8a 55 e6             	mov    -0x1a(%ebp),%dl
  1069d9:	88 55 e9             	mov    %dl,-0x17(%ebp)
				   shell->ctx->cmd_buff_len, sign);
  1069dc:	8b 40 08             	mov    0x8(%eax),%eax
		shift = shift_calc(shell->ctx->cmd_buff,
  1069df:	83 c0 46             	add    $0x46,%eax
				   shell->ctx->cmd_buff_len, sign);
  1069e2:	8b 78 fa             	mov    -0x6(%eax),%edi
  1069e5:	66 89 7d f0          	mov    %di,-0x10(%ebp)
				   shell->ctx->cmd_buff_pos,
  1069e9:	66 8b 78 fc          	mov    -0x4(%eax),%di
  1069ed:	66 89 7d f2          	mov    %di,-0xe(%ebp)
		shift = shift_calc(shell->ctx->cmd_buff,
  1069f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1069f4:	89 f8                	mov    %edi,%eax
	bool found = false;
  1069f6:	31 ff                	xor    %edi,%edi
		idx = pos + ret * sign;
  1069f8:	89 c1                	mov    %eax,%ecx
  1069fa:	66 2b 4d f2          	sub    -0xe(%ebp),%cx
		if (((idx == 0U) && (sign < 0)) ||
  1069fe:	66 85 c0             	test   %ax,%ax
  106a01:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  106a05:	75 06                	jne    106a0d <shell_op_cursor_word_move+0x6c>
  106a07:	80 7d e9 00          	cmpb   $0x0,-0x17(%ebp)
  106a0b:	75 3e                	jne    106a4b <shell_op_cursor_word_move+0xaa>
  106a0d:	66 39 45 f0          	cmp    %ax,-0x10(%ebp)
  106a11:	75 05                	jne    106a18 <shell_op_cursor_word_move+0x77>
  106a13:	66 85 f6             	test   %si,%si
  106a16:	7f 33                	jg     106a4b <shell_op_cursor_word_move+0xaa>
		if (isalnum((int)str[idx]) != 0) {
  106a18:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106a1b:	0f b7 d0             	movzwl %ax,%edx
  106a1e:	0f be 14 11          	movsbl (%ecx,%edx,1),%edx
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  106a22:	88 d1                	mov    %dl,%cl
  106a24:	83 c9 20             	or     $0x20,%ecx
  106a27:	0f be c9             	movsbl %cl,%ecx
  106a2a:	83 e9 61             	sub    $0x61,%ecx
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
  106a2d:	83 f9 19             	cmp    $0x19,%ecx
  106a30:	76 10                	jbe    106a42 <shell_op_cursor_word_move+0xa1>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  106a32:	83 ea 30             	sub    $0x30,%edx
	return (int)(isalpha(chr) || isdigit(chr));
  106a35:	83 fa 09             	cmp    $0x9,%edx
  106a38:	76 08                	jbe    106a42 <shell_op_cursor_word_move+0xa1>
			if (found) {
  106a3a:	89 fa                	mov    %edi,%edx
  106a3c:	84 d2                	test   %dl,%dl
  106a3e:	74 07                	je     106a47 <shell_op_cursor_word_move+0xa6>
  106a40:	eb 09                	jmp    106a4b <shell_op_cursor_word_move+0xaa>
			found = true;
  106a42:	bf 01 00 00 00       	mov    $0x1,%edi
	while (1) {
  106a47:	01 f0                	add    %esi,%eax
		idx = pos + ret * sign;
  106a49:	eb ad                	jmp    1069f8 <shell_op_cursor_word_move+0x57>
		shell_op_cursor_move(shell, sign * shift);
  106a4b:	0f bf 45 ea          	movswl -0x16(%ebp),%eax
  106a4f:	50                   	push   %eax
  106a50:	ff 75 08             	pushl  0x8(%ebp)
  106a53:	e8 c3 fe ff ff       	call   10691b <shell_op_cursor_move>
  106a58:	58                   	pop    %eax
  106a59:	5a                   	pop    %edx
  106a5a:	e9 69 ff ff ff       	jmp    1069c8 <shell_op_cursor_word_move+0x27>
	}
}
  106a5f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106a62:	5b                   	pop    %ebx
  106a63:	5e                   	pop    %esi
  106a64:	5f                   	pop    %edi
  106a65:	5d                   	pop    %ebp
  106a66:	c3                   	ret    

00106a67 <shell_op_cursor_home_move>:
	clear_eos(shell);
	cursor_restore(shell);
}

void shell_op_cursor_home_move(const struct shell *shell)
{
  106a67:	55                   	push   %ebp
  106a68:	89 e5                	mov    %esp,%ebp
  106a6a:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
  106a6d:	8b 42 08             	mov    0x8(%edx),%eax
  106a70:	66 8b 40 42          	mov    0x42(%eax),%ax
  106a74:	f7 d8                	neg    %eax
  106a76:	98                   	cwtl   
  106a77:	50                   	push   %eax
  106a78:	52                   	push   %edx
  106a79:	e8 9d fe ff ff       	call   10691b <shell_op_cursor_move>
  106a7e:	58                   	pop    %eax
  106a7f:	5a                   	pop    %edx
}
  106a80:	c9                   	leave  
  106a81:	c3                   	ret    

00106a82 <shell_op_cursor_end_move>:

void shell_op_cursor_end_move(const struct shell *shell)
{
  106a82:	55                   	push   %ebp
  106a83:	89 e5                	mov    %esp,%ebp
  106a85:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
  106a88:	8b 4a 08             	mov    0x8(%edx),%ecx
  106a8b:	8b 41 40             	mov    0x40(%ecx),%eax
  106a8e:	66 2b 41 42          	sub    0x42(%ecx),%ax
  106a92:	98                   	cwtl   
  106a93:	50                   	push   %eax
  106a94:	52                   	push   %edx
  106a95:	e8 81 fe ff ff       	call   10691b <shell_op_cursor_move>
  106a9a:	58                   	pop    %eax
  106a9b:	5a                   	pop    %edx
						shell->ctx->cmd_buff_pos);
}
  106a9c:	c9                   	leave  
  106a9d:	c3                   	ret    

00106a9e <shell_op_left_arrow>:


void shell_op_left_arrow(const struct shell *shell)
{
  106a9e:	55                   	push   %ebp
  106a9f:	89 e5                	mov    %esp,%ebp
  106aa1:	8b 45 08             	mov    0x8(%ebp),%eax
	if (shell->ctx->cmd_buff_pos > 0) {
  106aa4:	8b 50 08             	mov    0x8(%eax),%edx
  106aa7:	66 83 7a 42 00       	cmpw   $0x0,0x42(%edx)
  106aac:	74 0a                	je     106ab8 <shell_op_left_arrow+0x1a>
		shell_op_cursor_move(shell, -1);
  106aae:	6a ff                	push   $0xffffffff
  106ab0:	50                   	push   %eax
  106ab1:	e8 65 fe ff ff       	call   10691b <shell_op_cursor_move>
  106ab6:	58                   	pop    %eax
  106ab7:	5a                   	pop    %edx
	}
}
  106ab8:	c9                   	leave  
  106ab9:	c3                   	ret    

00106aba <shell_op_right_arrow>:

void shell_op_right_arrow(const struct shell *shell)
{
  106aba:	55                   	push   %ebp
  106abb:	89 e5                	mov    %esp,%ebp
  106abd:	8b 45 08             	mov    0x8(%ebp),%eax
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
  106ac0:	8b 50 08             	mov    0x8(%eax),%edx
  106ac3:	8b 4a 40             	mov    0x40(%edx),%ecx
  106ac6:	66 39 4a 42          	cmp    %cx,0x42(%edx)
  106aca:	73 0a                	jae    106ad6 <shell_op_right_arrow+0x1c>
		shell_op_cursor_move(shell, 1);
  106acc:	6a 01                	push   $0x1
  106ace:	50                   	push   %eax
  106acf:	e8 47 fe ff ff       	call   10691b <shell_op_cursor_move>
  106ad4:	58                   	pop    %eax
  106ad5:	5a                   	pop    %edx
	}
}
  106ad6:	c9                   	leave  
  106ad7:	c3                   	ret    

00106ad8 <shell_op_delete_from_cursor>:
	--shell->ctx->cmd_buff_len;
	reprint_from_cursor(shell, --diff, true);
}

void shell_op_delete_from_cursor(const struct shell *shell)
{
  106ad8:	55                   	push   %ebp
  106ad9:	89 e5                	mov    %esp,%ebp
  106adb:	8b 4d 08             	mov    0x8(%ebp),%ecx
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
  106ade:	8b 51 08             	mov    0x8(%ecx),%edx
  106ae1:	0f b7 42 42          	movzwl 0x42(%edx),%eax
  106ae5:	66 89 42 40          	mov    %ax,0x40(%edx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
  106ae9:	c6 44 02 46 00       	movb   $0x0,0x46(%edx,%eax,1)

	clear_eos(shell);
  106aee:	8b 41 14             	mov    0x14(%ecx),%eax
}
  106af1:	5d                   	pop    %ebp
	clear_eos(shell);
  106af2:	e9 8b fc ff ff       	jmp    106782 <clear_eos.isra.0>

00106af7 <shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void shell_cmd_line_erase(const struct shell *shell)
{
  106af7:	55                   	push   %ebp
  106af8:	89 e5                	mov    %esp,%ebp
  106afa:	53                   	push   %ebx
  106afb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
				  shell->ctx->cmd_buff_pos,
				  shell->ctx->cmd_buff_len);
  106afe:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  106b01:	83 c0 24             	add    $0x24,%eax
  106b04:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  106b08:	52                   	push   %edx
  106b09:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  106b0d:	52                   	push   %edx
  106b0e:	50                   	push   %eax
  106b0f:	e8 6d f7 ff ff       	call   106281 <shell_multiline_data_calc>
	shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
  106b14:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  106b17:	83 c4 0c             	add    $0xc,%esp
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
  106b1a:	0f b7 50 24          	movzwl 0x24(%eax),%edx
	shell_op_cursor_horiz_move(shell,
  106b1e:	b8 01 00 00 00       	mov    $0x1,%eax
  106b23:	29 d0                	sub    %edx,%eax
  106b25:	50                   	push   %eax
  106b26:	53                   	push   %ebx
  106b27:	e8 d5 fc ff ff       	call   106801 <shell_op_cursor_horiz_move>
  106b2c:	58                   	pop    %eax
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
  106b2d:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_op_cursor_horiz_move(shell,
  106b30:	5a                   	pop    %edx
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
  106b31:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  106b35:	48                   	dec    %eax
  106b36:	50                   	push   %eax
  106b37:	53                   	push   %ebx
  106b38:	e8 95 fc ff ff       	call   1067d2 <shell_op_cursor_vert_move>
  106b3d:	59                   	pop    %ecx
  106b3e:	58                   	pop    %eax

	clear_eos(shell);
  106b3f:	8b 43 14             	mov    0x14(%ebx),%eax
}
  106b42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  106b45:	c9                   	leave  
	clear_eos(shell);
  106b46:	e9 37 fc ff ff       	jmp    106782 <clear_eos.isra.0>

00106b4b <shell_print_cmd>:
{
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void shell_print_cmd(const struct shell *shell)
{
  106b4b:	55                   	push   %ebp
  106b4c:	89 e5                	mov    %esp,%ebp
  106b4e:	8b 55 08             	mov    0x8(%ebp),%edx
	shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
  106b51:	8b 42 08             	mov    0x8(%edx),%eax
  106b54:	83 c0 46             	add    $0x46,%eax
  106b57:	50                   	push   %eax
  106b58:	68 f8 4e 12 00       	push   $0x124ef8
  106b5d:	ff 72 14             	pushl  0x14(%edx)
  106b60:	e8 06 fc ff ff       	call   10676b <shell_raw_fprintf>
  106b65:	83 c4 0c             	add    $0xc,%esp
}
  106b68:	c9                   	leave  
  106b69:	c3                   	ret    

00106b6a <shell_write>:
	}
}

void shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
  106b6a:	55                   	push   %ebp
  106b6b:	89 e5                	mov    %esp,%ebp
  106b6d:	57                   	push   %edi
  106b6e:	56                   	push   %esi
	__ASSERT_NO_MSG(shell && data);

	size_t offset = 0;
  106b6f:	31 f6                	xor    %esi,%esi
{
  106b71:	53                   	push   %ebx
  106b72:	50                   	push   %eax
  106b73:	8b 7d 08             	mov    0x8(%ebp),%edi
  106b76:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t tmp_cnt;

	while (length) {
  106b79:	85 db                	test   %ebx,%ebx
  106b7b:	74 71                	je     106bee <shell_write+0x84>
		int err = shell->iface->api->write(shell->iface,
  106b7d:	8b 47 04             	mov    0x4(%edi),%eax
  106b80:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  106b83:	8b 10                	mov    (%eax),%edx
  106b85:	51                   	push   %ecx
  106b86:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  106b89:	53                   	push   %ebx
  106b8a:	01 f1                	add    %esi,%ecx
  106b8c:	51                   	push   %ecx
  106b8d:	50                   	push   %eax
  106b8e:	ff 52 0c             	call   *0xc(%edx)
				&((const uint8_t *) data)[offset], length,
				&tmp_cnt);
		(void)err;
		__ASSERT_NO_MSG(err == 0);
		__ASSERT_NO_MSG(length >= tmp_cnt);
		offset += tmp_cnt;
  106b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
		int err = shell->iface->api->write(shell->iface,
  106b94:	83 c4 10             	add    $0x10,%esp
		offset += tmp_cnt;
  106b97:	01 c6                	add    %eax,%esi
		length -= tmp_cnt;
  106b99:	29 c3                	sub    %eax,%ebx
		if (tmp_cnt == 0 &&
  106b9b:	85 c0                	test   %eax,%eax
  106b9d:	75 da                	jne    106b79 <shell_write+0xf>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
  106b9f:	8b 47 08             	mov    0x8(%edi),%eax
  106ba2:	8b 50 04             	mov    0x4(%eax),%edx
		if (tmp_cnt == 0 &&
  106ba5:	83 fa 03             	cmp    $0x3,%edx
  106ba8:	74 cf                	je     106b79 <shell_write+0xf>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
  106baa:	83 fa 02             	cmp    $0x2,%edx
  106bad:	77 23                	ja     106bd2 <shell_write+0x68>
  106baf:	6a ff                	push   $0xffffffff
		k_poll(&shell->ctx->events[SHELL_SIGNAL_TXDONE], 1, K_FOREVER);
  106bb1:	05 e4 02 00 00       	add    $0x2e4,%eax
  106bb6:	6a ff                	push   $0xffffffff
  106bb8:	6a 01                	push   $0x1
  106bba:	50                   	push   %eax
  106bbb:	e8 bb bd 01 00       	call   12297b <z_impl_k_poll>
  106bc0:	83 c4 10             	add    $0x10,%esp
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
  106bc3:	8b 47 08             	mov    0x8(%edi),%eax
  106bc6:	c7 80 a0 02 00 00 00 	movl   $0x0,0x2a0(%eax)
  106bcd:	00 00 00 
  106bd0:	eb a7                	jmp    106b79 <shell_write+0xf>
	return shell->ctx->internal.flags.tx_rdy == 1;
  106bd2:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
		while (!flag_tx_rdy_get(shell)) {
  106bd8:	80 e2 10             	and    $0x10,%dl
  106bdb:	74 f5                	je     106bd2 <shell_write+0x68>
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
  106bdd:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
  106be3:	83 e2 ef             	and    $0xffffffef,%edx
  106be6:	89 90 64 02 00 00    	mov    %edx,0x264(%eax)
}
  106bec:	eb 8b                	jmp    106b79 <shell_write+0xf>
			shell_pend_on_txdone(shell);
		}
	}
}
  106bee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106bf1:	5b                   	pop    %ebx
  106bf2:	5e                   	pop    %esi
  106bf3:	5f                   	pop    %edi
  106bf4:	5d                   	pop    %ebp
  106bf5:	c3                   	ret    

00106bf6 <shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void shell_print_stream(const void *user_ctx, const char *data,
			size_t data_len)
{
	shell_write((const struct shell *) user_ctx, data, data_len);
  106bf6:	e9 6f ff ff ff       	jmp    106b6a <shell_write>

00106bfb <shell_vt100_color_set>:

}

void shell_vt100_color_set(const struct shell *shell,
			   enum shell_vt100_color color)
{
  106bfb:	55                   	push   %ebp
  106bfc:	89 e5                	mov    %esp,%ebp
  106bfe:	83 ec 08             	sub    $0x8,%esp
  106c01:	8b 55 08             	mov    0x8(%ebp),%edx
  106c04:	8b 45 0c             	mov    0xc(%ebp),%eax

	if (shell->ctx->vt100_ctx.col.col == color) {
  106c07:	8b 4a 08             	mov    0x8(%edx),%ecx
  106c0a:	39 41 34             	cmp    %eax,0x34(%ecx)
  106c0d:	74 3a                	je     106c49 <shell_vt100_color_set+0x4e>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
  106c0f:	89 41 34             	mov    %eax,0x34(%ecx)

	if (color != SHELL_NORMAL) {
  106c12:	8b 52 14             	mov    0x14(%edx),%edx
  106c15:	85 c0                	test   %eax,%eax
  106c17:	74 1d                	je     106c36 <shell_vt100_color_set+0x3b>

		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  106c19:	83 c0 2f             	add    $0x2f,%eax
  106c1c:	c7 45 f8 1b 5b 31 3b 	movl   $0x3b315b1b,-0x8(%ebp)
  106c23:	88 45 fd             	mov    %al,-0x3(%ebp)

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c26:	8d 45 f8             	lea    -0x8(%ebp),%eax
		uint8_t cmd[] = SHELL_VT100_COLOR(color - 1);
  106c29:	c6 45 fc 33          	movb   $0x33,-0x4(%ebp)
  106c2d:	66 c7 45 fe 6d 00    	movw   $0x6d,-0x2(%ebp)
		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c33:	50                   	push   %eax
  106c34:	eb 05                	jmp    106c3b <shell_vt100_color_set+0x40>
	} else {
		static const uint8_t cmd[] = SHELL_VT100_MODESOFF;

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c36:	68 6c 41 12 00       	push   $0x12416c
  106c3b:	68 f8 4e 12 00       	push   $0x124ef8
  106c40:	52                   	push   %edx
  106c41:	e8 25 fb ff ff       	call   10676b <shell_raw_fprintf>
  106c46:	83 c4 0c             	add    $0xc,%esp
	}
}
  106c49:	c9                   	leave  
  106c4a:	c3                   	ret    

00106c4b <shell_vt100_colors_restore>:

void shell_vt100_colors_restore(const struct shell *shell,
				       const struct shell_vt100_colors *color)
{
  106c4b:	55                   	push   %ebp
  106c4c:	89 e5                	mov    %esp,%ebp
  106c4e:	56                   	push   %esi
  106c4f:	53                   	push   %ebx
  106c50:	83 ec 08             	sub    $0x8,%esp
  106c53:	8b 75 0c             	mov    0xc(%ebp),%esi
  106c56:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_vt100_color_set(shell, color->col);
  106c59:	ff 36                	pushl  (%esi)
  106c5b:	53                   	push   %ebx
  106c5c:	e8 9a ff ff ff       	call   106bfb <shell_vt100_color_set>
  106c61:	5a                   	pop    %edx
	vt100_bgcolor_set(shell, color->bgcol);
  106c62:	8b 46 04             	mov    0x4(%esi),%eax
	shell_vt100_color_set(shell, color->col);
  106c65:	59                   	pop    %ecx
	if ((bgcolor == SHELL_NORMAL) ||
  106c66:	85 c0                	test   %eax,%eax
  106c68:	74 35                	je     106c9f <shell_vt100_colors_restore+0x54>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
  106c6a:	8b 53 08             	mov    0x8(%ebx),%edx
	if ((bgcolor == SHELL_NORMAL) ||
  106c6d:	3b 42 38             	cmp    0x38(%edx),%eax
  106c70:	74 2d                	je     106c9f <shell_vt100_colors_restore+0x54>
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
  106c72:	89 42 38             	mov    %eax,0x38(%edx)
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106c75:	8d 48 2f             	lea    0x2f(%eax),%ecx
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c78:	8d 45 f2             	lea    -0xe(%ebp),%eax
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106c7b:	66 c7 45 f2 1b 5b    	movw   $0x5b1b,-0xe(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c81:	50                   	push   %eax
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106c82:	c6 45 f4 34          	movb   $0x34,-0xc(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c86:	68 f8 4e 12 00       	push   $0x124ef8
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106c8b:	88 4d f5             	mov    %cl,-0xb(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c8e:	ff 73 14             	pushl  0x14(%ebx)
	uint8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
  106c91:	66 c7 45 f6 6d 00    	movw   $0x6d,-0xa(%ebp)
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
  106c97:	e8 cf fa ff ff       	call   10676b <shell_raw_fprintf>
  106c9c:	83 c4 0c             	add    $0xc,%esp
}
  106c9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106ca2:	5b                   	pop    %ebx
  106ca3:	5e                   	pop    %esi
  106ca4:	5d                   	pop    %ebp
  106ca5:	c3                   	ret    

00106ca6 <shell_internal_vfprintf>:

void shell_internal_vfprintf(const struct shell *shell,
			     enum shell_vt100_color color, const char *fmt,
			     va_list args)
{
  106ca6:	55                   	push   %ebp
  106ca7:	89 e5                	mov    %esp,%ebp
  106ca9:	57                   	push   %edi
  106caa:	56                   	push   %esi
  106cab:	53                   	push   %ebx
  106cac:	83 ec 08             	sub    $0x8,%esp
  106caf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  106cb2:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
	    shell->ctx->internal.flags.use_colors &&
  106cb5:	8b 43 08             	mov    0x8(%ebx),%eax
  106cb8:	8b 90 64 02 00 00    	mov    0x264(%eax),%edx
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
  106cbe:	80 e2 02             	and    $0x2,%dl
  106cc1:	74 3c                	je     106cff <shell_internal_vfprintf+0x59>
	    shell->ctx->internal.flags.use_colors &&
  106cc3:	39 78 34             	cmp    %edi,0x34(%eax)
  106cc6:	74 37                	je     106cff <shell_internal_vfprintf+0x59>
			   enum shell_vt100_color color);

static inline void shell_vt100_colors_store(const struct shell *shell,
					    struct shell_vt100_colors *color)
{
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
  106cc8:	6a 08                	push   $0x8
  106cca:	83 c0 34             	add    $0x34,%eax
  106ccd:	50                   	push   %eax
  106cce:	8d 75 ec             	lea    -0x14(%ebp),%esi
  106cd1:	56                   	push   %esi
  106cd2:	e8 15 51 00 00       	call   10bdec <memcpy>
  106cd7:	83 c4 0c             	add    $0xc,%esp
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		shell_vt100_colors_store(shell, &col);
		shell_vt100_color_set(shell, color);
  106cda:	57                   	push   %edi
  106cdb:	53                   	push   %ebx
  106cdc:	e8 1a ff ff ff       	call   106bfb <shell_vt100_color_set>
  106ce1:	58                   	pop    %eax
  106ce2:	5a                   	pop    %edx

		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  106ce3:	ff 75 14             	pushl  0x14(%ebp)
  106ce6:	ff 75 10             	pushl  0x10(%ebp)
  106ce9:	ff 73 14             	pushl  0x14(%ebx)
  106cec:	e8 a6 f4 ff ff       	call   106197 <shell_fprintf_fmt>
  106cf1:	83 c4 0c             	add    $0xc,%esp

		shell_vt100_colors_restore(shell, &col);
  106cf4:	56                   	push   %esi
  106cf5:	53                   	push   %ebx
  106cf6:	e8 50 ff ff ff       	call   106c4b <shell_vt100_colors_restore>
  106cfb:	59                   	pop    %ecx
  106cfc:	5b                   	pop    %ebx
	    (color != shell->ctx->vt100_ctx.col.col)) {
  106cfd:	eb 11                	jmp    106d10 <shell_internal_vfprintf+0x6a>
	} else {
		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
  106cff:	ff 75 14             	pushl  0x14(%ebp)
  106d02:	ff 75 10             	pushl  0x10(%ebp)
  106d05:	ff 73 14             	pushl  0x14(%ebx)
  106d08:	e8 8a f4 ff ff       	call   106197 <shell_fprintf_fmt>
  106d0d:	83 c4 0c             	add    $0xc,%esp
	}
}
  106d10:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106d13:	5b                   	pop    %ebx
  106d14:	5e                   	pop    %esi
  106d15:	5f                   	pop    %edi
  106d16:	5d                   	pop    %ebp
  106d17:	c3                   	ret    

00106d18 <shell_internal_fprintf>:

void shell_internal_fprintf(const struct shell *shell,
			    enum shell_vt100_color color,
			    const char *fmt, ...)
{
  106d18:	55                   	push   %ebp
  106d19:	89 e5                	mov    %esp,%ebp
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args;

	va_start(args, fmt);
  106d1b:	8d 45 14             	lea    0x14(%ebp),%eax
	shell_internal_vfprintf(shell, color, fmt, args);
  106d1e:	50                   	push   %eax
  106d1f:	ff 75 10             	pushl  0x10(%ebp)
  106d22:	ff 75 0c             	pushl  0xc(%ebp)
  106d25:	ff 75 08             	pushl  0x8(%ebp)
  106d28:	e8 79 ff ff ff       	call   106ca6 <shell_internal_vfprintf>
  106d2d:	83 c4 10             	add    $0x10,%esp
	va_end(args);
}
  106d30:	c9                   	leave  
  106d31:	c3                   	ret    

00106d32 <shell_op_word_remove>:
{
  106d32:	55                   	push   %ebp
  106d33:	89 e5                	mov    %esp,%ebp
  106d35:	57                   	push   %edi
  106d36:	56                   	push   %esi
  106d37:	8b 75 08             	mov    0x8(%ebp),%esi
  106d3a:	53                   	push   %ebx
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  106d3b:	8b 46 08             	mov    0x8(%esi),%eax
  106d3e:	0f b7 48 42          	movzwl 0x42(%eax),%ecx
	if ((shell->ctx->cmd_buff_len == 0) ||
  106d42:	0f b7 50 40          	movzwl 0x40(%eax),%edx
  106d46:	66 85 c9             	test   %cx,%cx
  106d49:	0f 84 a9 00 00 00    	je     106df8 <shell_op_word_remove+0xc6>
  106d4f:	66 85 d2             	test   %dx,%dx
  106d52:	0f 84 a0 00 00 00    	je     106df8 <shell_op_word_remove+0xc6>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  106d58:	8d 4c 08 45          	lea    0x45(%eax,%ecx,1),%ecx
	char *str_start = &shell->ctx->cmd_buff[0];
  106d5c:	8d 78 46             	lea    0x46(%eax),%edi
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
  106d5f:	89 c8                	mov    %ecx,%eax
  106d61:	89 cb                	mov    %ecx,%ebx
  106d63:	29 c3                	sub    %eax,%ebx
	while ((str >= str_start) && (*str == ' ')) {
  106d65:	39 f8                	cmp    %edi,%eax
  106d67:	72 13                	jb     106d7c <shell_op_word_remove+0x4a>
  106d69:	80 38 20             	cmpb   $0x20,(%eax)
  106d6c:	75 09                	jne    106d77 <shell_op_word_remove+0x45>
		--str;
  106d6e:	48                   	dec    %eax
  106d6f:	eb f0                	jmp    106d61 <shell_op_word_remove+0x2f>
		--str;
  106d71:	48                   	dec    %eax
		++chars_to_delete;
  106d72:	43                   	inc    %ebx
	while ((str >= str_start) && (*str != ' ')) {
  106d73:	39 c7                	cmp    %eax,%edi
  106d75:	77 05                	ja     106d7c <shell_op_word_remove+0x4a>
  106d77:	80 38 20             	cmpb   $0x20,(%eax)
  106d7a:	75 f5                	jne    106d71 <shell_op_word_remove+0x3f>
		shell->ctx->cmd_buff_len - chars_to_delete);
  106d7c:	0f b7 cb             	movzwl %bx,%ecx
  106d7f:	29 ca                	sub    %ecx,%edx
	memmove(str + 1, str + 1 + chars_to_delete,
  106d81:	8d 78 01             	lea    0x1(%eax),%edi
  106d84:	52                   	push   %edx
  106d85:	8d 44 08 01          	lea    0x1(%eax,%ecx,1),%eax
  106d89:	50                   	push   %eax
  106d8a:	57                   	push   %edi
  106d8b:	e8 21 50 00 00       	call   10bdb1 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
  106d90:	8b 56 08             	mov    0x8(%esi),%edx
	memmove(str + 1, str + 1 + chars_to_delete,
  106d93:	83 c4 0c             	add    $0xc,%esp
	shell->ctx->cmd_buff_len -= chars_to_delete;
  106d96:	8b 42 40             	mov    0x40(%edx),%eax
  106d99:	29 d8                	sub    %ebx,%eax
  106d9b:	66 89 42 40          	mov    %ax,0x40(%edx)
	shell_op_cursor_move(shell, -chars_to_delete);
  106d9f:	f7 db                	neg    %ebx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  106da1:	0f b7 c0             	movzwl %ax,%eax
	shell_op_cursor_move(shell, -chars_to_delete);
  106da4:	0f bf db             	movswl %bx,%ebx
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  106da7:	c6 44 02 46 00       	movb   $0x0,0x46(%edx,%eax,1)
	shell_op_cursor_move(shell, -chars_to_delete);
  106dac:	53                   	push   %ebx
  106dad:	56                   	push   %esi
  106dae:	e8 68 fb ff ff       	call   10691b <shell_op_cursor_move>
  106db3:	58                   	pop    %eax
  106db4:	5a                   	pop    %edx
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
  106db5:	68 d3 50 12 00       	push   $0x1250d3
  106dba:	68 f8 4e 12 00       	push   $0x124ef8
  106dbf:	ff 76 14             	pushl  0x14(%esi)
  106dc2:	e8 a4 f9 ff ff       	call   10676b <shell_raw_fprintf>
  106dc7:	83 c4 0c             	add    $0xc,%esp
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
  106dca:	57                   	push   %edi
  106dcb:	68 f8 4e 12 00       	push   $0x124ef8
  106dd0:	6a 00                	push   $0x0
  106dd2:	56                   	push   %esi
  106dd3:	e8 40 ff ff ff       	call   106d18 <shell_internal_fprintf>
  106dd8:	83 c4 10             	add    $0x10,%esp
	clear_eos(shell);
  106ddb:	8b 46 14             	mov    0x14(%esi),%eax
  106dde:	e8 9f f9 ff ff       	call   106782 <clear_eos.isra.0>
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
  106de3:	68 d0 50 12 00       	push   $0x1250d0
  106de8:	68 f8 4e 12 00       	push   $0x124ef8
  106ded:	ff 76 14             	pushl  0x14(%esi)
  106df0:	e8 76 f9 ff ff       	call   10676b <shell_raw_fprintf>
  106df5:	83 c4 0c             	add    $0xc,%esp
}
  106df8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106dfb:	5b                   	pop    %ebx
  106dfc:	5e                   	pop    %esi
  106dfd:	5f                   	pop    %edi
  106dfe:	5d                   	pop    %ebp
  106dff:	c3                   	ret    

00106e00 <reprint_from_cursor>:
{
  106e00:	55                   	push   %ebp
	if (data_removed) {
  106e01:	84 c9                	test   %cl,%cl
{
  106e03:	89 e5                	mov    %esp,%ebp
  106e05:	57                   	push   %edi
  106e06:	56                   	push   %esi
  106e07:	89 cf                	mov    %ecx,%edi
  106e09:	53                   	push   %ebx
  106e0a:	89 d6                	mov    %edx,%esi
  106e0c:	89 c3                	mov    %eax,%ebx
	if (data_removed) {
  106e0e:	74 08                	je     106e18 <reprint_from_cursor+0x18>
		clear_eos(shell);
  106e10:	8b 40 14             	mov    0x14(%eax),%eax
  106e13:	e8 6a f9 ff ff       	call   106782 <clear_eos.isra.0>
		      &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
  106e18:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
  106e1b:	0f b7 50 42          	movzwl 0x42(%eax),%edx
  106e1f:	8d 44 10 46          	lea    0x46(%eax,%edx,1),%eax
  106e23:	50                   	push   %eax
  106e24:	68 f8 4e 12 00       	push   $0x124ef8
  106e29:	6a 00                	push   $0x0
  106e2b:	53                   	push   %ebx
  106e2c:	e8 e7 fe ff ff       	call   106d18 <shell_internal_fprintf>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  106e31:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
  106e34:	83 c4 10             	add    $0x10,%esp
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
  106e37:	8b 50 40             	mov    0x40(%eax),%edx
  106e3a:	66 89 50 42          	mov    %dx,0x42(%eax)
	if (full_line_cmd(shell)) {
  106e3e:	8d 43 08             	lea    0x8(%ebx),%eax
  106e41:	e8 54 f9 ff ff       	call   10679a <full_line_cmd.isra.0>
  106e46:	84 c0                	test   %al,%al
  106e48:	74 1a                	je     106e64 <reprint_from_cursor+0x64>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
  106e4a:	66 85 f6             	test   %si,%si
  106e4d:	75 06                	jne    106e55 <reprint_from_cursor+0x55>
  106e4f:	89 f8                	mov    %edi,%eax
  106e51:	84 c0                	test   %al,%al
  106e53:	75 0f                	jne    106e64 <reprint_from_cursor+0x64>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  106e55:	68 01 4e 12 00       	push   $0x124e01
  106e5a:	ff 73 14             	pushl  0x14(%ebx)
  106e5d:	e8 09 f9 ff ff       	call   10676b <shell_raw_fprintf>
  106e62:	59                   	pop    %ecx
  106e63:	5f                   	pop    %edi
	shell_op_cursor_move(shell, -diff);
  106e64:	f7 de                	neg    %esi
  106e66:	0f bf f6             	movswl %si,%esi
  106e69:	56                   	push   %esi
  106e6a:	53                   	push   %ebx
  106e6b:	e8 ab fa ff ff       	call   10691b <shell_op_cursor_move>
  106e70:	58                   	pop    %eax
  106e71:	5a                   	pop    %edx
}
  106e72:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106e75:	5b                   	pop    %ebx
  106e76:	5e                   	pop    %esi
  106e77:	5f                   	pop    %edi
  106e78:	5d                   	pop    %ebp
  106e79:	c3                   	ret    

00106e7a <data_insert>:
{
  106e7a:	55                   	push   %ebp
  106e7b:	89 e5                	mov    %esp,%ebp
  106e7d:	57                   	push   %edi
  106e7e:	56                   	push   %esi
  106e7f:	89 ce                	mov    %ecx,%esi
  106e81:	53                   	push   %ebx
  106e82:	89 c3                	mov    %eax,%ebx
  106e84:	83 ec 0c             	sub    $0xc,%esp
  106e87:	89 55 f0             	mov    %edx,-0x10(%ebp)
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106e8a:	8b 78 08             	mov    0x8(%eax),%edi
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  106e8d:	0f b7 c9             	movzwl %cx,%ecx
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106e90:	0f b7 47 40          	movzwl 0x40(%edi),%eax
  106e94:	89 c2                	mov    %eax,%edx
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  106e96:	01 c8                	add    %ecx,%eax
  106e98:	3d ff 00 00 00       	cmp    $0xff,%eax
  106e9d:	7f 6c                	jg     106f0b <data_insert+0x91>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106e9f:	0f b7 47 42          	movzwl 0x42(%edi),%eax
  106ea3:	29 c2                	sub    %eax,%edx
	memmove(curr_pos + len, curr_pos, after);
  106ea5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  106ea8:	0f b7 d2             	movzwl %dx,%edx
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
  106eab:	8d 7c 07 46          	lea    0x46(%edi,%eax,1),%edi
	memmove(curr_pos + len, curr_pos, after);
  106eaf:	52                   	push   %edx
  106eb0:	57                   	push   %edi
  106eb1:	89 55 e8             	mov    %edx,-0x18(%ebp)
  106eb4:	8d 04 0f             	lea    (%edi,%ecx,1),%eax
  106eb7:	50                   	push   %eax
  106eb8:	e8 f4 4e 00 00       	call   10bdb1 <memmove>
  106ebd:	83 c4 0c             	add    $0xc,%esp
	memcpy(curr_pos, data, len);
  106ec0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106ec3:	51                   	push   %ecx
  106ec4:	ff 75 f0             	pushl  -0x10(%ebp)
  106ec7:	57                   	push   %edi
  106ec8:	e8 1f 4f 00 00       	call   10bdec <memcpy>
	shell->ctx->cmd_buff_len += len;
  106ecd:	8b 4b 08             	mov    0x8(%ebx),%ecx
  106ed0:	89 f0                	mov    %esi,%eax
	memcpy(curr_pos, data, len);
  106ed2:	83 c4 0c             	add    $0xc,%esp
	if (!flag_echo_get(shell)) {
  106ed5:	8b 55 e8             	mov    -0x18(%ebp),%edx
	shell->ctx->cmd_buff_len += len;
  106ed8:	03 41 40             	add    0x40(%ecx),%eax
  106edb:	66 89 41 40          	mov    %ax,0x40(%ecx)
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
  106edf:	0f b7 c0             	movzwl %ax,%eax
  106ee2:	c6 44 01 46 00       	movb   $0x0,0x46(%ecx,%eax,1)
	if (!flag_echo_get(shell)) {
  106ee7:	8b 43 08             	mov    0x8(%ebx),%eax
	return shell->ctx->internal.flags.echo == 1;
  106eea:	8b 88 64 02 00 00    	mov    0x264(%eax),%ecx
  106ef0:	80 e1 04             	and    $0x4,%cl
  106ef3:	75 06                	jne    106efb <data_insert+0x81>
		shell->ctx->cmd_buff_pos += len;
  106ef5:	66 01 70 42          	add    %si,0x42(%eax)
		return;
  106ef9:	eb 10                	jmp    106f0b <data_insert+0x91>
}
  106efb:	8d 65 f4             	lea    -0xc(%ebp),%esp
	reprint_from_cursor(shell, after, false);
  106efe:	89 d8                	mov    %ebx,%eax
  106f00:	31 c9                	xor    %ecx,%ecx
}
  106f02:	5b                   	pop    %ebx
  106f03:	5e                   	pop    %esi
  106f04:	5f                   	pop    %edi
  106f05:	5d                   	pop    %ebp
	reprint_from_cursor(shell, after, false);
  106f06:	e9 f5 fe ff ff       	jmp    106e00 <reprint_from_cursor>
}
  106f0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  106f0e:	5b                   	pop    %ebx
  106f0f:	5e                   	pop    %esi
  106f10:	5f                   	pop    %edi
  106f11:	5d                   	pop    %ebp
  106f12:	c3                   	ret    

00106f13 <shell_op_char_insert>:
{
  106f13:	55                   	push   %ebp
  106f14:	89 e5                	mov    %esp,%ebp
  106f16:	56                   	push   %esi
  106f17:	53                   	push   %ebx
  106f18:	53                   	push   %ebx
  106f19:	8b 5d 08             	mov    0x8(%ebp),%ebx
  106f1c:	8b 45 0c             	mov    0xc(%ebp),%eax
  106f1f:	88 45 f4             	mov    %al,-0xc(%ebp)
	if (shell->ctx->internal.flags.insert_mode &&
  106f22:	8b 4b 08             	mov    0x8(%ebx),%ecx
  106f25:	8b 91 64 02 00 00    	mov    0x264(%ecx),%edx
  106f2b:	80 e2 01             	and    $0x1,%dl
  106f2e:	74 53                	je     106f83 <shell_op_char_insert+0x70>
		(shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
  106f30:	0f b7 51 42          	movzwl 0x42(%ecx),%edx
	if (shell->ctx->internal.flags.insert_mode &&
  106f34:	66 39 51 40          	cmp    %dx,0x40(%ecx)
  106f38:	74 49                	je     106f83 <shell_op_char_insert+0x70>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
  106f3a:	8d 72 01             	lea    0x1(%edx),%esi
  106f3d:	66 89 71 42          	mov    %si,0x42(%ecx)
  106f41:	88 44 11 46          	mov    %al,0x46(%ecx,%edx,1)
	if (!flag_echo_get(shell)) {
  106f45:	8b 53 08             	mov    0x8(%ebx),%edx
  106f48:	8b 92 64 02 00 00    	mov    0x264(%edx),%edx
  106f4e:	80 e2 04             	and    $0x4,%dl
  106f51:	74 3f                	je     106f92 <shell_op_char_insert+0x7f>
		char_replace(shell, data);
  106f53:	0f be c0             	movsbl %al,%eax
	shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
  106f56:	50                   	push   %eax
  106f57:	68 cd 50 12 00       	push   $0x1250cd
  106f5c:	ff 73 14             	pushl  0x14(%ebx)
  106f5f:	e8 07 f8 ff ff       	call   10676b <shell_raw_fprintf>
  106f64:	83 c4 0c             	add    $0xc,%esp
	if (shell_cursor_in_empty_line(shell)) {
  106f67:	53                   	push   %ebx
  106f68:	e8 c3 f8 ff ff       	call   106830 <shell_cursor_in_empty_line>
  106f6d:	59                   	pop    %ecx
  106f6e:	84 c0                	test   %al,%al
  106f70:	74 20                	je     106f92 <shell_op_char_insert+0x7f>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  106f72:	68 01 4e 12 00       	push   $0x124e01
  106f77:	ff 73 14             	pushl  0x14(%ebx)
  106f7a:	e8 ec f7 ff ff       	call   10676b <shell_raw_fprintf>
  106f7f:	58                   	pop    %eax
  106f80:	5a                   	pop    %edx
}
  106f81:	eb 0f                	jmp    106f92 <shell_op_char_insert+0x7f>
		data_insert(shell, &data, 1);
  106f83:	b9 01 00 00 00       	mov    $0x1,%ecx
  106f88:	8d 55 f4             	lea    -0xc(%ebp),%edx
  106f8b:	89 d8                	mov    %ebx,%eax
  106f8d:	e8 e8 fe ff ff       	call   106e7a <data_insert>
}
  106f92:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106f95:	5b                   	pop    %ebx
  106f96:	5e                   	pop    %esi
  106f97:	5d                   	pop    %ebp
  106f98:	c3                   	ret    

00106f99 <shell_op_completion_insert>:
{
  106f99:	55                   	push   %ebp
  106f9a:	89 e5                	mov    %esp,%ebp
	data_insert(shell, compl, compl_len);
  106f9c:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  106fa0:	8b 55 0c             	mov    0xc(%ebp),%edx
  106fa3:	8b 45 08             	mov    0x8(%ebp),%eax
}
  106fa6:	5d                   	pop    %ebp
	data_insert(shell, compl, compl_len);
  106fa7:	e9 ce fe ff ff       	jmp    106e7a <data_insert>

00106fac <shell_op_char_delete>:
{
  106fac:	55                   	push   %ebp
  106fad:	89 e5                	mov    %esp,%ebp
  106faf:	56                   	push   %esi
  106fb0:	53                   	push   %ebx
  106fb1:	8b 75 08             	mov    0x8(%ebp),%esi
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
  106fb4:	8b 56 08             	mov    0x8(%esi),%edx
  106fb7:	0f b7 42 42          	movzwl 0x42(%edx),%eax
	if (diff == 0U) {
  106fbb:	8b 5a 40             	mov    0x40(%edx),%ebx
  106fbe:	66 29 c3             	sub    %ax,%bx
  106fc1:	74 34                	je     106ff7 <shell_op_char_delete+0x4b>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
  106fc3:	8d 44 02 46          	lea    0x46(%edx,%eax,1),%eax
	memmove(str, str + 1, diff);
  106fc7:	0f b7 d3             	movzwl %bx,%edx
  106fca:	52                   	push   %edx
  106fcb:	8d 50 01             	lea    0x1(%eax),%edx
  106fce:	52                   	push   %edx
  106fcf:	50                   	push   %eax
  106fd0:	e8 dc 4d 00 00       	call   10bdb1 <memmove>
	--shell->ctx->cmd_buff_len;
  106fd5:	8b 46 08             	mov    0x8(%esi),%eax
	memmove(str, str + 1, diff);
  106fd8:	83 c4 0c             	add    $0xc,%esp
	reprint_from_cursor(shell, --diff, true);
  106fdb:	8d 53 ff             	lea    -0x1(%ebx),%edx
  106fde:	b9 01 00 00 00       	mov    $0x1,%ecx
	--shell->ctx->cmd_buff_len;
  106fe3:	66 ff 48 40          	decw   0x40(%eax)
}
  106fe7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106fea:	5b                   	pop    %ebx
	reprint_from_cursor(shell, --diff, true);
  106feb:	89 f0                	mov    %esi,%eax
  106fed:	0f b7 d2             	movzwl %dx,%edx
}
  106ff0:	5e                   	pop    %esi
  106ff1:	5d                   	pop    %ebp
	reprint_from_cursor(shell, --diff, true);
  106ff2:	e9 09 fe ff ff       	jmp    106e00 <reprint_from_cursor>
}
  106ff7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  106ffa:	5b                   	pop    %ebx
  106ffb:	5e                   	pop    %esi
  106ffc:	5d                   	pop    %ebp
  106ffd:	c3                   	ret    

00106ffe <shell_op_char_backspace>:
{
  106ffe:	55                   	push   %ebp
  106fff:	89 e5                	mov    %esp,%ebp
  107001:	53                   	push   %ebx
  107002:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if ((shell->ctx->cmd_buff_len == 0) ||
  107005:	8b 43 08             	mov    0x8(%ebx),%eax
  107008:	66 83 78 40 00       	cmpw   $0x0,0x40(%eax)
  10700d:	74 1d                	je     10702c <shell_op_char_backspace+0x2e>
  10700f:	66 83 78 42 00       	cmpw   $0x0,0x42(%eax)
  107014:	74 16                	je     10702c <shell_op_char_backspace+0x2e>
	shell_op_cursor_move(shell, -1);
  107016:	6a ff                	push   $0xffffffff
  107018:	53                   	push   %ebx
  107019:	e8 fd f8 ff ff       	call   10691b <shell_op_cursor_move>
  10701e:	58                   	pop    %eax
	shell_op_char_delete(shell);
  10701f:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  107022:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell_op_cursor_move(shell, -1);
  107025:	5a                   	pop    %edx
}
  107026:	c9                   	leave  
	shell_op_char_delete(shell);
  107027:	e9 80 ff ff ff       	jmp    106fac <shell_op_char_delete>
}
  10702c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10702f:	c9                   	leave  
  107030:	c3                   	ret    

00107031 <shell_print_prompt_and_cmd>:
{
  107031:	55                   	push   %ebp
  107032:	89 e5                	mov    %esp,%ebp
  107034:	53                   	push   %ebx
  107035:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
  107038:	8b 43 08             	mov    0x8(%ebx),%eax
  10703b:	ff 30                	pushl  (%eax)
  10703d:	68 f8 4e 12 00       	push   $0x124ef8
  107042:	6a 03                	push   $0x3
  107044:	53                   	push   %ebx
  107045:	e8 ce fc ff ff       	call   106d18 <shell_internal_fprintf>
	if (flag_echo_get(shell)) {
  10704a:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
  10704d:	83 c4 10             	add    $0x10,%esp
	return shell->ctx->internal.flags.echo == 1;
  107050:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
	if (flag_echo_get(shell)) {
  107056:	a8 04                	test   $0x4,%al
  107058:	74 13                	je     10706d <shell_print_prompt_and_cmd+0x3c>
		shell_print_cmd(shell);
  10705a:	53                   	push   %ebx
  10705b:	e8 eb fa ff ff       	call   106b4b <shell_print_cmd>
		shell_op_cursor_position_synchronize(shell);
  107060:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  107063:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		shell_print_cmd(shell);
  107066:	58                   	pop    %eax
}
  107067:	c9                   	leave  
		shell_op_cursor_position_synchronize(shell);
  107068:	e9 30 f8 ff ff       	jmp    10689d <shell_op_cursor_position_synchronize>
}
  10706d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107070:	c9                   	leave  
  107071:	c3                   	ret    

00107072 <z_impl_uart_irq_tx_disable>:
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_disable) {
  107072:	8b 50 08             	mov    0x8(%eax),%edx
  107075:	8b 52 20             	mov    0x20(%edx),%edx
  107078:	85 d2                	test   %edx,%edx
  10707a:	74 09                	je     107085 <z_impl_uart_irq_tx_disable+0x13>
{
  10707c:	55                   	push   %ebp
  10707d:	89 e5                	mov    %esp,%ebp
		api->irq_tx_disable(dev);
  10707f:	50                   	push   %eax
  107080:	ff d2                	call   *%edx
  107082:	58                   	pop    %eax
	}
#endif
}
  107083:	c9                   	leave  
  107084:	c3                   	ret    
  107085:	c3                   	ret    

00107086 <uninit>:

	return 0;
}

static int uninit(const struct shell_transport *transport)
{
  107086:	55                   	push   %ebp
  107087:	89 e5                	mov    %esp,%ebp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN)) {
		const struct device *dev = sh_uart->ctrl_blk->dev;
  107089:	8b 45 08             	mov    0x8(%ebp),%eax
  10708c:	8b 40 04             	mov    0x4(%eax),%eax
  10708f:	8b 00                	mov    (%eax),%eax
  107091:	8b 10                	mov    (%eax),%edx
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_disable) {
  107093:	8b 42 08             	mov    0x8(%edx),%eax
  107096:	8b 40 2c             	mov    0x2c(%eax),%eax
  107099:	85 c0                	test   %eax,%eax
  10709b:	74 04                	je     1070a1 <uninit+0x1b>
		api->irq_rx_disable(dev);
  10709d:	52                   	push   %edx
  10709e:	ff d0                	call   *%eax
  1070a0:	58                   	pop    %eax
	} else {
		k_timer_stop(sh_uart->timer);
	}

	return 0;
}
  1070a1:	31 c0                	xor    %eax,%eax
  1070a3:	c9                   	leave  
  1070a4:	c3                   	ret    

001070a5 <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
  1070a5:	55                   	push   %ebp
  1070a6:	89 e5                	mov    %esp,%ebp
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
  1070a8:	ff 75 10             	pushl  0x10(%ebp)
  1070ab:	ff 75 0c             	pushl  0xc(%ebp)
  1070ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1070b1:	8b 40 04             	mov    0x4(%eax),%eax
  1070b4:	ff 70 0c             	pushl  0xc(%eax)
  1070b7:	e8 08 bd ff ff       	call   102dc4 <ring_buf_get>
  1070bc:	8b 55 14             	mov    0x14(%ebp),%edx
  1070bf:	83 c4 0c             	add    $0xc,%esp
  1070c2:	89 02                	mov    %eax,(%edx)

	return 0;
}
  1070c4:	31 c0                	xor    %eax,%eax
  1070c6:	c9                   	leave  
  1070c7:	c3                   	ret    

001070c8 <init>:
{
  1070c8:	55                   	push   %ebp
  1070c9:	89 e5                	mov    %esp,%ebp
  1070cb:	53                   	push   %ebx
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  1070cc:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1070cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	sh_uart->ctrl_blk->handler = evt_handler;
  1070d2:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  1070d5:	8b 50 04             	mov    0x4(%eax),%edx
	sh_uart->ctrl_blk->dev = (const struct device *)config;
  1070d8:	8b 02                	mov    (%edx),%eax
	sh_uart->ctrl_blk->handler = evt_handler;
  1070da:	89 48 04             	mov    %ecx,0x4(%eax)
	sh_uart->ctrl_blk->context = context;
  1070dd:	8b 4d 14             	mov    0x14(%ebp),%ecx
	sh_uart->ctrl_blk->dev = (const struct device *)config;
  1070e0:	89 18                	mov    %ebx,(%eax)
	sh_uart->ctrl_blk->context = context;
  1070e2:	89 48 08             	mov    %ecx,0x8(%eax)
static inline void uart_irq_callback_user_data_set(const struct device *dev,
						   uart_irq_callback_user_data_t cb,
						   void *user_data)
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
  1070e5:	8b 43 08             	mov    0x8(%ebx),%eax
		(const struct uart_driver_api *)dev->api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
  1070e8:	85 c0                	test   %eax,%eax
  1070ea:	74 13                	je     1070ff <init+0x37>
  1070ec:	8b 40 48             	mov    0x48(%eax),%eax
  1070ef:	85 c0                	test   %eax,%eax
  1070f1:	74 0c                	je     1070ff <init+0x37>
		api->irq_callback_set(dev, cb, user_data);
  1070f3:	52                   	push   %edx
  1070f4:	68 ee 71 10 00       	push   $0x1071ee
  1070f9:	53                   	push   %ebx
  1070fa:	ff d0                	call   *%eax
  1070fc:	83 c4 0c             	add    $0xc,%esp
	if (api->irq_rx_enable) {
  1070ff:	8b 43 08             	mov    0x8(%ebx),%eax
  107102:	8b 40 28             	mov    0x28(%eax),%eax
  107105:	85 c0                	test   %eax,%eax
  107107:	74 04                	je     10710d <init+0x45>
		api->irq_rx_enable(dev);
  107109:	53                   	push   %ebx
  10710a:	ff d0                	call   *%eax
  10710c:	58                   	pop    %eax
}
  10710d:	31 c0                	xor    %eax,%eax
  10710f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107112:	c9                   	leave  
  107113:	c3                   	ret    

00107114 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
  107114:	55                   	push   %ebp
  107115:	89 e5                	mov    %esp,%ebp
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
  107117:	68 d6 50 12 00       	push   $0x1250d6
  10711c:	e8 e3 92 01 00       	call   120404 <z_impl_device_get_binding>
  107121:	5a                   	pop    %edx
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	uint32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	if (dev == NULL) {
  107122:	85 c0                	test   %eax,%eax
  107124:	ba ed ff ff ff       	mov    $0xffffffed,%edx
  107129:	74 16                	je     107141 <enable_shell_uart+0x2d>

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, true, log_backend, level);
  10712b:	6a 04                	push   $0x4
  10712d:	6a 01                	push   $0x1
  10712f:	6a 01                	push   $0x1
  107131:	50                   	push   %eax
  107132:	68 f0 31 12 00       	push   $0x1231f0
  107137:	e8 a4 eb ff ff       	call   105ce0 <shell_init>
  10713c:	83 c4 14             	add    $0x14,%esp

	return 0;
  10713f:	31 d2                	xor    %edx,%edx
}
  107141:	89 d0                	mov    %edx,%eax
  107143:	c9                   	leave  
  107144:	c3                   	ret    

00107145 <write>:
{
  107145:	55                   	push   %ebp
  107146:	89 e5                	mov    %esp,%ebp
  107148:	57                   	push   %edi
  107149:	56                   	push   %esi
  10714a:	53                   	push   %ebx
  10714b:	50                   	push   %eax
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  10714c:	8b 45 08             	mov    0x8(%ebp),%eax
{
  10714f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  107152:	8b 7d 10             	mov    0x10(%ebp),%edi
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
  107155:	8b 70 04             	mov    0x4(%eax),%esi
		!sh_uart->ctrl_blk->blocking_tx) {
  107158:	8b 06                	mov    (%esi),%eax
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
  10715a:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
  10715e:	74 08                	je     107168 <write+0x23>
  107160:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
  107163:	89 45 f0             	mov    %eax,-0x10(%ebp)
  107166:	eb 34                	jmp    10719c <write+0x57>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
  107168:	57                   	push   %edi
  107169:	53                   	push   %ebx
  10716a:	ff 76 08             	pushl  0x8(%esi)
  10716d:	e8 79 bb ff ff       	call   102ceb <ring_buf_put>
  107172:	8b 4d 14             	mov    0x14(%ebp),%ecx
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  107175:	8b 16                	mov    (%esi),%edx
  107177:	83 c4 0c             	add    $0xc,%esp
  10717a:	89 01                	mov    %eax,(%ecx)
  10717c:	b8 01 00 00 00       	mov    $0x1,%eax
  107181:	87 42 0c             	xchg   %eax,0xc(%edx)
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
  107184:	85 c0                	test   %eax,%eax
  107186:	75 3c                	jne    1071c4 <write+0x7f>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
  107188:	8b 06                	mov    (%esi),%eax
  10718a:	8b 10                	mov    (%eax),%edx
	if (api->irq_tx_enable) {
  10718c:	8b 42 08             	mov    0x8(%edx),%eax
  10718f:	8b 40 1c             	mov    0x1c(%eax),%eax
  107192:	85 c0                	test   %eax,%eax
  107194:	74 2e                	je     1071c4 <write+0x7f>
		api->irq_tx_enable(dev);
  107196:	52                   	push   %edx
  107197:	ff d0                	call   *%eax
  107199:	58                   	pop    %eax
  10719a:	eb 28                	jmp    1071c4 <write+0x7f>
		for (size_t i = 0; i < length; i++) {
  10719c:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  10719f:	8b 06                	mov    (%esi),%eax
  1071a1:	74 12                	je     1071b5 <write+0x70>
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
  1071a3:	0f b6 0b             	movzbl (%ebx),%ecx
  1071a6:	8b 00                	mov    (%eax),%eax
	api->poll_out(dev, out_char);
  1071a8:	8b 50 08             	mov    0x8(%eax),%edx
  1071ab:	51                   	push   %ecx
  1071ac:	50                   	push   %eax
  1071ad:	43                   	inc    %ebx
  1071ae:	ff 52 04             	call   *0x4(%edx)
  1071b1:	59                   	pop    %ecx
  1071b2:	58                   	pop    %eax
		for (size_t i = 0; i < length; i++) {
  1071b3:	eb e7                	jmp    10719c <write+0x57>
		*cnt = length;
  1071b5:	8b 4d 14             	mov    0x14(%ebp),%ecx
  1071b8:	89 39                	mov    %edi,(%ecx)
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
  1071ba:	ff 70 08             	pushl  0x8(%eax)
  1071bd:	6a 01                	push   $0x1
  1071bf:	ff 50 04             	call   *0x4(%eax)
  1071c2:	58                   	pop    %eax
  1071c3:	5a                   	pop    %edx
}
  1071c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1071c7:	31 c0                	xor    %eax,%eax
  1071c9:	5b                   	pop    %ebx
  1071ca:	5e                   	pop    %esi
  1071cb:	5f                   	pop    %edi
  1071cc:	5d                   	pop    %ebp
  1071cd:	c3                   	ret    

001071ce <enable>:
{
  1071ce:	55                   	push   %ebp
  1071cf:	89 e5                	mov    %esp,%ebp
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
  1071d1:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1071d4:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (blocking_tx) {
  1071d7:	84 d2                	test   %dl,%dl
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
  1071d9:	8b 40 04             	mov    0x4(%eax),%eax
  1071dc:	8b 00                	mov    (%eax),%eax
  1071de:	88 50 10             	mov    %dl,0x10(%eax)
	if (blocking_tx) {
  1071e1:	74 07                	je     1071ea <enable+0x1c>
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
  1071e3:	8b 00                	mov    (%eax),%eax
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_DISABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
  1071e5:	e8 88 fe ff ff       	call   107072 <z_impl_uart_irq_tx_disable>
}
  1071ea:	31 c0                	xor    %eax,%eax
  1071ec:	5d                   	pop    %ebp
  1071ed:	c3                   	ret    

001071ee <uart_callback>:
{
  1071ee:	55                   	push   %ebp
  1071ef:	89 e5                	mov    %esp,%ebp
  1071f1:	57                   	push   %edi
  1071f2:	56                   	push   %esi
  1071f3:	53                   	push   %ebx
  1071f4:	83 ec 10             	sub    $0x10,%esp
  1071f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1071fa:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (api->irq_update) {
  1071fd:	8b 43 08             	mov    0x8(%ebx),%eax
  107200:	8b 40 44             	mov    0x44(%eax),%eax
  107203:	85 c0                	test   %eax,%eax
  107205:	74 04                	je     10720b <uart_callback+0x1d>
		return api->irq_update(dev);
  107207:	53                   	push   %ebx
  107208:	ff d0                	call   *%eax
  10720a:	5f                   	pop    %edi
	if (api->irq_rx_ready) {
  10720b:	8b 43 08             	mov    0x8(%ebx),%eax
  10720e:	8b 40 34             	mov    0x34(%eax),%eax
  107211:	85 c0                	test   %eax,%eax
  107213:	0f 84 c4 00 00 00    	je     1072dd <uart_callback+0xef>
		return api->irq_rx_ready(dev);
  107219:	53                   	push   %ebx
  10721a:	ff d0                	call   *%eax
  10721c:	59                   	pop    %ecx
	if (uart_irq_rx_ready(dev)) {
  10721d:	85 c0                	test   %eax,%eax
  10721f:	0f 84 b8 00 00 00    	je     1072dd <uart_callback+0xef>
  107225:	b8 c8 31 12 00       	mov    $0x1231c8,%eax
	bool new_data = false;
  10722a:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
  10722e:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  107233:	c1 e8 03             	shr    $0x3,%eax
			LOG_WRN("RX ring buffer full.");
  107236:	c1 e0 06             	shl    $0x6,%eax
  107239:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
					 sh_uart->rx_ringbuf->size);
  10723d:	8b 46 0c             	mov    0xc(%esi),%eax
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
  107240:	8d 55 f0             	lea    -0x10(%ebp),%edx
  107243:	ff 70 10             	pushl  0x10(%eax)
  107246:	52                   	push   %edx
  107247:	50                   	push   %eax
  107248:	e8 1d ba ff ff       	call   102c6a <ring_buf_put_claim>
  10724d:	83 c4 0c             	add    $0xc,%esp
  107250:	89 c7                	mov    %eax,%edi
		if (len > 0) {
  107252:	85 c0                	test   %eax,%eax
  107254:	74 33                	je     107289 <uart_callback+0x9b>
	if (api->fifo_read) {
  107256:	8b 43 08             	mov    0x8(%ebx),%eax
  107259:	8b 50 18             	mov    0x18(%eax),%edx
	return 0;
  10725c:	31 c0                	xor    %eax,%eax
	if (api->fifo_read) {
  10725e:	85 d2                	test   %edx,%edx
  107260:	74 0a                	je     10726c <uart_callback+0x7e>
		return api->fifo_read(dev, rx_data, size);
  107262:	57                   	push   %edi
  107263:	ff 75 f0             	pushl  -0x10(%ebp)
  107266:	53                   	push   %ebx
  107267:	ff d2                	call   *%edx
  107269:	83 c4 0c             	add    $0xc,%esp
			rd_len = uart_fifo_read(dev, data, len);
  10726c:	89 c2                	mov    %eax,%edx
			if (rd_len > 0) {
  10726e:	85 c0                	test   %eax,%eax
  107270:	74 04                	je     107276 <uart_callback+0x88>
				new_data = true;
  107272:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
  107276:	50                   	push   %eax
  107277:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10727a:	ff 76 0c             	pushl  0xc(%esi)
  10727d:	e8 32 ba ff ff       	call   102cb4 <ring_buf_put_finish>
  107282:	58                   	pop    %eax
  107283:	5a                   	pop    %edx
			__ASSERT_NO_MSG(err == 0);
  107284:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  107287:	eb 36                	jmp    1072bf <uart_callback+0xd1>
			LOG_WRN("RX ring buffer full.");
  107289:	f6 05 24 5c 14 00 06 	testb  $0x6,0x145c24
  107290:	74 13                	je     1072a5 <uart_callback+0xb7>
  107292:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107295:	83 c8 02             	or     $0x2,%eax
  107298:	50                   	push   %eax
  107299:	68 dd 50 12 00       	push   $0x1250dd
  10729e:	e8 aa c2 ff ff       	call   10354d <log_0>
  1072a3:	59                   	pop    %ecx
  1072a4:	58                   	pop    %eax
	if (api->fifo_read) {
  1072a5:	8b 43 08             	mov    0x8(%ebx),%eax
	return 0;
  1072a8:	31 d2                	xor    %edx,%edx
	if (api->fifo_read) {
  1072aa:	8b 40 18             	mov    0x18(%eax),%eax
  1072ad:	85 c0                	test   %eax,%eax
  1072af:	74 0e                	je     1072bf <uart_callback+0xd1>
		return api->fifo_read(dev, rx_data, size);
  1072b1:	6a 01                	push   $0x1
  1072b3:	8d 55 ef             	lea    -0x11(%ebp),%edx
  1072b6:	52                   	push   %edx
  1072b7:	53                   	push   %ebx
  1072b8:	ff d0                	call   *%eax
  1072ba:	83 c4 0c             	add    $0xc,%esp
  1072bd:	89 c2                	mov    %eax,%edx
	} while (rd_len && (rd_len == len));
  1072bf:	85 d2                	test   %edx,%edx
  1072c1:	74 08                	je     1072cb <uart_callback+0xdd>
  1072c3:	39 d7                	cmp    %edx,%edi
  1072c5:	0f 84 72 ff ff ff    	je     10723d <uart_callback+0x4f>
	if (new_data) {
  1072cb:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
  1072cf:	74 0c                	je     1072dd <uart_callback+0xef>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
  1072d1:	8b 06                	mov    (%esi),%eax
  1072d3:	ff 70 08             	pushl  0x8(%eax)
  1072d6:	6a 00                	push   $0x0
  1072d8:	ff 50 04             	call   *0x4(%eax)
  1072db:	58                   	pop    %eax
  1072dc:	5a                   	pop    %edx
	if (api->irq_tx_ready) {
  1072dd:	8b 43 08             	mov    0x8(%ebx),%eax
  1072e0:	8b 40 24             	mov    0x24(%eax),%eax
  1072e3:	85 c0                	test   %eax,%eax
  1072e5:	74 60                	je     107347 <uart_callback+0x159>
		return api->irq_tx_ready(dev);
  1072e7:	53                   	push   %ebx
  1072e8:	ff d0                	call   *%eax
  1072ea:	5f                   	pop    %edi
	if (uart_irq_tx_ready(dev)) {
  1072eb:	85 c0                	test   %eax,%eax
  1072ed:	74 58                	je     107347 <uart_callback+0x159>
				 sh_uart->tx_ringbuf->size);
  1072ef:	8b 46 08             	mov    0x8(%esi),%eax
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (uint8_t **)&data,
  1072f2:	8d 55 f0             	lea    -0x10(%ebp),%edx
  1072f5:	ff 70 10             	pushl  0x10(%eax)
  1072f8:	52                   	push   %edx
  1072f9:	50                   	push   %eax
  1072fa:	e8 3b ba ff ff       	call   102d3a <ring_buf_get_claim>
  1072ff:	83 c4 0c             	add    $0xc,%esp
  107302:	89 c2                	mov    %eax,%edx
	if (len) {
  107304:	85 c0                	test   %eax,%eax
  107306:	74 23                	je     10732b <uart_callback+0x13d>
	if (api->fifo_fill) {
  107308:	8b 43 08             	mov    0x8(%ebx),%eax
  10730b:	8b 48 14             	mov    0x14(%eax),%ecx
	return 0;
  10730e:	31 c0                	xor    %eax,%eax
	if (api->fifo_fill) {
  107310:	85 c9                	test   %ecx,%ecx
  107312:	74 0a                	je     10731e <uart_callback+0x130>
		return api->fifo_fill(dev, tx_data, size);
  107314:	52                   	push   %edx
  107315:	ff 75 f0             	pushl  -0x10(%ebp)
  107318:	53                   	push   %ebx
  107319:	ff d1                	call   *%ecx
  10731b:	83 c4 0c             	add    $0xc,%esp
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
  10731e:	50                   	push   %eax
  10731f:	ff 76 08             	pushl  0x8(%esi)
  107322:	e8 63 ba ff ff       	call   102d8a <ring_buf_get_finish>
  107327:	59                   	pop    %ecx
  107328:	5b                   	pop    %ebx
		__ASSERT_NO_MSG(err == 0);
  107329:	eb 10                	jmp    10733b <uart_callback+0x14d>
  10732b:	89 d8                	mov    %ebx,%eax
  10732d:	e8 40 fd ff ff       	call   107072 <z_impl_uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
  107332:	8b 06                	mov    (%esi),%eax
  107334:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
  10733b:	8b 06                	mov    (%esi),%eax
  10733d:	ff 70 08             	pushl  0x8(%eax)
  107340:	6a 01                	push   $0x1
  107342:	ff 50 04             	call   *0x4(%eax)
  107345:	58                   	pop    %eax
  107346:	5a                   	pop    %edx
}
  107347:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10734a:	5b                   	pop    %ebx
  10734b:	5e                   	pop    %esi
  10734c:	5f                   	pop    %edi
  10734d:	5d                   	pop    %ebp
  10734e:	c3                   	ret    

0010734f <shell_raw_fprintf>:
{
  10734f:	55                   	push   %ebp
  107350:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  107352:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  107355:	50                   	push   %eax
  107356:	ff 75 0c             	pushl  0xc(%ebp)
  107359:	ff 75 08             	pushl  0x8(%ebp)
  10735c:	e8 36 ee ff ff       	call   106197 <shell_fprintf_fmt>
  107361:	83 c4 0c             	add    $0xc,%esp
}
  107364:	c9                   	leave  
  107365:	c3                   	ret    

00107366 <formatted_text_print.constprop.0>:
 *   shell		Pointer to shell instance.
 *   p_str		Pointer to string to be printed.
 *   terminal_offset	Requested left margin.
 *   offset_first_line	Add margin to the first printed line.
 */
static void formatted_text_print(const struct shell *shell, const char *str,
  107366:	55                   	push   %ebp
  107367:	89 e5                	mov    %esp,%ebp
  107369:	57                   	push   %edi
  10736a:	56                   	push   %esi
  10736b:	53                   	push   %ebx
  10736c:	83 ec 10             	sub    $0x10,%esp
  10736f:	89 55 f0             	mov    %edx,-0x10(%ebp)
  107372:	89 4d ec             	mov    %ecx,-0x14(%ebp)
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
  107375:	85 d2                	test   %edx,%edx
  107377:	0f 84 3c 01 00 00    	je     1074b9 <formatted_text_print.constprop.0+0x153>
  10737d:	89 c3                	mov    %eax,%ebx
  10737f:	31 f6                	xor    %esi,%esi
		shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
  107381:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107384:	0f be 04 30          	movsbl (%eax,%esi,1),%eax
  107388:	89 c1                	mov    %eax,%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  10738a:	83 e8 09             	sub    $0x9,%eax
  10738d:	83 f8 04             	cmp    $0x4,%eax
  107390:	77 03                	ja     107395 <formatted_text_print.constprop.0+0x2f>
		++offset;
  107392:	46                   	inc    %esi
  107393:	eb ec                	jmp    107381 <formatted_text_print.constprop.0+0x1b>
	while (isspace((int) *(str + offset))) {
  107395:	80 f9 20             	cmp    $0x20,%cl
  107398:	74 f8                	je     107392 <formatted_text_print.constprop.0+0x2c>
  10739a:	ff 75 f0             	pushl  -0x10(%ebp)
  10739d:	e8 7a 49 00 00       	call   10bd1c <strlen>
		size_t idx = 0;

		length = shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
  1073a2:	8b 53 08             	mov    0x8(%ebx),%edx
  1073a5:	0f b7 7a 2e          	movzwl 0x2e(%edx),%edi
  1073a9:	89 fa                	mov    %edi,%edx
  1073ab:	89 7d e8             	mov    %edi,-0x18(%ebp)
  1073ae:	2b 55 ec             	sub    -0x14(%ebp),%edx
			for (idx = 0; idx < length; idx++) {
  1073b1:	31 ff                	xor    %edi,%edi
		length = shell_strlen(str) - offset;
  1073b3:	0f b7 c0             	movzwl %ax,%eax
  1073b6:	29 f0                	sub    %esi,%eax
  1073b8:	59                   	pop    %ecx
		if (length <=
  1073b9:	39 d0                	cmp    %edx,%eax
  1073bb:	76 0d                	jbe    1073ca <formatted_text_print.constprop.0+0x64>
  1073bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1073c0:	01 f0                	add    %esi,%eax
  1073c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1073c5:	e9 83 00 00 00       	jmp    10744d <formatted_text_print.constprop.0+0xe7>
  1073ca:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1073cd:	01 f1                	add    %esi,%ecx
			for (idx = 0; idx < length; idx++) {
  1073cf:	39 f8                	cmp    %edi,%eax
  1073d1:	74 4a                	je     10741d <formatted_text_print.constprop.0+0xb7>
				if (*(str + offset + idx) == '\n') {
  1073d3:	8d 14 3e             	lea    (%esi,%edi,1),%edx
  1073d6:	80 3c 39 0a          	cmpb   $0xa,(%ecx,%edi,1)
  1073da:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1073dd:	75 3b                	jne    10741a <formatted_text_print.constprop.0+0xb4>
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
  1073df:	ff 73 14             	pushl  0x14(%ebx)
  1073e2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1073e5:	e8 88 ed ff ff       	call   106172 <shell_fprintf_buffer_flush>
					transport_buffer_flush(shell);
					shell_write(shell, str + offset, idx);
  1073ea:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1073ed:	89 3c 24             	mov    %edi,(%esp)
  1073f0:	51                   	push   %ecx
  1073f1:	53                   	push   %ebx
  1073f2:	e8 73 f7 ff ff       	call   106b6a <shell_write>
  1073f7:	83 c4 0c             	add    $0xc,%esp
					offset += idx + 1;
  1073fa:	8b 75 e8             	mov    -0x18(%ebp),%esi
  1073fd:	46                   	inc    %esi
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  1073fe:	68 01 4e 12 00       	push   $0x124e01
  107403:	ff 73 14             	pushl  0x14(%ebx)
  107406:	e8 44 ff ff ff       	call   10734f <shell_raw_fprintf>
  10740b:	5f                   	pop    %edi
  10740c:	58                   	pop    %eax
					cursor_next_line_move(shell);
					shell_op_cursor_horiz_move(shell,
  10740d:	ff 75 ec             	pushl  -0x14(%ebp)
  107410:	53                   	push   %ebx
  107411:	e8 eb f3 ff ff       	call   106801 <shell_op_cursor_horiz_move>
  107416:	58                   	pop    %eax
  107417:	5a                   	pop    %edx
							terminal_offset);
					break;
  107418:	eb 03                	jmp    10741d <formatted_text_print.constprop.0+0xb7>
			for (idx = 0; idx < length; idx++) {
  10741a:	47                   	inc    %edi
  10741b:	eb b2                	jmp    1073cf <formatted_text_print.constprop.0+0x69>
				}
			}

			/* String will fit in one line. */
			shell_raw_fprintf(shell->fprintf_ctx, str + offset);
  10741d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  107420:	01 f2                	add    %esi,%edx
  107422:	52                   	push   %edx
  107423:	ff 73 14             	pushl  0x14(%ebx)
  107426:	e8 24 ff ff ff       	call   10734f <shell_raw_fprintf>
  10742b:	58                   	pop    %eax
  10742c:	5a                   	pop    %edx
  10742d:	68 01 4e 12 00       	push   $0x124e01
  107432:	ff 73 14             	pushl  0x14(%ebx)
  107435:	e8 15 ff ff ff       	call   10734f <shell_raw_fprintf>
  10743a:	59                   	pop    %ecx
  10743b:	5b                   	pop    %ebx
}
  10743c:	eb 7b                	jmp    1074b9 <formatted_text_print.constprop.0+0x153>
		length = shell->ctx->vt100_ctx.cons.terminal_wid
				- terminal_offset;

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx)))) {
  10743e:	3c 20                	cmp    $0x20,%al
  107440:	74 1c                	je     10745e <formatted_text_print.constprop.0+0xf8>
				if (*(str + offset + idx) == '\n') {
					break;
				}
			}

			if ((idx + terminal_offset) >=
  107442:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107445:	01 f8                	add    %edi,%eax
  107447:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  10744a:	76 1a                	jbe    107466 <formatted_text_print.constprop.0+0x100>
			    shell->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
  10744c:	47                   	inc    %edi
			if (isspace((int) (*(str + offset + idx)))) {
  10744d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  107450:	0f be 0c 38          	movsbl (%eax,%edi,1),%ecx
  107454:	89 c8                	mov    %ecx,%eax
  107456:	83 e9 09             	sub    $0x9,%ecx
  107459:	83 f9 04             	cmp    $0x4,%ecx
  10745c:	77 e0                	ja     10743e <formatted_text_print.constprop.0+0xd8>
				if (*(str + offset + idx) == '\n') {
  10745e:	3c 0a                	cmp    $0xa,%al
  107460:	74 06                	je     107468 <formatted_text_print.constprop.0+0x102>
  107462:	89 fa                	mov    %edi,%edx
  107464:	eb dc                	jmp    107442 <formatted_text_print.constprop.0+0xdc>
  107466:	89 d7                	mov    %edx,%edi
  107468:	ff 73 14             	pushl  0x14(%ebx)
  10746b:	e8 02 ed ff ff       	call   106172 <shell_fprintf_buffer_flush>

		/* Writing one line, fprintf IO buffer must be flushed
		 * before calling shell_write.
		 */
		transport_buffer_flush(shell);
		shell_write(shell, str + offset, length);
  107470:	89 3c 24             	mov    %edi,(%esp)
  107473:	ff 75 e4             	pushl  -0x1c(%ebp)
		offset += length;
  107476:	01 fe                	add    %edi,%esi
		shell_write(shell, str + offset, length);
  107478:	53                   	push   %ebx
  107479:	e8 ec f6 ff ff       	call   106b6a <shell_write>
  10747e:	83 c4 0c             	add    $0xc,%esp

		/* Calculating text offset to ensure that next line will
		 * not begin with a space.
		 */
		while (isspace((int) (*(str + offset)))) {
  107481:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107484:	0f be 04 30          	movsbl (%eax,%esi,1),%eax
  107488:	89 c1                	mov    %eax,%ecx
  10748a:	83 e8 09             	sub    $0x9,%eax
  10748d:	83 f8 04             	cmp    $0x4,%eax
  107490:	77 03                	ja     107495 <formatted_text_print.constprop.0+0x12f>
			++offset;
  107492:	46                   	inc    %esi
  107493:	eb ec                	jmp    107481 <formatted_text_print.constprop.0+0x11b>
		while (isspace((int) (*(str + offset)))) {
  107495:	80 f9 20             	cmp    $0x20,%cl
  107498:	74 f8                	je     107492 <formatted_text_print.constprop.0+0x12c>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
  10749a:	68 01 4e 12 00       	push   $0x124e01
  10749f:	ff 73 14             	pushl  0x14(%ebx)
  1074a2:	e8 a8 fe ff ff       	call   10734f <shell_raw_fprintf>
  1074a7:	58                   	pop    %eax
  1074a8:	5a                   	pop    %edx
		}

		cursor_next_line_move(shell);
		shell_op_cursor_horiz_move(shell, terminal_offset);
  1074a9:	ff 75 ec             	pushl  -0x14(%ebp)
  1074ac:	53                   	push   %ebx
  1074ad:	e8 4f f3 ff ff       	call   106801 <shell_op_cursor_horiz_move>
  1074b2:	59                   	pop    %ecx
  1074b3:	5f                   	pop    %edi
	while (true) {
  1074b4:	e9 e1 fe ff ff       	jmp    10739a <formatted_text_print.constprop.0+0x34>

	}
	cursor_next_line_move(shell);
}
  1074b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1074bc:	5b                   	pop    %ebx
  1074bd:	5e                   	pop    %esi
  1074be:	5f                   	pop    %edi
  1074bf:	5d                   	pop    %ebp
  1074c0:	c3                   	ret    

001074c1 <shell_help_subcmd_print>:
 * help string
 */
void shell_help_subcmd_print(const struct shell *shell,
			     const struct shell_static_entry *parent,
			     const char *description)
{
  1074c1:	55                   	push   %ebp
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
	size_t idx = 0;
  1074c2:	31 c0                	xor    %eax,%eax
{
  1074c4:	89 e5                	mov    %esp,%ebp
  1074c6:	57                   	push   %edi
  1074c7:	56                   	push   %esi
  1074c8:	53                   	push   %ebx
	uint16_t longest = 0U;
  1074c9:	31 db                	xor    %ebx,%ebx
{
  1074cb:	83 ec 20             	sub    $0x20,%esp
  1074ce:	8b 75 08             	mov    0x8(%ebp),%esi

	/* Searching for the longest subcommand to print. */
	while ((entry = shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  1074d1:	8d 55 e0             	lea    -0x20(%ebp),%edx
  1074d4:	8d 78 01             	lea    0x1(%eax),%edi
  1074d7:	52                   	push   %edx
  1074d8:	50                   	push   %eax
  1074d9:	ff 75 0c             	pushl  0xc(%ebp)
  1074dc:	e8 38 f0 ff ff       	call   106519 <shell_cmd_get>
  1074e1:	83 c4 0c             	add    $0xc,%esp
  1074e4:	85 c0                	test   %eax,%eax
  1074e6:	74 18                	je     107500 <shell_help_subcmd_print+0x3f>
		longest = Z_MAX(longest, shell_strlen(entry->syntax));
  1074e8:	8b 00                	mov    (%eax),%eax
	return str == NULL ? 0U : (uint16_t)strlen(str);
  1074ea:	85 c0                	test   %eax,%eax
  1074ec:	74 0e                	je     1074fc <shell_help_subcmd_print+0x3b>
  1074ee:	50                   	push   %eax
  1074ef:	e8 28 48 00 00       	call   10bd1c <strlen>
  1074f4:	66 39 c3             	cmp    %ax,%bx
  1074f7:	5a                   	pop    %edx
  1074f8:	73 02                	jae    1074fc <shell_help_subcmd_print+0x3b>
  1074fa:	89 c3                	mov    %eax,%ebx
	while ((entry = shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  1074fc:	89 f8                	mov    %edi,%eax
  1074fe:	eb d1                	jmp    1074d1 <shell_help_subcmd_print+0x10>
	};

	/* No help to print */
	if (longest == 0) {
  107500:	66 85 db             	test   %bx,%bx
  107503:	0f 84 9c 00 00 00    	je     1075a5 <shell_help_subcmd_print+0xe4>
		return;
	}

	if (description != NULL) {
  107509:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10750d:	74 0e                	je     10751d <shell_help_subcmd_print+0x5c>
		shell_internal_fprintf(shell, SHELL_NORMAL, description);
  10750f:	ff 75 10             	pushl  0x10(%ebp)
  107512:	6a 00                	push   $0x0
  107514:	56                   	push   %esi
  107515:	e8 fe f7 ff ff       	call   106d18 <shell_internal_fprintf>
  10751a:	83 c4 0c             	add    $0xc,%esp
	while ((entry = shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  10751d:	31 c0                	xor    %eax,%eax
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  10751f:	8d 55 e0             	lea    -0x20(%ebp),%edx
  107522:	8d 78 01             	lea    0x1(%eax),%edi
  107525:	52                   	push   %edx
  107526:	89 7d dc             	mov    %edi,-0x24(%ebp)
  107529:	50                   	push   %eax
  10752a:	ff 75 0c             	pushl  0xc(%ebp)
  10752d:	e8 e7 ef ff ff       	call   106519 <shell_cmd_get>
  107532:	83 c4 0c             	add    $0xc,%esp
  107535:	85 c0                	test   %eax,%eax
  107537:	74 6c                	je     1075a5 <shell_help_subcmd_print+0xe4>
		help_item_print(shell, entry->syntax, longest, entry->help);
  107539:	8b 10                	mov    (%eax),%edx
  10753b:	8b 78 04             	mov    0x4(%eax),%edi
  10753e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  107541:	68 29 51 12 00       	push   $0x125129
  107546:	e8 d1 47 00 00       	call   10bd1c <strlen>
	if (item_name == NULL) {
  10754b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  10754e:	59                   	pop    %ecx
  10754f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (item_name == NULL) {
  107552:	85 d2                	test   %edx,%edx
  107554:	74 47                	je     10759d <shell_help_subcmd_print+0xdc>
		shell_internal_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:",
  107556:	68 29 51 12 00       	push   $0x125129
  10755b:	52                   	push   %edx
		help_item_print(shell, entry->syntax, longest, entry->help);
  10755c:	0f b7 c3             	movzwl %bx,%eax
		shell_internal_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:",
  10755f:	50                   	push   %eax
  107560:	68 29 51 12 00       	push   $0x125129
  107565:	68 1f 51 12 00       	push   $0x12511f
  10756a:	6a 00                	push   $0x0
  10756c:	56                   	push   %esi
  10756d:	e8 a6 f7 ff ff       	call   106d18 <shell_internal_fprintf>
  107572:	83 c4 1c             	add    $0x1c,%esp
	if (item_help == NULL) {
  107575:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  107578:	85 ff                	test   %edi,%edi
  10757a:	75 11                	jne    10758d <shell_help_subcmd_print+0xcc>
  10757c:	68 01 4e 12 00       	push   $0x124e01
  107581:	ff 76 14             	pushl  0x14(%esi)
  107584:	e8 c6 fd ff ff       	call   10734f <shell_raw_fprintf>
  107589:	58                   	pop    %eax
  10758a:	5a                   	pop    %edx
}
  10758b:	eb 10                	jmp    10759d <shell_help_subcmd_print+0xdc>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
  10758d:	8d 4c 4b 01          	lea    0x1(%ebx,%ecx,2),%ecx
	formatted_text_print(shell, item_help, offset, false);
  107591:	89 fa                	mov    %edi,%edx
  107593:	0f b7 c9             	movzwl %cx,%ecx
  107596:	89 f0                	mov    %esi,%eax
  107598:	e8 c9 fd ff ff       	call   107366 <formatted_text_print.constprop.0>
	while ((entry = shell_cmd_get(parent, idx++, &dloc)) != NULL) {
  10759d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1075a0:	e9 7a ff ff ff       	jmp    10751f <shell_help_subcmd_print+0x5e>
	}
}
  1075a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1075a8:	5b                   	pop    %ebx
  1075a9:	5e                   	pop    %esi
  1075aa:	5f                   	pop    %edi
  1075ab:	5d                   	pop    %ebp
  1075ac:	c3                   	ret    

001075ad <shell_help_cmd_print>:

void shell_help_cmd_print(const struct shell *shell,
			  const struct shell_static_entry *cmd)
{
  1075ad:	55                   	push   %ebp
  1075ae:	89 e5                	mov    %esp,%ebp
  1075b0:	57                   	push   %edi
  1075b1:	56                   	push   %esi
  1075b2:	8b 75 0c             	mov    0xc(%ebp),%esi
  1075b5:	53                   	push   %ebx
  1075b6:	8b 7d 08             	mov    0x8(%ebp),%edi
  1075b9:	31 db                	xor    %ebx,%ebx
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = shell_strlen(cmd->syntax) + shell_strlen(cmd_sep);
  1075bb:	8b 06                	mov    (%esi),%eax
  1075bd:	85 c0                	test   %eax,%eax
  1075bf:	74 09                	je     1075ca <shell_help_cmd_print+0x1d>
  1075c1:	50                   	push   %eax
  1075c2:	e8 55 47 00 00       	call   10bd1c <strlen>
  1075c7:	5a                   	pop    %edx
  1075c8:	89 c3                	mov    %eax,%ebx
  1075ca:	68 d4 41 12 00       	push   $0x1241d4
  1075cf:	e8 48 47 00 00       	call   10bd1c <strlen>

	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
  1075d4:	c7 04 24 d4 41 12 00 	movl   $0x1241d4,(%esp)
	field_width = shell_strlen(cmd->syntax) + shell_strlen(cmd_sep);
  1075db:	01 c3                	add    %eax,%ebx
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
  1075dd:	ff 36                	pushl  (%esi)
  1075df:	68 a3 50 12 00       	push   $0x1250a3
  1075e4:	6a 00                	push   $0x0
  1075e6:	57                   	push   %edi
  1075e7:	e8 2c f7 ff ff       	call   106d18 <shell_internal_fprintf>
				cmd->syntax, cmd_sep);

	formatted_text_print(shell, cmd->help, field_width, false);
  1075ec:	8b 56 04             	mov    0x4(%esi),%edx
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
  1075ef:	83 c4 14             	add    $0x14,%esp
}
  1075f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
	formatted_text_print(shell, cmd->help, field_width, false);
  1075f5:	89 f8                	mov    %edi,%eax
  1075f7:	0f b7 cb             	movzwl %bx,%ecx
}
  1075fa:	5b                   	pop    %ebx
  1075fb:	5e                   	pop    %esi
  1075fc:	5f                   	pop    %edi
  1075fd:	5d                   	pop    %ebp
	formatted_text_print(shell, cmd->help, field_width, false);
  1075fe:	e9 63 fd ff ff       	jmp    107366 <formatted_text_print.constprop.0>

00107603 <cmd_bacskpace_mode_backspace>:
	return 0;
}

static int cmd_bacskpace_mode_backspace(const struct shell *shell, size_t argc,
					char **argv)
{
  107603:	55                   	push   %ebp
  107604:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
  107606:	8b 45 08             	mov    0x8(%ebp),%eax
  107609:	8b 50 08             	mov    0x8(%eax),%edx
  10760c:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  107612:	83 e0 df             	and    $0xffffffdf,%eax
  107615:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
	ARG_UNUSED(argv);

	flag_mode_delete_set(shell, false);

	return 0;
}
  10761b:	31 c0                	xor    %eax,%eax
  10761d:	5d                   	pop    %ebp
  10761e:	c3                   	ret    

0010761f <cmd_bacskpace_mode_delete>:

static int cmd_bacskpace_mode_delete(const struct shell *shell, size_t argc,
				      char **argv)
{
  10761f:	55                   	push   %ebp
  107620:	89 e5                	mov    %esp,%ebp
  107622:	8b 45 08             	mov    0x8(%ebp),%eax
  107625:	8b 50 08             	mov    0x8(%eax),%edx
  107628:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  10762e:	83 c8 20             	or     $0x20,%eax
  107631:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
	ARG_UNUSED(argv);

	flag_mode_delete_set(shell, true);

	return 0;
}
  107637:	31 c0                	xor    %eax,%eax
  107639:	5d                   	pop    %ebp
  10763a:	c3                   	ret    

0010763b <cmd_colors_off>:

static int cmd_colors_off(const struct shell *shell, size_t argc, char **argv)
{
  10763b:	55                   	push   %ebp
  10763c:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
  10763e:	8b 45 08             	mov    0x8(%ebp),%eax
  107641:	8b 50 08             	mov    0x8(%eax),%edx
  107644:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  10764a:	83 e0 fd             	and    $0xfffffffd,%eax
  10764d:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
	ARG_UNUSED(argv);

	flag_use_colors_set(shell, false);

	return 0;
}
  107653:	31 c0                	xor    %eax,%eax
  107655:	5d                   	pop    %ebp
  107656:	c3                   	ret    

00107657 <cmd_colors_on>:

static int cmd_colors_on(const struct shell *shell, size_t argc, char **argv)
{
  107657:	55                   	push   %ebp
  107658:	89 e5                	mov    %esp,%ebp
  10765a:	8b 45 08             	mov    0x8(%ebp),%eax
  10765d:	8b 50 08             	mov    0x8(%eax),%edx
  107660:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  107666:	83 c8 02             	or     $0x2,%eax
  107669:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
	ARG_UNUSED(argv);

	flag_use_colors_set(shell, true);

	return 0;
}
  10766f:	31 c0                	xor    %eax,%eax
  107671:	5d                   	pop    %ebp
  107672:	c3                   	ret    

00107673 <cmd_echo_off>:

static int cmd_echo_off(const struct shell *shell, size_t argc, char **argv)
{
  107673:	55                   	push   %ebp
  107674:	89 e5                	mov    %esp,%ebp
	shell->ctx->internal.flags.echo = val ? 1 : 0;
  107676:	8b 45 08             	mov    0x8(%ebp),%eax
  107679:	8b 50 08             	mov    0x8(%eax),%edx
  10767c:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  107682:	83 e0 fb             	and    $0xfffffffb,%eax
  107685:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
	ARG_UNUSED(argv);

	flag_echo_set(shell, false);

	return 0;
}
  10768b:	31 c0                	xor    %eax,%eax
  10768d:	5d                   	pop    %ebp
  10768e:	c3                   	ret    

0010768f <cmd_echo_on>:

static int cmd_echo_on(const struct shell *shell, size_t argc, char **argv)
{
  10768f:	55                   	push   %ebp
  107690:	89 e5                	mov    %esp,%ebp
  107692:	8b 45 08             	mov    0x8(%ebp),%eax
  107695:	8b 50 08             	mov    0x8(%eax),%edx
  107698:	8b 82 64 02 00 00    	mov    0x264(%edx),%eax
  10769e:	83 c8 04             	or     $0x4,%eax
  1076a1:	89 82 64 02 00 00    	mov    %eax,0x264(%edx)
	ARG_UNUSED(argv);

	flag_echo_set(shell, true);

	return 0;
}
  1076a7:	31 c0                	xor    %eax,%eax
  1076a9:	5d                   	pop    %ebp
  1076aa:	c3                   	ret    

001076ab <cmd_shell_stats_reset>:
	return 0;
}

static int cmd_shell_stats_reset(const struct shell *shell,
				 size_t argc, char **argv)
{
  1076ab:	55                   	push   %ebp
  1076ac:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell->stats->log_lost_cnt = 0;
  1076ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1076b1:	8b 40 18             	mov    0x18(%eax),%eax
  1076b4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	return 0;
}
  1076ba:	31 c0                	xor    %eax,%eax
  1076bc:	5d                   	pop    %ebp
  1076bd:	c3                   	ret    

001076be <shell_raw_fprintf>:
{
  1076be:	55                   	push   %ebp
  1076bf:	89 e5                	mov    %esp,%ebp
	va_start(args, fmt);
  1076c1:	8d 45 10             	lea    0x10(%ebp),%eax
	shell_fprintf_fmt(ctx, fmt, args);
  1076c4:	50                   	push   %eax
  1076c5:	ff 75 0c             	pushl  0xc(%ebp)
  1076c8:	ff 75 08             	pushl  0x8(%ebp)
  1076cb:	e8 c7 ea ff ff       	call   106197 <shell_fprintf_fmt>
  1076d0:	83 c4 0c             	add    $0xc,%esp
}
  1076d3:	c9                   	leave  
  1076d4:	c3                   	ret    

001076d5 <cmd_clear>:
{
  1076d5:	55                   	push   %ebp
  1076d6:	89 e5                	mov    %esp,%ebp
  1076d8:	53                   	push   %ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  1076d9:	68 f0 41 12 00       	push   $0x1241f0
{
  1076de:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
  1076e1:	68 f8 4e 12 00       	push   $0x124ef8
  1076e6:	ff 73 14             	pushl  0x14(%ebx)
  1076e9:	e8 d0 ff ff ff       	call   1076be <shell_raw_fprintf>
  1076ee:	83 c4 0c             	add    $0xc,%esp
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
  1076f1:	68 e8 41 12 00       	push   $0x1241e8
  1076f6:	68 f8 4e 12 00       	push   $0x124ef8
  1076fb:	ff 73 14             	pushl  0x14(%ebx)
  1076fe:	e8 bb ff ff ff       	call   1076be <shell_raw_fprintf>
  107703:	83 c4 0c             	add    $0xc,%esp
}
  107706:	31 c0                	xor    %eax,%eax
  107708:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10770b:	c9                   	leave  
  10770c:	c3                   	ret    

0010770d <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
  10770d:	55                   	push   %ebp
  10770e:	89 e5                	mov    %esp,%ebp
  107710:	53                   	push   %ebx
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  107711:	68 d8 41 12 00       	push   $0x1241d8
{
  107716:	8b 5d 08             	mov    0x8(%ebp),%ebx
	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  107719:	68 f8 4e 12 00       	push   $0x124ef8
  10771e:	ff 73 14             	pushl  0x14(%ebx)
  107721:	e8 98 ff ff ff       	call   1076be <shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
  107726:	8b 43 08             	mov    0x8(%ebx),%eax
  107729:	c7 40 2c 18 00 50 00 	movl   $0x500018,0x2c(%eax)
	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
  107730:	83 c4 0c             	add    $0xc,%esp

	return 0;
}
  107733:	31 c0                	xor    %eax,%eax
  107735:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107738:	c9                   	leave  
  107739:	c3                   	ret    

0010773a <cmd_shell_stats_show>:
{
  10773a:	55                   	push   %ebp
  10773b:	89 e5                	mov    %esp,%ebp
  10773d:	8b 45 08             	mov    0x8(%ebp),%eax
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
  107740:	8b 50 18             	mov    0x18(%eax),%edx
  107743:	ff 32                	pushl  (%edx)
  107745:	68 2c 51 12 00       	push   $0x12512c
  10774a:	6a 00                	push   $0x0
  10774c:	50                   	push   %eax
  10774d:	e8 cd e8 ff ff       	call   10601f <shell_fprintf>
  107752:	83 c4 10             	add    $0x10,%esp
}
  107755:	31 c0                	xor    %eax,%eax
  107757:	c9                   	leave  
  107758:	c3                   	ret    

00107759 <cmd_help>:
{
  107759:	55                   	push   %ebp
  10775a:	89 e5                	mov    %esp,%ebp
  10775c:	53                   	push   %ebx
	shell_print(shell,
  10775d:	68 3b 51 12 00       	push   $0x12513b
{
  107762:	8b 5d 08             	mov    0x8(%ebp),%ebx
	shell_print(shell,
  107765:	6a 00                	push   $0x0
  107767:	53                   	push   %ebx
  107768:	e8 b2 e8 ff ff       	call   10601f <shell_fprintf>
  10776d:	83 c4 0c             	add    $0xc,%esp
	shell_print(shell,
  107770:	68 2a 52 12 00       	push   $0x12522a
  107775:	6a 00                	push   $0x0
  107777:	53                   	push   %ebx
  107778:	e8 a2 e8 ff ff       	call   10601f <shell_fprintf>
  10777d:	83 c4 0c             	add    $0xc,%esp
		shell_help_subcmd_print(shell, NULL, "\nAvailable commands:\n");
  107780:	68 f3 52 12 00       	push   $0x1252f3
  107785:	6a 00                	push   $0x0
  107787:	53                   	push   %ebx
  107788:	e8 34 fd ff ff       	call   1074c1 <shell_help_subcmd_print>
  10778d:	83 c4 0c             	add    $0xc,%esp
}
  107790:	31 c0                	xor    %eax,%eax
  107792:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107795:	c9                   	leave  
  107796:	c3                   	ret    

00107797 <cmd_history>:
{
  107797:	55                   	push   %ebp
  107798:	89 e5                	mov    %esp,%ebp
  10779a:	57                   	push   %edi
  10779b:	56                   	push   %esi
	size_t i = 0;
  10779c:	31 ff                	xor    %edi,%edi
{
  10779e:	53                   	push   %ebx
  10779f:	50                   	push   %eax
  1077a0:	8b 75 08             	mov    0x8(%ebp),%esi
		shell_history_get(shell->history, true,
  1077a3:	8d 45 f2             	lea    -0xe(%ebp),%eax
  1077a6:	50                   	push   %eax
				  shell->ctx->temp_buff, &len);
  1077a7:	8b 46 08             	mov    0x8(%esi),%eax
  1077aa:	05 46 01 00 00       	add    $0x146,%eax
		shell_history_get(shell->history, true,
  1077af:	50                   	push   %eax
  1077b0:	6a 01                	push   $0x1
  1077b2:	ff 76 0c             	pushl  0xc(%esi)
  1077b5:	e8 dd 02 00 00       	call   107a97 <shell_history_get>
  1077ba:	83 c4 10             	add    $0x10,%esp
		if (len) {
  1077bd:	8b 46 08             	mov    0x8(%esi),%eax
  1077c0:	66 83 7d f2 00       	cmpw   $0x0,-0xe(%ebp)
  1077c5:	74 1e                	je     1077e5 <cmd_history+0x4e>
			shell_print(shell, "[%3d] %s",
  1077c7:	05 46 01 00 00       	add    $0x146,%eax
  1077cc:	8d 5f 01             	lea    0x1(%edi),%ebx
  1077cf:	50                   	push   %eax
  1077d0:	57                   	push   %edi
  1077d1:	89 df                	mov    %ebx,%edi
  1077d3:	68 09 53 12 00       	push   $0x125309
  1077d8:	6a 00                	push   $0x0
  1077da:	56                   	push   %esi
  1077db:	e8 3f e8 ff ff       	call   10601f <shell_fprintf>
  1077e0:	83 c4 14             	add    $0x14,%esp
		shell_history_get(shell->history, true,
  1077e3:	eb be                	jmp    1077a3 <cmd_history+0xc>
	shell->ctx->temp_buff[0] = '\0';
  1077e5:	c6 80 46 01 00 00 00 	movb   $0x0,0x146(%eax)
}
  1077ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1077ef:	31 c0                	xor    %eax,%eax
  1077f1:	5b                   	pop    %ebx
  1077f2:	5e                   	pop    %esi
  1077f3:	5f                   	pop    %edi
  1077f4:	5d                   	pop    %ebp
  1077f5:	c3                   	ret    

001077f6 <cmd_echo>:
{
  1077f6:	55                   	push   %ebp
  1077f7:	89 e5                	mov    %esp,%ebp
	if (argc == 2) {
  1077f9:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
{
  1077fd:	8b 45 08             	mov    0x8(%ebp),%eax
  107800:	8b 55 10             	mov    0x10(%ebp),%edx
	if (argc == 2) {
  107803:	75 21                	jne    107826 <cmd_echo+0x30>
		shell_error(shell, "%s:%s%s", argv[0],
  107805:	ff 72 04             	pushl  0x4(%edx)
  107808:	68 17 53 12 00       	push   $0x125317
  10780d:	ff 32                	pushl  (%edx)
  10780f:	68 2c 53 12 00       	push   $0x12532c
  107814:	6a 02                	push   $0x2
  107816:	50                   	push   %eax
  107817:	e8 03 e8 ff ff       	call   10601f <shell_fprintf>
  10781c:	83 c4 18             	add    $0x18,%esp
  10781f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  107824:	eb 2b                	jmp    107851 <cmd_echo+0x5b>
	shell_print(shell, "Echo status: %s",
  107826:	8b 50 08             	mov    0x8(%eax),%edx
	return shell->ctx->internal.flags.echo == 1;
  107829:	8b 8a 64 02 00 00    	mov    0x264(%edx),%ecx
  10782f:	ba d9 4e 12 00       	mov    $0x124ed9,%edx
  107834:	80 e1 04             	and    $0x4,%cl
  107837:	75 05                	jne    10783e <cmd_echo+0x48>
  107839:	ba 13 53 12 00       	mov    $0x125313,%edx
  10783e:	52                   	push   %edx
  10783f:	68 35 53 12 00       	push   $0x125335
  107844:	6a 00                	push   $0x0
  107846:	50                   	push   %eax
  107847:	e8 d3 e7 ff ff       	call   10601f <shell_fprintf>
  10784c:	83 c4 10             	add    $0x10,%esp
	return 0;
  10784f:	31 c0                	xor    %eax,%eax
}
  107851:	c9                   	leave  
  107852:	c3                   	ret    

00107853 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
  107853:	55                   	push   %ebp
  107854:	89 e5                	mov    %esp,%ebp
  107856:	57                   	push   %edi
  107857:	56                   	push   %esi
  107858:	53                   	push   %ebx
  107859:	83 ec 0c             	sub    $0xc,%esp
	int err;

	if (argc != 1) {
  10785c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
{
  107860:	8b 5d 08             	mov    0x8(%ebp),%ebx
  107863:	8b 45 10             	mov    0x10(%ebp),%eax
	if (argc != 1) {
  107866:	74 24                	je     10788c <cmd_resize+0x39>
		shell_error(shell, "%s:%s%s", argv[0],
  107868:	ff 70 04             	pushl  0x4(%eax)
  10786b:	68 17 53 12 00       	push   $0x125317
  107870:	ff 30                	pushl  (%eax)
  107872:	68 2c 53 12 00       	push   $0x12532c
  107877:	6a 02                	push   $0x2
  107879:	53                   	push   %ebx
  10787a:	e8 a0 e7 ff ff       	call   10601f <shell_fprintf>
  10787f:	83 c4 18             	add    $0x18,%esp
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
  107882:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  107887:	e9 b9 01 00 00       	jmp    107a45 <cmd_resize+0x1f2>
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
  10788c:	68 83 53 12 00       	push   $0x125383
  107891:	68 f8 4e 12 00       	push   $0x124ef8
  107896:	ff 73 14             	pushl  0x14(%ebx)
  107899:	e8 20 fe ff ff       	call   1076be <shell_raw_fprintf>
  10789e:	83 c4 0c             	add    $0xc,%esp
	shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
  1078a1:	68 06 ff ff ff       	push   $0xffffff06
  1078a6:	53                   	push   %ebx
  1078a7:	e8 26 ef ff ff       	call   1067d2 <shell_op_cursor_vert_move>
  1078ac:	5a                   	pop    %edx
  1078ad:	59                   	pop    %ecx
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
  1078ae:	68 fa 00 00 00       	push   $0xfa
  1078b3:	53                   	push   %ebx
  1078b4:	e8 48 ef ff ff       	call   106801 <shell_op_cursor_horiz_move>
  1078b9:	5e                   	pop    %esi
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  1078ba:	8b 43 08             	mov    0x8(%ebx),%eax
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
  1078bd:	5f                   	pop    %edi
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  1078be:	05 46 01 00 00       	add    $0x146,%eax
  1078c3:	68 00 01 00 00       	push   $0x100
	char c = 0;
  1078c8:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  1078cc:	6a 00                	push   $0x0
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
  1078ce:	bf e8 03 00 00       	mov    $0x3e8,%edi
  1078d3:	50                   	push   %eax
  1078d4:	e8 82 45 00 00       	call   10be5b <memset>
  1078d9:	83 c4 0c             	add    $0xc,%esp
	uint16_t buff_idx = 0U;
  1078dc:	31 f6                	xor    %esi,%esi
	shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
  1078de:	68 e0 41 12 00       	push   $0x1241e0
  1078e3:	ff 73 14             	pushl  0x14(%ebx)
  1078e6:	e8 d3 fd ff ff       	call   1076be <shell_raw_fprintf>
  1078eb:	58                   	pop    %eax
  1078ec:	5a                   	pop    %edx
  1078ed:	ff 73 14             	pushl  0x14(%ebx)
  1078f0:	e8 7d e8 ff ff       	call   106172 <shell_fprintf_buffer_flush>
  1078f5:	59                   	pop    %ecx
			(void)shell->iface->api->read(shell->iface, &c,
  1078f6:	8b 43 04             	mov    0x4(%ebx),%eax
  1078f9:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  1078fc:	8b 10                	mov    (%eax),%edx
  1078fe:	51                   	push   %ecx
  1078ff:	6a 01                	push   $0x1
  107901:	8d 4d ef             	lea    -0x11(%ebp),%ecx
  107904:	51                   	push   %ecx
  107905:	50                   	push   %eax
  107906:	ff 52 10             	call   *0x10(%edx)
  107909:	83 c4 10             	add    $0x10,%esp
			if (cnt == 0) {
  10790c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  107910:	75 14                	jne    107926 <cmd_resize+0xd3>
	z_impl_k_busy_wait(usec_to_wait);
  107912:	68 e8 03 00 00       	push   $0x3e8
  107917:	e8 8c a0 01 00       	call   1219a8 <z_impl_k_busy_wait>
	for (uint16_t i = 0; i < 1000; i++) {
  10791c:	66 4f                	dec    %di
  10791e:	58                   	pop    %eax
  10791f:	75 d5                	jne    1078f6 <cmd_resize+0xa3>
  107921:	e9 dc 00 00 00       	jmp    107a02 <cmd_resize+0x1af>
			if ((c != SHELL_VT100_ASCII_ESC) &&
  107926:	8a 55 ef             	mov    -0x11(%ebp),%dl
  107929:	8b 43 08             	mov    0x8(%ebx),%eax
  10792c:	80 fa 1b             	cmp    $0x1b,%dl
  10792f:	0f 84 b1 00 00 00    	je     1079e6 <cmd_resize+0x193>
  107935:	80 b8 46 01 00 00 1b 	cmpb   $0x1b,0x146(%eax)
  10793c:	75 b8                	jne    1078f6 <cmd_resize+0xa3>
			if (c == 'R') { /* End of response from the terminal. */
  10793e:	80 fa 52             	cmp    $0x52,%dl
  107941:	0f 85 9f 00 00 00    	jne    1079e6 <cmd_resize+0x193>
				shell->ctx->temp_buff[buff_idx] = '\0';
  107947:	0f b7 f6             	movzwl %si,%esi
  10794a:	31 ff                	xor    %edi,%edi
	*y = 0U;
  10794c:	31 d2                	xor    %edx,%edx
				shell->ctx->temp_buff[buff_idx] = '\0';
  10794e:	c6 84 30 46 01 00 00 	movb   $0x0,0x146(%eax,%esi,1)
  107955:	00 
				if (shell->ctx->temp_buff[1] != '[') {
  107956:	80 b8 47 01 00 00 5b 	cmpb   $0x5b,0x147(%eax)
  10795d:	0f 85 98 00 00 00    	jne    1079fb <cmd_resize+0x1a8>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
  107963:	66 0f be 8c 38 48 01 	movsbw 0x148(%eax,%edi,1),%cx
  10796a:	00 00 
  10796c:	8d 77 03             	lea    0x3(%edi),%esi
  10796f:	80 f9 3b             	cmp    $0x3b,%cl
  107972:	74 12                	je     107986 <cmd_resize+0x133>
					*y = *y * 10U +
  107974:	6b d2 0a             	imul   $0xa,%edx,%edx
  107977:	47                   	inc    %edi
  107978:	8d 54 0a d0          	lea    -0x30(%edx,%ecx,1),%edx
					if (buff_idx >=
  10797c:	81 ff fe 00 00 00    	cmp    $0xfe,%edi
  107982:	75 df                	jne    107963 <cmd_resize+0x110>
  107984:	eb 7c                	jmp    107a02 <cmd_resize+0x1af>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
  107986:	66 81 fe 00 01       	cmp    $0x100,%si
  10798b:	74 75                	je     107a02 <cmd_resize+0x1af>
  10798d:	0f b7 ce             	movzwl %si,%ecx
  107990:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  107993:	89 7d e8             	mov    %edi,-0x18(%ebp)
	*x = 0U;
  107996:	31 ff                	xor    %edi,%edi
				while (shell->ctx->temp_buff[buff_idx]
  107998:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10799b:	66 0f be 89 46 01 00 	movsbw 0x146(%ecx),%cx
  1079a2:	00 
  1079a3:	84 c9                	test   %cl,%cl
  1079a5:	74 14                	je     1079bb <cmd_resize+0x168>
					*x = *x * 10U +
  1079a7:	6b ff 0a             	imul   $0xa,%edi,%edi
					(shell->ctx->temp_buff[buff_idx++] -
  1079aa:	46                   	inc    %esi
  1079ab:	ff 45 e8             	incl   -0x18(%ebp)
					if (buff_idx >=
  1079ae:	66 81 fe ff 00       	cmp    $0xff,%si
					*x = *x * 10U +
  1079b3:	8d 7c 0f d0          	lea    -0x30(%edi,%ecx,1),%edi
					if (buff_idx >=
  1079b7:	76 df                	jbe    107998 <cmd_resize+0x145>
  1079b9:	eb 47                	jmp    107a02 <cmd_resize+0x1af>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  1079bb:	66 81 ff fa 00       	cmp    $0xfa,%di
				shell->ctx->temp_buff[0] = 0;
  1079c0:	c6 80 46 01 00 00 00 	movb   $0x0,0x146(%eax)
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  1079c7:	76 05                	jbe    1079ce <cmd_resize+0x17b>
  1079c9:	bf fa 00 00 00       	mov    $0xfa,%edi
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
  1079ce:	66 81 fa fa 00       	cmp    $0xfa,%dx
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
  1079d3:	66 89 78 2e          	mov    %di,0x2e(%eax)
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
  1079d7:	76 05                	jbe    1079de <cmd_resize+0x18b>
  1079d9:	ba fa 00 00 00       	mov    $0xfa,%edx
  1079de:	66 89 50 2c          	mov    %dx,0x2c(%eax)
	int ret_val = 0;
  1079e2:	31 c0                	xor    %eax,%eax
  1079e4:	eb 21                	jmp    107a07 <cmd_resize+0x1b4>
			shell->ctx->temp_buff[buff_idx] = c;
  1079e6:	0f b7 ce             	movzwl %si,%ecx
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
  1079e9:	46                   	inc    %esi
  1079ea:	66 83 fe 09          	cmp    $0x9,%si
			shell->ctx->temp_buff[buff_idx] = c;
  1079ee:	88 94 08 46 01 00 00 	mov    %dl,0x146(%eax,%ecx,1)
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
  1079f5:	0f 86 fb fe ff ff    	jbe    1078f6 <cmd_resize+0xa3>
				shell->ctx->temp_buff[0] = 0;
  1079fb:	c6 80 46 01 00 00 00 	movb   $0x0,0x146(%eax)
		ret_val = -ENOTSUP;
  107a02:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
  107a07:	68 80 53 12 00       	push   $0x125380
  107a0c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  107a0f:	68 f8 4e 12 00       	push   $0x124ef8
  107a14:	ff 73 14             	pushl  0x14(%ebx)
  107a17:	e8 a2 fc ff ff       	call   1076be <shell_raw_fprintf>
	}

	err = terminal_size_get(shell);
	if (err != 0) {
  107a1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107a1f:	83 c4 0c             	add    $0xc,%esp
  107a22:	85 c0                	test   %eax,%eax
  107a24:	74 1f                	je     107a45 <cmd_resize+0x1f2>
		shell->ctx->vt100_ctx.cons.terminal_wid =
				CONFIG_SHELL_DEFAULT_TERMINAL_WIDTH;
		shell->ctx->vt100_ctx.cons.terminal_hei =
  107a26:	8b 43 08             	mov    0x8(%ebx),%eax
  107a29:	c7 40 2c 18 00 50 00 	movl   $0x500018,0x2c(%eax)
				CONFIG_SHELL_DEFAULT_TERMINAL_HEIGHT;
		shell_warn(shell, "No response from the terminal, assumed 80x24"
  107a30:	68 46 53 12 00       	push   $0x125346
  107a35:	6a 04                	push   $0x4
  107a37:	53                   	push   %ebx
  107a38:	e8 e2 e5 ff ff       	call   10601f <shell_fprintf>
  107a3d:	83 c4 0c             	add    $0xc,%esp
  107a40:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
  107a45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107a48:	5b                   	pop    %ebx
  107a49:	5e                   	pop    %esi
  107a4a:	5f                   	pop    %edi
  107a4b:	5d                   	pop    %ebp
  107a4c:	c3                   	ret    

00107a4d <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
  107a4d:	55                   	push   %ebp
  107a4e:	89 e5                	mov    %esp,%ebp
  107a50:	53                   	push   %ebx
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
  107a51:	8b 50 08             	mov    0x8(%eax),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  107a54:	8b 5a 04             	mov    0x4(%edx),%ebx
  107a57:	8b 0a                	mov    (%edx),%ecx
  107a59:	89 0b                	mov    %ecx,(%ebx)
	node->next->prev = node->prev;
  107a5b:	89 59 04             	mov    %ebx,0x4(%ecx)
	sys_dlist_remove(l_item);

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
  107a5e:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
	node->next = NULL;
  107a62:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	node->prev = NULL;
  107a68:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
  107a6f:	0f b7 52 0a          	movzwl 0xa(%edx),%edx
	total_len = offsetof(struct shell_history_item, data) +
  107a73:	8d 54 11 0c          	lea    0xc(%ecx,%edx,1),%edx
	ring_buf_get_finish(history->ring_buf, total_len);
  107a77:	52                   	push   %edx
  107a78:	ff 30                	pushl  (%eax)
  107a7a:	e8 0b b3 ff ff       	call   102d8a <ring_buf_get_finish>

	return true;
}
  107a7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	ring_buf_get_finish(history->ring_buf, total_len);
  107a82:	58                   	pop    %eax
}
  107a83:	b0 01                	mov    $0x1,%al
	ring_buf_get_finish(history->ring_buf, total_len);
  107a85:	5a                   	pop    %edx
}
  107a86:	c9                   	leave  
  107a87:	c3                   	ret    

00107a88 <shell_history_mode_exit>:
{
  107a88:	55                   	push   %ebp
  107a89:	89 e5                	mov    %esp,%ebp
	history->current = NULL;
  107a8b:	8b 45 08             	mov    0x8(%ebp),%eax
  107a8e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  107a95:	5d                   	pop    %ebp
  107a96:	c3                   	ret    

00107a97 <shell_history_get>:
{
  107a97:	55                   	push   %ebp
  107a98:	89 e5                	mov    %esp,%ebp
  107a9a:	57                   	push   %edi
  107a9b:	56                   	push   %esi
  107a9c:	8b 45 08             	mov    0x8(%ebp),%eax
  107a9f:	53                   	push   %ebx
  107aa0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  107aa3:	8b 75 10             	mov    0x10(%ebp),%esi
	return list->head == list;
  107aa6:	8b 58 04             	mov    0x4(%eax),%ebx
	if (sys_dlist_is_empty(&history->list)) {
  107aa9:	8d 50 04             	lea    0x4(%eax),%edx
{
  107aac:	8b 7d 14             	mov    0x14(%ebp),%edi
	if (sys_dlist_is_empty(&history->list)) {
  107aaf:	39 d3                	cmp    %edx,%ebx
  107ab1:	75 09                	jne    107abc <shell_history_get+0x25>
		*len = 0U;
  107ab3:	66 c7 07 00 00       	movw   $0x0,(%edi)
		return false;
  107ab8:	31 c0                	xor    %eax,%eax
  107aba:	eb 4e                	jmp    107b0a <shell_history_get+0x73>
	if (!up) { /* button down */
  107abc:	8b 50 0c             	mov    0xc(%eax),%edx
  107abf:	84 c9                	test   %cl,%cl
  107ac1:	75 16                	jne    107ad9 <shell_history_get+0x42>
		if (history->current == NULL) {
  107ac3:	85 d2                	test   %edx,%edx
  107ac5:	74 ec                	je     107ab3 <shell_history_get+0x1c>
	return (node == list->head) ? NULL : node->prev;
  107ac7:	39 d3                	cmp    %edx,%ebx
  107ac9:	75 09                	jne    107ad4 <shell_history_get+0x3d>
	history->current = l_item;
  107acb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	if (l_item) {
  107ad2:	eb df                	jmp    107ab3 <shell_history_get+0x1c>
  107ad4:	8b 5a 04             	mov    0x4(%edx),%ebx
  107ad7:	eb 0b                	jmp    107ae4 <shell_history_get+0x4d>
		sys_dlist_peek_head_not_empty(&history->list) :
  107ad9:	85 d2                	test   %edx,%edx
  107adb:	74 07                	je     107ae4 <shell_history_get+0x4d>
	return (node == list->tail) ? NULL : node->next;
  107add:	39 50 08             	cmp    %edx,0x8(%eax)
  107ae0:	74 e9                	je     107acb <shell_history_get+0x34>
  107ae2:	8b 1a                	mov    (%edx),%ebx
	history->current = l_item;
  107ae4:	89 58 0c             	mov    %ebx,0xc(%eax)
	if (l_item) {
  107ae7:	85 db                	test   %ebx,%ebx
  107ae9:	74 c8                	je     107ab3 <shell_history_get+0x1c>
		memcpy(dst, h_item->data, h_item->len);
  107aeb:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  107aef:	50                   	push   %eax
  107af0:	8d 43 0c             	lea    0xc(%ebx),%eax
  107af3:	50                   	push   %eax
  107af4:	56                   	push   %esi
  107af5:	e8 f2 42 00 00       	call   10bdec <memcpy>
		*len = h_item->len;
  107afa:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
		memcpy(dst, h_item->data, h_item->len);
  107afe:	83 c4 0c             	add    $0xc,%esp
		*len = h_item->len;
  107b01:	66 89 07             	mov    %ax,(%edi)
		dst[*len] = '\0';
  107b04:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
		return true;
  107b08:	b0 01                	mov    $0x1,%al
}
  107b0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107b0d:	5b                   	pop    %ebx
  107b0e:	5e                   	pop    %esi
  107b0f:	5f                   	pop    %edi
  107b10:	5d                   	pop    %ebp
  107b11:	c3                   	ret    

00107b12 <shell_history_purge>:

void shell_history_purge(struct shell_history *history)
{
  107b12:	55                   	push   %ebp
  107b13:	89 e5                	mov    %esp,%ebp
  107b15:	53                   	push   %ebx
  107b16:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (sys_dlist_is_empty(&history->list)) {
  107b19:	8d 43 04             	lea    0x4(%ebx),%eax
  107b1c:	39 43 04             	cmp    %eax,0x4(%ebx)
  107b1f:	74 0b                	je     107b2c <shell_history_purge+0x1a>
  107b21:	89 d8                	mov    %ebx,%eax
  107b23:	e8 25 ff ff ff       	call   107a4d <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
  107b28:	84 c0                	test   %al,%al
  107b2a:	75 ed                	jne    107b19 <shell_history_purge+0x7>
	}
}
  107b2c:	5b                   	pop    %ebx
  107b2d:	5d                   	pop    %ebp
  107b2e:	c3                   	ret    

00107b2f <shell_history_put>:

void shell_history_put(struct shell_history *history, uint8_t *line, size_t len)
{
  107b2f:	55                   	push   %ebp
  107b30:	89 e5                	mov    %esp,%ebp
  107b32:	57                   	push   %edi
  107b33:	56                   	push   %esi
  107b34:	53                   	push   %ebx
  107b35:	83 ec 0c             	sub    $0xc,%esp
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
  107b38:	8b 45 10             	mov    0x10(%ebp),%eax
{
  107b3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
  107b3e:	83 c0 0c             	add    $0xc,%eax
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
  107b41:	89 c6                	mov    %eax,%esi
  107b43:	f7 de                	neg    %esi
  107b45:	89 f1                	mov    %esi,%ecx

	/* align to word. */
	total_len += padding;
  107b47:	83 e6 03             	and    $0x3,%esi
  107b4a:	01 c6                	add    %eax,%esi

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
  107b4c:	8b 03                	mov    (%ebx),%eax
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
  107b4e:	83 e1 03             	and    $0x3,%ecx
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	/* One element is used to distinguish between empty and full state. */
	return buf->size - 1;
  107b51:	8b 40 10             	mov    0x10(%eax),%eax
  107b54:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  107b58:	48                   	dec    %eax
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
  107b59:	39 c6                	cmp    %eax,%esi
  107b5b:	0f 87 18 01 00 00    	ja     107c79 <shell_history_put+0x14a>
		return;
	}

	shell_history_mode_exit(history);

	if (len == 0) {
  107b61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
	history->current = NULL;
  107b65:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	if (len == 0) {
  107b6c:	0f 84 07 01 00 00    	je     107c79 <shell_history_put+0x14a>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
  107b72:	8d 43 04             	lea    0x4(%ebx),%eax
  107b75:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return list->head == list;
  107b78:	8b 43 04             	mov    0x4(%ebx),%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
  107b7b:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  107b7e:	75 09                	jne    107b89 <shell_history_put+0x5a>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
  107b80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (l_item &&
  107b87:	eb 2a                	jmp    107bb3 <shell_history_put+0x84>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
  107b89:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (l_item &&
  107b8c:	85 c0                	test   %eax,%eax
  107b8e:	74 23                	je     107bb3 <shell_history_put+0x84>
	   (h_item->len == len) &&
  107b90:	0f b7 50 08          	movzwl 0x8(%eax),%edx
	if (l_item &&
  107b94:	3b 55 10             	cmp    0x10(%ebp),%edx
  107b97:	75 1a                	jne    107bb3 <shell_history_put+0x84>
	   (memcmp(h_item->data, line, len) == 0)) {
  107b99:	ff 75 10             	pushl  0x10(%ebp)
  107b9c:	ff 75 0c             	pushl  0xc(%ebp)
  107b9f:	83 c0 0c             	add    $0xc,%eax
  107ba2:	50                   	push   %eax
  107ba3:	e8 d7 41 00 00       	call   10bd7f <memcmp>
  107ba8:	83 c4 0c             	add    $0xc,%esp
	   (h_item->len == len) &&
  107bab:	85 c0                	test   %eax,%eax
  107bad:	0f 84 c6 00 00 00    	je     107c79 <shell_history_put+0x14a>
		/* Same command as before, do not store */
		return;
	}

	do {
		claim_len = ring_buf_put_claim(history->ring_buf,
  107bb3:	56                   	push   %esi
  107bb4:	8d 55 f0             	lea    -0x10(%ebp),%edx
  107bb7:	52                   	push   %edx
  107bb8:	ff 33                	pushl  (%ebx)
  107bba:	e8 ab b0 ff ff       	call   102c6a <ring_buf_put_claim>
  107bbf:	83 c4 0c             	add    $0xc,%esp
  107bc2:	89 c7                	mov    %eax,%edi
						(uint8_t **)&h_item, total_len);
		/* second allocation may succeed if we were at the end of the
		 * buffer.
		 */
		if (claim_len < total_len) {
  107bc4:	39 c6                	cmp    %eax,%esi
  107bc6:	8d 55 f0             	lea    -0x10(%ebp),%edx
  107bc9:	76 22                	jbe    107bed <shell_history_put+0xbe>
			claim2_len =
				ring_buf_put_claim(history->ring_buf,
  107bcb:	56                   	push   %esi
  107bcc:	52                   	push   %edx
  107bcd:	ff 33                	pushl  (%ebx)
  107bcf:	e8 96 b0 ff ff       	call   102c6a <ring_buf_put_claim>
  107bd4:	83 c4 0c             	add    $0xc,%esp
						   (uint8_t **)&h_item, total_len);
			if (claim2_len == total_len) {
  107bd7:	39 c6                	cmp    %eax,%esi
  107bd9:	75 55                	jne    107c30 <shell_history_put+0x101>
				ring_buf_put_finish(history->ring_buf,
  107bdb:	57                   	push   %edi
  107bdc:	ff 33                	pushl  (%ebx)
  107bde:	e8 d1 b0 ff ff       	call   102cb4 <ring_buf_put_finish>
						    claim_len);
				padding += claim_len;
  107be3:	66 01 7d ea          	add    %di,-0x16(%ebp)
				ring_buf_put_finish(history->ring_buf,
  107be7:	58                   	pop    %eax
  107be8:	5a                   	pop    %edx
				padding += claim_len;
  107be9:	89 f7                	mov    %esi,%edi
  107beb:	eb 02                	jmp    107bef <shell_history_put+0xc0>
				claim_len = total_len;
			}
		}

		if (claim_len == total_len) {
  107bed:	75 41                	jne    107c30 <shell_history_put+0x101>
			add_to_head(history, h_item, line, len, padding);
  107bef:	8b 75 f0             	mov    -0x10(%ebp),%esi
	item->len = len;
  107bf2:	8b 45 10             	mov    0x10(%ebp),%eax
  107bf5:	66 89 46 08          	mov    %ax,0x8(%esi)
	item->padding = padding;
  107bf9:	66 8b 45 ea          	mov    -0x16(%ebp),%ax
  107bfd:	66 89 46 0a          	mov    %ax,0xa(%esi)
	memcpy(item->data, src, len);
  107c01:	8d 46 0c             	lea    0xc(%esi),%eax
  107c04:	ff 75 10             	pushl  0x10(%ebp)
  107c07:	ff 75 0c             	pushl  0xc(%ebp)
  107c0a:	50                   	push   %eax
  107c0b:	e8 dc 41 00 00       	call   10bdec <memcpy>
	node->next = list->head;
  107c10:	8b 43 04             	mov    0x4(%ebx),%eax
  107c13:	83 c4 0c             	add    $0xc,%esp
	node->prev = list;
  107c16:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	node->next = list->head;
  107c19:	89 06                	mov    %eax,(%esi)
	node->prev = list;
  107c1b:	89 4e 04             	mov    %ecx,0x4(%esi)
	list->head->prev = node;
  107c1e:	89 70 04             	mov    %esi,0x4(%eax)
	list->head = node;
  107c21:	89 73 04             	mov    %esi,0x4(%ebx)
			ring_buf_put_finish(history->ring_buf, claim_len);
  107c24:	57                   	push   %edi
  107c25:	ff 33                	pushl  (%ebx)
  107c27:	e8 88 b0 ff ff       	call   102cb4 <ring_buf_put_finish>
  107c2c:	59                   	pop    %ecx
  107c2d:	5b                   	pop    %ebx
			break;
  107c2e:	eb 49                	jmp    107c79 <shell_history_put+0x14a>
		}

		ring_buf_put_finish(history->ring_buf, 0);
  107c30:	6a 00                	push   $0x0
  107c32:	ff 33                	pushl  (%ebx)
  107c34:	e8 7b b0 ff ff       	call   102cb4 <ring_buf_put_finish>
  107c39:	58                   	pop    %eax
	if (sys_dlist_is_empty(&history->list)) {
  107c3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107c3d:	3b 43 04             	cmp    0x4(%ebx),%eax
		ring_buf_put_finish(history->ring_buf, 0);
  107c40:	5a                   	pop    %edx
	if (sys_dlist_is_empty(&history->list)) {
  107c41:	75 25                	jne    107c68 <shell_history_put+0x139>
			 * continues memory in worst case equals half of the
			 * ring buffer capacity. By reseting ring buffer we
			 * ensure that it is capable to provide continues memory
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
  107c43:	8b 03                	mov    (%ebx),%eax
	memset(&buf->misc, 0, sizeof(buf->misc));
  107c45:	83 c0 08             	add    $0x8,%eax
	buf->head = 0;
  107c48:	c7 40 f8 00 00 00 00 	movl   $0x0,-0x8(%eax)
	buf->tail = 0;
  107c4f:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	memset(&buf->misc, 0, sizeof(buf->misc));
  107c56:	6a 08                	push   $0x8
  107c58:	6a 00                	push   $0x0
  107c5a:	50                   	push   %eax
  107c5b:	e8 fb 41 00 00       	call   10be5b <memset>
  107c60:	83 c4 0c             	add    $0xc,%esp
}
  107c63:	e9 4b ff ff ff       	jmp    107bb3 <shell_history_put+0x84>
  107c68:	89 d8                	mov    %ebx,%eax
  107c6a:	e8 de fd ff ff       	call   107a4d <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
  107c6f:	84 c0                	test   %al,%al
  107c71:	0f 85 3c ff ff ff    	jne    107bb3 <shell_history_put+0x84>
  107c77:	eb ca                	jmp    107c43 <shell_history_put+0x114>
		}
	} while (1);
}
  107c79:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107c7c:	5b                   	pop    %ebx
  107c7d:	5e                   	pop    %esi
  107c7e:	5f                   	pop    %edi
  107c7f:	5d                   	pop    %ebp
  107c80:	c3                   	ret    

00107c81 <shell_history_init>:

void shell_history_init(struct shell_history *history)
{
  107c81:	55                   	push   %ebp
  107c82:	89 e5                	mov    %esp,%ebp
  107c84:	8b 45 08             	mov    0x8(%ebp),%eax
	sys_dlist_init(&history->list);
  107c87:	8d 50 04             	lea    0x4(%eax),%edx
	history->current = NULL;
  107c8a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	list->head = (sys_dnode_t *)list;
  107c91:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail = (sys_dnode_t *)list;
  107c94:	89 50 08             	mov    %edx,0x8(%eax)
}
  107c97:	5d                   	pop    %ebp
  107c98:	c3                   	ret    

00107c99 <msg_from_fifo.isra.0>:
	backend->control_block->dropped_cnt = 0;
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
	}
}

static struct log_msg *msg_from_fifo(const struct shell_log_backend *backend)
  107c99:	55                   	push   %ebp
  107c9a:	89 e5                	mov    %esp,%ebp
  107c9c:	83 ec 08             	sub    $0x8,%esp
	return z_impl_k_msgq_get(msgq, data, timeout);
  107c9f:	6a 00                	push   $0x0
  107ca1:	8d 55 f8             	lea    -0x8(%ebp),%edx
  107ca4:	6a 00                	push   $0x0
  107ca6:	52                   	push   %edx
  107ca7:	50                   	push   %eax
  107ca8:	e8 f0 8d 01 00       	call   120a9d <z_impl_k_msgq_get>
  107cad:	83 c4 10             	add    $0x10,%esp
	struct shell_log_backend_msg msg;
	int err;

	err = k_msgq_get(backend->msgq, &msg, K_NO_WAIT);

	return (err == 0) ? msg.msg : NULL;
  107cb0:	85 c0                	test   %eax,%eax
  107cb2:	75 05                	jne    107cb9 <msg_from_fifo.isra.0+0x20>
  107cb4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107cb7:	eb 02                	jmp    107cbb <msg_from_fifo.isra.0+0x22>
  107cb9:	31 c0                	xor    %eax,%eax
}
  107cbb:	c9                   	leave  
  107cbc:	c3                   	ret    

00107cbd <dropped>:
		shell_log_backend_disable(shell->log_backend);
	}
}

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
  107cbd:	55                   	push   %ebp
  107cbe:	89 e5                	mov    %esp,%ebp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  107cc0:	8b 45 08             	mov    0x8(%ebp),%eax
{
  107cc3:	8b 55 0c             	mov    0xc(%ebp),%edx
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  107cc6:	8b 40 04             	mov    0x4(%eax),%eax
  107cc9:	8b 00                	mov    (%eax),%eax
	const struct shell_log_backend *log_backend = shell->log_backend;
  107ccb:	8b 48 1c             	mov    0x1c(%eax),%ecx
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  107cce:	8b 40 18             	mov    0x18(%eax),%eax
  107cd1:	f0 01 10             	lock add %edx,(%eax)
  107cd4:	8b 41 0c             	mov    0xc(%ecx),%eax
  107cd7:	f0 01 10             	lock add %edx,(%eax)

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
  107cda:	5d                   	pop    %ebp
  107cdb:	c3                   	ret    

00107cdc <put>:
{
  107cdc:	55                   	push   %ebp
  107cdd:	89 e5                	mov    %esp,%ebp
  107cdf:	57                   	push   %edi
  107ce0:	56                   	push   %esi
  107ce1:	53                   	push   %ebx
  107ce2:	83 ec 18             	sub    $0x18,%esp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  107ce5:	8b 45 08             	mov    0x8(%ebp),%eax
{
  107ce8:	8b 75 0c             	mov    0xc(%ebp),%esi
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  107ceb:	8b 40 04             	mov    0x4(%eax),%eax
  107cee:	8b 38                	mov    (%eax),%edi
			shell->ctx->internal.flags.use_colors;
  107cf0:	8b 47 08             	mov    0x8(%edi),%eax
  107cf3:	8b 80 64 02 00 00    	mov    0x264(%eax),%eax
	log_msg_get(msg);
  107cf9:	56                   	push   %esi
			shell->ctx->internal.flags.use_colors;
  107cfa:	d1 e8                	shr    %eax
  107cfc:	88 c3                	mov    %al,%bl
	log_msg_get(msg);
  107cfe:	e8 56 bb ff ff       	call   103859 <log_msg_get>
  107d03:	58                   	pop    %eax
	switch (shell->log_backend->control_block->state) {
  107d04:	8b 47 1c             	mov    0x1c(%edi),%eax
			shell->ctx->internal.flags.use_colors;
  107d07:	83 e3 01             	and    $0x1,%ebx
	switch (shell->log_backend->control_block->state) {
  107d0a:	8b 40 0c             	mov    0xc(%eax),%eax
  107d0d:	8b 40 04             	mov    0x4(%eax),%eax
  107d10:	83 f8 01             	cmp    $0x1,%eax
  107d13:	74 2f                	je     107d44 <put+0x68>
  107d15:	83 f8 03             	cmp    $0x3,%eax
  107d18:	0f 85 f4 00 00 00    	jne    107e12 <put+0x136>
		shell_cmd_line_erase(shell);
  107d1e:	57                   	push   %edi
  107d1f:	e8 d3 ed ff ff       	call   106af7 <shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
  107d24:	8b 47 1c             	mov    0x1c(%edi),%eax
  107d27:	8b 50 08             	mov    0x8(%eax),%edx
		flags |= LOG_OUTPUT_FLAG_COLORS;
  107d2a:	89 d8                	mov    %ebx,%eax
  107d2c:	83 e0 01             	and    $0x1,%eax
  107d2f:	83 c0 0e             	add    $0xe,%eax
	log_output_msg_process(log_output, msg, flags);
  107d32:	89 04 24             	mov    %eax,(%esp)
  107d35:	56                   	push   %esi
  107d36:	52                   	push   %edx
  107d37:	e8 d4 c3 ff ff       	call   104110 <log_output_msg_process>
  107d3c:	83 c4 0c             	add    $0xc,%esp
	log_msg_put(msg);
  107d3f:	e9 ce 00 00 00       	jmp    107e12 <put+0x136>
		msg_to_fifo(shell, msg);
  107d44:	89 75 e0             	mov    %esi,-0x20(%ebp)
	struct shell_log_backend_msg t_msg = {
  107d47:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	return z_impl_k_uptime_ticks();
  107d4a:	e8 38 a6 01 00       	call   122387 <z_impl_k_uptime_ticks>
  107d4f:	ba 0a 00 00 00       	mov    $0xa,%edx
  107d54:	f7 e2                	mul    %edx
	return (uint32_t)k_uptime_get();
  107d56:	89 45 e8             	mov    %eax,-0x18(%ebp)
			 K_MSEC(shell->log_backend->timeout));
  107d59:	8b 47 1c             	mov    0x1c(%edi),%eax
  107d5c:	31 d2                	xor    %edx,%edx
	err = k_msgq_put(shell->log_backend->msgq, &t_msg,
  107d5e:	8b 58 04             	mov    0x4(%eax),%ebx
			 K_MSEC(shell->log_backend->timeout));
  107d61:	8b 40 10             	mov    0x10(%eax),%eax
		t += off;
  107d64:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  107d67:	6a 00                	push   $0x0
		t += off;
  107d69:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  107d6c:	6a 0a                	push   $0xa
  107d6e:	52                   	push   %edx
  107d6f:	50                   	push   %eax
  107d70:	e8 ab 84 ff ff       	call   100220 <__udivdi3>
  107d75:	83 c4 10             	add    $0x10,%esp
	return z_impl_k_msgq_put(msgq, data, timeout);
  107d78:	52                   	push   %edx
  107d79:	50                   	push   %eax
  107d7a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  107d7d:	50                   	push   %eax
  107d7e:	53                   	push   %ebx
  107d7f:	e8 59 8c 01 00       	call   1209dd <z_impl_k_msgq_put>
  107d84:	83 c4 10             	add    $0x10,%esp
	switch (err) {
  107d87:	83 f8 b0             	cmp    $0xffffffb0,%eax
  107d8a:	74 05                	je     107d91 <put+0xb5>
  107d8c:	83 f8 f5             	cmp    $0xfffffff5,%eax
  107d8f:	75 6d                	jne    107dfe <put+0x122>
	struct k_msgq *msgq = shell->log_backend->msgq;
  107d91:	8b 47 1c             	mov    0x1c(%edi),%eax
  107d94:	8b 70 04             	mov    0x4(%eax),%esi
	uint32_t timeout = shell->log_backend->timeout;
  107d97:	8b 40 10             	mov    0x10(%eax),%eax
  107d9a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	return z_impl_k_uptime_ticks();
  107d9d:	e8 e5 a5 01 00       	call   122387 <z_impl_k_uptime_ticks>
			return t * (to_hz / from_hz);
  107da2:	ba 0a 00 00 00       	mov    $0xa,%edx
  107da7:	f7 e2                	mul    %edx
  107da9:	89 c3                	mov    %eax,%ebx
	return z_impl_k_msgq_peek(msgq, data);
  107dab:	8d 55 ec             	lea    -0x14(%ebp),%edx
  107dae:	52                   	push   %edx
  107daf:	56                   	push   %esi
  107db0:	e8 bd 8d 01 00       	call   120b72 <z_impl_k_msgq_peek>
  107db5:	5a                   	pop    %edx
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
  107db6:	85 c0                	test   %eax,%eax
  107db8:	59                   	pop    %ecx
  107db9:	75 2c                	jne    107de7 <put+0x10b>
  107dbb:	89 d8                	mov    %ebx,%eax
  107dbd:	2b 45 f0             	sub    -0x10(%ebp),%eax
  107dc0:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  107dc3:	73 22                	jae    107de7 <put+0x10b>
	return z_impl_k_msgq_get(msgq, data, timeout);
  107dc5:	6a 00                	push   $0x0
  107dc7:	8d 55 ec             	lea    -0x14(%ebp),%edx
  107dca:	6a 00                	push   $0x0
  107dcc:	52                   	push   %edx
  107dcd:	56                   	push   %esi
  107dce:	e8 ca 8c 01 00       	call   120a9d <z_impl_k_msgq_get>
  107dd3:	83 c4 10             	add    $0x10,%esp
			log_msg_put(msg.msg);
  107dd6:	ff 75 ec             	pushl  -0x14(%ebp)
  107dd9:	e8 08 bc ff ff       	call   1039e6 <log_msg_put>
  107dde:	58                   	pop    %eax
  107ddf:	8b 47 18             	mov    0x18(%edi),%eax
  107de2:	f0 ff 00             	lock incl (%eax)
		err = k_msgq_peek(msgq, &msg);
  107de5:	eb c4                	jmp    107dab <put+0xcf>
		err = k_msgq_put(shell->log_backend->msgq, &msg, K_NO_WAIT);
  107de7:	8b 47 1c             	mov    0x1c(%edi),%eax
  107dea:	8b 40 04             	mov    0x4(%eax),%eax
	return z_impl_k_msgq_put(msgq, data, timeout);
  107ded:	6a 00                	push   $0x0
  107def:	8d 55 e0             	lea    -0x20(%ebp),%edx
  107df2:	6a 00                	push   $0x0
  107df4:	52                   	push   %edx
  107df5:	50                   	push   %eax
  107df6:	e8 e2 8b 01 00       	call   1209dd <z_impl_k_msgq_put>
  107dfb:	83 c4 10             	add    $0x10,%esp
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
  107dfe:	8b 47 08             	mov    0x8(%edi),%eax
  107e01:	05 78 02 00 00       	add    $0x278,%eax
	return z_impl_k_poll_signal_raise(signal, result);
  107e06:	6a 00                	push   $0x0
  107e08:	50                   	push   %eax
  107e09:	e8 88 ac 01 00       	call   122a96 <z_impl_k_poll_signal_raise>
  107e0e:	5a                   	pop    %edx
  107e0f:	59                   	pop    %ecx
  107e10:	eb 07                	jmp    107e19 <put+0x13d>
		log_msg_put(msg);
  107e12:	56                   	push   %esi
  107e13:	e8 ce bb ff ff       	call   1039e6 <log_msg_put>
  107e18:	58                   	pop    %eax
}
  107e19:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107e1c:	5b                   	pop    %ebx
  107e1d:	5e                   	pop    %esi
  107e1e:	5f                   	pop    %edi
  107e1f:	5d                   	pop    %ebp
  107e20:	c3                   	ret    

00107e21 <shell_log_backend_output_func>:
{
  107e21:	55                   	push   %ebp
  107e22:	89 e5                	mov    %esp,%ebp
  107e24:	8b 45 0c             	mov    0xc(%ebp),%eax
	shell_print_stream(ctx, data, length);
  107e27:	50                   	push   %eax
  107e28:	ff 75 08             	pushl  0x8(%ebp)
  107e2b:	ff 75 10             	pushl  0x10(%ebp)
  107e2e:	e8 c3 ed ff ff       	call   106bf6 <shell_print_stream>
}
  107e33:	8b 45 0c             	mov    0xc(%ebp),%eax
	shell_print_stream(ctx, data, length);
  107e36:	83 c4 0c             	add    $0xc,%esp
}
  107e39:	c9                   	leave  
  107e3a:	c3                   	ret    

00107e3b <shell_log_backend_enable>:
{
  107e3b:	55                   	push   %ebp
  107e3c:	89 e5                	mov    %esp,%ebp
  107e3e:	56                   	push   %esi
  107e3f:	53                   	push   %ebx
		log_backend_enable(backend->backend, ctx, init_log_level);
  107e40:	ff 75 10             	pushl  0x10(%ebp)
{
  107e43:	8b 5d 08             	mov    0x8(%ebp),%ebx
  107e46:	8b 75 0c             	mov    0xc(%ebp),%esi
		log_backend_enable(backend->backend, ctx, init_log_level);
  107e49:	56                   	push   %esi
  107e4a:	ff 33                	pushl  (%ebx)
  107e4c:	e8 15 b3 ff ff       	call   103166 <log_backend_enable>
		log_output_ctx_set(backend->log_output, ctx);
  107e51:	8b 43 08             	mov    0x8(%ebx),%eax
  107e54:	8b 40 04             	mov    0x4(%eax),%eax
		log_backend_enable(backend->backend, ctx, init_log_level);
  107e57:	83 c4 0c             	add    $0xc,%esp
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
  107e5a:	89 70 04             	mov    %esi,0x4(%eax)
	backend->control_block->dropped_cnt = 0;
  107e5d:	8b 43 0c             	mov    0xc(%ebx),%eax
  107e60:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
  107e66:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
}
  107e6d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  107e70:	5b                   	pop    %ebx
  107e71:	5e                   	pop    %esi
  107e72:	5d                   	pop    %ebp
  107e73:	c3                   	ret    

00107e74 <shell_log_backend_disable>:
{
  107e74:	55                   	push   %ebp
  107e75:	89 e5                	mov    %esp,%ebp
  107e77:	53                   	push   %ebx
  107e78:	8b 5d 08             	mov    0x8(%ebp),%ebx
	while ((msg = msg_from_fifo(backend)) != NULL) {
  107e7b:	8b 43 04             	mov    0x4(%ebx),%eax
  107e7e:	e8 16 fe ff ff       	call   107c99 <msg_from_fifo.isra.0>
  107e83:	85 c0                	test   %eax,%eax
  107e85:	74 09                	je     107e90 <shell_log_backend_disable+0x1c>
		log_msg_put(msg);
  107e87:	50                   	push   %eax
  107e88:	e8 59 bb ff ff       	call   1039e6 <log_msg_put>
  107e8d:	5a                   	pop    %edx
  107e8e:	eb eb                	jmp    107e7b <shell_log_backend_disable+0x7>
	log_backend_disable(backend->backend);
  107e90:	ff 33                	pushl  (%ebx)
  107e92:	e8 7a b3 ff ff       	call   103211 <log_backend_disable>
  107e97:	58                   	pop    %eax
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
  107e98:	8b 43 0c             	mov    0xc(%ebx),%eax
}
  107e9b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
  107e9e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
}
  107ea5:	c9                   	leave  
  107ea6:	c3                   	ret    

00107ea7 <shell_log_backend_process>:
{
  107ea7:	55                   	push   %ebp
  107ea8:	89 e5                	mov    %esp,%ebp
  107eaa:	57                   	push   %edi
  107eab:	56                   	push   %esi
  107eac:	53                   	push   %ebx
  107ead:	83 ec 0c             	sub    $0xc,%esp
  107eb0:	8b 55 08             	mov    0x8(%ebp),%edx
			(const struct shell *)backend->backend->cb->ctx;
  107eb3:	8b 02                	mov    (%edx),%eax
	const struct shell *shell =
  107eb5:	8b 40 04             	mov    0x4(%eax),%eax
  107eb8:	8b 38                	mov    (%eax),%edi
			shell->ctx->internal.flags.use_colors;
  107eba:	8b 47 08             	mov    0x8(%edi),%eax
  107ebd:	8b 98 64 02 00 00    	mov    0x264(%eax),%ebx
	struct log_msg *msg = msg_from_fifo(backend);
  107ec3:	8b 42 04             	mov    0x4(%edx),%eax
			shell->ctx->internal.flags.use_colors;
  107ec6:	d1 eb                	shr    %ebx
	struct log_msg *msg = msg_from_fifo(backend);
  107ec8:	e8 cc fd ff ff       	call   107c99 <msg_from_fifo.isra.0>
  107ecd:	89 c6                	mov    %eax,%esi
			shell->ctx->internal.flags.use_colors;
  107ecf:	83 e3 01             	and    $0x1,%ebx
	if (!msg) {
  107ed2:	31 c0                	xor    %eax,%eax
  107ed4:	85 f6                	test   %esi,%esi
  107ed6:	74 78                	je     107f50 <shell_log_backend_process+0xa9>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  107ed8:	8b 55 08             	mov    0x8(%ebp),%edx
  107edb:	31 c9                	xor    %ecx,%ecx
  107edd:	8b 42 0c             	mov    0xc(%edx),%eax
  107ee0:	87 08                	xchg   %ecx,(%eax)
	if (dropped) {
  107ee2:	85 c9                	test   %ecx,%ecx
  107ee4:	74 4a                	je     107f30 <shell_log_backend_process+0x89>
		if (colors) {
  107ee6:	84 db                	test   %bl,%bl
  107ee8:	74 2b                	je     107f15 <shell_log_backend_process+0x6e>
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
  107eea:	8b 47 08             	mov    0x8(%edi),%eax
  107eed:	6a 08                	push   $0x8
  107eef:	83 c0 34             	add    $0x34,%eax
  107ef2:	89 55 08             	mov    %edx,0x8(%ebp)
  107ef5:	50                   	push   %eax
  107ef6:	8d 45 ec             	lea    -0x14(%ebp),%eax
  107ef9:	50                   	push   %eax
  107efa:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  107efd:	e8 ea 3e 00 00       	call   10bdec <memcpy>
  107f02:	83 c4 0c             	add    $0xc,%esp
			shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
  107f05:	6a 02                	push   $0x2
  107f07:	57                   	push   %edi
  107f08:	e8 ee ec ff ff       	call   106bfb <shell_vt100_color_set>
  107f0d:	59                   	pop    %ecx
  107f0e:	8b 55 08             	mov    0x8(%ebp),%edx
  107f11:	58                   	pop    %eax
  107f12:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		log_output_dropped_process(backend->log_output, dropped);
  107f15:	51                   	push   %ecx
  107f16:	ff 72 08             	pushl  0x8(%edx)
  107f19:	e8 38 c3 ff ff       	call   104256 <log_output_dropped_process>
		if (colors) {
  107f1e:	84 db                	test   %bl,%bl
		log_output_dropped_process(backend->log_output, dropped);
  107f20:	58                   	pop    %eax
  107f21:	5a                   	pop    %edx
		if (colors) {
  107f22:	74 0c                	je     107f30 <shell_log_backend_process+0x89>
			shell_vt100_colors_restore(shell, &col);
  107f24:	8d 45 ec             	lea    -0x14(%ebp),%eax
  107f27:	50                   	push   %eax
  107f28:	57                   	push   %edi
  107f29:	e8 1d ed ff ff       	call   106c4b <shell_vt100_colors_restore>
  107f2e:	5a                   	pop    %edx
  107f2f:	59                   	pop    %ecx
	msg_process(shell->log_backend->log_output, msg, colors);
  107f30:	8b 47 1c             	mov    0x1c(%edi),%eax
		flags |= LOG_OUTPUT_FLAG_COLORS;
  107f33:	83 e3 01             	and    $0x1,%ebx
  107f36:	83 c3 0e             	add    $0xe,%ebx
	msg_process(shell->log_backend->log_output, msg, colors);
  107f39:	8b 40 08             	mov    0x8(%eax),%eax
	log_output_msg_process(log_output, msg, flags);
  107f3c:	53                   	push   %ebx
  107f3d:	56                   	push   %esi
  107f3e:	50                   	push   %eax
  107f3f:	e8 cc c1 ff ff       	call   104110 <log_output_msg_process>
  107f44:	83 c4 0c             	add    $0xc,%esp
	log_msg_put(msg);
  107f47:	56                   	push   %esi
  107f48:	e8 99 ba ff ff       	call   1039e6 <log_msg_put>
  107f4d:	58                   	pop    %eax
	return true;
  107f4e:	b0 01                	mov    $0x1,%al
}
  107f50:	8d 65 f4             	lea    -0xc(%ebp),%esp
  107f53:	5b                   	pop    %ebx
  107f54:	5e                   	pop    %esi
  107f55:	5f                   	pop    %edi
  107f56:	5d                   	pop    %ebp
  107f57:	c3                   	ret    

00107f58 <panic>:
{
  107f58:	55                   	push   %ebp
  107f59:	89 e5                	mov    %esp,%ebp
  107f5b:	53                   	push   %ebx
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
  107f5c:	8b 45 08             	mov    0x8(%ebp),%eax
  107f5f:	8b 40 04             	mov    0x4(%eax),%eax
  107f62:	8b 18                	mov    (%eax),%ebx
	err = shell->iface->api->enable(shell->iface, true);
  107f64:	8b 43 04             	mov    0x4(%ebx),%eax
  107f67:	8b 10                	mov    (%eax),%edx
  107f69:	6a 01                	push   $0x1
  107f6b:	50                   	push   %eax
  107f6c:	ff 52 08             	call   *0x8(%edx)
  107f6f:	59                   	pop    %ecx
	if (err == 0) {
  107f70:	85 c0                	test   %eax,%eax
	err = shell->iface->api->enable(shell->iface, true);
  107f72:	5a                   	pop    %edx
  107f73:	8b 43 1c             	mov    0x1c(%ebx),%eax
	if (err == 0) {
  107f76:	75 4e                	jne    107fc6 <panic+0x6e>
		shell->log_backend->control_block->state =
  107f78:	8b 40 0c             	mov    0xc(%eax),%eax
  107f7b:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
						  shell->ctx->cmd_buff_len);
  107f82:	8b 43 08             	mov    0x8(%ebx),%eax
		shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
  107f85:	83 c0 24             	add    $0x24,%eax
  107f88:	0f b7 50 1c          	movzwl 0x1c(%eax),%edx
  107f8c:	52                   	push   %edx
  107f8d:	0f b7 50 1e          	movzwl 0x1e(%eax),%edx
  107f91:	52                   	push   %edx
  107f92:	50                   	push   %eax
  107f93:	e8 e9 e2 ff ff       	call   106281 <shell_multiline_data_calc>
  107f98:	83 c4 0c             	add    $0xc,%esp
		shell_op_cursor_vert_move(shell, -1);
  107f9b:	6a ff                	push   $0xffffffff
  107f9d:	53                   	push   %ebx
  107f9e:	e8 2f e8 ff ff       	call   1067d2 <shell_op_cursor_vert_move>
  107fa3:	59                   	pop    %ecx
  107fa4:	58                   	pop    %eax
					   -shell->ctx->vt100_ctx.cons.cur_x);
  107fa5:	8b 43 08             	mov    0x8(%ebx),%eax
  107fa8:	0f b7 40 24          	movzwl 0x24(%eax),%eax
		shell_op_cursor_horiz_move(shell,
  107fac:	f7 d8                	neg    %eax
  107fae:	50                   	push   %eax
  107faf:	53                   	push   %ebx
  107fb0:	e8 4c e8 ff ff       	call   106801 <shell_op_cursor_horiz_move>
  107fb5:	58                   	pop    %eax
  107fb6:	5a                   	pop    %edx
		while (shell_log_backend_process(shell->log_backend)) {
  107fb7:	ff 73 1c             	pushl  0x1c(%ebx)
  107fba:	e8 e8 fe ff ff       	call   107ea7 <shell_log_backend_process>
  107fbf:	5a                   	pop    %edx
  107fc0:	84 c0                	test   %al,%al
  107fc2:	75 f3                	jne    107fb7 <panic+0x5f>
  107fc4:	eb 0c                	jmp    107fd2 <panic+0x7a>
}
  107fc6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		shell_log_backend_disable(shell->log_backend);
  107fc9:	89 45 08             	mov    %eax,0x8(%ebp)
}
  107fcc:	c9                   	leave  
		shell_log_backend_disable(shell->log_backend);
  107fcd:	e9 a2 fe ff ff       	jmp    107e74 <shell_log_backend_disable>
}
  107fd2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  107fd5:	c9                   	leave  
  107fd6:	c3                   	ret    

00107fd7 <shell_wildcard_character_exist>:

	return ret_val;
}

bool shell_wildcard_character_exist(const char *str)
{
  107fd7:	55                   	push   %ebp
  107fd8:	89 e5                	mov    %esp,%ebp
  107fda:	56                   	push   %esi
  107fdb:	53                   	push   %ebx
  107fdc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return str == NULL ? 0U : (uint16_t)strlen(str);
  107fdf:	85 db                	test   %ebx,%ebx
  107fe1:	75 04                	jne    107fe7 <shell_wildcard_character_exist+0x10>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
  107fe3:	31 c0                	xor    %eax,%eax
  107fe5:	eb 26                	jmp    10800d <shell_wildcard_character_exist+0x36>
  107fe7:	53                   	push   %ebx
  107fe8:	e8 2f 3d 00 00       	call   10bd1c <strlen>
  107fed:	5a                   	pop    %edx
	for (size_t i = 0; i < str_len; i++) {
  107fee:	31 d2                	xor    %edx,%edx
  107ff0:	0f b7 f0             	movzwl %ax,%esi
  107ff3:	39 f2                	cmp    %esi,%edx
  107ff5:	73 ec                	jae    107fe3 <shell_wildcard_character_exist+0xc>
		if ((str[i] == '?') || (str[i] == '*')) {
  107ff7:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  107ffa:	80 f9 3f             	cmp    $0x3f,%cl
  107ffd:	0f 94 c0             	sete   %al
  108000:	80 f9 2a             	cmp    $0x2a,%cl
  108003:	0f 94 c1             	sete   %cl
  108006:	08 c8                	or     %cl,%al
  108008:	75 03                	jne    10800d <shell_wildcard_character_exist+0x36>
	for (size_t i = 0; i < str_len; i++) {
  10800a:	42                   	inc    %edx
  10800b:	eb e6                	jmp    107ff3 <shell_wildcard_character_exist+0x1c>
}
  10800d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  108010:	5b                   	pop    %ebx
  108011:	5e                   	pop    %esi
  108012:	5d                   	pop    %ebp
  108013:	c3                   	ret    

00108014 <shell_wildcard_prepare>:

void shell_wildcard_prepare(const struct shell *shell)
{
  108014:	55                   	push   %ebp
  108015:	89 e5                	mov    %esp,%ebp
  108017:	53                   	push   %ebx
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  108018:	68 00 01 00 00       	push   $0x100
{
  10801d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  108020:	6a 00                	push   $0x0
  108022:	8b 43 08             	mov    0x8(%ebx),%eax
  108025:	05 46 01 00 00       	add    $0x146,%eax
  10802a:	50                   	push   %eax
  10802b:	e8 2b 3e 00 00       	call   10be5b <memset>
	memcpy(shell->ctx->temp_buff,
			shell->ctx->cmd_buff,
			shell->ctx->cmd_buff_len);
  108030:	8b 43 08             	mov    0x8(%ebx),%eax
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
  108033:	83 c4 0c             	add    $0xc,%esp
	memcpy(shell->ctx->temp_buff,
  108036:	0f b7 50 40          	movzwl 0x40(%eax),%edx
  10803a:	52                   	push   %edx
			shell->ctx->cmd_buff,
  10803b:	8d 50 46             	lea    0x46(%eax),%edx
	memcpy(shell->ctx->temp_buff,
  10803e:	52                   	push   %edx
  10803f:	05 46 01 00 00       	add    $0x146,%eax
  108044:	50                   	push   %eax
  108045:	e8 a2 3d 00 00       	call   10bdec <memcpy>
  10804a:	83 c4 0c             	add    $0xc,%esp

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	shell_spaces_trim(shell->ctx->temp_buff);
  10804d:	8b 43 08             	mov    0x8(%ebx),%eax
  108050:	05 46 01 00 00       	add    $0x146,%eax
  108055:	50                   	push   %eax
  108056:	e8 c2 e5 ff ff       	call   10661d <shell_spaces_trim>
  10805b:	8b 53 08             	mov    0x8(%ebx),%edx
  10805e:	59                   	pop    %ecx
  10805f:	81 c2 46 01 00 00    	add    $0x146,%edx
  108065:	74 09                	je     108070 <shell_wildcard_prepare+0x5c>
  108067:	52                   	push   %edx
  108068:	e8 af 3c 00 00       	call   10bd1c <strlen>
  10806d:	5a                   	pop    %edx
  10806e:	eb 02                	jmp    108072 <shell_wildcard_prepare+0x5e>
  108070:	31 c0                	xor    %eax,%eax

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
  108072:	8b 53 08             	mov    0x8(%ebx),%edx
  108075:	40                   	inc    %eax
}
  108076:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
  108079:	66 89 42 44          	mov    %ax,0x44(%edx)
}
  10807d:	c9                   	leave  
  10807e:	c3                   	ret    

0010807f <shell_wildcard_process>:


enum shell_wildcard_status shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
  10807f:	55                   	push   %ebp
  108080:	89 e5                	mov    %esp,%ebp
  108082:	57                   	push   %edi
  108083:	56                   	push   %esi
  108084:	53                   	push   %ebx
  108085:	83 ec 24             	sub    $0x24,%esp
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
  108088:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10808c:	75 0a                	jne    108098 <shell_wildcard_process+0x19>
		return ret_val;
  10808e:	bb 03 00 00 00       	mov    $0x3,%ebx
  108093:	e9 28 01 00 00       	jmp    1081c0 <shell_wildcard_process+0x141>
	}

	if (!shell_wildcard_character_exist(pattern)) {
  108098:	ff 75 10             	pushl  0x10(%ebp)
  10809b:	e8 37 ff ff ff       	call   107fd7 <shell_wildcard_character_exist>
  1080a0:	5f                   	pop    %edi
  1080a1:	84 c0                	test   %al,%al
  1080a3:	74 e9                	je     10808e <shell_wildcard_process+0xf>
	size_t cnt = 0;
  1080a5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	size_t cmd_idx = 0;
  1080ac:	31 c0                	xor    %eax,%eax
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
  1080ae:	bb 02 00 00 00       	mov    $0x2,%ebx
	while ((entry = shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
  1080b3:	8d 55 e0             	lea    -0x20(%ebp),%edx
  1080b6:	8d 48 01             	lea    0x1(%eax),%ecx
  1080b9:	52                   	push   %edx
  1080ba:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  1080bd:	50                   	push   %eax
  1080be:	ff 75 0c             	pushl  0xc(%ebp)
  1080c1:	e8 53 e4 ff ff       	call   106519 <shell_cmd_get>
  1080c6:	83 c4 0c             	add    $0xc,%esp
  1080c9:	89 c6                	mov    %eax,%esi
  1080cb:	85 c0                	test   %eax,%eax
  1080cd:	0f 84 cc 00 00 00    	je     10819f <shell_wildcard_process+0x120>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
  1080d3:	6a 00                	push   $0x0
  1080d5:	ff 36                	pushl  (%esi)
  1080d7:	ff 75 10             	pushl  0x10(%ebp)
  1080da:	e8 b3 8b ff ff       	call   100c92 <fnmatch>
  1080df:	83 c4 0c             	add    $0xc,%esp
  1080e2:	85 c0                	test   %eax,%eax
  1080e4:	0f 85 a8 00 00 00    	jne    108192 <shell_wildcard_process+0x113>
			ret_val = command_add(shell->ctx->temp_buff,
  1080ea:	8b 06                	mov    (%esi),%eax
  1080ec:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
  1080f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
					      &shell->ctx->cmd_tmp_buff_len,
  1080f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1080f8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1080fc:	8b 58 08             	mov    0x8(%eax),%ebx
  1080ff:	74 0d                	je     10810e <shell_wildcard_process+0x8f>
  108101:	ff 75 dc             	pushl  -0x24(%ebp)
  108104:	e8 13 3c 00 00       	call   10bd1c <strlen>
  108109:	5e                   	pop    %esi
  10810a:	66 89 45 da          	mov    %ax,-0x26(%ebp)
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
  10810e:	0f b7 43 44          	movzwl 0x44(%ebx),%eax
  108112:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  108116:	8d 44 30 01          	lea    0x1(%eax,%esi,1),%eax
  10811a:	3d 00 01 00 00       	cmp    $0x100,%eax
  10811f:	7e 1c                	jle    10813d <shell_wildcard_process+0xbe>
				shell_internal_fprintf(shell,
  108121:	ff 75 10             	pushl  0x10(%ebp)
			ret_val = command_add(shell->ctx->temp_buff,
  108124:	bb 01 00 00 00       	mov    $0x1,%ebx
				shell_internal_fprintf(shell,
  108129:	68 51 57 12 00       	push   $0x125751
  10812e:	6a 04                	push   $0x4
  108130:	ff 75 08             	pushl  0x8(%ebp)
  108133:	e8 e0 eb ff ff       	call   106d18 <shell_internal_fprintf>
  108138:	83 c4 10             	add    $0x10,%esp
				break;
  10813b:	eb 62                	jmp    10819f <shell_wildcard_process+0x120>
	completion_addr = strstr(buff, pattern);
  10813d:	ff 75 10             	pushl  0x10(%ebp)
			ret_val = command_add(shell->ctx->temp_buff,
  108140:	8d 83 46 01 00 00    	lea    0x146(%ebx),%eax
	completion_addr = strstr(buff, pattern);
  108146:	50                   	push   %eax
  108147:	e8 dc 3a 00 00       	call   10bc28 <strstr>
  10814c:	5a                   	pop    %edx
  10814d:	89 c7                	mov    %eax,%edi
  10814f:	59                   	pop    %ecx
	if (!completion_addr) {
  108150:	85 c0                	test   %eax,%eax
  108152:	74 46                	je     10819a <shell_wildcard_process+0x11b>
  108154:	50                   	push   %eax
  108155:	e8 c2 3b 00 00       	call   10bd1c <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
  10815a:	0f b7 c0             	movzwl %ax,%eax
  10815d:	40                   	inc    %eax
  10815e:	89 04 24             	mov    %eax,(%esp)
  108161:	57                   	push   %edi
  108162:	8d 44 37 01          	lea    0x1(%edi,%esi,1),%eax
  108166:	50                   	push   %eax
  108167:	e8 45 3c 00 00       	call   10bdb1 <memmove>
  10816c:	83 c4 0c             	add    $0xc,%esp
	memcpy(completion_addr, cmd, cmd_len);
  10816f:	56                   	push   %esi
  108170:	ff 75 dc             	pushl  -0x24(%ebp)
  108173:	57                   	push   %edi
  108174:	e8 73 3c 00 00       	call   10bdec <memcpy>
	completion_addr[cmd_len] = ' ';
  108179:	c6 04 37 20          	movb   $0x20,(%edi,%esi,1)
	*buff_len += cmd_len + 1; /* + 1 for space */
  10817d:	66 8b 45 da          	mov    -0x26(%ebp),%ax
  108181:	66 03 43 44          	add    0x44(%ebx),%ax
			cnt++;
  108185:	ff 45 d4             	incl   -0x2c(%ebp)
	*buff_len += cmd_len + 1; /* + 1 for space */
  108188:	40                   	inc    %eax
	memcpy(completion_addr, cmd, cmd_len);
  108189:	83 c4 0c             	add    $0xc,%esp
	*buff_len += cmd_len + 1; /* + 1 for space */
  10818c:	66 89 43 44          	mov    %ax,0x44(%ebx)
			ret_val = command_add(shell->ctx->temp_buff,
  108190:	31 db                	xor    %ebx,%ebx
  108192:	8b 45 d0             	mov    -0x30(%ebp),%eax
  108195:	e9 19 ff ff ff       	jmp    1080b3 <shell_wildcard_process+0x34>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
  10819a:	bb 02 00 00 00       	mov    $0x2,%ebx
	if (cnt > 0) {
  10819f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  1081a3:	74 1b                	je     1081c0 <shell_wildcard_process+0x141>
				     &shell->ctx->cmd_tmp_buff_len, pattern);
  1081a5:	8b 45 08             	mov    0x8(%ebp),%eax
  1081a8:	8b 40 08             	mov    0x8(%eax),%eax
		shell_pattern_remove(shell->ctx->temp_buff,
  1081ab:	ff 75 10             	pushl  0x10(%ebp)
  1081ae:	8d 50 44             	lea    0x44(%eax),%edx
  1081b1:	05 46 01 00 00       	add    $0x146,%eax
  1081b6:	52                   	push   %edx
  1081b7:	50                   	push   %eax
  1081b8:	e8 f0 e2 ff ff       	call   1064ad <shell_pattern_remove>
  1081bd:	83 c4 0c             	add    $0xc,%esp
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
  1081c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1081c3:	89 d8                	mov    %ebx,%eax
  1081c5:	5b                   	pop    %ebx
  1081c6:	5e                   	pop    %esi
  1081c7:	5f                   	pop    %edi
  1081c8:	5d                   	pop    %ebp
  1081c9:	c3                   	ret    

001081ca <shell_wildcard_finalize>:

void shell_wildcard_finalize(const struct shell *shell)
{
  1081ca:	55                   	push   %ebp
  1081cb:	89 e5                	mov    %esp,%ebp
  1081cd:	53                   	push   %ebx
  1081ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memcpy(shell->ctx->cmd_buff,
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
  1081d1:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->cmd_buff,
  1081d4:	0f b7 50 44          	movzwl 0x44(%eax),%edx
  1081d8:	52                   	push   %edx
	       shell->ctx->temp_buff,
  1081d9:	8d 90 46 01 00 00    	lea    0x146(%eax),%edx
	memcpy(shell->ctx->cmd_buff,
  1081df:	52                   	push   %edx
  1081e0:	83 c0 46             	add    $0x46,%eax
  1081e3:	50                   	push   %eax
  1081e4:	e8 03 3c 00 00       	call   10bdec <memcpy>
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
  1081e9:	8b 43 08             	mov    0x8(%ebx),%eax
	memcpy(shell->ctx->cmd_buff,
  1081ec:	83 c4 0c             	add    $0xc,%esp
}
  1081ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
  1081f2:	8b 50 44             	mov    0x44(%eax),%edx
  1081f5:	66 89 50 40          	mov    %dx,0x40(%eax)
}
  1081f9:	c9                   	leave  
  1081fa:	c3                   	ret    

001081fb <__do_init_array_aux>:
 * @brief Execute initialization routines referenced in .init_array section
 *
 * @return N/A
 */
void __do_init_array_aux(void)
{
  1081fb:	55                   	push   %ebp
  1081fc:	89 e5                	mov    %esp,%ebp
  1081fe:	53                   	push   %ebx
	for (func_ptr *func = __init_array_start;
  1081ff:	bb b0 30 12 00       	mov    $0x1230b0,%ebx
  108204:	81 fb b0 30 12 00    	cmp    $0x1230b0,%ebx
  10820a:	73 07                	jae    108213 <__do_init_array_aux+0x18>
		func < __init_array_end;
		func++) {
		(*func)();
  10820c:	ff 13                	call   *(%ebx)
		func++) {
  10820e:	83 c3 04             	add    $0x4,%ebx
  108211:	eb f1                	jmp    108204 <__do_init_array_aux+0x9>
	}
}
  108213:	5b                   	pop    %ebx
  108214:	5d                   	pop    %ebp
  108215:	c3                   	ret    

00108216 <__do_global_ctors_aux>:
 *
 * This routine is invoked by the kernel prior to the execution of the
 * application's main().
 */
void __do_global_ctors_aux(void)
{
  108216:	55                   	push   %ebp
  108217:	89 e5                	mov    %esp,%ebp
  108219:	56                   	push   %esi
  10821a:	53                   	push   %ebx
	unsigned int nCtors;

	nCtors = (unsigned long)__CTOR_LIST__[0];
  10821b:	8b 1d a8 30 12 00    	mov    0x1230a8,%ebx

	while (nCtors >= 1U) {
  108221:	8d 34 9d a8 30 12 00 	lea    0x1230a8(,%ebx,4),%esi
  108228:	85 db                	test   %ebx,%ebx
  10822a:	74 08                	je     108234 <__do_global_ctors_aux+0x1e>
		__CTOR_LIST__[nCtors--]();
  10822c:	ff 16                	call   *(%esi)
  10822e:	4b                   	dec    %ebx
  10822f:	83 ee 04             	sub    $0x4,%esi
  108232:	eb f4                	jmp    108228 <__do_global_ctors_aux+0x12>
	}
}
  108234:	5b                   	pop    %ebx
  108235:	5e                   	pop    %esi
  108236:	5d                   	pop    %ebp
  108237:	c3                   	ret    

00108238 <append_u8>:

/* The CoAP message ID that is incremented each time coap_next_id() is called. */
static uint16_t message_id;

static inline bool append_u8(struct coap_packet *cpkt, uint8_t data)
{
  108238:	55                   	push   %ebp
  108239:	89 e5                	mov    %esp,%ebp
  10823b:	57                   	push   %edi
  10823c:	56                   	push   %esi
  10823d:	53                   	push   %ebx
	if (!cpkt) {
		return false;
  10823e:	31 db                	xor    %ebx,%ebx
	if (!cpkt) {
  108240:	85 c0                	test   %eax,%eax
  108242:	74 1e                	je     108262 <append_u8+0x2a>
	}

	if (cpkt->max_len - cpkt->offset < 1) {
  108244:	0f b7 70 04          	movzwl 0x4(%eax),%esi
  108248:	0f b7 78 06          	movzwl 0x6(%eax),%edi
  10824c:	29 f7                	sub    %esi,%edi
		return false;
  10824e:	31 db                	xor    %ebx,%ebx
	if (cpkt->max_len - cpkt->offset < 1) {
  108250:	89 f1                	mov    %esi,%ecx
  108252:	85 ff                	test   %edi,%edi
  108254:	7e 0c                	jle    108262 <append_u8+0x2a>
		return false;
	}

	cpkt->data[cpkt->offset++] = data;
  108256:	8b 18                	mov    (%eax),%ebx
  108258:	41                   	inc    %ecx
  108259:	66 89 48 04          	mov    %cx,0x4(%eax)
  10825d:	88 14 33             	mov    %dl,(%ebx,%esi,1)

	return true;
  108260:	b3 01                	mov    $0x1,%bl
}
  108262:	88 d8                	mov    %bl,%al
  108264:	5b                   	pop    %ebx
  108265:	5e                   	pop    %esi
  108266:	5f                   	pop    %edi
  108267:	5d                   	pop    %ebp
  108268:	c3                   	ret    

00108269 <append_be16>:

static inline bool append_be16(struct coap_packet *cpkt, uint16_t data)
{
  108269:	55                   	push   %ebp
  10826a:	89 e5                	mov    %esp,%ebp
  10826c:	57                   	push   %edi
  10826d:	56                   	push   %esi
  10826e:	53                   	push   %ebx
	if (!cpkt) {
		return false;
  10826f:	31 db                	xor    %ebx,%ebx
	if (!cpkt) {
  108271:	85 c0                	test   %eax,%eax
  108273:	74 2d                	je     1082a2 <append_be16+0x39>
	}

	if (cpkt->max_len - cpkt->offset < 2) {
  108275:	0f b7 70 04          	movzwl 0x4(%eax),%esi
  108279:	0f b7 78 06          	movzwl 0x6(%eax),%edi
  10827d:	29 f7                	sub    %esi,%edi
		return false;
  10827f:	31 db                	xor    %ebx,%ebx
	if (cpkt->max_len - cpkt->offset < 2) {
  108281:	89 f1                	mov    %esi,%ecx
  108283:	4f                   	dec    %edi
  108284:	7e 1c                	jle    1082a2 <append_be16+0x39>
		return false;
	}

	cpkt->data[cpkt->offset++] = data >> 8;
  108286:	8b 18                	mov    (%eax),%ebx
  108288:	41                   	inc    %ecx
  108289:	66 89 48 04          	mov    %cx,0x4(%eax)
  10828d:	88 34 33             	mov    %dh,(%ebx,%esi,1)
	cpkt->data[cpkt->offset++] = (uint8_t) data;
  108290:	0f b7 48 04          	movzwl 0x4(%eax),%ecx
  108294:	8b 18                	mov    (%eax),%ebx
  108296:	8d 71 01             	lea    0x1(%ecx),%esi
  108299:	66 89 70 04          	mov    %si,0x4(%eax)
  10829d:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)

	return true;
  1082a0:	b3 01                	mov    $0x1,%bl
}
  1082a2:	88 d8                	mov    %bl,%al
  1082a4:	5b                   	pop    %ebx
  1082a5:	5e                   	pop    %esi
  1082a6:	5f                   	pop    %edi
  1082a7:	5d                   	pop    %ebp
  1082a8:	c3                   	ret    

001082a9 <decode_delta>:
	return max_len - offset;
}

static int decode_delta(uint8_t *data, uint16_t offset, uint16_t *pos, uint16_t max_len,
			uint16_t opt, uint16_t *opt_ext, uint16_t *hdr_len)
{
  1082a9:	55                   	push   %ebp
  1082aa:	89 e5                	mov    %esp,%ebp
  1082ac:	57                   	push   %edi
  1082ad:	56                   	push   %esi
  1082ae:	8b 75 0c             	mov    0xc(%ebp),%esi
  1082b1:	53                   	push   %ebx
	int ret = 0;

	if (opt == COAP_OPTION_EXT_13) {
  1082b2:	66 83 fe 0d          	cmp    $0xd,%si
{
  1082b6:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (opt == COAP_OPTION_EXT_13) {
  1082b9:	75 33                	jne    1082ee <decode_delta+0x45>
		uint8_t val;

		*hdr_len = 1U;
  1082bb:	8b 75 14             	mov    0x14(%ebp),%esi

		ret = read_u8(data, offset, pos, max_len, &val);
  1082be:	0f b7 da             	movzwl %dx,%ebx
		*hdr_len = 1U;
  1082c1:	66 c7 06 01 00       	movw   $0x1,(%esi)
		ret = read_u8(data, offset, pos, max_len, &val);
  1082c6:	0f b7 f7             	movzwl %di,%esi
	if (max_len - offset < 1) {
  1082c9:	89 f7                	mov    %esi,%edi
  1082cb:	29 df                	sub    %ebx,%edi
  1082cd:	85 ff                	test   %edi,%edi
  1082cf:	7f 07                	jg     1082d8 <decode_delta+0x2f>
		if (ret < 0) {
			return -EINVAL;
  1082d1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1082d6:	eb 68                	jmp    108340 <decode_delta+0x97>
	*value = data[offset++];
  1082d8:	42                   	inc    %edx
  1082d9:	0f b6 1c 18          	movzbl (%eax,%ebx,1),%ebx
	*pos = offset;
  1082dd:	66 89 11             	mov    %dx,(%ecx)
		if (ret < 0) {
  1082e0:	89 f0                	mov    %esi,%eax
	return max_len - offset;
  1082e2:	0f b7 d2             	movzwl %dx,%edx
		if (ret < 0) {
  1082e5:	29 d0                	sub    %edx,%eax
  1082e7:	78 e8                	js     1082d1 <decode_delta+0x28>
		}

		opt = val + COAP_OPTION_EXT_13;
  1082e9:	83 c3 0d             	add    $0xd,%ebx
  1082ec:	eb 4c                	jmp    10833a <decode_delta+0x91>
	} else if (opt == COAP_OPTION_EXT_14) {
  1082ee:	66 83 fe 0e          	cmp    $0xe,%si
  1082f2:	75 3c                	jne    108330 <decode_delta+0x87>
		uint16_t val;

		*hdr_len = 2U;
  1082f4:	8b 75 14             	mov    0x14(%ebp),%esi

		ret = read_be16(data, offset, pos, max_len, &val);
  1082f7:	0f b7 da             	movzwl %dx,%ebx
		*hdr_len = 2U;
  1082fa:	66 c7 06 02 00       	movw   $0x2,(%esi)
		ret = read_be16(data, offset, pos, max_len, &val);
  1082ff:	0f b7 f7             	movzwl %di,%esi
	if (max_len - offset < 2) {
  108302:	89 f7                	mov    %esi,%edi
  108304:	29 df                	sub    %ebx,%edi
  108306:	4f                   	dec    %edi
  108307:	7e c8                	jle    1082d1 <decode_delta+0x28>
	*value |= data[offset++];
  108309:	8d 7a 02             	lea    0x2(%edx),%edi
	*value = data[offset++] << 8;
  10830c:	42                   	inc    %edx
	*value |= data[offset++];
  10830d:	0f b7 d2             	movzwl %dx,%edx
	*value = data[offset++] << 8;
  108310:	0f b6 1c 18          	movzbl (%eax,%ebx,1),%ebx
	*value |= data[offset++];
  108314:	0f b6 04 10          	movzbl (%eax,%edx,1),%eax
	*value = data[offset++] << 8;
  108318:	c1 e3 08             	shl    $0x8,%ebx
	*pos = offset;
  10831b:	66 89 39             	mov    %di,(%ecx)
	*value |= data[offset++];
  10831e:	09 c3                	or     %eax,%ebx
		if (ret < 0) {
  108320:	89 f0                	mov    %esi,%eax
	return max_len - offset;
  108322:	0f b7 ff             	movzwl %di,%edi
		if (ret < 0) {
  108325:	29 f8                	sub    %edi,%eax
  108327:	78 a8                	js     1082d1 <decode_delta+0x28>
			return -EINVAL;
		}

		opt = val + COAP_OPTION_EXT_269;
  108329:	66 81 c3 0d 01       	add    $0x10d,%bx
  10832e:	eb 0a                	jmp    10833a <decode_delta+0x91>
	} else if (opt == COAP_OPTION_EXT_15) {
  108330:	66 83 fe 0f          	cmp    $0xf,%si
  108334:	74 9b                	je     1082d1 <decode_delta+0x28>
  108336:	89 f3                	mov    %esi,%ebx
	int ret = 0;
  108338:	31 c0                	xor    %eax,%eax
		return -EINVAL;
	}

	*opt_ext = opt;
  10833a:	8b 55 10             	mov    0x10(%ebp),%edx
  10833d:	66 89 1a             	mov    %bx,(%edx)

	return ret;
}
  108340:	5b                   	pop    %ebx
  108341:	5e                   	pop    %esi
  108342:	5f                   	pop    %edi
  108343:	5d                   	pop    %ebp
  108344:	c3                   	ret    

00108345 <update_descriptive_block>:
	return val;
}

static int update_descriptive_block(struct coap_block_context *ctx,
				    int block, int size)
{
  108345:	55                   	push   %ebp
  108346:	89 e5                	mov    %esp,%ebp
  108348:	57                   	push   %edi
  108349:	56                   	push   %esi
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
  10834a:	89 d6                	mov    %edx,%esi
  10834c:	c1 fe 04             	sar    $0x4,%esi
{
  10834f:	53                   	push   %ebx
  108350:	89 cb                	mov    %ecx,%ebx
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
  108352:	89 d1                	mov    %edx,%ecx
  108354:	83 e1 07             	and    $0x7,%ecx
  108357:	83 c1 04             	add    $0x4,%ecx
  10835a:	d3 e6                	shl    %cl,%esi

	if (block == -ENOENT) {
  10835c:	83 fa fe             	cmp    $0xfffffffe,%edx
  10835f:	74 4f                	je     1083b0 <update_descriptive_block+0x6b>
		return 0;
	}

	if (size && ctx->total_size && ctx->total_size != size) {
  108361:	85 db                	test   %ebx,%ebx
  108363:	74 0f                	je     108374 <update_descriptive_block+0x2f>
  108365:	8b 38                	mov    (%eax),%edi
  108367:	85 ff                	test   %edi,%edi
  108369:	74 09                	je     108374 <update_descriptive_block+0x2f>
		return -EINVAL;
  10836b:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
	if (size && ctx->total_size && ctx->total_size != size) {
  108370:	39 df                	cmp    %ebx,%edi
  108372:	75 3e                	jne    1083b2 <update_descriptive_block+0x6d>
	}

	if (ctx->current > 0 && GET_BLOCK_SIZE(block) > ctx->block_size) {
  108374:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  108378:	74 0f                	je     108389 <update_descriptive_block+0x44>
  10837a:	89 d7                	mov    %edx,%edi
		return -EINVAL;
  10837c:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
	if (ctx->current > 0 && GET_BLOCK_SIZE(block) > ctx->block_size) {
  108381:	83 e7 07             	and    $0x7,%edi
  108384:	3b 78 08             	cmp    0x8(%eax),%edi
  108387:	77 29                	ja     1083b2 <update_descriptive_block+0x6d>
		return -EINVAL;
	}

	if (ctx->total_size && new_current > ctx->total_size) {
  108389:	8b 38                	mov    (%eax),%edi
  10838b:	85 ff                	test   %edi,%edi
  10838d:	74 09                	je     108398 <update_descriptive_block+0x53>
		return -EINVAL;
  10838f:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
	if (ctx->total_size && new_current > ctx->total_size) {
  108394:	39 f7                	cmp    %esi,%edi
  108396:	72 1a                	jb     1083b2 <update_descriptive_block+0x6d>
		return -EINVAL;
	}

	if (size) {
  108398:	85 db                	test   %ebx,%ebx
  10839a:	74 02                	je     10839e <update_descriptive_block+0x59>
		ctx->total_size = size;
  10839c:	89 18                	mov    %ebx,(%eax)
	}
	ctx->current = new_current;
	ctx->block_size = MIN(GET_BLOCK_SIZE(block), ctx->block_size);
  10839e:	83 e2 07             	and    $0x7,%edx
  1083a1:	8b 48 08             	mov    0x8(%eax),%ecx
	ctx->current = new_current;
  1083a4:	89 70 04             	mov    %esi,0x4(%eax)
	ctx->block_size = MIN(GET_BLOCK_SIZE(block), ctx->block_size);
  1083a7:	39 d1                	cmp    %edx,%ecx
  1083a9:	76 02                	jbe    1083ad <update_descriptive_block+0x68>
  1083ab:	89 d1                	mov    %edx,%ecx
  1083ad:	89 48 08             	mov    %ecx,0x8(%eax)
		return 0;
  1083b0:	31 c9                	xor    %ecx,%ecx

	return 0;
}
  1083b2:	5b                   	pop    %ebx
  1083b3:	89 c8                	mov    %ecx,%eax
  1083b5:	5e                   	pop    %esi
  1083b6:	5f                   	pop    %edi
  1083b7:	5d                   	pop    %ebp
  1083b8:	c3                   	ret    

001083b9 <append>:
{
  1083b9:	55                   	push   %ebp
	if (!cpkt || !data) {
  1083ba:	85 c0                	test   %eax,%eax
{
  1083bc:	89 e5                	mov    %esp,%ebp
  1083be:	57                   	push   %edi
  1083bf:	56                   	push   %esi
  1083c0:	53                   	push   %ebx
  1083c1:	53                   	push   %ebx
  1083c2:	89 c3                	mov    %eax,%ebx
  1083c4:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if (!cpkt || !data) {
  1083c7:	0f 94 c1             	sete   %cl
  1083ca:	85 d2                	test   %edx,%edx
  1083cc:	0f 94 c0             	sete   %al
  1083cf:	08 c8                	or     %cl,%al
  1083d1:	75 2a                	jne    1083fd <append+0x44>
	if (cpkt->max_len - cpkt->offset < len) {
  1083d3:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  1083d7:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  1083db:	0f b7 75 f0          	movzwl -0x10(%ebp),%esi
  1083df:	29 cf                	sub    %ecx,%edi
  1083e1:	39 fe                	cmp    %edi,%esi
  1083e3:	7f 1a                	jg     1083ff <append+0x46>
	memcpy(cpkt->data + cpkt->offset, data, len);
  1083e5:	56                   	push   %esi
  1083e6:	03 0b                	add    (%ebx),%ecx
  1083e8:	52                   	push   %edx
  1083e9:	51                   	push   %ecx
  1083ea:	e8 fd 39 00 00       	call   10bdec <memcpy>
	cpkt->offset += len;
  1083ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memcpy(cpkt->data + cpkt->offset, data, len);
  1083f2:	83 c4 0c             	add    $0xc,%esp
	cpkt->offset += len;
  1083f5:	66 01 43 04          	add    %ax,0x4(%ebx)
	return true;
  1083f9:	b0 01                	mov    $0x1,%al
  1083fb:	eb 02                	jmp    1083ff <append+0x46>
		return false;
  1083fd:	31 c0                	xor    %eax,%eax
}
  1083ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108402:	5b                   	pop    %ebx
  108403:	5e                   	pop    %esi
  108404:	5f                   	pop    %edi
  108405:	5d                   	pop    %ebp
  108406:	c3                   	ret    

00108407 <parse_option>:
{
  108407:	55                   	push   %ebp
  108408:	89 e5                	mov    %esp,%ebp
  10840a:	57                   	push   %edi
  10840b:	56                   	push   %esi
  10840c:	89 ce                	mov    %ecx,%esi
  10840e:	53                   	push   %ebx
  10840f:	83 ec 14             	sub    $0x14,%esp
  108412:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	r = read_u8(data, offset, pos, max_len, &opt);
  108415:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  108419:	89 45 e8             	mov    %eax,-0x18(%ebp)
{
  10841c:	8b 7d 10             	mov    0x10(%ebp),%edi
	r = read_u8(data, offset, pos, max_len, &opt);
  10841f:	0f b7 c2             	movzwl %dx,%eax
	if (max_len - offset < 1) {
  108422:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  108425:	29 c1                	sub    %eax,%ecx
  108427:	85 c9                	test   %ecx,%ecx
  108429:	0f 8e cf 01 00 00    	jle    1085fe <parse_option+0x1f7>
	*value = data[offset++];
  10842f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  108432:	42                   	inc    %edx
  108433:	8a 0c 03             	mov    (%ebx,%eax,1),%cl
	*pos = offset;
  108436:	66 89 16             	mov    %dx,(%esi)
	if (r < 0) {
  108439:	8b 45 e8             	mov    -0x18(%ebp),%eax
	return max_len - offset;
  10843c:	0f b7 d2             	movzwl %dx,%edx
	if (r < 0) {
  10843f:	29 d0                	sub    %edx,%eax
  108441:	0f 88 de 01 00 00    	js     108625 <parse_option+0x21e>
	*opt_len += 1U;
  108447:	66 ff 07             	incw   (%edi)
	if (opt == COAP_MARKER) {
  10844a:	80 f9 ff             	cmp    $0xff,%cl
  10844d:	75 0d                	jne    10845c <parse_option+0x55>
		return r > 0 ? 0 : -EINVAL;
  10844f:	85 c0                	test   %eax,%eax
  108451:	0f 85 cc 01 00 00    	jne    108623 <parse_option+0x21c>
  108457:	e9 a2 01 00 00       	jmp    1085fe <parse_option+0x1f7>
	return (opt & 0xF0) >> 4;
  10845c:	88 ca                	mov    %cl,%dl
	len = option_header_get_len(opt);
  10845e:	83 e1 0f             	and    $0xf,%ecx
	return (opt & 0xF0) >> 4;
  108461:	c0 ea 04             	shr    $0x4,%dl
	len = option_header_get_len(opt);
  108464:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
	delta = option_header_get_delta(opt);
  108468:	0f b6 da             	movzbl %dl,%ebx
  10846b:	66 89 5d f0          	mov    %bx,-0x10(%ebp)
	if (r == 0 && delta > COAP_OPTION_NO_EXT) {
  10846f:	85 c0                	test   %eax,%eax
  108471:	75 0a                	jne    10847d <parse_option+0x76>
  108473:	66 83 fb 0c          	cmp    $0xc,%bx
  108477:	0f 87 81 01 00 00    	ja     1085fe <parse_option+0x1f7>
	if (delta > COAP_OPTION_NO_EXT) {
  10847d:	80 fa 0c             	cmp    $0xc,%dl
  108480:	76 54                	jbe    1084d6 <parse_option+0xcf>
		r = decode_delta(data, *pos, pos, max_len,
  108482:	8d 4d ee             	lea    -0x12(%ebp),%ecx
  108485:	51                   	push   %ecx
  108486:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  108489:	51                   	push   %ecx
  10848a:	89 f1                	mov    %esi,%ecx
  10848c:	0f b6 d2             	movzbl %dl,%edx
  10848f:	52                   	push   %edx
  108490:	0f b7 06             	movzwl (%esi),%eax
  108493:	ff 75 e8             	pushl  -0x18(%ebp)
  108496:	89 c2                	mov    %eax,%edx
  108498:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10849b:	e8 09 fe ff ff       	call   1082a9 <decode_delta>
  1084a0:	83 c4 10             	add    $0x10,%esp
		if ((r < 0) || (r == 0 && len > COAP_OPTION_NO_EXT)) {
  1084a3:	85 c0                	test   %eax,%eax
  1084a5:	0f 88 53 01 00 00    	js     1085fe <parse_option+0x1f7>
  1084ab:	66 83 7d f2 0c       	cmpw   $0xc,-0xe(%ebp)
  1084b0:	76 08                	jbe    1084ba <parse_option+0xb3>
  1084b2:	85 c0                	test   %eax,%eax
  1084b4:	0f 84 44 01 00 00    	je     1085fe <parse_option+0x1f7>
		if (u16_add_overflow(*opt_len, hdr_len, opt_len)) {
  1084ba:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
#endif

#if use_builtin(__builtin_add_overflow)
static inline bool u16_add_overflow(uint16_t a, uint16_t b, uint16_t *result)
{
	return __builtin_add_overflow(a, b, result);
  1084be:	31 c9                	xor    %ecx,%ecx
  1084c0:	66 03 17             	add    (%edi),%dx
  1084c3:	73 05                	jae    1084ca <parse_option+0xc3>
  1084c5:	b9 01 00 00 00       	mov    $0x1,%ecx
  1084ca:	66 85 c9             	test   %cx,%cx
  1084cd:	66 89 17             	mov    %dx,(%edi)
  1084d0:	0f 85 28 01 00 00    	jne    1085fe <parse_option+0x1f7>
	if (len > COAP_OPTION_NO_EXT) {
  1084d6:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  1084da:	66 83 fa 0c          	cmp    $0xc,%dx
  1084de:	76 42                	jbe    108522 <parse_option+0x11b>
		r = decode_delta(data, *pos, pos, max_len,
  1084e0:	8d 4d ee             	lea    -0x12(%ebp),%ecx
  1084e3:	51                   	push   %ecx
  1084e4:	8d 4d f2             	lea    -0xe(%ebp),%ecx
  1084e7:	51                   	push   %ecx
  1084e8:	89 f1                	mov    %esi,%ecx
  1084ea:	52                   	push   %edx
  1084eb:	0f b7 06             	movzwl (%esi),%eax
  1084ee:	ff 75 e8             	pushl  -0x18(%ebp)
  1084f1:	89 c2                	mov    %eax,%edx
  1084f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1084f6:	e8 ae fd ff ff       	call   1082a9 <decode_delta>
  1084fb:	83 c4 10             	add    $0x10,%esp
		if (r < 0) {
  1084fe:	85 c0                	test   %eax,%eax
  108500:	0f 88 f8 00 00 00    	js     1085fe <parse_option+0x1f7>
		if (u16_add_overflow(*opt_len, hdr_len, opt_len)) {
  108506:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
  10850a:	31 c9                	xor    %ecx,%ecx
  10850c:	66 03 17             	add    (%edi),%dx
  10850f:	73 05                	jae    108516 <parse_option+0x10f>
  108511:	b9 01 00 00 00       	mov    $0x1,%ecx
  108516:	66 85 c9             	test   %cx,%cx
  108519:	66 89 17             	mov    %dx,(%edi)
  10851c:	0f 85 dc 00 00 00    	jne    1085fe <parse_option+0x1f7>
	if (u16_add_overflow(*opt_delta, delta, opt_delta) ||
  108522:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  108526:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  108529:	31 c9                	xor    %ecx,%ecx
  10852b:	66 03 13             	add    (%ebx),%dx
  10852e:	73 05                	jae    108535 <parse_option+0x12e>
  108530:	b9 01 00 00 00       	mov    $0x1,%ecx
  108535:	66 85 c9             	test   %cx,%cx
  108538:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10853b:	66 89 13             	mov    %dx,(%ebx)
  10853e:	0f 85 ba 00 00 00    	jne    1085fe <parse_option+0x1f7>
	    u16_add_overflow(*opt_len, len, opt_len)) {
  108544:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
  108548:	89 d1                	mov    %edx,%ecx
  10854a:	89 d3                	mov    %edx,%ebx
  10854c:	66 03 0f             	add    (%edi),%cx
  10854f:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  108555:	73 06                	jae    10855d <parse_option+0x156>
  108557:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%ebp)
	if (u16_add_overflow(*opt_delta, delta, opt_delta) ||
  10855d:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  108562:	66 89 0f             	mov    %cx,(%edi)
  108565:	0f 85 93 00 00 00    	jne    1085fe <parse_option+0x1f7>
	if (r == 0 && len != 0U) {
  10856b:	66 85 db             	test   %bx,%bx
  10856e:	74 08                	je     108578 <parse_option+0x171>
  108570:	85 c0                	test   %eax,%eax
  108572:	0f 84 86 00 00 00    	je     1085fe <parse_option+0x1f7>
	if (option) {
  108578:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10857c:	0f 84 83 00 00 00    	je     108605 <parse_option+0x1fe>
		if (len > sizeof(option->value)) {
  108582:	66 83 fb 0c          	cmp    $0xc,%bx
  108586:	76 2f                	jbe    1085b7 <parse_option+0x1b0>
			NET_ERR("%u is > sizeof(coap_option->value)(%zu)!",
  108588:	f6 05 ac 5b 14 00 07 	testb  $0x7,0x145bac
  10858f:	74 6d                	je     1085fe <parse_option+0x1f7>
  108591:	b8 d8 30 12 00       	mov    $0x1230d8,%eax
  108596:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10859b:	c1 e8 03             	shr    $0x3,%eax
  10859e:	c1 e0 06             	shl    $0x6,%eax
  1085a1:	83 c8 01             	or     $0x1,%eax
  1085a4:	50                   	push   %eax
  1085a5:	6a 0c                	push   $0xc
  1085a7:	53                   	push   %ebx
  1085a8:	68 a3 57 12 00       	push   $0x1257a3
  1085ad:	e8 fe af ff ff       	call   1035b0 <log_2>
  1085b2:	83 c4 10             	add    $0x10,%esp
  1085b5:	eb 47                	jmp    1085fe <parse_option+0x1f7>
		option->delta = *opt_delta;
  1085b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1085ba:	8b 7d 14             	mov    0x14(%ebp),%edi
	if (max_len - offset < len) {
  1085bd:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		option->delta = *opt_delta;
  1085c0:	66 8b 00             	mov    (%eax),%ax
		option->len = len;
  1085c3:	88 5f 02             	mov    %bl,0x2(%edi)
		option->delta = *opt_delta;
  1085c6:	66 89 07             	mov    %ax,(%edi)
		option->len = len;
  1085c9:	89 f8                	mov    %edi,%eax
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
  1085cb:	83 c0 03             	add    $0x3,%eax
  1085ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1085d1:	0f b7 06             	movzwl (%esi),%eax
	if (max_len - offset < len) {
  1085d4:	29 c1                	sub    %eax,%ecx
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
  1085d6:	89 c7                	mov    %eax,%edi
	if (max_len - offset < len) {
  1085d8:	39 ca                	cmp    %ecx,%edx
  1085da:	7f 22                	jg     1085fe <parse_option+0x1f7>
	memcpy(value, data + offset, len);
  1085dc:	03 45 e4             	add    -0x1c(%ebp),%eax
  1085df:	0f b7 d3             	movzwl %bx,%edx
  1085e2:	52                   	push   %edx
	offset += len;
  1085e3:	01 fb                	add    %edi,%ebx
	memcpy(value, data + offset, len);
  1085e5:	50                   	push   %eax
  1085e6:	ff 75 e0             	pushl  -0x20(%ebp)
  1085e9:	e8 fe 37 00 00       	call   10bdec <memcpy>
	*pos = offset;
  1085ee:	66 89 1e             	mov    %bx,(%esi)
		if (r < 0) {
  1085f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
	memcpy(value, data + offset, len);
  1085f4:	83 c4 0c             	add    $0xc,%esp
	return max_len - offset;
  1085f7:	0f b7 db             	movzwl %bx,%ebx
		if (r < 0) {
  1085fa:	29 d8                	sub    %ebx,%eax
  1085fc:	79 27                	jns    108625 <parse_option+0x21e>
			return -EINVAL;
  1085fe:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  108603:	eb 20                	jmp    108625 <parse_option+0x21e>
  108605:	31 c0                	xor    %eax,%eax
  108607:	66 03 16             	add    (%esi),%dx
  10860a:	73 05                	jae    108611 <parse_option+0x20a>
  10860c:	b8 01 00 00 00       	mov    $0x1,%eax
		if (u16_add_overflow(*pos, len, pos)) {
  108611:	66 85 c0             	test   %ax,%ax
  108614:	66 89 16             	mov    %dx,(%esi)
  108617:	75 e5                	jne    1085fe <parse_option+0x1f7>
		r = max_len - *pos;
  108619:	0f b7 d2             	movzwl %dx,%edx
  10861c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10861f:	29 d0                	sub    %edx,%eax
  108621:	eb 02                	jmp    108625 <parse_option+0x21e>
		return r > 0 ? 0 : -EINVAL;
  108623:	31 c0                	xor    %eax,%eax
}
  108625:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108628:	5b                   	pop    %ebx
  108629:	5e                   	pop    %esi
  10862a:	5f                   	pop    %edi
  10862b:	5d                   	pop    %ebp
  10862c:	c3                   	ret    

0010862d <coap_packet_init>:
{
  10862d:	55                   	push   %ebp
  10862e:	89 e5                	mov    %esp,%ebp
  108630:	57                   	push   %edi
  108631:	56                   	push   %esi
  108632:	53                   	push   %ebx
  108633:	83 ec 10             	sub    $0x10,%esp
  108636:	8b 45 14             	mov    0x14(%ebp),%eax
  108639:	8b 75 10             	mov    0x10(%ebp),%esi
  10863c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10863f:	8b 45 1c             	mov    0x1c(%ebp),%eax
  108642:	89 45 f0             	mov    %eax,-0x10(%ebp)
  108645:	8b 45 24             	mov    0x24(%ebp),%eax
  108648:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10864b:	8b 45 28             	mov    0x28(%ebp),%eax
	if (!cpkt || !data || !max_len) {
  10864e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
{
  108652:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  108655:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!cpkt || !data || !max_len) {
  108658:	0f 94 c1             	sete   %cl
  10865b:	66 85 f6             	test   %si,%si
{
  10865e:	8b 7d 18             	mov    0x18(%ebp),%edi
	if (!cpkt || !data || !max_len) {
  108661:	0f 94 c0             	sete   %al
  108664:	08 c1                	or     %al,%cl
  108666:	75 04                	jne    10866c <coap_packet_init+0x3f>
  108668:	85 db                	test   %ebx,%ebx
  10866a:	75 0a                	jne    108676 <coap_packet_init+0x49>
		return -EINVAL;
  10866c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  108671:	e9 94 00 00 00       	jmp    10870a <coap_packet_init+0xdd>
	hdr |= (type & 0x3) << 4;
  108676:	c1 e7 04             	shl    $0x4,%edi
	memset(cpkt, 0, sizeof(*cpkt));
  108679:	6a 10                	push   $0x10
  10867b:	6a 00                	push   $0x0
	hdr |= (type & 0x3) << 4;
  10867d:	83 e7 30             	and    $0x30,%edi
	memset(cpkt, 0, sizeof(*cpkt));
  108680:	53                   	push   %ebx
  108681:	e8 d5 37 00 00       	call   10be5b <memset>
	hdr = (ver & 0x3) << 6;
  108686:	8a 55 ec             	mov    -0x14(%ebp),%dl
	cpkt->data = data;
  108689:	8b 45 0c             	mov    0xc(%ebp),%eax
	hdr = (ver & 0x3) << 6;
  10868c:	c1 e2 06             	shl    $0x6,%edx
	memset(cpkt, 0, sizeof(*cpkt));
  10868f:	83 c4 0c             	add    $0xc,%esp
	hdr |= (type & 0x3) << 4;
  108692:	09 fa                	or     %edi,%edx
	hdr |= tokenlen & 0xF;
  108694:	8b 7d f0             	mov    -0x10(%ebp),%edi
  108697:	83 e7 0f             	and    $0xf,%edi
	cpkt->data = data;
  10869a:	89 03                	mov    %eax,(%ebx)
	hdr |= tokenlen & 0xF;
  10869c:	09 fa                	or     %edi,%edx
	cpkt->offset = 0U;
  10869e:	66 c7 43 04 00 00    	movw   $0x0,0x4(%ebx)
	cpkt->max_len = max_len;
  1086a4:	66 89 73 06          	mov    %si,0x6(%ebx)
	cpkt->delta = 0U;
  1086a8:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	res = append_u8(cpkt, hdr);
  1086ae:	0f b6 d2             	movzbl %dl,%edx
  1086b1:	89 d8                	mov    %ebx,%eax
  1086b3:	e8 80 fb ff ff       	call   108238 <append_u8>
	if (!res) {
  1086b8:	84 c0                	test   %al,%al
  1086ba:	74 b0                	je     10866c <coap_packet_init+0x3f>
	res = append_u8(cpkt, code);
  1086bc:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
  1086c0:	89 d8                	mov    %ebx,%eax
  1086c2:	e8 71 fb ff ff       	call   108238 <append_u8>
	if (!res) {
  1086c7:	84 c0                	test   %al,%al
  1086c9:	74 a1                	je     10866c <coap_packet_init+0x3f>
	res = append_be16(cpkt, id);
  1086cb:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
  1086cf:	89 d8                	mov    %ebx,%eax
  1086d1:	e8 93 fb ff ff       	call   108269 <append_be16>
	if (!res) {
  1086d6:	84 c0                	test   %al,%al
  1086d8:	74 92                	je     10866c <coap_packet_init+0x3f>
	if (token && tokenlen) {
  1086da:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  1086de:	74 06                	je     1086e6 <coap_packet_init+0xb9>
  1086e0:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  1086e4:	75 0d                	jne    1086f3 <coap_packet_init+0xc6>
	cpkt->hdr_len = 1 + 1 + 2 + tokenlen;
  1086e6:	8a 45 f0             	mov    -0x10(%ebp),%al
  1086e9:	83 c0 04             	add    $0x4,%eax
  1086ec:	88 43 08             	mov    %al,0x8(%ebx)
	return 0;
  1086ef:	31 c0                	xor    %eax,%eax
  1086f1:	eb 17                	jmp    10870a <coap_packet_init+0xdd>
		res = append(cpkt, token, tokenlen);
  1086f3:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  1086f7:	8b 55 20             	mov    0x20(%ebp),%edx
  1086fa:	89 d8                	mov    %ebx,%eax
  1086fc:	e8 b8 fc ff ff       	call   1083b9 <append>
		if (!res) {
  108701:	84 c0                	test   %al,%al
  108703:	75 e1                	jne    1086e6 <coap_packet_init+0xb9>
  108705:	e9 62 ff ff ff       	jmp    10866c <coap_packet_init+0x3f>
}
  10870a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10870d:	5b                   	pop    %ebx
  10870e:	5e                   	pop    %esi
  10870f:	5f                   	pop    %edi
  108710:	5d                   	pop    %ebp
  108711:	c3                   	ret    

00108712 <coap_packet_append_option>:
{
  108712:	55                   	push   %ebp
  108713:	89 e5                	mov    %esp,%ebp
  108715:	57                   	push   %edi
  108716:	56                   	push   %esi
  108717:	53                   	push   %ebx
  108718:	83 ec 0c             	sub    $0xc,%esp
  10871b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10871e:	8b 45 0c             	mov    0xc(%ebp),%eax
  108721:	8b 55 14             	mov    0x14(%ebp),%edx
	if (!cpkt) {
  108724:	85 db                	test   %ebx,%ebx
  108726:	74 46                	je     10876e <coap_packet_append_option+0x5c>
	if (len && !value) {
  108728:	66 85 d2             	test   %dx,%dx
  10872b:	89 c6                	mov    %eax,%esi
  10872d:	0f 95 45 ef          	setne  -0x11(%ebp)
  108731:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  108735:	75 06                	jne    10873d <coap_packet_append_option+0x2b>
  108737:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  10873b:	75 31                	jne    10876e <coap_packet_append_option+0x5c>
	if (code < cpkt->delta) {
  10873d:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  108740:	66 39 c1             	cmp    %ax,%cx
  108743:	76 33                	jbe    108778 <coap_packet_append_option+0x66>
		NET_ERR("Options should be in ascending order");
  108745:	f6 05 ac 5b 14 00 07 	testb  $0x7,0x145bac
  10874c:	74 20                	je     10876e <coap_packet_append_option+0x5c>
  10874e:	b8 d8 30 12 00       	mov    $0x1230d8,%eax
  108753:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  108758:	c1 e8 03             	shr    $0x3,%eax
  10875b:	c1 e0 06             	shl    $0x6,%eax
  10875e:	83 c8 01             	or     $0x1,%eax
  108761:	50                   	push   %eax
  108762:	68 cc 57 12 00       	push   $0x1257cc
  108767:	e8 e1 ad ff ff       	call   10354d <log_0>
  10876c:	58                   	pop    %eax
  10876d:	5a                   	pop    %edx
  10876e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  108773:	e9 32 01 00 00       	jmp    1088aa <coap_packet_append_option+0x198>
	if (cpkt->opt_len) {
  108778:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  10877d:	0f b7 fa             	movzwl %dx,%edi
  108780:	74 09                	je     10878b <coap_packet_append_option+0x79>
		code = (code == cpkt->delta) ? 0 : code - cpkt->delta;
  108782:	66 39 c1             	cmp    %ax,%cx
  108785:	74 0c                	je     108793 <coap_packet_append_option+0x81>
  108787:	89 c6                	mov    %eax,%esi
  108789:	29 ce                	sub    %ecx,%esi
	if (num < COAP_OPTION_EXT_13) {
  10878b:	66 83 fe 0c          	cmp    $0xc,%si
  10878f:	77 0e                	ja     10879f <coap_packet_append_option+0x8d>
  108791:	eb 02                	jmp    108795 <coap_packet_append_option+0x83>
		code = (code == cpkt->delta) ? 0 : code - cpkt->delta;
  108793:	31 f6                	xor    %esi,%esi
		*opt = num;
  108795:	89 f0                	mov    %esi,%eax
		*ext = 0U;
  108797:	31 c9                	xor    %ecx,%ecx
		return 0;
  108799:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
  10879d:	eb 1e                	jmp    1087bd <coap_packet_append_option+0xab>
	} else if (num < COAP_OPTION_EXT_269) {
  10879f:	66 81 fe 0c 01       	cmp    $0x10c,%si
  1087a4:	77 0b                	ja     1087b1 <coap_packet_append_option+0x9f>
		*ext = num - COAP_OPTION_EXT_13;
  1087a6:	8d 4e f3             	lea    -0xd(%esi),%ecx
		*opt = COAP_OPTION_EXT_13;
  1087a9:	b0 0d                	mov    $0xd,%al
		return 1;
  1087ab:	c6 45 f2 01          	movb   $0x1,-0xe(%ebp)
  1087af:	eb 0c                	jmp    1087bd <coap_packet_append_option+0xab>
	*ext = num - COAP_OPTION_EXT_269;
  1087b1:	8d 8e f3 fe ff ff    	lea    -0x10d(%esi),%ecx
	*opt = COAP_OPTION_EXT_14;
  1087b7:	b0 0e                	mov    $0xe,%al
	return 2;
  1087b9:	c6 45 f2 02          	movb   $0x2,-0xe(%ebp)
	if (num < COAP_OPTION_EXT_13) {
  1087bd:	66 83 fa 0c          	cmp    $0xc,%dx
  1087c1:	77 0c                	ja     1087cf <coap_packet_append_option+0xbd>
		*ext = 0U;
  1087c3:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
		return 0;
  1087c9:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  1087cd:	eb 25                	jmp    1087f4 <coap_packet_append_option+0xe2>
	} else if (num < COAP_OPTION_EXT_269) {
  1087cf:	66 81 fa 0c 01       	cmp    $0x10c,%dx
  1087d4:	77 0f                	ja     1087e5 <coap_packet_append_option+0xd3>
		*ext = num - COAP_OPTION_EXT_13;
  1087d6:	83 ea 0d             	sub    $0xd,%edx
		return 1;
  1087d9:	c6 45 f3 01          	movb   $0x1,-0xd(%ebp)
		*ext = num - COAP_OPTION_EXT_13;
  1087dd:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
		*opt = COAP_OPTION_EXT_13;
  1087e1:	b2 0d                	mov    $0xd,%dl
		return 1;
  1087e3:	eb 0f                	jmp    1087f4 <coap_packet_append_option+0xe2>
	*ext = num - COAP_OPTION_EXT_269;
  1087e5:	66 81 ea 0d 01       	sub    $0x10d,%dx
	return 2;
  1087ea:	c6 45 f3 02          	movb   $0x2,-0xd(%ebp)
	*ext = num - COAP_OPTION_EXT_269;
  1087ee:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
	*opt = COAP_OPTION_EXT_14;
  1087f2:	b2 0e                	mov    $0xe,%dl
	*opt = (delta & 0xF) << 4;
  1087f4:	c1 e0 04             	shl    $0x4,%eax
  1087f7:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	*opt |= (len & 0xF);
  1087fa:	09 c2                	or     %eax,%edx
	res = append_u8(cpkt, opt);
  1087fc:	89 d8                	mov    %ebx,%eax
  1087fe:	0f b6 d2             	movzbl %dl,%edx
  108801:	e8 32 fa ff ff       	call   108238 <append_u8>
	if (!res) {
  108806:	84 c0                	test   %al,%al
  108808:	0f 84 60 ff ff ff    	je     10876e <coap_packet_append_option+0x5c>
	if (delta_size == 1U) {
  10880e:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  108812:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  108815:	75 13                	jne    10882a <coap_packet_append_option+0x118>
		res = append_u8(cpkt, (uint8_t)delta_ext);
  108817:	0f b6 d1             	movzbl %cl,%edx
  10881a:	89 d8                	mov    %ebx,%eax
  10881c:	e8 17 fa ff ff       	call   108238 <append_u8>
		if (!res) {
  108821:	84 c0                	test   %al,%al
  108823:	75 7d                	jne    1088a2 <coap_packet_append_option+0x190>
  108825:	e9 44 ff ff ff       	jmp    10876e <coap_packet_append_option+0x5c>
	} else if (delta_size == 2U) {
  10882a:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  10882e:	75 72                	jne    1088a2 <coap_packet_append_option+0x190>
		res = append_be16(cpkt, delta_ext);
  108830:	0f b7 d1             	movzwl %cx,%edx
  108833:	89 d8                	mov    %ebx,%eax
  108835:	e8 2f fa ff ff       	call   108269 <append_be16>
		if (!res) {
  10883a:	84 c0                	test   %al,%al
  10883c:	0f 84 2c ff ff ff    	je     10876e <coap_packet_append_option+0x5c>
	if (len_size == 1U) {
  108842:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  108846:	75 0d                	jne    108855 <coap_packet_append_option+0x143>
		res = append_u8(cpkt, (uint8_t)len_ext);
  108848:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
  10884c:	89 d8                	mov    %ebx,%eax
  10884e:	e8 e5 f9 ff ff       	call   108238 <append_u8>
  108853:	eb 0b                	jmp    108860 <coap_packet_append_option+0x14e>
		res = append_be16(cpkt, len_ext);
  108855:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  108859:	89 d8                	mov    %ebx,%eax
  10885b:	e8 09 fa ff ff       	call   108269 <append_be16>
		if (!res) {
  108860:	84 c0                	test   %al,%al
  108862:	0f 84 06 ff ff ff    	je     10876e <coap_packet_append_option+0x5c>
	if (len && value) {
  108868:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10886c:	74 1a                	je     108888 <coap_packet_append_option+0x176>
  10886e:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  108872:	74 14                	je     108888 <coap_packet_append_option+0x176>
		res = append(cpkt, value, len);
  108874:	89 f9                	mov    %edi,%ecx
  108876:	8b 55 10             	mov    0x10(%ebp),%edx
  108879:	89 d8                	mov    %ebx,%eax
  10887b:	e8 39 fb ff ff       	call   1083b9 <append>
		if (!res) {
  108880:	84 c0                	test   %al,%al
  108882:	0f 84 e6 fe ff ff    	je     10876e <coap_packet_append_option+0x5c>
	return  (1 + delta_size + len_size + len);
  108888:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
	cpkt->delta += code;
  10888c:	66 01 73 0c          	add    %si,0xc(%ebx)
	return  (1 + delta_size + len_size + len);
  108890:	8d 44 07 01          	lea    0x1(%edi,%eax,1),%eax
  108894:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
  108898:	01 c7                	add    %eax,%edi
	return 0;
  10889a:	31 c0                	xor    %eax,%eax
	cpkt->opt_len += r;
  10889c:	66 01 7b 0a          	add    %di,0xa(%ebx)
	return 0;
  1088a0:	eb 08                	jmp    1088aa <coap_packet_append_option+0x198>
	if (len_size == 1U) {
  1088a2:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
  1088a6:	75 c0                	jne    108868 <coap_packet_append_option+0x156>
  1088a8:	eb 9e                	jmp    108848 <coap_packet_append_option+0x136>
}
  1088aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1088ad:	5b                   	pop    %ebx
  1088ae:	5e                   	pop    %esi
  1088af:	5f                   	pop    %edi
  1088b0:	5d                   	pop    %ebp
  1088b1:	c3                   	ret    

001088b2 <coap_append_option_int>:
{
  1088b2:	55                   	push   %ebp
  1088b3:	89 e5                	mov    %esp,%ebp
  1088b5:	50                   	push   %eax
  1088b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1088b9:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (val == 0U) {
  1088bc:	85 c0                	test   %eax,%eax
  1088be:	75 06                	jne    1088c6 <coap_append_option_int+0x14>
		data[0] = 0U;
  1088c0:	c6 45 fc 00          	movb   $0x0,-0x4(%ebp)
		len = 0U;
  1088c4:	eb 3f                	jmp    108905 <coap_append_option_int+0x53>
	} else if (val < 0xFF) {
  1088c6:	3d fe 00 00 00       	cmp    $0xfe,%eax
  1088cb:	77 07                	ja     1088d4 <coap_append_option_int+0x22>
		data[0] = (uint8_t) val;
  1088cd:	88 45 fc             	mov    %al,-0x4(%ebp)
		len = 1U;
  1088d0:	b0 01                	mov    $0x1,%al
  1088d2:	eb 31                	jmp    108905 <coap_append_option_int+0x53>
	} else if (val < 0xFFFF) {
  1088d4:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  1088d9:	77 0a                	ja     1088e5 <coap_append_option_int+0x33>
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val >> 8;
  1088db:	86 e0                	xchg   %ah,%al
  1088dd:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
		len = 2U;
  1088e1:	b0 02                	mov    $0x2,%al
  1088e3:	eb 20                	jmp    108905 <coap_append_option_int+0x53>
	} else if (val < 0xFFFFFF) {
  1088e5:	89 c1                	mov    %eax,%ecx
  1088e7:	c1 e9 10             	shr    $0x10,%ecx
  1088ea:	3d fe ff ff 00       	cmp    $0xfffffe,%eax
  1088ef:	77 0d                	ja     1088fe <coap_append_option_int+0x4c>
  1088f1:	86 e0                	xchg   %ah,%al
		data[0] = val >> 16;
  1088f3:	88 4d fc             	mov    %cl,-0x4(%ebp)
  1088f6:	66 89 45 fd          	mov    %ax,-0x3(%ebp)
		len = 3U;
  1088fa:	b0 03                	mov    $0x3,%al
  1088fc:	eb 07                	jmp    108905 <coap_append_option_int+0x53>
	dst[1] = val;
  1088fe:	0f c8                	bswap  %eax
	dst[0] = val >> 8;
  108900:	89 45 fc             	mov    %eax,-0x4(%ebp)
		len = 4U;
  108903:	b0 04                	mov    $0x4,%al
	return coap_packet_append_option(cpkt, code, data, len);
  108905:	0f b6 c0             	movzbl %al,%eax
  108908:	50                   	push   %eax
  108909:	8d 45 fc             	lea    -0x4(%ebp),%eax
  10890c:	50                   	push   %eax
  10890d:	0f b7 d2             	movzwl %dx,%edx
  108910:	52                   	push   %edx
  108911:	ff 75 08             	pushl  0x8(%ebp)
  108914:	e8 f9 fd ff ff       	call   108712 <coap_packet_append_option>
  108919:	83 c4 10             	add    $0x10,%esp
}
  10891c:	c9                   	leave  
  10891d:	c3                   	ret    

0010891e <coap_option_value_to_int>:
{
  10891e:	55                   	push   %ebp
  10891f:	89 e5                	mov    %esp,%ebp
  108921:	8b 55 08             	mov    0x8(%ebp),%edx
	switch (option->len) {
  108924:	8a 42 02             	mov    0x2(%edx),%al
  108927:	3c 03                	cmp    $0x3,%al
  108929:	74 25                	je     108950 <coap_option_value_to_int+0x32>
  10892b:	77 0a                	ja     108937 <coap_option_value_to_int+0x19>
  10892d:	3c 01                	cmp    $0x1,%al
  10892f:	74 0e                	je     10893f <coap_option_value_to_int+0x21>
  108931:	3c 02                	cmp    $0x2,%al
  108933:	74 10                	je     108945 <coap_option_value_to_int+0x27>
  108935:	eb 04                	jmp    10893b <coap_option_value_to_int+0x1d>
  108937:	3c 04                	cmp    $0x4,%al
  108939:	74 2d                	je     108968 <coap_option_value_to_int+0x4a>
  10893b:	31 c0                	xor    %eax,%eax
  10893d:	eb 2e                	jmp    10896d <coap_option_value_to_int+0x4f>
		return option->value[0];
  10893f:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  108943:	eb 28                	jmp    10896d <coap_option_value_to_int+0x4f>
		return (option->value[1] << 0) | (option->value[0] << 8);
  108945:	66 8b 42 03          	mov    0x3(%edx),%ax
  108949:	86 e0                	xchg   %ah,%al
  10894b:	0f b7 c0             	movzwl %ax,%eax
  10894e:	eb 1d                	jmp    10896d <coap_option_value_to_int+0x4f>
		return (option->value[2] << 0) | (option->value[1] << 8) |
  108950:	0f b6 42 04          	movzbl 0x4(%edx),%eax
			(option->value[0] << 16);
  108954:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
		return (option->value[2] << 0) | (option->value[1] << 8) |
  108958:	c1 e0 08             	shl    $0x8,%eax
  10895b:	0f b6 52 05          	movzbl 0x5(%edx),%edx
			(option->value[0] << 16);
  10895f:	c1 e1 10             	shl    $0x10,%ecx
		return (option->value[2] << 0) | (option->value[1] << 8) |
  108962:	09 c8                	or     %ecx,%eax
  108964:	09 d0                	or     %edx,%eax
  108966:	eb 05                	jmp    10896d <coap_option_value_to_int+0x4f>
		return (option->value[3] << 0) | (option->value[2] << 8) |
  108968:	8b 42 03             	mov    0x3(%edx),%eax
  10896b:	0f c8                	bswap  %eax
}
  10896d:	5d                   	pop    %ebp
  10896e:	c3                   	ret    

0010896f <coap_packet_append_payload_marker>:
{
  10896f:	55                   	push   %ebp
	return append_u8(cpkt, COAP_MARKER) ? 0 : -EINVAL;
  108970:	ba ff 00 00 00       	mov    $0xff,%edx
{
  108975:	89 e5                	mov    %esp,%ebp
	return append_u8(cpkt, COAP_MARKER) ? 0 : -EINVAL;
  108977:	8b 45 08             	mov    0x8(%ebp),%eax
  10897a:	e8 b9 f8 ff ff       	call   108238 <append_u8>
}
  10897f:	5d                   	pop    %ebp
	return append_u8(cpkt, COAP_MARKER) ? 0 : -EINVAL;
  108980:	3c 01                	cmp    $0x1,%al
  108982:	19 c0                	sbb    %eax,%eax
  108984:	83 e0 ea             	and    $0xffffffea,%eax
}
  108987:	c3                   	ret    

00108988 <coap_next_token>:
{
  108988:	55                   	push   %ebp
  108989:	89 e5                	mov    %esp,%ebp
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
  10898b:	e8 c2 75 01 00       	call   11ff52 <z_impl_sys_rand32_get>
	rand[0] = sys_rand32_get();
  108990:	a3 50 eb 12 00       	mov    %eax,0x12eb50
  108995:	e8 b8 75 01 00       	call   11ff52 <z_impl_sys_rand32_get>
}
  10899a:	5d                   	pop    %ebp
	rand[1] = sys_rand32_get();
  10899b:	a3 54 eb 12 00       	mov    %eax,0x12eb54
}
  1089a0:	b8 50 eb 12 00       	mov    $0x12eb50,%eax
  1089a5:	c3                   	ret    

001089a6 <coap_packet_parse>:
{
  1089a6:	55                   	push   %ebp
  1089a7:	89 e5                	mov    %esp,%ebp
  1089a9:	57                   	push   %edi
  1089aa:	56                   	push   %esi
  1089ab:	53                   	push   %ebx
  1089ac:	83 ec 0c             	sub    $0xc,%esp
  1089af:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1089b2:	8b 75 10             	mov    0x10(%ebp),%esi
	if (!cpkt || !data) {
  1089b5:	85 ff                	test   %edi,%edi
{
  1089b7:	8b 4d 18             	mov    0x18(%ebp),%ecx
	if (!cpkt || !data) {
  1089ba:	0f 94 c2             	sete   %dl
	if (len < BASIC_HEADER_SIZE) {
  1089bd:	66 83 fe 03          	cmp    $0x3,%si
{
  1089c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (len < BASIC_HEADER_SIZE) {
  1089c4:	0f 96 c0             	setbe  %al
{
  1089c7:	88 4d eb             	mov    %cl,-0x15(%ebp)
	if (len < BASIC_HEADER_SIZE) {
  1089ca:	08 c2                	or     %al,%dl
  1089cc:	75 04                	jne    1089d2 <coap_packet_parse+0x2c>
  1089ce:	85 db                	test   %ebx,%ebx
  1089d0:	75 0a                	jne    1089dc <coap_packet_parse+0x36>
		return -EINVAL;
  1089d2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  1089d7:	e9 b6 00 00 00       	jmp    108a92 <coap_packet_parse+0xec>
	if (options) {
  1089dc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1089e0:	74 14                	je     1089f6 <coap_packet_parse+0x50>
		memset(options, 0, opt_num * sizeof(struct coap_option));
  1089e2:	0f b6 c9             	movzbl %cl,%ecx
  1089e5:	c1 e1 04             	shl    $0x4,%ecx
  1089e8:	51                   	push   %ecx
  1089e9:	6a 00                	push   $0x0
  1089eb:	ff 75 14             	pushl  0x14(%ebp)
  1089ee:	e8 68 34 00 00       	call   10be5b <memset>
  1089f3:	83 c4 0c             	add    $0xc,%esp
	cpkt->data = data;
  1089f6:	89 3b                	mov    %edi,(%ebx)
	cpkt->offset = 0U;
  1089f8:	66 c7 43 04 00 00    	movw   $0x0,0x4(%ebx)
	cpkt->max_len = len;
  1089fe:	66 89 73 06          	mov    %si,0x6(%ebx)
	cpkt->hdr_len = 0U;
  108a02:	c6 43 08 00          	movb   $0x0,0x8(%ebx)
	cpkt->opt_len = 0U;
  108a06:	c7 43 0a 00 00 00 00 	movl   $0x0,0xa(%ebx)
	tkl = cpkt->data[0] & 0x0f;
  108a0d:	8a 17                	mov    (%edi),%dl
  108a0f:	83 e2 0f             	and    $0xf,%edx
	if (tkl > 8) {
  108a12:	80 fa 08             	cmp    $0x8,%dl
  108a15:	77 bb                	ja     1089d2 <coap_packet_parse+0x2c>
	cpkt->hdr_len = BASIC_HEADER_SIZE + tkl;
  108a17:	83 c2 04             	add    $0x4,%edx
  108a1a:	88 53 08             	mov    %dl,0x8(%ebx)
	if (cpkt->hdr_len > len) {
  108a1d:	66 0f be d2          	movsbw %dl,%dx
  108a21:	66 39 f2             	cmp    %si,%dx
  108a24:	77 ac                	ja     1089d2 <coap_packet_parse+0x2c>
	cpkt->offset = cpkt->hdr_len;
  108a26:	66 89 53 04          	mov    %dx,0x4(%ebx)
		return 0;
  108a2a:	b8 00 00 00 00       	mov    $0x0,%eax
	if (cpkt->hdr_len == len) {
  108a2f:	74 61                	je     108a92 <coap_packet_parse+0xec>
	offset = cpkt->offset;
  108a31:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
	opt_len = 0U;
  108a35:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
	delta = 0U;
  108a3b:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	num = 0U;
  108a41:	31 f6                	xor    %esi,%esi
		option = num < opt_num ? &options[num++] : NULL;
  108a43:	89 f1                	mov    %esi,%ecx
  108a45:	31 c0                	xor    %eax,%eax
  108a47:	3a 4d eb             	cmp    -0x15(%ebp),%cl
  108a4a:	73 0a                	jae    108a56 <coap_packet_parse+0xb0>
  108a4c:	0f b6 c1             	movzbl %cl,%eax
  108a4f:	c1 e0 04             	shl    $0x4,%eax
  108a52:	46                   	inc    %esi
  108a53:	03 45 14             	add    0x14(%ebp),%eax
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
  108a56:	50                   	push   %eax
  108a57:	8d 45 ee             	lea    -0x12(%ebp),%eax
  108a5a:	50                   	push   %eax
  108a5b:	8d 45 f2             	lea    -0xe(%ebp),%eax
  108a5e:	50                   	push   %eax
  108a5f:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  108a62:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  108a66:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  108a6a:	50                   	push   %eax
  108a6b:	8b 03                	mov    (%ebx),%eax
  108a6d:	e8 95 f9 ff ff       	call   108407 <parse_option>
  108a72:	83 c4 10             	add    $0x10,%esp
		if (ret < 0) {
  108a75:	85 c0                	test   %eax,%eax
  108a77:	78 19                	js     108a92 <coap_packet_parse+0xec>
		} else if (ret == 0) {
  108a79:	75 c8                	jne    108a43 <coap_packet_parse+0x9d>
	cpkt->opt_len = opt_len;
  108a7b:	66 8b 55 ee          	mov    -0x12(%ebp),%dx
  108a7f:	66 89 53 0a          	mov    %dx,0xa(%ebx)
	cpkt->delta = delta;
  108a83:	66 8b 55 f2          	mov    -0xe(%ebp),%dx
  108a87:	66 89 53 0c          	mov    %dx,0xc(%ebx)
	cpkt->offset = offset;
  108a8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  108a8e:	66 89 53 04          	mov    %dx,0x4(%ebx)
}
  108a92:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108a95:	5b                   	pop    %ebx
  108a96:	5e                   	pop    %esi
  108a97:	5f                   	pop    %edi
  108a98:	5d                   	pop    %ebp
  108a99:	c3                   	ret    

00108a9a <coap_find_options>:
{
  108a9a:	55                   	push   %ebp
  108a9b:	89 e5                	mov    %esp,%ebp
  108a9d:	57                   	push   %edi
  108a9e:	56                   	push   %esi
  108a9f:	53                   	push   %ebx
	num = 0U;
  108aa0:	31 db                	xor    %ebx,%ebx
{
  108aa2:	83 ec 0c             	sub    $0xc,%esp
	opt_len = 0U;
  108aa5:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
{
  108aab:	8b 45 14             	mov    0x14(%ebp),%eax
  108aae:	8b 7d 0c             	mov    0xc(%ebp),%edi
  108ab1:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
	offset = cpkt->hdr_len;
  108ab5:	8b 45 08             	mov    0x8(%ebp),%eax
	delta = 0U;
  108ab8:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	offset = cpkt->hdr_len;
  108abe:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  108ac2:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	while (delta <= code && num < veclen) {
  108ac6:	0f b6 c3             	movzbl %bl,%eax
  108ac9:	66 3b 45 ea          	cmp    -0x16(%ebp),%ax
  108acd:	73 42                	jae    108b11 <coap_find_options+0x77>
				 &options[num]);
  108acf:	0f b6 f3             	movzbl %bl,%esi
  108ad2:	c1 e6 04             	shl    $0x4,%esi
		r = parse_option(cpkt->data, offset, &offset,
  108ad5:	8d 45 ee             	lea    -0x12(%ebp),%eax
  108ad8:	03 75 10             	add    0x10(%ebp),%esi
  108adb:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  108ade:	56                   	push   %esi
  108adf:	50                   	push   %eax
  108ae0:	8d 45 f2             	lea    -0xe(%ebp),%eax
  108ae3:	50                   	push   %eax
  108ae4:	8b 45 08             	mov    0x8(%ebp),%eax
  108ae7:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  108aeb:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  108aef:	50                   	push   %eax
  108af0:	8b 45 08             	mov    0x8(%ebp),%eax
  108af3:	8b 00                	mov    (%eax),%eax
  108af5:	e8 0d f9 ff ff       	call   108407 <parse_option>
  108afa:	83 c4 10             	add    $0x10,%esp
		if (r < 0) {
  108afd:	85 c0                	test   %eax,%eax
  108aff:	78 15                	js     108b16 <coap_find_options+0x7c>
		if (code == options[num].delta) {
  108b01:	66 39 3e             	cmp    %di,(%esi)
  108b04:	75 01                	jne    108b07 <coap_find_options+0x6d>
			num++;
  108b06:	43                   	inc    %ebx
		if (r == 0) {
  108b07:	85 c0                	test   %eax,%eax
  108b09:	74 06                	je     108b11 <coap_find_options+0x77>
	while (delta <= code && num < veclen) {
  108b0b:	66 39 7d f2          	cmp    %di,-0xe(%ebp)
  108b0f:	76 b5                	jbe    108ac6 <coap_find_options+0x2c>
	return num;
  108b11:	0f b6 c3             	movzbl %bl,%eax
  108b14:	eb 05                	jmp    108b1b <coap_find_options+0x81>
			return -EINVAL;
  108b16:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  108b1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108b1e:	5b                   	pop    %ebx
  108b1f:	5e                   	pop    %esi
  108b20:	5f                   	pop    %edi
  108b21:	5d                   	pop    %ebp
  108b22:	c3                   	ret    

00108b23 <coap_header_get_type>:
{
  108b23:	55                   	push   %ebp
		return 0;
  108b24:	31 c0                	xor    %eax,%eax
{
  108b26:	89 e5                	mov    %esp,%ebp
  108b28:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!cpkt || !cpkt->data) {
  108b2b:	85 d2                	test   %edx,%edx
  108b2d:	74 0f                	je     108b3e <coap_header_get_type+0x1b>
  108b2f:	8b 12                	mov    (%edx),%edx
  108b31:	85 d2                	test   %edx,%edx
  108b33:	74 09                	je     108b3e <coap_header_get_type+0x1b>
	return (cpkt->data[0] & 0x30) >> 4;
  108b35:	0f b6 02             	movzbl (%edx),%eax
  108b38:	c1 f8 04             	sar    $0x4,%eax
  108b3b:	83 e0 03             	and    $0x3,%eax
}
  108b3e:	5d                   	pop    %ebp
  108b3f:	c3                   	ret    

00108b40 <coap_header_get_token>:
{
  108b40:	55                   	push   %ebp
  108b41:	89 e5                	mov    %esp,%ebp
  108b43:	53                   	push   %ebx
		return 0;
  108b44:	31 db                	xor    %ebx,%ebx
{
  108b46:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!cpkt || !cpkt->data) {
  108b49:	85 c0                	test   %eax,%eax
  108b4b:	74 20                	je     108b6d <coap_header_get_token+0x2d>
  108b4d:	8b 00                	mov    (%eax),%eax
  108b4f:	85 c0                	test   %eax,%eax
  108b51:	74 1a                	je     108b6d <coap_header_get_token+0x2d>
	if (tkl) {
  108b53:	8a 18                	mov    (%eax),%bl
  108b55:	80 e3 0f             	and    $0xf,%bl
  108b58:	74 13                	je     108b6d <coap_header_get_token+0x2d>
		memcpy(token, cpkt->data + BASIC_HEADER_SIZE, tkl);
  108b5a:	0f b6 d3             	movzbl %bl,%edx
  108b5d:	52                   	push   %edx
  108b5e:	83 c0 04             	add    $0x4,%eax
  108b61:	50                   	push   %eax
  108b62:	ff 75 0c             	pushl  0xc(%ebp)
  108b65:	e8 82 32 00 00       	call   10bdec <memcpy>
  108b6a:	83 c4 0c             	add    $0xc,%esp
}
  108b6d:	88 d8                	mov    %bl,%al
  108b6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  108b72:	c9                   	leave  
  108b73:	c3                   	ret    

00108b74 <coap_header_get_code>:
{
  108b74:	55                   	push   %ebp
		return 0;
  108b75:	31 c0                	xor    %eax,%eax
{
  108b77:	89 e5                	mov    %esp,%ebp
  108b79:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!cpkt || !cpkt->data) {
  108b7c:	85 d2                	test   %edx,%edx
  108b7e:	74 41                	je     108bc1 <coap_header_get_code+0x4d>
  108b80:	8b 12                	mov    (%edx),%edx
  108b82:	85 d2                	test   %edx,%edx
  108b84:	74 3b                	je     108bc1 <coap_header_get_code+0x4d>
	return cpkt->data[1];
  108b86:	8a 42 01             	mov    0x1(%edx),%al
	switch (code) {
  108b89:	3c a5                	cmp    $0xa5,%al
  108b8b:	77 32                	ja     108bbf <coap_header_get_code+0x4b>
  108b8d:	3c 87                	cmp    $0x87,%al
  108b8f:	77 12                	ja     108ba3 <coap_header_get_code+0x2f>
  108b91:	3c 5f                	cmp    $0x5f,%al
  108b93:	74 2c                	je     108bc1 <coap_header_get_code+0x4d>
  108b95:	77 20                	ja     108bb7 <coap_header_get_code+0x43>
  108b97:	3c 04                	cmp    $0x4,%al
  108b99:	76 26                	jbe    108bc1 <coap_header_get_code+0x4d>
  108b9b:	8d 50 c0             	lea    -0x40(%eax),%edx
  108b9e:	80 fa 05             	cmp    $0x5,%dl
  108ba1:	eb 1a                	jmp    108bbd <coap_header_get_code+0x49>
  108ba3:	8d 48 78             	lea    0x78(%eax),%ecx
  108ba6:	ba 01 00 00 00       	mov    $0x1,%edx
  108bab:	d3 e2                	shl    %cl,%edx
  108bad:	81 e2 b1 00 00 3f    	and    $0x3f0000b1,%edx
  108bb3:	74 0a                	je     108bbf <coap_header_get_code+0x4b>
  108bb5:	eb 0a                	jmp    108bc1 <coap_header_get_code+0x4d>
  108bb7:	8d 50 80             	lea    -0x80(%eax),%edx
  108bba:	80 fa 06             	cmp    $0x6,%dl
  108bbd:	76 02                	jbe    108bc1 <coap_header_get_code+0x4d>
		return COAP_CODE_EMPTY;
  108bbf:	31 c0                	xor    %eax,%eax
}
  108bc1:	5d                   	pop    %ebp
  108bc2:	c3                   	ret    

00108bc3 <is_request>:
{
  108bc3:	55                   	push   %ebp
  108bc4:	89 e5                	mov    %esp,%ebp
	uint8_t code = coap_header_get_code(cpkt);
  108bc6:	50                   	push   %eax
  108bc7:	e8 a8 ff ff ff       	call   108b74 <coap_header_get_code>
  108bcc:	5a                   	pop    %edx
	return !(code & ~COAP_REQUEST_MASK);
  108bcd:	a8 f8                	test   $0xf8,%al
}
  108bcf:	c9                   	leave  
	return !(code & ~COAP_REQUEST_MASK);
  108bd0:	0f 94 c0             	sete   %al
}
  108bd3:	c3                   	ret    

00108bd4 <coap_header_get_id>:
{
  108bd4:	55                   	push   %ebp
		return 0;
  108bd5:	31 c0                	xor    %eax,%eax
{
  108bd7:	89 e5                	mov    %esp,%ebp
  108bd9:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!cpkt || !cpkt->data) {
  108bdc:	85 d2                	test   %edx,%edx
  108bde:	74 15                	je     108bf5 <coap_header_get_id+0x21>
  108be0:	8b 0a                	mov    (%edx),%ecx
  108be2:	85 c9                	test   %ecx,%ecx
  108be4:	74 0f                	je     108bf5 <coap_header_get_id+0x21>
	return (cpkt->data[2] << 8) | cpkt->data[3];
  108be6:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  108bea:	c1 e0 08             	shl    $0x8,%eax
  108bed:	89 c2                	mov    %eax,%edx
  108bef:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
  108bf3:	09 d0                	or     %edx,%eax
}
  108bf5:	5d                   	pop    %ebp
  108bf6:	c3                   	ret    

00108bf7 <coap_packet_get_payload>:
{
  108bf7:	55                   	push   %ebp
  108bf8:	89 e5                	mov    %esp,%ebp
  108bfa:	56                   	push   %esi
  108bfb:	53                   	push   %ebx
  108bfc:	8b 55 08             	mov    0x8(%ebp),%edx
  108bff:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!cpkt || !len) {
  108c02:	85 d2                	test   %edx,%edx
  108c04:	74 04                	je     108c0a <coap_packet_get_payload+0x13>
  108c06:	85 db                	test   %ebx,%ebx
  108c08:	75 04                	jne    108c0e <coap_packet_get_payload+0x17>
		return NULL;
  108c0a:	31 c0                	xor    %eax,%eax
  108c0c:	eb 29                	jmp    108c37 <coap_packet_get_payload+0x40>
	payload_len = cpkt->max_len - cpkt->hdr_len - cpkt->opt_len;
  108c0e:	0f b6 4a 08          	movzbl 0x8(%edx),%ecx
  108c12:	0f b7 72 0a          	movzwl 0xa(%edx),%esi
  108c16:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  108c1a:	01 f1                	add    %esi,%ecx
  108c1c:	29 c8                	sub    %ecx,%eax
	if (payload_len > 0) {
  108c1e:	89 c1                	mov    %eax,%ecx
  108c20:	79 02                	jns    108c24 <coap_packet_get_payload+0x2d>
  108c22:	31 c9                	xor    %ecx,%ecx
  108c24:	66 89 0b             	mov    %cx,(%ebx)
	return !(*len) ? NULL :
  108c27:	85 c0                	test   %eax,%eax
  108c29:	7e df                	jle    108c0a <coap_packet_get_payload+0x13>
		cpkt->data + cpkt->hdr_len + cpkt->opt_len;
  108c2b:	0f b6 42 08          	movzbl 0x8(%edx),%eax
  108c2f:	0f b7 4a 0a          	movzwl 0xa(%edx),%ecx
  108c33:	01 c8                	add    %ecx,%eax
	return !(*len) ? NULL :
  108c35:	03 02                	add    (%edx),%eax
}
  108c37:	5b                   	pop    %ebx
  108c38:	5e                   	pop    %esi
  108c39:	5d                   	pop    %ebp
  108c3a:	c3                   	ret    

00108c3b <coap_block_transfer_init>:
{
  108c3b:	55                   	push   %ebp
  108c3c:	89 e5                	mov    %esp,%ebp
  108c3e:	8b 45 08             	mov    0x8(%ebp),%eax
	ctx->block_size = block_size;
  108c41:	8b 55 0c             	mov    0xc(%ebp),%edx
  108c44:	89 50 08             	mov    %edx,0x8(%eax)
	ctx->total_size = total_size;
  108c47:	8b 55 10             	mov    0x10(%ebp),%edx
  108c4a:	89 10                	mov    %edx,(%eax)
	ctx->current = 0;
  108c4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
  108c53:	5d                   	pop    %ebp
  108c54:	31 c0                	xor    %eax,%eax
  108c56:	c3                   	ret    

00108c57 <coap_append_block1_option>:
{
  108c57:	55                   	push   %ebp
  108c58:	89 e5                	mov    %esp,%ebp
  108c5a:	57                   	push   %edi
  108c5b:	56                   	push   %esi
	if (is_request(cpkt)) {
  108c5c:	8b 45 08             	mov    0x8(%ebp),%eax
{
  108c5f:	53                   	push   %ebx
	if (is_request(cpkt)) {
  108c60:	e8 5e ff ff ff       	call   108bc3 <is_request>
{
  108c65:	8b 75 0c             	mov    0xc(%ebp),%esi
	uint16_t bytes = coap_block_size_to_bytes(ctx->block_size);
  108c68:	8b 7e 08             	mov    0x8(%esi),%edi
	if (is_request(cpkt)) {
  108c6b:	88 c2                	mov    %al,%dl
  108c6d:	89 fb                	mov    %edi,%ebx
  108c6f:	8b 46 04             	mov    0x4(%esi),%eax
 * @return The size in bytes that the block_size represents
 */
static inline uint16_t coap_block_size_to_bytes(
	enum coap_block_size block_size)
{
	return (1 << (block_size + 4));
  108c72:	8d 4f 04             	lea    0x4(%edi),%ecx
  108c75:	bf 01 00 00 00       	mov    $0x1,%edi
  108c7a:	d3 e7                	shl    %cl,%edi
  108c7c:	83 e3 07             	and    $0x7,%ebx
  108c7f:	84 d2                	test   %dl,%dl
  108c81:	0f b7 cf             	movzwl %di,%ecx
  108c84:	74 17                	je     108c9d <coap_append_block1_option+0x46>
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
  108c86:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  108c89:	3b 16                	cmp    (%esi),%edx
  108c8b:	19 f6                	sbb    %esi,%esi
		SET_NUM(val, ctx->current / bytes);
  108c8d:	31 d2                	xor    %edx,%edx
  108c8f:	f7 f1                	div    %ecx
  108c91:	c1 e0 04             	shl    $0x4,%eax
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
  108c94:	83 e6 08             	and    $0x8,%esi
		SET_NUM(val, ctx->current / bytes);
  108c97:	09 c3                	or     %eax,%ebx
  108c99:	09 f3                	or     %esi,%ebx
  108c9b:	eb 09                	jmp    108ca6 <coap_append_block1_option+0x4f>
		SET_NUM(val, ctx->current / bytes);
  108c9d:	31 d2                	xor    %edx,%edx
  108c9f:	f7 f1                	div    %ecx
  108ca1:	c1 e0 04             	shl    $0x4,%eax
  108ca4:	09 c3                	or     %eax,%ebx
	r = coap_append_option_int(cpkt, COAP_OPTION_BLOCK1, val);
  108ca6:	53                   	push   %ebx
  108ca7:	6a 1b                	push   $0x1b
  108ca9:	ff 75 08             	pushl  0x8(%ebp)
  108cac:	e8 01 fc ff ff       	call   1088b2 <coap_append_option_int>
  108cb1:	83 c4 0c             	add    $0xc,%esp
}
  108cb4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108cb7:	5b                   	pop    %ebx
  108cb8:	5e                   	pop    %esi
  108cb9:	5f                   	pop    %edi
  108cba:	5d                   	pop    %ebp
  108cbb:	c3                   	ret    

00108cbc <coap_append_block2_option>:
{
  108cbc:	55                   	push   %ebp
  108cbd:	89 e5                	mov    %esp,%ebp
  108cbf:	57                   	push   %edi
  108cc0:	56                   	push   %esi
	if (is_request(cpkt)) {
  108cc1:	8b 45 08             	mov    0x8(%ebp),%eax
{
  108cc4:	53                   	push   %ebx
	if (is_request(cpkt)) {
  108cc5:	e8 f9 fe ff ff       	call   108bc3 <is_request>
{
  108cca:	8b 75 0c             	mov    0xc(%ebp),%esi
	uint16_t bytes = coap_block_size_to_bytes(ctx->block_size);
  108ccd:	8b 7e 08             	mov    0x8(%esi),%edi
	if (is_request(cpkt)) {
  108cd0:	88 c2                	mov    %al,%dl
  108cd2:	89 fb                	mov    %edi,%ebx
  108cd4:	8b 46 04             	mov    0x4(%esi),%eax
  108cd7:	8d 4f 04             	lea    0x4(%edi),%ecx
  108cda:	bf 01 00 00 00       	mov    $0x1,%edi
  108cdf:	d3 e7                	shl    %cl,%edi
  108ce1:	83 e3 07             	and    $0x7,%ebx
  108ce4:	84 d2                	test   %dl,%dl
  108ce6:	0f b7 cf             	movzwl %di,%ecx
  108ce9:	74 09                	je     108cf4 <coap_append_block2_option+0x38>
		SET_NUM(val, ctx->current / bytes);
  108ceb:	31 d2                	xor    %edx,%edx
  108ced:	f7 f1                	div    %ecx
  108cef:	c1 e0 04             	shl    $0x4,%eax
  108cf2:	eb 13                	jmp    108d07 <coap_append_block2_option+0x4b>
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
  108cf4:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  108cf7:	3b 16                	cmp    (%esi),%edx
  108cf9:	19 f6                	sbb    %esi,%esi
		SET_NUM(val, ctx->current / bytes);
  108cfb:	31 d2                	xor    %edx,%edx
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
  108cfd:	83 e6 08             	and    $0x8,%esi
		SET_NUM(val, ctx->current / bytes);
  108d00:	f7 f1                	div    %ecx
  108d02:	c1 e0 04             	shl    $0x4,%eax
		SET_MORE(val, ctx->current + bytes < ctx->total_size);
  108d05:	09 f3                	or     %esi,%ebx
		SET_NUM(val, ctx->current / bytes);
  108d07:	09 c3                	or     %eax,%ebx
	r = coap_append_option_int(cpkt, COAP_OPTION_BLOCK2, val);
  108d09:	53                   	push   %ebx
  108d0a:	6a 17                	push   $0x17
  108d0c:	ff 75 08             	pushl  0x8(%ebp)
  108d0f:	e8 9e fb ff ff       	call   1088b2 <coap_append_option_int>
  108d14:	83 c4 0c             	add    $0xc,%esp
}
  108d17:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108d1a:	5b                   	pop    %ebx
  108d1b:	5e                   	pop    %esi
  108d1c:	5f                   	pop    %edi
  108d1d:	5d                   	pop    %ebp
  108d1e:	c3                   	ret    

00108d1f <coap_get_option_int>:
{
  108d1f:	55                   	push   %ebp
	struct coap_option option = {};
  108d20:	31 c0                	xor    %eax,%eax
{
  108d22:	89 e5                	mov    %esp,%ebp
  108d24:	57                   	push   %edi
  108d25:	83 ec 10             	sub    $0x10,%esp
	struct coap_option option = {};
  108d28:	b9 04 00 00 00       	mov    $0x4,%ecx
  108d2d:	8d 7d ec             	lea    -0x14(%ebp),%edi
  108d30:	f3 ab                	rep stos %eax,%es:(%edi)
	count = coap_find_options(cpkt, code, &option, count);
  108d32:	6a 01                	push   $0x1
  108d34:	8d 7d ec             	lea    -0x14(%ebp),%edi
  108d37:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  108d3b:	57                   	push   %edi
  108d3c:	50                   	push   %eax
  108d3d:	ff 75 08             	pushl  0x8(%ebp)
  108d40:	e8 55 fd ff ff       	call   108a9a <coap_find_options>
  108d45:	83 c4 10             	add    $0x10,%esp
  108d48:	89 c2                	mov    %eax,%edx
	if (count <= 0) {
  108d4a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  108d4f:	85 d2                	test   %edx,%edx
  108d51:	7e 07                	jle    108d5a <coap_get_option_int+0x3b>
	val = coap_option_value_to_int(&option);
  108d53:	57                   	push   %edi
  108d54:	e8 c5 fb ff ff       	call   10891e <coap_option_value_to_int>
  108d59:	5a                   	pop    %edx
}
  108d5a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  108d5d:	c9                   	leave  
  108d5e:	c3                   	ret    

00108d5f <coap_update_from_block>:
	return 0;
}

int coap_update_from_block(const struct coap_packet *cpkt,
			   struct coap_block_context *ctx)
{
  108d5f:	55                   	push   %ebp
  108d60:	89 e5                	mov    %esp,%ebp
  108d62:	57                   	push   %edi
  108d63:	56                   	push   %esi
  108d64:	53                   	push   %ebx
  108d65:	83 ec 0c             	sub    $0xc,%esp
  108d68:	8b 7d 08             	mov    0x8(%ebp),%edi
  108d6b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r, block1, block2, size1, size2;

	block1 = coap_get_option_int(cpkt, COAP_OPTION_BLOCK1);
  108d6e:	6a 1b                	push   $0x1b
  108d70:	57                   	push   %edi
  108d71:	e8 a9 ff ff ff       	call   108d1f <coap_get_option_int>
  108d76:	5a                   	pop    %edx
  108d77:	89 45 ec             	mov    %eax,-0x14(%ebp)
  108d7a:	59                   	pop    %ecx
	block2 = coap_get_option_int(cpkt, COAP_OPTION_BLOCK2);
  108d7b:	6a 17                	push   $0x17
  108d7d:	57                   	push   %edi
  108d7e:	e8 9c ff ff ff       	call   108d1f <coap_get_option_int>
  108d83:	5e                   	pop    %esi
  108d84:	89 45 f0             	mov    %eax,-0x10(%ebp)
  108d87:	5a                   	pop    %edx
	size1 = coap_get_option_int(cpkt, COAP_OPTION_SIZE1);
  108d88:	6a 3c                	push   $0x3c
  108d8a:	57                   	push   %edi
  108d8b:	e8 8f ff ff ff       	call   108d1f <coap_get_option_int>
  108d90:	59                   	pop    %ecx
  108d91:	5e                   	pop    %esi
  108d92:	89 c6                	mov    %eax,%esi
	size2 = coap_get_option_int(cpkt, COAP_OPTION_SIZE2);
  108d94:	6a 1c                	push   $0x1c
  108d96:	57                   	push   %edi
  108d97:	e8 83 ff ff ff       	call   108d1f <coap_get_option_int>
  108d9c:	5a                   	pop    %edx

	size1 = size1 == -ENOENT ? 0 : size1;
  108d9d:	83 fe fe             	cmp    $0xfffffffe,%esi
	size2 = coap_get_option_int(cpkt, COAP_OPTION_SIZE2);
  108da0:	59                   	pop    %ecx
  108da1:	89 c2                	mov    %eax,%edx
	size1 = size1 == -ENOENT ? 0 : size1;
  108da3:	75 02                	jne    108da7 <coap_update_from_block+0x48>
  108da5:	31 f6                	xor    %esi,%esi
	size2 = size2 == -ENOENT ? 0 : size2;
  108da7:	83 fa fe             	cmp    $0xfffffffe,%edx
  108daa:	75 02                	jne    108dae <coap_update_from_block+0x4f>
  108dac:	31 d2                	xor    %edx,%edx

	if (is_request(cpkt)) {
  108dae:	89 f8                	mov    %edi,%eax
  108db0:	89 55 e8             	mov    %edx,-0x18(%ebp)
  108db3:	e8 0b fe ff ff       	call   108bc3 <is_request>
  108db8:	8b 55 e8             	mov    -0x18(%ebp),%edx
  108dbb:	84 c0                	test   %al,%al
  108dbd:	74 3f                	je     108dfe <coap_update_from_block+0x9f>
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
  108dbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  108dc2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  108dc5:	c1 fa 04             	sar    $0x4,%edx
  108dc8:	83 e0 07             	and    $0x7,%eax
  108dcb:	89 d7                	mov    %edx,%edi
  108dcd:	8d 48 04             	lea    0x4(%eax),%ecx
  108dd0:	d3 e7                	shl    %cl,%edi
  108dd2:	89 f9                	mov    %edi,%ecx
	if (block == -ENOENT) {
  108dd4:	83 7d f0 fe          	cmpl   $0xfffffffe,-0x10(%ebp)
  108dd8:	74 1d                	je     108df7 <coap_update_from_block+0x98>
	if (GET_MORE(block)) {
  108dda:	f6 45 f0 08          	testb  $0x8,-0x10(%ebp)
  108dde:	75 57                	jne    108e37 <coap_update_from_block+0xd8>
	if (GET_NUM(block) > 0 && GET_BLOCK_SIZE(block) != ctx->block_size) {
  108de0:	8b 7b 08             	mov    0x8(%ebx),%edi
  108de3:	85 d2                	test   %edx,%edx
  108de5:	7e 04                	jle    108deb <coap_update_from_block+0x8c>
  108de7:	39 f8                	cmp    %edi,%eax
  108de9:	75 4c                	jne    108e37 <coap_update_from_block+0xd8>
	ctx->current = new_current;
  108deb:	89 4b 04             	mov    %ecx,0x4(%ebx)
	ctx->block_size = MIN(GET_BLOCK_SIZE(block), ctx->block_size);
  108dee:	39 f8                	cmp    %edi,%eax
  108df0:	76 02                	jbe    108df4 <coap_update_from_block+0x95>
  108df2:	89 f8                	mov    %edi,%eax
  108df4:	89 43 08             	mov    %eax,0x8(%ebx)
		r = update_control_block2(ctx, block2, size2);
		if (r) {
			return r;
		}

		return update_descriptive_block(ctx, block1, size1);
  108df7:	89 f1                	mov    %esi,%ecx
  108df9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  108dfc:	eb 2b                	jmp    108e29 <coap_update_from_block+0xca>
	size_t new_current = GET_NUM(block) << (GET_BLOCK_SIZE(block) + 4);
  108dfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  108e01:	8b 7d ec             	mov    -0x14(%ebp),%edi
  108e04:	c1 ff 04             	sar    $0x4,%edi
  108e07:	83 e0 07             	and    $0x7,%eax
  108e0a:	8d 48 04             	lea    0x4(%eax),%ecx
  108e0d:	d3 e7                	shl    %cl,%edi
	if (block == -ENOENT) {
  108e0f:	83 7d ec fe          	cmpl   $0xfffffffe,-0x14(%ebp)
  108e13:	74 0f                	je     108e24 <coap_update_from_block+0xc5>
	if (new_current != ctx->current) {
  108e15:	3b 7b 04             	cmp    0x4(%ebx),%edi
  108e18:	75 1d                	jne    108e37 <coap_update_from_block+0xd8>
	if (GET_BLOCK_SIZE(block) > ctx->block_size) {
  108e1a:	3b 43 08             	cmp    0x8(%ebx),%eax
  108e1d:	77 18                	ja     108e37 <coap_update_from_block+0xd8>
	ctx->block_size = GET_BLOCK_SIZE(block);
  108e1f:	89 43 08             	mov    %eax,0x8(%ebx)
	ctx->total_size = size;
  108e22:	89 33                	mov    %esi,(%ebx)
	r = update_control_block1(ctx, block1, size1);
	if (r) {
		return r;
	}

	return update_descriptive_block(ctx, block2, size2);
  108e24:	89 d1                	mov    %edx,%ecx
  108e26:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
  108e29:	8d 65 f4             	lea    -0xc(%ebp),%esp
	return update_descriptive_block(ctx, block2, size2);
  108e2c:	89 d8                	mov    %ebx,%eax
}
  108e2e:	5b                   	pop    %ebx
  108e2f:	5e                   	pop    %esi
  108e30:	5f                   	pop    %edi
  108e31:	5d                   	pop    %ebp
	return update_descriptive_block(ctx, block2, size2);
  108e32:	e9 0e f5 ff ff       	jmp    108345 <update_descriptive_block>
}
  108e37:	8d 65 f4             	lea    -0xc(%ebp),%esp
  108e3a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  108e3f:	5b                   	pop    %ebx
  108e40:	5e                   	pop    %esi
  108e41:	5f                   	pop    %edi
  108e42:	5d                   	pop    %ebp
  108e43:	c3                   	ret    

00108e44 <coap_next_block>:

size_t coap_next_block(const struct coap_packet *cpkt,
		       struct coap_block_context *ctx)
{
  108e44:	55                   	push   %ebp
  108e45:	89 e5                	mov    %esp,%ebp
  108e47:	56                   	push   %esi
  108e48:	53                   	push   %ebx
  108e49:	8b 75 08             	mov    0x8(%ebp),%esi
  108e4c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int block;

	if (is_request(cpkt)) {
  108e4f:	89 f0                	mov    %esi,%eax
  108e51:	e8 6d fd ff ff       	call   108bc3 <is_request>
  108e56:	84 c0                	test   %al,%al
  108e58:	74 04                	je     108e5e <coap_next_block+0x1a>
		block = coap_get_option_int(cpkt, COAP_OPTION_BLOCK1);
  108e5a:	6a 1b                	push   $0x1b
  108e5c:	eb 02                	jmp    108e60 <coap_next_block+0x1c>
	} else {
		block = coap_get_option_int(cpkt, COAP_OPTION_BLOCK2);
  108e5e:	6a 17                	push   $0x17
  108e60:	56                   	push   %esi
  108e61:	e8 b9 fe ff ff       	call   108d1f <coap_get_option_int>
  108e66:	5a                   	pop    %edx
  108e67:	89 c2                	mov    %eax,%edx
  108e69:	59                   	pop    %ecx
	}

	if (!GET_MORE(block)) {
		return 0;
  108e6a:	31 c0                	xor    %eax,%eax
	if (!GET_MORE(block)) {
  108e6c:	80 e2 08             	and    $0x8,%dl
  108e6f:	74 16                	je     108e87 <coap_next_block+0x43>
  108e71:	8b 43 08             	mov    0x8(%ebx),%eax
  108e74:	8d 48 04             	lea    0x4(%eax),%ecx
  108e77:	b8 01 00 00 00       	mov    $0x1,%eax
  108e7c:	d3 e0                	shl    %cl,%eax
	}

	ctx->current += coap_block_size_to_bytes(ctx->block_size);
  108e7e:	0f b7 c0             	movzwl %ax,%eax
  108e81:	03 43 04             	add    0x4(%ebx),%eax
  108e84:	89 43 04             	mov    %eax,0x4(%ebx)

	return ctx->current;
}
  108e87:	8d 65 f8             	lea    -0x8(%ebp),%esp
  108e8a:	5b                   	pop    %ebx
  108e8b:	5e                   	pop    %esi
  108e8c:	5d                   	pop    %ebp
  108e8d:	c3                   	ret    

00108e8e <coap_pending_init>:

int coap_pending_init(struct coap_pending *pending,
		      const struct coap_packet *request,
		      const struct sockaddr *addr)
{
  108e8e:	55                   	push   %ebp
  108e8f:	89 e5                	mov    %esp,%ebp
  108e91:	56                   	push   %esi
  108e92:	53                   	push   %ebx
	memset(pending, 0, sizeof(*pending));
  108e93:	6a 1c                	push   $0x1c
{
  108e95:	8b 5d 08             	mov    0x8(%ebp),%ebx
	memset(pending, 0, sizeof(*pending));
  108e98:	6a 00                	push   $0x0
{
  108e9a:	8b 75 0c             	mov    0xc(%ebp),%esi
	memset(pending, 0, sizeof(*pending));
  108e9d:	53                   	push   %ebx
  108e9e:	e8 b8 2f 00 00       	call   10be5b <memset>
  108ea3:	83 c4 0c             	add    $0xc,%esp

	pending->id = coap_header_get_id(request);
  108ea6:	56                   	push   %esi
  108ea7:	e8 28 fd ff ff       	call   108bd4 <coap_header_get_id>
  108eac:	66 89 43 10          	mov    %ax,0x10(%ebx)

	memcpy(&pending->addr, addr, sizeof(*addr));
  108eb0:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  108eb7:	ff 75 10             	pushl  0x10(%ebp)
  108eba:	53                   	push   %ebx
  108ebb:	e8 2c 2f 00 00       	call   10bdec <memcpy>

	pending->data = request->data;
  108ec0:	8b 06                	mov    (%esi),%eax
	memcpy(&pending->addr, addr, sizeof(*addr));
  108ec2:	83 c4 0c             	add    $0xc,%esp
	pending->data = request->data;
  108ec5:	89 43 14             	mov    %eax,0x14(%ebx)
	pending->len = request->offset;
  108ec8:	8b 46 04             	mov    0x4(%esi),%eax
  108ecb:	66 89 43 18          	mov    %ax,0x18(%ebx)
	return z_impl_k_uptime_ticks();
  108ecf:	e8 b3 94 01 00       	call   122387 <z_impl_k_uptime_ticks>
  108ed4:	ba 0a 00 00 00       	mov    $0xa,%edx
  108ed9:	f7 e2                	mul    %edx
  108edb:	89 43 08             	mov    %eax,0x8(%ebx)
	pending->t0 = k_uptime_get_32();

	return 0;
}
  108ede:	8d 65 f8             	lea    -0x8(%ebp),%esp
  108ee1:	31 c0                	xor    %eax,%eax
  108ee3:	5b                   	pop    %ebx
  108ee4:	5e                   	pop    %esi
  108ee5:	5d                   	pop    %ebp
  108ee6:	c3                   	ret    

00108ee7 <coap_pending_next_unused>:

struct coap_pending *coap_pending_next_unused(
	struct coap_pending *pendings, size_t len)
{
  108ee7:	55                   	push   %ebp
	struct coap_pending *p;
	size_t i;

	for (i = 0, p = pendings; i < len; i++, p++) {
  108ee8:	31 d2                	xor    %edx,%edx
{
  108eea:	89 e5                	mov    %esp,%ebp
	for (i = 0, p = pendings; i < len; i++, p++) {
  108eec:	8b 45 08             	mov    0x8(%ebp),%eax
  108eef:	3b 55 0c             	cmp    0xc(%ebp),%edx
  108ef2:	74 0c                	je     108f00 <coap_pending_next_unused+0x19>
		if (p->timeout == 0) {
  108ef4:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  108ef8:	74 08                	je     108f02 <coap_pending_next_unused+0x1b>
	for (i = 0, p = pendings; i < len; i++, p++) {
  108efa:	42                   	inc    %edx
  108efb:	83 c0 1c             	add    $0x1c,%eax
  108efe:	eb ef                	jmp    108eef <coap_pending_next_unused+0x8>
			return p;
		}
	}

	return NULL;
  108f00:	31 c0                	xor    %eax,%eax
}
  108f02:	5d                   	pop    %ebp
  108f03:	c3                   	ret    

00108f04 <coap_reply_next_unused>:

struct coap_reply *coap_reply_next_unused(
	struct coap_reply *replies, size_t len)
{
  108f04:	55                   	push   %ebp
	struct coap_reply *r;
	size_t i;

	for (i = 0, r = replies; i < len; i++, r++) {
  108f05:	31 d2                	xor    %edx,%edx
{
  108f07:	89 e5                	mov    %esp,%ebp
	for (i = 0, r = replies; i < len; i++, r++) {
  108f09:	8b 45 08             	mov    0x8(%ebp),%eax
  108f0c:	3b 55 0c             	cmp    0xc(%ebp),%edx
  108f0f:	74 0b                	je     108f1c <coap_reply_next_unused+0x18>
		if (!r->reply) {
  108f11:	83 38 00             	cmpl   $0x0,(%eax)
  108f14:	74 08                	je     108f1e <coap_reply_next_unused+0x1a>
	for (i = 0, r = replies; i < len; i++, r++) {
  108f16:	42                   	inc    %edx
  108f17:	83 c0 18             	add    $0x18,%eax
  108f1a:	eb f0                	jmp    108f0c <coap_reply_next_unused+0x8>
			return r;
		}
	}

	return NULL;
  108f1c:	31 c0                	xor    %eax,%eax
}
  108f1e:	5d                   	pop    %ebp
  108f1f:	c3                   	ret    

00108f20 <coap_pending_received>:
}

struct coap_pending *coap_pending_received(
	const struct coap_packet *response,
	struct coap_pending *pendings, size_t len)
{
  108f20:	55                   	push   %ebp
  108f21:	89 e5                	mov    %esp,%ebp
	struct coap_pending *p;
	uint16_t resp_id = coap_header_get_id(response);
  108f23:	ff 75 08             	pushl  0x8(%ebp)
  108f26:	e8 a9 fc ff ff       	call   108bd4 <coap_header_get_id>
  108f2b:	5a                   	pop    %edx
  108f2c:	89 c1                	mov    %eax,%ecx
	size_t i;

	for (i = 0, p = pendings; i < len; i++, p++) {
  108f2e:	31 d2                	xor    %edx,%edx
  108f30:	8b 45 0c             	mov    0xc(%ebp),%eax
  108f33:	3b 55 10             	cmp    0x10(%ebp),%edx
  108f36:	74 12                	je     108f4a <coap_pending_received+0x2a>
		if (!p->timeout) {
  108f38:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  108f3c:	74 06                	je     108f44 <coap_pending_received+0x24>
			continue;
		}

		if (resp_id != p->id) {
  108f3e:	66 39 48 10          	cmp    %cx,0x10(%eax)
  108f42:	74 08                	je     108f4c <coap_pending_received+0x2c>
	for (i = 0, p = pendings; i < len; i++, p++) {
  108f44:	42                   	inc    %edx
  108f45:	83 c0 1c             	add    $0x1c,%eax
  108f48:	eb e9                	jmp    108f33 <coap_pending_received+0x13>
		}

		return p;
	}

	return NULL;
  108f4a:	31 c0                	xor    %eax,%eax
}
  108f4c:	c9                   	leave  
  108f4d:	c3                   	ret    

00108f4e <coap_pending_next_to_expire>:

struct coap_pending *coap_pending_next_to_expire(
	struct coap_pending *pendings, size_t len)
{
  108f4e:	55                   	push   %ebp
	struct coap_pending *p, *found = NULL;
  108f4f:	31 d2                	xor    %edx,%edx
{
  108f51:	89 e5                	mov    %esp,%ebp
  108f53:	57                   	push   %edi
  108f54:	56                   	push   %esi
  108f55:	53                   	push   %ebx
  108f56:	8b 45 08             	mov    0x8(%ebp),%eax
	size_t i;
	uint32_t expiry, min_expiry;

	for (i = 0, p = pendings; i < len; i++, p++) {
  108f59:	31 db                	xor    %ebx,%ebx
  108f5b:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  108f5e:	74 24                	je     108f84 <coap_pending_next_to_expire+0x36>
		if (!p->timeout) {
  108f60:	8b 78 0c             	mov    0xc(%eax),%edi
  108f63:	89 f1                	mov    %esi,%ecx
  108f65:	85 ff                	test   %edi,%edi
  108f67:	74 13                	je     108f7c <coap_pending_next_to_expire+0x2e>
			continue;
		}

		expiry = p->t0 + p->timeout;
  108f69:	03 78 08             	add    0x8(%eax),%edi

		if (!found || (int32_t)(expiry - min_expiry) < 0) {
  108f6c:	85 d2                	test   %edx,%edx
		expiry = p->t0 + p->timeout;
  108f6e:	89 f9                	mov    %edi,%ecx
		if (!found || (int32_t)(expiry - min_expiry) < 0) {
  108f70:	74 08                	je     108f7a <coap_pending_next_to_expire+0x2c>
  108f72:	39 f7                	cmp    %esi,%edi
  108f74:	78 04                	js     108f7a <coap_pending_next_to_expire+0x2c>
  108f76:	89 f1                	mov    %esi,%ecx
  108f78:	eb 02                	jmp    108f7c <coap_pending_next_to_expire+0x2e>
  108f7a:	89 c2                	mov    %eax,%edx
	for (i = 0, p = pendings; i < len; i++, p++) {
  108f7c:	43                   	inc    %ebx
  108f7d:	83 c0 1c             	add    $0x1c,%eax
  108f80:	89 ce                	mov    %ecx,%esi
  108f82:	eb d7                	jmp    108f5b <coap_pending_next_to_expire+0xd>
			found = p;
		}
	}

	return found;
}
  108f84:	5b                   	pop    %ebx
  108f85:	89 d0                	mov    %edx,%eax
  108f87:	5e                   	pop    %esi
  108f88:	5f                   	pop    %edi
  108f89:	5d                   	pop    %ebp
  108f8a:	c3                   	ret    

00108f8b <coap_pending_cycle>:
	/* initial or unrecognized */
	return INIT_ACK_TIMEOUT;
}

bool coap_pending_cycle(struct coap_pending *pending)
{
  108f8b:	55                   	push   %ebp
	switch (previous) {
  108f8c:	ba 48 49 00 00       	mov    $0x4948,%edx
{
  108f91:	89 e5                	mov    %esp,%ebp
  108f93:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int32_t old = pending->timeout;
  108f96:	8b 41 0c             	mov    0xc(%ecx),%eax

	pending->t0 += pending->timeout;
  108f99:	01 41 08             	add    %eax,0x8(%ecx)
	switch (previous) {
  108f9c:	3d 48 49 00 00       	cmp    $0x4948,%eax
  108fa1:	74 1f                	je     108fc2 <coap_pending_cycle+0x37>
	return INIT_ACK_TIMEOUT;
  108fa3:	ba 29 09 00 00       	mov    $0x929,%edx
	switch (previous) {
  108fa8:	77 18                	ja     108fc2 <coap_pending_cycle+0x37>
  108faa:	3d 52 12 00 00       	cmp    $0x1252,%eax
  108faf:	74 0e                	je     108fbf <coap_pending_cycle+0x34>
  108fb1:	3d a4 24 00 00       	cmp    $0x24a4,%eax
  108fb6:	74 07                	je     108fbf <coap_pending_cycle+0x34>
  108fb8:	3d 29 09 00 00       	cmp    $0x929,%eax
  108fbd:	75 03                	jne    108fc2 <coap_pending_cycle+0x37>
		return previous << 1;
  108fbf:	8d 14 00             	lea    (%eax,%eax,1),%edx
	pending->timeout = next_timeout(pending->timeout);
  108fc2:	89 51 0c             	mov    %edx,0xc(%ecx)

	return (old != pending->timeout);
  108fc5:	39 d0                	cmp    %edx,%eax
}
  108fc7:	5d                   	pop    %ebp
	return (old != pending->timeout);
  108fc8:	0f 95 c0             	setne  %al
}
  108fcb:	c3                   	ret    

00108fcc <coap_pending_clear>:

void coap_pending_clear(struct coap_pending *pending)
{
  108fcc:	55                   	push   %ebp
  108fcd:	89 e5                	mov    %esp,%ebp
  108fcf:	8b 45 08             	mov    0x8(%ebp),%eax
	pending->timeout = 0;
  108fd2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	pending->data = NULL;
  108fd9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
  108fe0:	5d                   	pop    %ebp
  108fe1:	c3                   	ret    

00108fe2 <coap_pendings_clear>:

void coap_pendings_clear(struct coap_pending *pendings, size_t len)
{
  108fe2:	55                   	push   %ebp
	struct coap_pending *p;
	size_t i;

	for (i = 0, p = pendings; i < len; i++, p++) {
  108fe3:	31 d2                	xor    %edx,%edx
{
  108fe5:	89 e5                	mov    %esp,%ebp
  108fe7:	8b 45 08             	mov    0x8(%ebp),%eax
	for (i = 0, p = pendings; i < len; i++, p++) {
  108fea:	3b 55 0c             	cmp    0xc(%ebp),%edx
  108fed:	74 14                	je     109003 <coap_pendings_clear+0x21>
	pending->timeout = 0;
  108fef:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	pending->data = NULL;
  108ff6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	for (i = 0, p = pendings; i < len; i++, p++) {
  108ffd:	42                   	inc    %edx
  108ffe:	83 c0 1c             	add    $0x1c,%eax
  109001:	eb e7                	jmp    108fea <coap_pendings_clear+0x8>
		coap_pending_clear(p);
	}
}
  109003:	5d                   	pop    %ebp
  109004:	c3                   	ret    

00109005 <coap_response_received>:

struct coap_reply *coap_response_received(
	const struct coap_packet *response,
	const struct sockaddr *from,
	struct coap_reply *replies, size_t len)
{
  109005:	55                   	push   %ebp
  109006:	89 e5                	mov    %esp,%ebp
  109008:	57                   	push   %edi
  109009:	56                   	push   %esi
  10900a:	53                   	push   %ebx
  10900b:	83 ec 10             	sub    $0x10,%esp
  10900e:	8b 75 08             	mov    0x8(%ebp),%esi
	uint8_t token[8];
	uint16_t id;
	uint8_t tkl;
	size_t i;

	id = coap_header_get_id(response);
  109011:	56                   	push   %esi
  109012:	e8 bd fb ff ff       	call   108bd4 <coap_header_get_id>
  109017:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	tkl = coap_header_get_token(response, (uint8_t *)token);
  10901b:	8d 45 ec             	lea    -0x14(%ebp),%eax
  10901e:	89 04 24             	mov    %eax,(%esp)
  109021:	56                   	push   %esi
  109022:	e8 19 fb ff ff       	call   108b40 <coap_header_get_token>
  109027:	5b                   	pop    %ebx
  109028:	5f                   	pop    %edi
  109029:	88 c3                	mov    %al,%bl

	for (i = 0, r = replies; i < len; i++, r++) {
  10902b:	8b 7d 10             	mov    0x10(%ebp),%edi
  10902e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  109035:	8b 45 e8             	mov    -0x18(%ebp),%eax
  109038:	3b 45 14             	cmp    0x14(%ebp),%eax
  10903b:	74 69                	je     1090a6 <coap_response_received+0xa1>
		int age;

		if ((r->id == 0U) && (r->tkl == 0U)) {
  10903d:	8b 47 0c             	mov    0xc(%edi),%eax
  109040:	66 85 c0             	test   %ax,%ax
  109043:	75 06                	jne    10904b <coap_response_received+0x46>
  109045:	80 7f 16 00          	cmpb   $0x0,0x16(%edi)
  109049:	74 53                	je     10909e <coap_response_received+0x99>
			continue;
		}

		/* Piggybacked must match id when token is empty */
		if ((r->id != id) && (tkl == 0U)) {
  10904b:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  10904f:	74 06                	je     109057 <coap_response_received+0x52>
  109051:	84 db                	test   %bl,%bl
  109053:	75 16                	jne    10906b <coap_response_received+0x66>
  109055:	eb 47                	jmp    10909e <coap_response_received+0x99>
			continue;
		}

		if (tkl > 0 && memcmp(r->token, token, tkl)) {
  109057:	84 db                	test   %bl,%bl
  109059:	75 10                	jne    10906b <coap_response_received+0x66>
			continue;
		}

		age = coap_get_option_int(response, COAP_OPTION_OBSERVE);
  10905b:	6a 06                	push   $0x6
  10905d:	56                   	push   %esi
  10905e:	e8 bc fc ff ff       	call   108d1f <coap_get_option_int>
  109063:	5a                   	pop    %edx
		if (age > 0) {
  109064:	85 c0                	test   %eax,%eax
		age = coap_get_option_int(response, COAP_OPTION_OBSERVE);
  109066:	59                   	pop    %ecx
		if (age > 0) {
  109067:	7f 1c                	jg     109085 <coap_response_received+0x80>
  109069:	eb 27                	jmp    109092 <coap_response_received+0x8d>
		if (tkl > 0 && memcmp(r->token, token, tkl)) {
  10906b:	0f b6 c3             	movzbl %bl,%eax
  10906e:	50                   	push   %eax
  10906f:	8d 45 ec             	lea    -0x14(%ebp),%eax
  109072:	50                   	push   %eax
  109073:	8d 47 0e             	lea    0xe(%edi),%eax
  109076:	50                   	push   %eax
  109077:	e8 03 2d 00 00       	call   10bd7f <memcmp>
  10907c:	83 c4 0c             	add    $0xc,%esp
  10907f:	85 c0                	test   %eax,%eax
  109081:	74 d8                	je     10905b <coap_response_received+0x56>
  109083:	eb 19                	jmp    10909e <coap_response_received+0x99>
			/* age == 2 means that the notifications wrapped,
			 * or this is the first one
			 */
			if (r->age > age && age != 2) {
  109085:	39 47 08             	cmp    %eax,0x8(%edi)
  109088:	7e 05                	jle    10908f <coap_response_received+0x8a>
  10908a:	83 f8 02             	cmp    $0x2,%eax
  10908d:	75 0f                	jne    10909e <coap_response_received+0x99>
				continue;
			}

			r->age = age;
  10908f:	89 47 08             	mov    %eax,0x8(%edi)
		}

		r->reply(response, r, from);
  109092:	ff 75 0c             	pushl  0xc(%ebp)
  109095:	57                   	push   %edi
  109096:	56                   	push   %esi
  109097:	ff 17                	call   *(%edi)
  109099:	83 c4 0c             	add    $0xc,%esp
		return r;
  10909c:	eb 0a                	jmp    1090a8 <coap_response_received+0xa3>
	for (i = 0, r = replies; i < len; i++, r++) {
  10909e:	ff 45 e8             	incl   -0x18(%ebp)
  1090a1:	83 c7 18             	add    $0x18,%edi
  1090a4:	eb 8f                	jmp    109035 <coap_response_received+0x30>
	}

	return NULL;
  1090a6:	31 ff                	xor    %edi,%edi
}
  1090a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1090ab:	89 f8                	mov    %edi,%eax
  1090ad:	5b                   	pop    %ebx
  1090ae:	5e                   	pop    %esi
  1090af:	5f                   	pop    %edi
  1090b0:	5d                   	pop    %ebp
  1090b1:	c3                   	ret    

001090b2 <coap_reply_init>:

void coap_reply_init(struct coap_reply *reply,
		     const struct coap_packet *request)
{
  1090b2:	55                   	push   %ebp
  1090b3:	89 e5                	mov    %esp,%ebp
  1090b5:	57                   	push   %edi
  1090b6:	56                   	push   %esi
  1090b7:	53                   	push   %ebx
  1090b8:	83 ec 08             	sub    $0x8,%esp
  1090bb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1090be:	8b 75 08             	mov    0x8(%ebp),%esi
	uint8_t token[8];
	uint8_t tkl;
	int age;

	reply->id = coap_header_get_id(request);
  1090c1:	57                   	push   %edi
  1090c2:	e8 0d fb ff ff       	call   108bd4 <coap_header_get_id>
	tkl = coap_header_get_token(request, (uint8_t *)&token);
  1090c7:	8d 55 ec             	lea    -0x14(%ebp),%edx
	reply->id = coap_header_get_id(request);
  1090ca:	66 89 46 0c          	mov    %ax,0xc(%esi)
	tkl = coap_header_get_token(request, (uint8_t *)&token);
  1090ce:	89 14 24             	mov    %edx,(%esp)
  1090d1:	57                   	push   %edi
  1090d2:	e8 69 fa ff ff       	call   108b40 <coap_header_get_token>
  1090d7:	5a                   	pop    %edx
  1090d8:	59                   	pop    %ecx
  1090d9:	88 c3                	mov    %al,%bl

	if (tkl > 0) {
  1090db:	84 c0                	test   %al,%al
  1090dd:	74 14                	je     1090f3 <coap_reply_init+0x41>
		memcpy(reply->token, token, tkl);
  1090df:	0f b6 c0             	movzbl %al,%eax
  1090e2:	50                   	push   %eax
  1090e3:	8d 55 ec             	lea    -0x14(%ebp),%edx
  1090e6:	52                   	push   %edx
  1090e7:	8d 46 0e             	lea    0xe(%esi),%eax
  1090ea:	50                   	push   %eax
  1090eb:	e8 fc 2c 00 00       	call   10bdec <memcpy>
  1090f0:	83 c4 0c             	add    $0xc,%esp
	}

	reply->tkl = tkl;
  1090f3:	88 5e 16             	mov    %bl,0x16(%esi)

	age = coap_get_option_int(request, COAP_OPTION_OBSERVE);
  1090f6:	6a 06                	push   $0x6
  1090f8:	57                   	push   %edi
  1090f9:	e8 21 fc ff ff       	call   108d1f <coap_get_option_int>
  1090fe:	5a                   	pop    %edx

	/* It means that the request enabled observing a resource */
	if (age == 0) {
  1090ff:	85 c0                	test   %eax,%eax
	age = coap_get_option_int(request, COAP_OPTION_OBSERVE);
  109101:	59                   	pop    %ecx
	if (age == 0) {
  109102:	75 07                	jne    10910b <coap_reply_init+0x59>
		reply->age = 2;
  109104:	c7 46 08 02 00 00 00 	movl   $0x2,0x8(%esi)
	}
}
  10910b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10910e:	5b                   	pop    %ebx
  10910f:	5e                   	pop    %esi
  109110:	5f                   	pop    %edi
  109111:	5d                   	pop    %ebp
  109112:	c3                   	ret    

00109113 <coap_reply_clear>:

void coap_reply_clear(struct coap_reply *reply)
{
  109113:	55                   	push   %ebp
  109114:	89 e5                	mov    %esp,%ebp
	(void)memset(reply, 0, sizeof(*reply));
  109116:	6a 18                	push   $0x18
  109118:	6a 00                	push   $0x0
  10911a:	ff 75 08             	pushl  0x8(%ebp)
  10911d:	e8 39 2d 00 00       	call   10be5b <memset>
  109122:	83 c4 0c             	add    $0xc,%esp
}
  109125:	c9                   	leave  
  109126:	c3                   	ret    

00109127 <coap_replies_clear>:

void coap_replies_clear(struct coap_reply *replies, size_t len)
{
  109127:	55                   	push   %ebp
  109128:	89 e5                	mov    %esp,%ebp
  10912a:	56                   	push   %esi
  10912b:	53                   	push   %ebx
	struct coap_reply *r;
	size_t i;

	for (i = 0, r = replies; i < len; i++, r++) {
  10912c:	31 db                	xor    %ebx,%ebx
{
  10912e:	8b 75 08             	mov    0x8(%ebp),%esi
	for (i = 0, r = replies; i < len; i++, r++) {
  109131:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  109134:	74 0d                	je     109143 <coap_replies_clear+0x1c>
		coap_reply_clear(r);
  109136:	56                   	push   %esi
	for (i = 0, r = replies; i < len; i++, r++) {
  109137:	43                   	inc    %ebx
		coap_reply_clear(r);
  109138:	e8 d6 ff ff ff       	call   109113 <coap_reply_clear>
	for (i = 0, r = replies; i < len; i++, r++) {
  10913d:	83 c6 18             	add    $0x18,%esi
		coap_reply_clear(r);
  109140:	58                   	pop    %eax
	for (i = 0, r = replies; i < len; i++, r++) {
  109141:	eb ee                	jmp    109131 <coap_replies_clear+0xa>
	}
}
  109143:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109146:	5b                   	pop    %ebx
  109147:	5e                   	pop    %esi
  109148:	5d                   	pop    %ebp
  109149:	c3                   	ret    

0010914a <net_coap_init>:
 * use and should therefore not be exposed to applications.
 *
 * @return N/A
 */
void net_coap_init(void)
{
  10914a:	55                   	push   %ebp
  10914b:	89 e5                	mov    %esp,%ebp
  10914d:	e8 00 6e 01 00       	call   11ff52 <z_impl_sys_rand32_get>
	/* Initialize message_id to a random number */
	message_id = (uint16_t)sys_rand32_get();
}
  109152:	5d                   	pop    %ebp
	message_id = (uint16_t)sys_rand32_get();
  109153:	66 a3 70 ed 12 00    	mov    %ax,0x12ed70
}
  109159:	c3                   	ret    

0010915a <coap_next_id>:

uint16_t coap_next_id(void)
{
	return message_id++;
  10915a:	66 a1 70 ed 12 00    	mov    0x12ed70,%ax
  109160:	8d 50 01             	lea    0x1(%eax),%edx
  109163:	66 89 15 70 ed 12 00 	mov    %dx,0x12ed70
}
  10916a:	c3                   	ret    

0010916b <z_errno>:
  10916b:	e9 f5 72 01 00       	jmp    120465 <z_impl_z_errno>

00109170 <z_fdtable_call_ioctl>:
 * @param request ioctl request number
 * @param ... Variadic arguments to ioctl
 */
static inline int z_fdtable_call_ioctl(const struct fd_op_vtable *vtable, void *obj,
				       unsigned long request, ...)
{
  109170:	55                   	push   %ebp
  109171:	89 e5                	mov    %esp,%ebp
	va_list args;
	int res;

	va_start(args, request);
  109173:	8d 45 14             	lea    0x14(%ebp),%eax
	res = vtable->ioctl(obj, request, args);
  109176:	50                   	push   %eax
  109177:	8b 45 08             	mov    0x8(%ebp),%eax
  10917a:	ff 75 10             	pushl  0x10(%ebp)
  10917d:	ff 75 0c             	pushl  0xc(%ebp)
  109180:	ff 50 0c             	call   *0xc(%eax)
  109183:	83 c4 0c             	add    $0xc,%esp
	va_end(args);

	return res;
}
  109186:	c9                   	leave  
  109187:	c3                   	ret    

00109188 <sock_ioctl_vmeth>:
{
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
}

static int sock_ioctl_vmeth(void *obj, unsigned int request, va_list args)
{
  109188:	55                   	push   %ebp
  109189:	89 e5                	mov    %esp,%ebp
  10918b:	57                   	push   %edi
  10918c:	56                   	push   %esi
  10918d:	8b 45 0c             	mov    0xc(%ebp),%eax
  109190:	53                   	push   %ebx
  109191:	8b 55 08             	mov    0x8(%ebp),%edx
  109194:	8b 4d 10             	mov    0x10(%ebp),%ecx
	switch (request) {
  109197:	3d 02 01 00 00       	cmp    $0x102,%eax
  10919c:	74 55                	je     1091f3 <sock_ioctl_vmeth+0x6b>
  10919e:	77 0f                	ja     1091af <sock_ioctl_vmeth+0x27>
  1091a0:	83 f8 03             	cmp    $0x3,%eax
  1091a3:	74 1a                	je     1091bf <sock_ioctl_vmeth+0x37>
  1091a5:	83 f8 04             	cmp    $0x4,%eax
  1091a8:	74 25                	je     1091cf <sock_ioctl_vmeth+0x47>
  1091aa:	e9 ce 00 00 00       	jmp    10927d <sock_ioctl_vmeth+0xf5>
  1091af:	3d 03 01 00 00       	cmp    $0x103,%eax
  1091b4:	0f 84 8c 00 00 00    	je     109246 <sock_ioctl_vmeth+0xbe>
  1091ba:	e9 be 00 00 00       	jmp    10927d <sock_ioctl_vmeth+0xf5>

	/* In Zephyr, fcntl() is just an alias of ioctl(). */
	case F_GETFL:
		if (sock_is_nonblock(obj)) {
  1091bf:	f6 42 68 02          	testb  $0x2,0x68(%edx)
		    return O_NONBLOCK;
  1091c3:	b8 00 40 00 00       	mov    $0x4000,%eax
		if (sock_is_nonblock(obj)) {
  1091c8:	74 1a                	je     1091e4 <sock_ioctl_vmeth+0x5c>
  1091ca:	e9 bc 00 00 00       	jmp    10928b <sock_ioctl_vmeth+0x103>
	case F_SETFL: {
		int flags;

		flags = va_arg(args, int);

		if (flags & O_NONBLOCK) {
  1091cf:	8b 01                	mov    (%ecx),%eax
  1091d1:	8b 4a 68             	mov    0x68(%edx),%ecx
  1091d4:	83 e1 fd             	and    $0xfffffffd,%ecx
  1091d7:	25 00 40 00 00       	and    $0x4000,%eax
  1091dc:	74 0d                	je     1091eb <sock_ioctl_vmeth+0x63>
static inline void sock_set_flag(struct net_context *ctx, uintptr_t mask,
				 uintptr_t flag)
{
	uintptr_t val = POINTER_TO_UINT(ctx->socket_data);

	val = (val & ~mask) | flag;
  1091de:	83 c9 02             	or     $0x2,%ecx
  1091e1:	89 4a 68             	mov    %ecx,0x68(%edx)
	(ctx)->socket_data = UINT_TO_POINTER(val);
  1091e4:	31 c0                	xor    %eax,%eax
  1091e6:	e9 a0 00 00 00       	jmp    10928b <sock_ioctl_vmeth+0x103>
  1091eb:	89 4a 68             	mov    %ecx,0x68(%edx)
}
  1091ee:	e9 98 00 00 00       	jmp    10928b <sock_ioctl_vmeth+0x103>

		pfd = va_arg(args, struct zsock_pollfd *);
		pev = va_arg(args, struct k_poll_event **);
		pev_end = va_arg(args, struct k_poll_event *);

		return zsock_poll_prepare_ctx(obj, pfd, pev, pev_end);
  1091f3:	8b 01                	mov    (%ecx),%eax
  1091f5:	66 8b 70 04          	mov    0x4(%eax),%si
	if (pfd->events & ZSOCK_POLLIN) {
  1091f9:	f7 c6 01 00 00 00    	test   $0x1,%esi
  1091ff:	74 35                	je     109236 <sock_ioctl_vmeth+0xae>
		pev = va_arg(args, struct k_poll_event **);
  109201:	8b 59 04             	mov    0x4(%ecx),%ebx
			return -ENOMEM;
  109204:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		if (*pev == pev_end) {
  109209:	8b 3b                	mov    (%ebx),%edi
  10920b:	39 79 08             	cmp    %edi,0x8(%ecx)
  10920e:	74 7b                	je     10928b <sock_ioctl_vmeth+0x103>
		(*pev)->obj = &ctx->recv_q;
  109210:	8d 42 6c             	lea    0x6c(%edx),%eax
  109213:	89 47 10             	mov    %eax,0x10(%edi)
		(*pev)->type = K_POLL_TYPE_FIFO_DATA_AVAILABLE;
  109216:	8b 0b                	mov    (%ebx),%ecx
  109218:	8a 41 0d             	mov    0xd(%ecx),%al
  10921b:	83 e0 f0             	and    $0xfffffff0,%eax
  10921e:	83 c8 04             	or     $0x4,%eax
  109221:	88 41 0d             	mov    %al,0xd(%ecx)
		(*pev)->mode = K_POLL_MODE_NOTIFY_ONLY;
  109224:	8b 03                	mov    (%ebx),%eax
  109226:	80 60 0e fd          	andb   $0xfd,0xe(%eax)
		(*pev)->state = K_POLL_STATE_NOT_READY;
  10922a:	8b 03                	mov    (%ebx),%eax
  10922c:	81 60 0c ff 0f fe ff 	andl   $0xfffe0fff,0xc(%eax)
		(*pev)++;
  109233:	83 03 14             	addl   $0x14,(%ebx)
		return -EALREADY;
  109236:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
	if (pfd->events & ZSOCK_POLLOUT) {
  10923b:	83 e6 04             	and    $0x4,%esi
  10923e:	75 4b                	jne    10928b <sock_ioctl_vmeth+0x103>
	if (sock_is_eof(ctx)) {
  109240:	f6 42 68 01          	testb  $0x1,0x68(%edx)
  109244:	eb 82                	jmp    1091c8 <sock_ioctl_vmeth+0x40>

	case ZFD_IOCTL_POLL_UPDATE: {
		struct zsock_pollfd *pfd;
		struct k_poll_event **pev;

		pfd = va_arg(args, struct zsock_pollfd *);
  109246:	8b 01                	mov    (%ecx),%eax
		pev = va_arg(args, struct k_poll_event **);
  109248:	8b 59 04             	mov    0x4(%ecx),%ebx
	if (pfd->events & ZSOCK_POLLOUT) {
  10924b:	8b 48 04             	mov    0x4(%eax),%ecx
  10924e:	f6 c1 04             	test   $0x4,%cl
  109251:	74 05                	je     109258 <sock_ioctl_vmeth+0xd0>
		pfd->revents |= ZSOCK_POLLOUT;
  109253:	66 83 48 06 04       	orw    $0x4,0x6(%eax)
	if (pfd->events & ZSOCK_POLLIN) {
  109258:	80 e1 01             	and    $0x1,%cl
  10925b:	74 87                	je     1091e4 <sock_ioctl_vmeth+0x5c>
		if ((*pev)->state != K_POLL_STATE_NOT_READY || sock_is_eof(ctx)) {
  10925d:	8b 0b                	mov    (%ebx),%ecx
  10925f:	f7 41 0c 00 f0 01 00 	testl  $0x1f000,0xc(%ecx)
  109266:	75 06                	jne    10926e <sock_ioctl_vmeth+0xe6>
  109268:	f6 42 68 01          	testb  $0x1,0x68(%edx)
  10926c:	74 05                	je     109273 <sock_ioctl_vmeth+0xeb>
			pfd->revents |= ZSOCK_POLLIN;
  10926e:	66 83 48 06 01       	orw    $0x1,0x6(%eax)
		(*pev)++;
  109273:	83 c1 14             	add    $0x14,%ecx
  109276:	89 0b                	mov    %ecx,(%ebx)
  109278:	e9 67 ff ff ff       	jmp    1091e4 <sock_ioctl_vmeth+0x5c>

		return zsock_poll_update_ctx(obj, pfd, pev);
	}

	default:
		errno = EOPNOTSUPP;
  10927d:	e8 e9 fe ff ff       	call   10916b <z_errno>
  109282:	c7 00 2d 00 00 00    	movl   $0x2d,(%eax)
		return -1;
  109288:	83 c8 ff             	or     $0xffffffff,%eax
	}
}
  10928b:	5b                   	pop    %ebx
  10928c:	5e                   	pop    %esi
  10928d:	5f                   	pop    %edi
  10928e:	5d                   	pop    %ebp
  10928f:	c3                   	ret    

00109290 <get_sock_vtable>:
{
  109290:	55                   	push   %ebp
  109291:	89 e5                	mov    %esp,%ebp
  109293:	53                   	push   %ebx
  109294:	51                   	push   %ecx
  109295:	89 c3                	mov    %eax,%ebx
	ctx = z_get_fd_obj_and_vtable(sock,
  109297:	52                   	push   %edx
  109298:	50                   	push   %eax
  109299:	e8 34 7a ff ff       	call   100cd2 <z_get_fd_obj_and_vtable>
  10929e:	5a                   	pop    %edx
	if (ctx == NULL) {
  10929f:	85 c0                	test   %eax,%eax
	ctx = z_get_fd_obj_and_vtable(sock,
  1092a1:	59                   	pop    %ecx
	if (ctx == NULL) {
  1092a2:	75 38                	jne    1092dc <get_sock_vtable+0x4c>
		NET_ERR("invalid access on sock %d by thread %p", sock,
  1092a4:	f6 05 04 5c 14 00 07 	testb  $0x7,0x145c04
  1092ab:	74 2f                	je     1092dc <get_sock_vtable+0x4c>
  1092ad:	ba 88 31 12 00       	mov    $0x123188,%edx
  1092b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1092b5:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  1092bb:	c1 ea 03             	shr    $0x3,%edx
  1092be:	c1 e2 06             	shl    $0x6,%edx
  1092c1:	83 ca 01             	or     $0x1,%edx
  1092c4:	52                   	push   %edx
  1092c5:	ff 35 c8 e9 12 00    	pushl  0x12e9c8
  1092cb:	53                   	push   %ebx
  1092cc:	68 60 58 12 00       	push   $0x125860
  1092d1:	e8 da a2 ff ff       	call   1035b0 <log_2>
  1092d6:	83 c4 10             	add    $0x10,%esp
  1092d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  1092dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1092df:	c9                   	leave  
  1092e0:	c3                   	ret    

001092e1 <sock_getsockopt_vmeth>:
  1092e1:	55                   	push   %ebp
  1092e2:	89 e5                	mov    %esp,%ebp
  1092e4:	e8 82 fe ff ff       	call   10916b <z_errno>
  1092e9:	c7 00 2a 00 00 00    	movl   $0x2a,(%eax)
  1092ef:	83 c8 ff             	or     $0xffffffff,%eax
  1092f2:	5d                   	pop    %ebp
  1092f3:	c3                   	ret    

001092f4 <zsock_received_cb>:
{
  1092f4:	55                   	push   %ebp
  1092f5:	89 e5                	mov    %esp,%ebp
  1092f7:	57                   	push   %edi
  1092f8:	56                   	push   %esi
  1092f9:	53                   	push   %ebx
  1092fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1092fd:	8b 75 0c             	mov    0xc(%ebp),%esi
  109300:	8d 7b 6c             	lea    0x6c(%ebx),%edi
	if (!pkt) {
  109303:	85 f6                	test   %esi,%esi
  109305:	75 2f                	jne    109336 <zsock_received_cb+0x42>
	return z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
  109307:	6a 00                	push   $0x0
  109309:	ff 73 70             	pushl  0x70(%ebx)
  10930c:	e8 57 7b 01 00       	call   120e68 <z_queue_node_peek>
  109311:	59                   	pop    %ecx
		if (!last_pkt) {
  109312:	85 c0                	test   %eax,%eax
  109314:	5e                   	pop    %esi
  109315:	75 13                	jne    10932a <zsock_received_cb+0x36>
	val = (val & ~mask) | flag;
  109317:	83 4b 68 01          	orl    $0x1,0x68(%ebx)
	z_impl_k_queue_cancel_wait(queue);
  10931b:	89 7d 08             	mov    %edi,0x8(%ebp)
}
  10931e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109321:	5b                   	pop    %ebx
  109322:	5e                   	pop    %esi
  109323:	5f                   	pop    %edi
  109324:	5d                   	pop    %ebp
  109325:	e9 9d 7b 01 00       	jmp    120ec7 <z_impl_k_queue_cancel_wait>
	return pkt->sent_or_eof;
}

static inline void net_pkt_set_eof(struct net_pkt *pkt, bool eof)
{
	pkt->sent_or_eof = eof;
  10932a:	80 48 3d 02          	orb    $0x2,0x3d(%eax)
  10932e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109331:	5b                   	pop    %ebx
  109332:	5e                   	pop    %esi
  109333:	5f                   	pop    %edi
  109334:	5d                   	pop    %ebp
  109335:	c3                   	ret    
static inline
enum net_sock_type net_context_get_type(struct net_context *context)
{
	NET_ASSERT(context);

	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
  109336:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
  10933d:	c1 e8 06             	shr    $0x6,%eax
  109340:	83 e0 03             	and    $0x3,%eax
  109343:	80 66 3d fd          	andb   $0xfd,0x3d(%esi)
	if (net_context_get_type(ctx) == SOCK_STREAM) {
  109347:	48                   	dec    %eax
  109348:	75 13                	jne    10935d <zsock_received_cb+0x69>
		net_context_update_recv_wnd(ctx, -net_pkt_remaining_data(pkt));
  10934a:	56                   	push   %esi
  10934b:	e8 26 6e 00 00       	call   110176 <net_pkt_remaining_data>
  109350:	f7 d8                	neg    %eax
  109352:	89 04 24             	mov    %eax,(%esp)
  109355:	53                   	push   %ebx
  109356:	e8 90 63 00 00       	call   10f6eb <net_context_update_recv_wnd>
  10935b:	58                   	pop    %eax
  10935c:	5a                   	pop    %edx
	k_fifo_put(&ctx->recv_q, pkt);
  10935d:	89 75 0c             	mov    %esi,0xc(%ebp)
  109360:	89 7d 08             	mov    %edi,0x8(%ebp)
}
  109363:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109366:	5b                   	pop    %ebx
  109367:	5e                   	pop    %esi
  109368:	5f                   	pop    %edi
  109369:	5d                   	pop    %ebp
	k_fifo_put(&ctx->recv_q, pkt);
  10936a:	e9 aa 7b 01 00       	jmp    120f19 <k_queue_append>

0010936f <zsock_accepted_cb>:
			      int status, void *user_data) {
  10936f:	55                   	push   %ebp
  109370:	89 e5                	mov    %esp,%ebp
  109372:	56                   	push   %esi
  109373:	53                   	push   %ebx
	if (status == 0) {
  109374:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
			      int status, void *user_data) {
  109378:	8b 75 08             	mov    0x8(%ebp),%esi
  10937b:	8b 5d 18             	mov    0x18(%ebp),%ebx
	if (status == 0) {
  10937e:	75 32                	jne    1093b2 <zsock_accepted_cb+0x43>
		(void)net_context_recv(new_ctx, zsock_received_cb, K_NO_WAIT,
  109380:	6a 00                	push   $0x0
  109382:	6a 00                	push   $0x0
  109384:	6a 00                	push   $0x0
  109386:	68 f4 92 10 00       	push   $0x1092f4
  10938b:	56                   	push   %esi
  10938c:	e8 e9 61 00 00       	call   10f57a <net_context_recv>
  109391:	83 c4 14             	add    $0x14,%esp
		k_fifo_init(&new_ctx->recv_q);
  109394:	8d 46 6c             	lea    0x6c(%esi),%eax
		k_fifo_put(&parent->accept_q, new_ctx);
  109397:	83 c3 6c             	add    $0x6c,%ebx
	z_impl_k_queue_init(queue);
  10939a:	50                   	push   %eax
  10939b:	e8 f0 7a 01 00       	call   120e90 <z_impl_k_queue_init>
  1093a0:	89 75 0c             	mov    %esi,0xc(%ebp)
  1093a3:	89 5d 08             	mov    %ebx,0x8(%ebp)
  1093a6:	58                   	pop    %eax
}
  1093a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1093aa:	5b                   	pop    %ebx
  1093ab:	5e                   	pop    %esi
  1093ac:	5d                   	pop    %ebp
		k_fifo_put(&parent->accept_q, new_ctx);
  1093ad:	e9 67 7b 01 00       	jmp    120f19 <k_queue_append>
}
  1093b2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1093b5:	5b                   	pop    %ebx
  1093b6:	5e                   	pop    %esi
  1093b7:	5d                   	pop    %ebp
  1093b8:	c3                   	ret    

001093b9 <zsock_socket_internal>:
{
  1093b9:	55                   	push   %ebp
  1093ba:	89 e5                	mov    %esp,%ebp
  1093bc:	57                   	push   %edi
  1093bd:	56                   	push   %esi
  1093be:	53                   	push   %ebx
  1093bf:	53                   	push   %ebx
  1093c0:	8b 7d 0c             	mov    0xc(%ebp),%edi
  1093c3:	8b 75 10             	mov    0x10(%ebp),%esi
	int fd = z_reserve_fd();
  1093c6:	e8 31 79 ff ff       	call   100cfc <z_reserve_fd>
	if (fd < 0) {
  1093cb:	85 c0                	test   %eax,%eax
  1093cd:	0f 88 8e 00 00 00    	js     109461 <zsock_socket_internal+0xa8>
  1093d3:	89 c3                	mov    %eax,%ebx
	if (proto == 0) {
  1093d5:	85 f6                	test   %esi,%esi
  1093d7:	75 1f                	jne    1093f8 <zsock_socket_internal+0x3f>
		if (family == AF_INET || family == AF_INET6) {
  1093d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1093dc:	48                   	dec    %eax
  1093dd:	83 f8 01             	cmp    $0x1,%eax
  1093e0:	77 16                	ja     1093f8 <zsock_socket_internal+0x3f>
			if (type == SOCK_DGRAM) {
  1093e2:	83 ff 02             	cmp    $0x2,%edi
  1093e5:	74 0c                	je     1093f3 <zsock_socket_internal+0x3a>
			} else if (type == SOCK_STREAM) {
  1093e7:	83 ff 01             	cmp    $0x1,%edi
  1093ea:	75 0c                	jne    1093f8 <zsock_socket_internal+0x3f>
				proto = IPPROTO_TCP;
  1093ec:	be 06 00 00 00       	mov    $0x6,%esi
  1093f1:	eb 05                	jmp    1093f8 <zsock_socket_internal+0x3f>
				proto = IPPROTO_UDP;
  1093f3:	be 11 00 00 00       	mov    $0x11,%esi
	res = net_context_get(family, type, proto, &ctx);
  1093f8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1093fb:	50                   	push   %eax
  1093fc:	0f b7 c6             	movzwl %si,%eax
  1093ff:	50                   	push   %eax
  109400:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  109404:	57                   	push   %edi
  109405:	50                   	push   %eax
  109406:	e8 e0 56 00 00       	call   10eaeb <net_context_get>
  10940b:	83 c4 10             	add    $0x10,%esp
  10940e:	89 c7                	mov    %eax,%edi
	if (res < 0) {
  109410:	85 c0                	test   %eax,%eax
  109412:	79 12                	jns    109426 <zsock_socket_internal+0x6d>
		z_free_fd(fd);
  109414:	53                   	push   %ebx
  109415:	e8 64 79 ff ff       	call   100d7e <z_free_fd>
  10941a:	59                   	pop    %ecx
		errno = -res;
  10941b:	e8 4b fd ff ff       	call   10916b <z_errno>
  109420:	f7 df                	neg    %edi
  109422:	89 38                	mov    %edi,(%eax)
		return -1;
  109424:	eb 3b                	jmp    109461 <zsock_socket_internal+0xa8>
	ctx->user_data = NULL;
  109426:	8b 45 f0             	mov    -0x10(%ebp),%eax
  109429:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	ctx->socket_data = NULL;
  10942f:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
	k_fifo_init(&ctx->recv_q);
  109436:	83 c0 6c             	add    $0x6c,%eax
  109439:	50                   	push   %eax
  10943a:	e8 51 7a 01 00       	call   120e90 <z_impl_k_queue_init>
  10943f:	5a                   	pop    %edx
	if (proto == IPPROTO_TCP) {
  109440:	83 fe 06             	cmp    $0x6,%esi
  109443:	75 09                	jne    10944e <zsock_socket_internal+0x95>
		net_context_ref(ctx);
  109445:	ff 75 f0             	pushl  -0x10(%ebp)
  109448:	e8 c1 58 00 00       	call   10ed0e <net_context_ref>
  10944d:	58                   	pop    %eax
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
  10944e:	68 40 36 12 00       	push   $0x123640
  109453:	ff 75 f0             	pushl  -0x10(%ebp)
  109456:	53                   	push   %ebx
  109457:	e8 07 79 ff ff       	call   100d63 <z_finalize_fd>
  10945c:	83 c4 0c             	add    $0xc,%esp
	return fd;
  10945f:	eb 03                	jmp    109464 <zsock_socket_internal+0xab>
		return -1;
  109461:	83 cb ff             	or     $0xffffffff,%ebx
}
  109464:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109467:	89 d8                	mov    %ebx,%eax
  109469:	5b                   	pop    %ebx
  10946a:	5e                   	pop    %esi
  10946b:	5f                   	pop    %edi
  10946c:	5d                   	pop    %ebp
  10946d:	c3                   	ret    

0010946e <z_impl_zsock_socket>:
{
  10946e:	55                   	push   %ebp
  10946f:	89 e5                	mov    %esp,%ebp
  109471:	57                   	push   %edi
  109472:	56                   	push   %esi
  109473:	53                   	push   %ebx
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
  109474:	bb b0 30 12 00       	mov    $0x1230b0,%ebx
{
  109479:	50                   	push   %eax
  10947a:	8b 75 08             	mov    0x8(%ebp),%esi
  10947d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  109480:	8b 55 10             	mov    0x10(%ebp),%edx
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
  109483:	81 fb b0 30 12 00    	cmp    $0x1230b0,%ebx
  109489:	73 37                	jae    1094c2 <z_impl_zsock_socket+0x54>
		if (sock_family->family != family &&
  10948b:	8b 03                	mov    (%ebx),%eax
  10948d:	85 c0                	test   %eax,%eax
  10948f:	74 04                	je     109495 <z_impl_zsock_socket+0x27>
  109491:	39 f0                	cmp    %esi,%eax
  109493:	75 28                	jne    1094bd <z_impl_zsock_socket+0x4f>
		if (!sock_family->is_supported(family, type, proto)) {
  109495:	52                   	push   %edx
  109496:	89 55 f0             	mov    %edx,-0x10(%ebp)
  109499:	57                   	push   %edi
  10949a:	56                   	push   %esi
  10949b:	ff 53 04             	call   *0x4(%ebx)
  10949e:	83 c4 0c             	add    $0xc,%esp
  1094a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1094a4:	84 c0                	test   %al,%al
  1094a6:	74 15                	je     1094bd <z_impl_zsock_socket+0x4f>
		return sock_family->handler(family, type, proto);
  1094a8:	89 7d 0c             	mov    %edi,0xc(%ebp)
  1094ab:	89 75 08             	mov    %esi,0x8(%ebp)
  1094ae:	89 55 10             	mov    %edx,0x10(%ebp)
  1094b1:	8b 43 08             	mov    0x8(%ebx),%eax
}
  1094b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1094b7:	5b                   	pop    %ebx
  1094b8:	5e                   	pop    %esi
  1094b9:	5f                   	pop    %edi
  1094ba:	5d                   	pop    %ebp
		return sock_family->handler(family, type, proto);
  1094bb:	ff e0                	jmp    *%eax
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
  1094bd:	83 c3 0c             	add    $0xc,%ebx
  1094c0:	eb c1                	jmp    109483 <z_impl_zsock_socket+0x15>
		return zsock_socket_internal(family, type, proto);
  1094c2:	89 7d 0c             	mov    %edi,0xc(%ebp)
  1094c5:	89 75 08             	mov    %esi,0x8(%ebp)
  1094c8:	89 55 10             	mov    %edx,0x10(%ebp)
}
  1094cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1094ce:	5b                   	pop    %ebx
  1094cf:	5e                   	pop    %esi
  1094d0:	5f                   	pop    %edi
  1094d1:	5d                   	pop    %ebp
		return zsock_socket_internal(family, type, proto);
  1094d2:	e9 e2 fe ff ff       	jmp    1093b9 <zsock_socket_internal>

001094d7 <zsock_close_ctx>:
{
  1094d7:	55                   	push   %ebp
  1094d8:	89 e5                	mov    %esp,%ebp
  1094da:	57                   	push   %edi
  1094db:	56                   	push   %esi
  1094dc:	53                   	push   %ebx
  1094dd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
  1094e0:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
  1094e7:	83 f0 06             	xor    $0x6,%eax
  1094ea:	a8 06                	test   $0x6,%al
  1094ec:	75 10                	jne    1094fe <zsock_close_ctx+0x27>
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
  1094ee:	6a 00                	push   $0x0
  1094f0:	6a 00                	push   $0x0
  1094f2:	6a 00                	push   $0x0
  1094f4:	6a 00                	push   $0x0
  1094f6:	53                   	push   %ebx
  1094f7:	e8 0f 5f 00 00       	call   10f40b <net_context_accept>
  1094fc:	eb 0e                	jmp    10950c <zsock_close_ctx+0x35>
		(void)net_context_recv(ctx, NULL, K_NO_WAIT, NULL);
  1094fe:	6a 00                	push   $0x0
  109500:	6a 00                	push   $0x0
  109502:	6a 00                	push   $0x0
  109504:	6a 00                	push   $0x0
  109506:	53                   	push   %ebx
  109507:	e8 6e 60 00 00       	call   10f57a <net_context_recv>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
  10950c:	66 8b b3 92 00 00 00 	mov    0x92(%ebx),%si
  109513:	83 c4 14             	add    $0x14,%esp
  109516:	66 d1 ee             	shr    %si
  109519:	83 e6 03             	and    $0x3,%esi
	while ((p = k_fifo_get(&ctx->recv_q, K_NO_WAIT)) != NULL) {
  10951c:	8d 7b 6c             	lea    0x6c(%ebx),%edi
	return z_impl_k_queue_get(queue, timeout);
  10951f:	6a 00                	push   $0x0
  109521:	6a 00                	push   $0x0
  109523:	57                   	push   %edi
  109524:	e8 2e 7a 01 00       	call   120f57 <z_impl_k_queue_get>
  109529:	83 c4 0c             	add    $0xc,%esp
  10952c:	85 c0                	test   %eax,%eax
  10952e:	74 17                	je     109547 <zsock_close_ctx+0x70>
		if (is_listen) {
  109530:	66 83 fe 03          	cmp    $0x3,%si
  109534:	75 08                	jne    10953e <zsock_close_ctx+0x67>
			net_context_put(p);
  109536:	50                   	push   %eax
  109537:	e8 40 58 00 00       	call   10ed7c <net_context_put>
  10953c:	eb 06                	jmp    109544 <zsock_close_ctx+0x6d>
			net_pkt_unref(p);
  10953e:	50                   	push   %eax
  10953f:	e8 38 65 00 00       	call   10fa7c <net_pkt_unref>
  109544:	59                   	pop    %ecx
  109545:	eb d5                	jmp    10951c <zsock_close_ctx+0x45>
	z_impl_k_queue_cancel_wait(queue);
  109547:	57                   	push   %edi
  109548:	e8 7a 79 01 00       	call   120ec7 <z_impl_k_queue_cancel_wait>
	SET_ERRNO(net_context_put(ctx));
  10954d:	89 1c 24             	mov    %ebx,(%esp)
  109550:	e8 27 58 00 00       	call   10ed7c <net_context_put>
  109555:	89 c3                	mov    %eax,%ebx
  109557:	5a                   	pop    %edx
	return 0;
  109558:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_put(ctx));
  10955a:	85 db                	test   %ebx,%ebx
  10955c:	79 0c                	jns    10956a <zsock_close_ctx+0x93>
  10955e:	e8 08 fc ff ff       	call   10916b <z_errno>
  109563:	f7 db                	neg    %ebx
  109565:	89 18                	mov    %ebx,(%eax)
  109567:	83 c8 ff             	or     $0xffffffff,%eax
}
  10956a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10956d:	5b                   	pop    %ebx
  10956e:	5e                   	pop    %esi
  10956f:	5f                   	pop    %edi
  109570:	5d                   	pop    %ebp
  109571:	c3                   	ret    

00109572 <sock_close_vmeth>:
	return zsock_setsockopt_ctx(obj, level, optname, optval, optlen);
}

static int sock_close_vmeth(void *obj)
{
	return zsock_close_ctx(obj);
  109572:	e9 60 ff ff ff       	jmp    1094d7 <zsock_close_ctx>

00109577 <z_impl_zsock_close>:
{
  109577:	55                   	push   %ebp
  109578:	89 e5                	mov    %esp,%ebp
  10957a:	53                   	push   %ebx
  10957b:	83 ec 08             	sub    $0x8,%esp
  10957e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	void *ctx = get_sock_vtable(sock, &vtable);
  109581:	8d 55 f8             	lea    -0x8(%ebp),%edx
  109584:	89 d8                	mov    %ebx,%eax
  109586:	e8 05 fd ff ff       	call   109290 <get_sock_vtable>
	if (ctx == NULL) {
  10958b:	85 c0                	test   %eax,%eax
  10958d:	75 10                	jne    10959f <z_impl_zsock_close+0x28>
		errno = EBADF;
  10958f:	e8 d7 fb ff ff       	call   10916b <z_errno>
  109594:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
		return -1;
  10959a:	83 c8 ff             	or     $0xffffffff,%eax
  10959d:	eb 16                	jmp    1095b5 <z_impl_zsock_close+0x3e>
	ret = vtable->fd_vtable.close(ctx);
  10959f:	50                   	push   %eax
  1095a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1095a3:	ff 50 08             	call   *0x8(%eax)
	z_free_fd(sock);
  1095a6:	89 1c 24             	mov    %ebx,(%esp)
	ret = vtable->fd_vtable.close(ctx);
  1095a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	z_free_fd(sock);
  1095ac:	e8 cd 77 ff ff       	call   100d7e <z_free_fd>
  1095b1:	58                   	pop    %eax
  1095b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  1095b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1095b8:	c9                   	leave  
  1095b9:	c3                   	ret    

001095ba <zsock_bind_ctx>:
{
  1095ba:	55                   	push   %ebp
  1095bb:	89 e5                	mov    %esp,%ebp
  1095bd:	57                   	push   %edi
  1095be:	56                   	push   %esi
  1095bf:	53                   	push   %ebx
  1095c0:	8b 75 08             	mov    0x8(%ebp),%esi
	SET_ERRNO(net_context_bind(ctx, addr, addrlen));
  1095c3:	ff 75 10             	pushl  0x10(%ebp)
  1095c6:	ff 75 0c             	pushl  0xc(%ebp)
  1095c9:	56                   	push   %esi
  1095ca:	e8 19 58 00 00       	call   10ede8 <net_context_bind>
  1095cf:	83 c4 0c             	add    $0xc,%esp
  1095d2:	89 c3                	mov    %eax,%ebx
  1095d4:	85 c0                	test   %eax,%eax
  1095d6:	78 2e                	js     109606 <zsock_bind_ctx+0x4c>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
  1095d8:	0f b7 86 92 00 00 00 	movzwl 0x92(%esi),%eax
  1095df:	c1 e8 06             	shr    $0x6,%eax
	return 0;
  1095e2:	31 ff                	xor    %edi,%edi
  1095e4:	83 e0 03             	and    $0x3,%eax
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
  1095e7:	83 f8 02             	cmp    $0x2,%eax
  1095ea:	75 26                	jne    109612 <zsock_bind_ctx+0x58>
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
  1095ec:	ff 36                	pushl  (%esi)
  1095ee:	6a 00                	push   $0x0
  1095f0:	6a 00                	push   $0x0
  1095f2:	68 f4 92 10 00       	push   $0x1092f4
  1095f7:	56                   	push   %esi
  1095f8:	e8 7d 5f 00 00       	call   10f57a <net_context_recv>
  1095fd:	83 c4 14             	add    $0x14,%esp
  109600:	89 c3                	mov    %eax,%ebx
  109602:	85 c0                	test   %eax,%eax
  109604:	79 0c                	jns    109612 <zsock_bind_ctx+0x58>
  109606:	e8 60 fb ff ff       	call   10916b <z_errno>
  10960b:	83 cf ff             	or     $0xffffffff,%edi
  10960e:	f7 db                	neg    %ebx
  109610:	89 18                	mov    %ebx,(%eax)
}
  109612:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109615:	89 f8                	mov    %edi,%eax
  109617:	5b                   	pop    %ebx
  109618:	5e                   	pop    %esi
  109619:	5f                   	pop    %edi
  10961a:	5d                   	pop    %ebp
  10961b:	c3                   	ret    

0010961c <sock_bind_vmeth>:
	return zsock_bind_ctx(obj, addr, addrlen);
  10961c:	e9 99 ff ff ff       	jmp    1095ba <zsock_bind_ctx>

00109621 <zsock_connect_ctx>:
{
  109621:	55                   	push   %ebp
  109622:	89 e5                	mov    %esp,%ebp
  109624:	56                   	push   %esi
  109625:	53                   	push   %ebx
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
  109626:	6a 00                	push   $0x0
{
  109628:	8b 75 08             	mov    0x8(%ebp),%esi
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
  10962b:	6a 00                	push   $0x0
  10962d:	68 2c 01 00 00       	push   $0x12c
  109632:	6a 00                	push   $0x0
  109634:	ff 75 10             	pushl  0x10(%ebp)
  109637:	ff 75 0c             	pushl  0xc(%ebp)
  10963a:	56                   	push   %esi
  10963b:	e8 8a 5c 00 00       	call   10f2ca <net_context_connect>
  109640:	83 c4 1c             	add    $0x1c,%esp
  109643:	89 c3                	mov    %eax,%ebx
  109645:	85 c0                	test   %eax,%eax
  109647:	78 1c                	js     109665 <zsock_connect_ctx+0x44>
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
  109649:	ff 36                	pushl  (%esi)
  10964b:	6a 00                	push   $0x0
  10964d:	6a 00                	push   $0x0
  10964f:	68 f4 92 10 00       	push   $0x1092f4
  109654:	56                   	push   %esi
  109655:	e8 20 5f 00 00       	call   10f57a <net_context_recv>
  10965a:	89 c3                	mov    %eax,%ebx
  10965c:	83 c4 14             	add    $0x14,%esp
	return 0;
  10965f:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
  109661:	85 db                	test   %ebx,%ebx
  109663:	79 0c                	jns    109671 <zsock_connect_ctx+0x50>
  109665:	e8 01 fb ff ff       	call   10916b <z_errno>
  10966a:	f7 db                	neg    %ebx
  10966c:	89 18                	mov    %ebx,(%eax)
  10966e:	83 c8 ff             	or     $0xffffffff,%eax
}
  109671:	8d 65 f8             	lea    -0x8(%ebp),%esp
  109674:	5b                   	pop    %ebx
  109675:	5e                   	pop    %esi
  109676:	5d                   	pop    %ebp
  109677:	c3                   	ret    

00109678 <sock_connect_vmeth>:
	return zsock_connect_ctx(obj, addr, addrlen);
  109678:	e9 a4 ff ff ff       	jmp    109621 <zsock_connect_ctx>

0010967d <z_impl_zsock_connect>:
{
  10967d:	55                   	push   %ebp
  10967e:	89 e5                	mov    %esp,%ebp
  109680:	50                   	push   %eax
	VTABLE_CALL(connect, sock, addr, addrlen);
  109681:	8d 55 fc             	lea    -0x4(%ebp),%edx
  109684:	8b 45 08             	mov    0x8(%ebp),%eax
  109687:	e8 04 fc ff ff       	call   109290 <get_sock_vtable>
  10968c:	85 c0                	test   %eax,%eax
  10968e:	74 0a                	je     10969a <z_impl_zsock_connect+0x1d>
  109690:	8b 55 fc             	mov    -0x4(%ebp),%edx
  109693:	8b 52 14             	mov    0x14(%edx),%edx
  109696:	85 d2                	test   %edx,%edx
  109698:	75 10                	jne    1096aa <z_impl_zsock_connect+0x2d>
  10969a:	e8 cc fa ff ff       	call   10916b <z_errno>
  10969f:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
  1096a5:	83 c8 ff             	or     $0xffffffff,%eax
  1096a8:	eb 0c                	jmp    1096b6 <z_impl_zsock_connect+0x39>
  1096aa:	ff 75 10             	pushl  0x10(%ebp)
  1096ad:	ff 75 0c             	pushl  0xc(%ebp)
  1096b0:	50                   	push   %eax
  1096b1:	ff d2                	call   *%edx
  1096b3:	83 c4 0c             	add    $0xc,%esp
}
  1096b6:	c9                   	leave  
  1096b7:	c3                   	ret    

001096b8 <zsock_listen_ctx>:
{
  1096b8:	55                   	push   %ebp
  1096b9:	89 e5                	mov    %esp,%ebp
  1096bb:	56                   	push   %esi
  1096bc:	53                   	push   %ebx
	SET_ERRNO(net_context_listen(ctx, backlog));
  1096bd:	ff 75 0c             	pushl  0xc(%ebp)
{
  1096c0:	8b 75 08             	mov    0x8(%ebp),%esi
	SET_ERRNO(net_context_listen(ctx, backlog));
  1096c3:	56                   	push   %esi
  1096c4:	e8 0c 59 00 00       	call   10efd5 <net_context_listen>
  1096c9:	5a                   	pop    %edx
  1096ca:	89 c3                	mov    %eax,%ebx
  1096cc:	59                   	pop    %ecx
  1096cd:	85 c0                	test   %eax,%eax
  1096cf:	78 1b                	js     1096ec <zsock_listen_ctx+0x34>
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
  1096d1:	56                   	push   %esi
  1096d2:	6a 00                	push   $0x0
  1096d4:	6a 00                	push   $0x0
  1096d6:	68 6f 93 10 00       	push   $0x10936f
  1096db:	56                   	push   %esi
  1096dc:	e8 2a 5d 00 00       	call   10f40b <net_context_accept>
  1096e1:	89 c3                	mov    %eax,%ebx
  1096e3:	83 c4 14             	add    $0x14,%esp
	return 0;
  1096e6:	31 c0                	xor    %eax,%eax
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
  1096e8:	85 db                	test   %ebx,%ebx
  1096ea:	79 0c                	jns    1096f8 <zsock_listen_ctx+0x40>
  1096ec:	e8 7a fa ff ff       	call   10916b <z_errno>
  1096f1:	f7 db                	neg    %ebx
  1096f3:	89 18                	mov    %ebx,(%eax)
  1096f5:	83 c8 ff             	or     $0xffffffff,%eax
}
  1096f8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1096fb:	5b                   	pop    %ebx
  1096fc:	5e                   	pop    %esi
  1096fd:	5d                   	pop    %ebp
  1096fe:	c3                   	ret    

001096ff <sock_listen_vmeth>:
	return zsock_listen_ctx(obj, backlog);
  1096ff:	e9 b4 ff ff ff       	jmp    1096b8 <zsock_listen_ctx>

00109704 <zsock_accept_ctx>:
{
  109704:	55                   	push   %ebp
  109705:	89 e5                	mov    %esp,%ebp
  109707:	57                   	push   %edi
  109708:	56                   	push   %esi
  109709:	53                   	push   %ebx
  10970a:	83 ec 08             	sub    $0x8,%esp
	fd = z_reserve_fd();
  10970d:	e8 ea 75 ff ff       	call   100cfc <z_reserve_fd>
	if (fd < 0) {
  109712:	85 c0                	test   %eax,%eax
  109714:	0f 88 46 01 00 00    	js     109860 <zsock_accept_ctx+0x15c>
  10971a:	89 c3                	mov    %eax,%ebx
	if (sock_is_nonblock(parent)) {
  10971c:	8b 45 08             	mov    0x8(%ebp),%eax
  10971f:	31 ff                	xor    %edi,%edi
  109721:	8b 40 68             	mov    0x68(%eax),%eax
  109724:	d1 e8                	shr    %eax
  109726:	83 f0 01             	xor    $0x1,%eax
  109729:	83 e0 01             	and    $0x1,%eax
  10972c:	89 c6                	mov    %eax,%esi
  10972e:	f7 de                	neg    %esi
  109730:	83 d7 00             	adc    $0x0,%edi
  109733:	89 75 ec             	mov    %esi,-0x14(%ebp)
  109736:	f7 df                	neg    %edi
  109738:	89 7d f0             	mov    %edi,-0x10(%ebp)
	return z_impl_k_queue_get(queue, timeout);
  10973b:	ff 75 f0             	pushl  -0x10(%ebp)
  10973e:	ff 75 ec             	pushl  -0x14(%ebp)
	ctx = k_fifo_get(&parent->accept_q, timeout);
  109741:	8b 45 08             	mov    0x8(%ebp),%eax
  109744:	83 c0 6c             	add    $0x6c,%eax
  109747:	50                   	push   %eax
  109748:	e8 0a 78 01 00       	call   120f57 <z_impl_k_queue_get>
  10974d:	83 c4 0c             	add    $0xc,%esp
  109750:	89 c6                	mov    %eax,%esi
	if (ctx == NULL) {
  109752:	85 c0                	test   %eax,%eax
  109754:	75 2f                	jne    109785 <zsock_accept_ctx+0x81>
		z_free_fd(fd);
  109756:	53                   	push   %ebx
  109757:	e8 22 76 ff ff       	call   100d7e <z_free_fd>
		if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10975c:	8b 45 f0             	mov    -0x10(%ebp),%eax
		z_free_fd(fd);
  10975f:	59                   	pop    %ecx
		if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  109760:	0b 45 ec             	or     -0x14(%ebp),%eax
  109763:	75 10                	jne    109775 <zsock_accept_ctx+0x71>
			errno = EAGAIN;
  109765:	e8 01 fa ff ff       	call   10916b <z_errno>
  10976a:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
  109770:	e9 eb 00 00 00       	jmp    109860 <zsock_accept_ctx+0x15c>
			errno = EINVAL;
  109775:	e8 f1 f9 ff ff       	call   10916b <z_errno>
  10977a:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
  109780:	e9 db 00 00 00       	jmp    109860 <zsock_accept_ctx+0x15c>
  109785:	6a 00                	push   $0x0
  109787:	ff 70 70             	pushl  0x70(%eax)
  10978a:	e8 d9 76 01 00       	call   120e68 <z_queue_node_peek>
  10978f:	5f                   	pop    %edi
	if (last_pkt) {
  109790:	85 c0                	test   %eax,%eax
  109792:	5a                   	pop    %edx
  109793:	74 21                	je     1097b6 <zsock_accept_ctx+0xb2>
		if (net_pkt_eof(last_pkt)) {
  109795:	f6 40 3d 02          	testb  $0x2,0x3d(%eax)
  109799:	74 1b                	je     1097b6 <zsock_accept_ctx+0xb2>
  10979b:	83 4e 68 01          	orl    $0x1,0x68(%esi)
			z_free_fd(fd);
  10979f:	53                   	push   %ebx
  1097a0:	e8 d9 75 ff ff       	call   100d7e <z_free_fd>
  1097a5:	59                   	pop    %ecx
			errno = ECONNABORTED;
  1097a6:	e8 c0 f9 ff ff       	call   10916b <z_errno>
  1097ab:	c7 00 35 00 00 00    	movl   $0x35,(%eax)
			return -1;
  1097b1:	e9 aa 00 00 00       	jmp    109860 <zsock_accept_ctx+0x15c>
	if (net_context_is_closing(ctx)) {
  1097b6:	66 8b 86 92 00 00 00 	mov    0x92(%esi),%ax
  1097bd:	f6 c4 04             	test   $0x4,%ah
  1097c0:	74 17                	je     1097d9 <zsock_accept_ctx+0xd5>
		errno = ECONNABORTED;
  1097c2:	e8 a4 f9 ff ff       	call   10916b <z_errno>
  1097c7:	c7 00 35 00 00 00    	movl   $0x35,(%eax)
		z_free_fd(fd);
  1097cd:	53                   	push   %ebx
  1097ce:	e8 ab 75 ff ff       	call   100d7e <z_free_fd>
  1097d3:	5a                   	pop    %edx
		return -1;
  1097d4:	e9 87 00 00 00       	jmp    109860 <zsock_accept_ctx+0x15c>
		context->flags &= ~NET_CONTEXT_ACCEPTING_SOCK;
  1097d9:	80 e4 fd             	and    $0xfd,%ah
  1097dc:	66 89 86 92 00 00 00 	mov    %ax,0x92(%esi)
	if (addr != NULL && addrlen != NULL) {
  1097e3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1097e7:	74 5e                	je     109847 <zsock_accept_ctx+0x143>
  1097e9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1097ed:	74 58                	je     109847 <zsock_accept_ctx+0x143>
		int len = MIN(*addrlen, sizeof(ctx->remote));
  1097ef:	8b 45 10             	mov    0x10(%ebp),%eax
  1097f2:	8b 00                	mov    (%eax),%eax
  1097f4:	83 f8 08             	cmp    $0x8,%eax
  1097f7:	76 05                	jbe    1097fe <zsock_accept_ctx+0xfa>
  1097f9:	b8 08 00 00 00       	mov    $0x8,%eax
		memcpy(addr, &ctx->remote, len);
  1097fe:	50                   	push   %eax
  1097ff:	8d 46 2c             	lea    0x2c(%esi),%eax
  109802:	50                   	push   %eax
  109803:	ff 75 0c             	pushl  0xc(%ebp)
  109806:	e8 e1 25 00 00       	call   10bdec <memcpy>
		if (ctx->remote.sa_family == AF_INET) {
  10980b:	8b 46 2c             	mov    0x2c(%esi),%eax
		memcpy(addr, &ctx->remote, len);
  10980e:	83 c4 0c             	add    $0xc,%esp
		if (ctx->remote.sa_family == AF_INET) {
  109811:	66 83 f8 01          	cmp    $0x1,%ax
  109815:	75 0b                	jne    109822 <zsock_accept_ctx+0x11e>
			*addrlen = sizeof(struct sockaddr_in);
  109817:	8b 45 10             	mov    0x10(%ebp),%eax
  10981a:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
  109820:	eb 25                	jmp    109847 <zsock_accept_ctx+0x143>
		} else if (ctx->remote.sa_family == AF_INET6) {
  109822:	66 83 f8 02          	cmp    $0x2,%ax
  109826:	75 0b                	jne    109833 <zsock_accept_ctx+0x12f>
			*addrlen = sizeof(struct sockaddr_in6);
  109828:	8b 45 10             	mov    0x10(%ebp),%eax
  10982b:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
  109831:	eb 14                	jmp    109847 <zsock_accept_ctx+0x143>
			z_free_fd(fd);
  109833:	53                   	push   %ebx
  109834:	e8 45 75 ff ff       	call   100d7e <z_free_fd>
  109839:	58                   	pop    %eax
			errno = ENOTSUP;
  10983a:	e8 2c f9 ff ff       	call   10916b <z_errno>
  10983f:	c7 00 23 00 00 00    	movl   $0x23,(%eax)
			return -1;
  109845:	eb 19                	jmp    109860 <zsock_accept_ctx+0x15c>
	net_context_ref(ctx);
  109847:	56                   	push   %esi
  109848:	e8 c1 54 00 00       	call   10ed0e <net_context_ref>
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
  10984d:	c7 04 24 40 36 12 00 	movl   $0x123640,(%esp)
  109854:	56                   	push   %esi
  109855:	53                   	push   %ebx
  109856:	e8 08 75 ff ff       	call   100d63 <z_finalize_fd>
  10985b:	83 c4 0c             	add    $0xc,%esp
	return fd;
  10985e:	eb 03                	jmp    109863 <zsock_accept_ctx+0x15f>
		return -1;
  109860:	83 cb ff             	or     $0xffffffff,%ebx
}
  109863:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109866:	89 d8                	mov    %ebx,%eax
  109868:	5b                   	pop    %ebx
  109869:	5e                   	pop    %esi
  10986a:	5f                   	pop    %edi
  10986b:	5d                   	pop    %ebp
  10986c:	c3                   	ret    

0010986d <sock_accept_vmeth>:
	return zsock_accept_ctx(obj, addr, addrlen);
  10986d:	e9 92 fe ff ff       	jmp    109704 <zsock_accept_ctx>

00109872 <zsock_sendto_ctx>:
{
  109872:	55                   	push   %ebp
  109873:	89 e5                	mov    %esp,%ebp
  109875:	57                   	push   %edi
  109876:	56                   	push   %esi
  109877:	53                   	push   %ebx
  109878:	83 ec 10             	sub    $0x10,%esp
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
  10987b:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
{
  10987f:	8b 75 08             	mov    0x8(%ebp),%esi
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
  109882:	75 26                	jne    1098aa <zsock_sendto_ctx+0x38>
  109884:	f6 46 68 02          	testb  $0x2,0x68(%esi)
  109888:	75 20                	jne    1098aa <zsock_sendto_ctx+0x38>
		buf_timeout = z_timeout_end_calc(MAX_WAIT_BUFS);
  10988a:	6a 00                	push   $0x0
	k_timeout_t timeout = K_FOREVER;
  10988c:	83 cf ff             	or     $0xffffffff,%edi
		buf_timeout = z_timeout_end_calc(MAX_WAIT_BUFS);
  10988f:	68 e8 03 00 00       	push   $0x3e8
  109894:	e8 f3 8a 01 00       	call   12238c <z_timeout_end_calc>
  109899:	59                   	pop    %ecx
  10989a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10989d:	5b                   	pop    %ebx
  10989e:	89 55 e8             	mov    %edx,-0x18(%ebp)
	k_timeout_t timeout = K_FOREVER;
  1098a1:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
  1098a8:	eb 17                	jmp    1098c1 <zsock_sendto_ctx+0x4f>
		timeout = K_NO_WAIT;
  1098aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1098b1:	31 ff                	xor    %edi,%edi
	uint64_t buf_timeout = 0;
  1098b3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1098ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	status = net_context_recv(ctx, zsock_received_cb,
  1098c1:	ff 36                	pushl  (%esi)
  1098c3:	6a 00                	push   $0x0
  1098c5:	6a 00                	push   $0x0
  1098c7:	68 f4 92 10 00       	push   $0x1092f4
  1098cc:	56                   	push   %esi
  1098cd:	e8 a8 5c 00 00       	call   10f57a <net_context_recv>
  1098d2:	83 c4 14             	add    $0x14,%esp
  1098d5:	89 c3                	mov    %eax,%ebx
	if (status < 0) {
  1098d7:	85 c0                	test   %eax,%eax
  1098d9:	79 66                	jns    109941 <zsock_sendto_ctx+0xcf>
		errno = -status;
  1098db:	e8 8b f8 ff ff       	call   10916b <z_errno>
  1098e0:	e9 ab 00 00 00       	jmp    109990 <zsock_sendto_ctx+0x11e>
			status = net_context_send(ctx, buf, len, NULL, timeout,
  1098e5:	51                   	push   %ecx
  1098e6:	57                   	push   %edi
  1098e7:	50                   	push   %eax
  1098e8:	6a 00                	push   $0x0
  1098ea:	ff 75 10             	pushl  0x10(%ebp)
  1098ed:	ff 75 0c             	pushl  0xc(%ebp)
  1098f0:	56                   	push   %esi
  1098f1:	e8 88 5b 00 00       	call   10f47e <net_context_send>
  1098f6:	83 c4 1c             	add    $0x1c,%esp
  1098f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (status < 0) {
  1098fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  109900:	0f 89 95 00 00 00    	jns    10999b <zsock_sendto_ctx+0x129>
			if (((status == -ENOBUFS) || (status == -EAGAIN)) &&
  109906:	83 7d f0 c9          	cmpl   $0xffffffc9,-0x10(%ebp)
  10990a:	0f 94 c2             	sete   %dl
  10990d:	83 7d f0 f5          	cmpl   $0xfffffff5,-0x10(%ebp)
  109911:	0f 94 c0             	sete   %al
  109914:	08 c2                	or     %al,%dl
  109916:	74 70                	je     109988 <zsock_sendto_ctx+0x116>
  109918:	85 7d ec             	test   %edi,-0x14(%ebp)
  10991b:	74 6b                	je     109988 <zsock_sendto_ctx+0x116>
				int64_t remaining = buf_timeout - z_tick_get();
  10991d:	e8 37 8a 01 00       	call   122359 <z_tick_get>
  109922:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  109925:	29 c1                	sub    %eax,%ecx
  109927:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  10992a:	19 d3                	sbb    %edx,%ebx
  10992c:	89 c8                	mov    %ecx,%eax
				if (remaining <= 0) {
  10992e:	31 c9                	xor    %ecx,%ecx
  109930:	39 c1                	cmp    %eax,%ecx
  109932:	19 d9                	sbb    %ebx,%ecx
  109934:	7d 32                	jge    109968 <zsock_sendto_ctx+0xf6>
	return z_impl_k_sleep(timeout);
  109936:	6a 00                	push   $0x0
  109938:	6a 0a                	push   $0xa
  10993a:	e8 d4 7e 01 00       	call   121813 <z_impl_k_sleep>
  10993f:	58                   	pop    %eax
  109940:	5a                   	pop    %edx
		if (dest_addr) {
  109941:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  109945:	8b 0e                	mov    (%esi),%ecx
			status = net_context_sendto(ctx, buf, len, dest_addr,
  109947:	8b 45 ec             	mov    -0x14(%ebp),%eax
		if (dest_addr) {
  10994a:	74 99                	je     1098e5 <zsock_sendto_ctx+0x73>
			status = net_context_sendto(ctx, buf, len, dest_addr,
  10994c:	51                   	push   %ecx
  10994d:	57                   	push   %edi
  10994e:	50                   	push   %eax
  10994f:	6a 00                	push   $0x0
  109951:	ff 75 1c             	pushl  0x1c(%ebp)
  109954:	ff 75 18             	pushl  0x18(%ebp)
  109957:	ff 75 10             	pushl  0x10(%ebp)
  10995a:	ff 75 0c             	pushl  0xc(%ebp)
  10995d:	56                   	push   %esi
  10995e:	e8 d0 5b 00 00       	call   10f533 <net_context_sendto>
  109963:	83 c4 24             	add    $0x24,%esp
  109966:	eb 91                	jmp    1098f9 <zsock_sendto_ctx+0x87>
					if (status == -ENOBUFS) {
  109968:	83 7d f0 c9          	cmpl   $0xffffffc9,-0x10(%ebp)
  10996c:	75 0d                	jne    10997b <zsock_sendto_ctx+0x109>
						errno = ENOMEM;
  10996e:	e8 f8 f7 ff ff       	call   10916b <z_errno>
  109973:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
  109979:	eb 19                	jmp    109994 <zsock_sendto_ctx+0x122>
						errno = ENOBUFS;
  10997b:	e8 eb f7 ff ff       	call   10916b <z_errno>
  109980:	c7 00 37 00 00 00    	movl   $0x37,(%eax)
					return -1;
  109986:	eb 0c                	jmp    109994 <zsock_sendto_ctx+0x122>
				errno = -status;
  109988:	e8 de f7 ff ff       	call   10916b <z_errno>
  10998d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  109990:	f7 db                	neg    %ebx
  109992:	89 18                	mov    %ebx,(%eax)
				return -1;
  109994:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
}
  10999b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10999e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1099a1:	5b                   	pop    %ebx
  1099a2:	5e                   	pop    %esi
  1099a3:	5f                   	pop    %edi
  1099a4:	5d                   	pop    %ebp
  1099a5:	c3                   	ret    

001099a6 <sock_sendto_vmeth>:
	return zsock_sendto_ctx(obj, buf, len, flags, dest_addr, addrlen);
  1099a6:	e9 c7 fe ff ff       	jmp    109872 <zsock_sendto_ctx>

001099ab <sock_write_vmeth>:
{
  1099ab:	55                   	push   %ebp
  1099ac:	89 e5                	mov    %esp,%ebp
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
  1099ae:	6a 00                	push   $0x0
  1099b0:	6a 00                	push   $0x0
  1099b2:	6a 00                	push   $0x0
  1099b4:	ff 75 10             	pushl  0x10(%ebp)
  1099b7:	ff 75 0c             	pushl  0xc(%ebp)
  1099ba:	ff 75 08             	pushl  0x8(%ebp)
  1099bd:	e8 b0 fe ff ff       	call   109872 <zsock_sendto_ctx>
  1099c2:	83 c4 18             	add    $0x18,%esp
}
  1099c5:	c9                   	leave  
  1099c6:	c3                   	ret    

001099c7 <z_impl_zsock_sendto>:
{
  1099c7:	55                   	push   %ebp
  1099c8:	89 e5                	mov    %esp,%ebp
  1099ca:	50                   	push   %eax
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
  1099cb:	8d 55 fc             	lea    -0x4(%ebp),%edx
  1099ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1099d1:	e8 ba f8 ff ff       	call   109290 <get_sock_vtable>
  1099d6:	85 c0                	test   %eax,%eax
  1099d8:	74 0a                	je     1099e4 <z_impl_zsock_sendto+0x1d>
  1099da:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1099dd:	8b 52 20             	mov    0x20(%edx),%edx
  1099e0:	85 d2                	test   %edx,%edx
  1099e2:	75 10                	jne    1099f4 <z_impl_zsock_sendto+0x2d>
  1099e4:	e8 82 f7 ff ff       	call   10916b <z_errno>
  1099e9:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
  1099ef:	83 c8 ff             	or     $0xffffffff,%eax
  1099f2:	eb 15                	jmp    109a09 <z_impl_zsock_sendto+0x42>
  1099f4:	ff 75 1c             	pushl  0x1c(%ebp)
  1099f7:	ff 75 18             	pushl  0x18(%ebp)
  1099fa:	ff 75 14             	pushl  0x14(%ebp)
  1099fd:	ff 75 10             	pushl  0x10(%ebp)
  109a00:	ff 75 0c             	pushl  0xc(%ebp)
  109a03:	50                   	push   %eax
  109a04:	ff d2                	call   *%edx
  109a06:	83 c4 18             	add    $0x18,%esp
}
  109a09:	c9                   	leave  
  109a0a:	c3                   	ret    

00109a0b <zsock_sendmsg_ctx>:
{
  109a0b:	55                   	push   %ebp
  109a0c:	89 e5                	mov    %esp,%ebp
  109a0e:	53                   	push   %ebx
  109a0f:	8b 55 10             	mov    0x10(%ebp),%edx
  109a12:	8b 45 08             	mov    0x8(%ebp),%eax
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
  109a15:	f6 c2 40             	test   $0x40,%dl
  109a18:	75 0b                	jne    109a25 <zsock_sendmsg_ctx+0x1a>
  109a1a:	83 c9 ff             	or     $0xffffffff,%ecx
  109a1d:	f6 40 68 02          	testb  $0x2,0x68(%eax)
  109a21:	89 cb                	mov    %ecx,%ebx
  109a23:	74 04                	je     109a29 <zsock_sendmsg_ctx+0x1e>
		timeout = K_NO_WAIT;
  109a25:	31 c9                	xor    %ecx,%ecx
  109a27:	31 db                	xor    %ebx,%ebx
	status = net_context_sendmsg(ctx, msg, flags, NULL, timeout, NULL);
  109a29:	6a 00                	push   $0x0
  109a2b:	53                   	push   %ebx
  109a2c:	51                   	push   %ecx
  109a2d:	6a 00                	push   $0x0
  109a2f:	52                   	push   %edx
  109a30:	ff 75 0c             	pushl  0xc(%ebp)
  109a33:	50                   	push   %eax
  109a34:	e8 b6 5a 00 00       	call   10f4ef <net_context_sendmsg>
  109a39:	83 c4 1c             	add    $0x1c,%esp
  109a3c:	89 c3                	mov    %eax,%ebx
	if (status < 0) {
  109a3e:	85 c0                	test   %eax,%eax
  109a40:	79 0c                	jns    109a4e <zsock_sendmsg_ctx+0x43>
		errno = -status;
  109a42:	e8 24 f7 ff ff       	call   10916b <z_errno>
  109a47:	f7 db                	neg    %ebx
  109a49:	89 18                	mov    %ebx,(%eax)
		return -1;
  109a4b:	83 cb ff             	or     $0xffffffff,%ebx
}
  109a4e:	89 d8                	mov    %ebx,%eax
  109a50:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  109a53:	c9                   	leave  
  109a54:	c3                   	ret    

00109a55 <sock_sendmsg_vmeth>:
	return zsock_sendmsg_ctx(obj, msg, flags);
  109a55:	e9 b1 ff ff ff       	jmp    109a0b <zsock_sendmsg_ctx>

00109a5a <zsock_recvfrom_ctx>:
{
  109a5a:	55                   	push   %ebp
  109a5b:	89 e5                	mov    %esp,%ebp
  109a5d:	57                   	push   %edi
  109a5e:	56                   	push   %esi
  109a5f:	53                   	push   %ebx
		return 0;
  109a60:	31 db                	xor    %ebx,%ebx
{
  109a62:	83 ec 34             	sub    $0x34,%esp
	if (max_len == 0) {
  109a65:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
{
  109a69:	8b 75 08             	mov    0x8(%ebp),%esi
	if (max_len == 0) {
  109a6c:	0f 84 c5 03 00 00    	je     109e37 <zsock_recvfrom_ctx+0x3dd>
	enum net_sock_type sock_type = net_context_get_type(ctx);
  109a72:	66 8b 96 92 00 00 00 	mov    0x92(%esi),%dx
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
  109a79:	89 d0                	mov    %edx,%eax
  109a7b:	c1 e8 06             	shr    $0x6,%eax
  109a7e:	83 e0 03             	and    $0x3,%eax
	if (sock_type == SOCK_DGRAM) {
  109a81:	83 f8 02             	cmp    $0x2,%eax
  109a84:	0f 85 5e 02 00 00    	jne    109ce8 <zsock_recvfrom_ctx+0x28e>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
  109a8a:	f6 45 14 40          	testb  $0x40,0x14(%ebp)
		timeout = K_NO_WAIT;
  109a8e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  109a95:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
  109a9c:	75 1c                	jne    109aba <zsock_recvfrom_ctx+0x60>
  109a9e:	8b 46 68             	mov    0x68(%esi),%eax
  109aa1:	31 db                	xor    %ebx,%ebx
  109aa3:	d1 e8                	shr    %eax
  109aa5:	83 f0 01             	xor    $0x1,%eax
  109aa8:	83 e0 01             	and    $0x1,%eax
  109aab:	89 c1                	mov    %eax,%ecx
  109aad:	f7 d9                	neg    %ecx
  109aaf:	83 d3 00             	adc    $0x0,%ebx
  109ab2:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  109ab5:	f7 db                	neg    %ebx
  109ab7:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
	if (flags & ZSOCK_MSG_PEEK) {
  109aba:	8b 45 14             	mov    0x14(%ebp),%eax
  109abd:	8d 56 6c             	lea    0x6c(%esi),%edx
  109ac0:	83 e0 02             	and    $0x2,%eax
  109ac3:	89 45 cc             	mov    %eax,-0x34(%ebp)
  109ac6:	74 48                	je     109b10 <zsock_recvfrom_ctx+0xb6>
	struct k_poll_event events[] = {
  109ac8:	8d 7d e0             	lea    -0x20(%ebp),%edi
  109acb:	31 c0                	xor    %eax,%eax
  109acd:	b9 04 00 00 00       	mov    $0x4,%ecx
  109ad2:	f3 ab                	rep stos %eax,%es:(%edi)
  109ad4:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
  109ad8:	89 55 f0             	mov    %edx,-0x10(%ebp)
	return z_impl_k_poll(events, num_events, timeout);
  109adb:	ff 75 d4             	pushl  -0x2c(%ebp)
  109ade:	ff 75 d0             	pushl  -0x30(%ebp)
  109ae1:	8d 45 e0             	lea    -0x20(%ebp),%eax
  109ae4:	6a 01                	push   $0x1
  109ae6:	50                   	push   %eax
  109ae7:	e8 8f 8e 01 00       	call   12297b <z_impl_k_poll>
  109aec:	89 c3                	mov    %eax,%ebx
  109aee:	83 c4 10             	add    $0x10,%esp
		if (res && res != -EAGAIN && res != -EINTR) {
  109af1:	8d 40 04             	lea    0x4(%eax),%eax
  109af4:	83 e0 fb             	and    $0xfffffffb,%eax
  109af7:	74 09                	je     109b02 <zsock_recvfrom_ctx+0xa8>
  109af9:	83 fb f5             	cmp    $0xfffffff5,%ebx
  109afc:	0f 85 70 02 00 00    	jne    109d72 <zsock_recvfrom_ctx+0x318>
	return z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
  109b02:	6a 00                	push   $0x0
  109b04:	ff 76 6c             	pushl  0x6c(%esi)
  109b07:	e8 5c 73 01 00       	call   120e68 <z_queue_node_peek>
  109b0c:	5f                   	pop    %edi
  109b0d:	5a                   	pop    %edx
  109b0e:	eb 0f                	jmp    109b1f <zsock_recvfrom_ctx+0xc5>
	return z_impl_k_queue_get(queue, timeout);
  109b10:	ff 75 d4             	pushl  -0x2c(%ebp)
  109b13:	ff 75 d0             	pushl  -0x30(%ebp)
  109b16:	52                   	push   %edx
  109b17:	e8 3b 74 01 00       	call   120f57 <z_impl_k_queue_get>
  109b1c:	83 c4 0c             	add    $0xc,%esp
  109b1f:	89 c7                	mov    %eax,%edi
	if (!pkt) {
  109b21:	85 c0                	test   %eax,%eax
  109b23:	75 13                	jne    109b38 <zsock_recvfrom_ctx+0xde>
		errno = EAGAIN;
  109b25:	e8 41 f6 ff ff       	call   10916b <z_errno>
  109b2a:	c7 00 0b 00 00 00    	movl   $0xb,(%eax)
		return -1;
  109b30:	83 cb ff             	or     $0xffffffff,%ebx
  109b33:	e9 ff 02 00 00       	jmp    109e37 <zsock_recvfrom_ctx+0x3dd>
 * @param backup The cursor where to backup net_pkt cursor
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
  109b38:	8b 40 14             	mov    0x14(%eax),%eax
  109b3b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	backup->pos = pkt->cursor.pos;
  109b3e:	8b 47 18             	mov    0x18(%edi),%eax
	if (src_addr && addrlen) {
  109b41:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  109b45:	89 45 c8             	mov    %eax,-0x38(%ebp)
  109b48:	0f 84 3c 01 00 00    	je     109c8a <zsock_recvfrom_ctx+0x230>
  109b4e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  109b52:	0f 84 32 01 00 00    	je     109c8a <zsock_recvfrom_ctx+0x230>
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
  109b58:	8b 45 1c             	mov    0x1c(%ebp),%eax
  109b5b:	8b 18                	mov    (%eax),%ebx
  109b5d:	66 8b 86 90 00 00 00 	mov    0x90(%esi),%ax
  109b64:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
	net_pkt_cursor_init(pkt);
  109b68:	57                   	push   %edi
  109b69:	e8 7c 60 00 00       	call   10fbea <net_pkt_cursor_init>
	return pkt->family;
  109b6e:	8a 47 3f             	mov    0x3f(%edi),%al
  109b71:	d0 e8                	shr    %al
	addr->sa_family = net_pkt_family(pkt);
  109b73:	8b 55 18             	mov    0x18(%ebp),%edx
  109b76:	83 e0 07             	and    $0x7,%eax
	net_pkt_cursor_init(pkt);
  109b79:	5e                   	pop    %esi
	addr->sa_family = net_pkt_family(pkt);
  109b7a:	0f b6 c8             	movzbl %al,%ecx
  109b7d:	66 89 0a             	mov    %cx,(%edx)
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
  109b80:	fe c8                	dec    %al
  109b82:	74 0a                	je     109b8e <zsock_recvfrom_ctx+0x134>
		ret = -ENOTSUP;
  109b84:	be dd ff ff ff       	mov    $0xffffffdd,%esi
  109b89:	e9 aa 00 00 00       	jmp    109c38 <zsock_recvfrom_ctx+0x1de>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
  109b8e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  109b95:	c7 45 e4 14 00 00 00 	movl   $0x14,-0x1c(%ebp)
			ret = -EINVAL;
  109b9c:	be ea ff ff ff       	mov    $0xffffffea,%esi
		if (addrlen < sizeof(struct sockaddr_in)) {
  109ba1:	83 fb 07             	cmp    $0x7,%ebx
  109ba4:	0f 86 8e 00 00 00    	jbe    109c38 <zsock_recvfrom_ctx+0x1de>
		ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(
  109baa:	8d 45 e0             	lea    -0x20(%ebp),%eax
  109bad:	50                   	push   %eax
  109bae:	57                   	push   %edi
  109baf:	e8 a1 68 00 00       	call   110455 <net_pkt_get_data>
  109bb4:	5a                   	pop    %edx
  109bb5:	89 c3                	mov    %eax,%ebx
  109bb7:	59                   	pop    %ecx
		if (!ipv4_hdr ||
  109bb8:	85 c0                	test   %eax,%eax
  109bba:	74 6b                	je     109c27 <zsock_recvfrom_ctx+0x1cd>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
  109bbc:	ff 75 e4             	pushl  -0x1c(%ebp)
  109bbf:	57                   	push   %edi
  109bc0:	e8 46 64 00 00       	call   11000b <net_pkt_skip>
  109bc5:	59                   	pop    %ecx
  109bc6:	85 c0                	test   %eax,%eax
  109bc8:	5e                   	pop    %esi
  109bc9:	75 5c                	jne    109c27 <zsock_recvfrom_ctx+0x1cd>
		    net_pkt_skip(pkt, net_pkt_ipv4_opts_len(pkt))) {
  109bcb:	0f b6 47 43          	movzbl 0x43(%edi),%eax
  109bcf:	50                   	push   %eax
  109bd0:	57                   	push   %edi
  109bd1:	e8 35 64 00 00       	call   11000b <net_pkt_skip>
  109bd6:	5e                   	pop    %esi
		    net_pkt_acknowledge_data(pkt, &ipv4_access) ||
  109bd7:	85 c0                	test   %eax,%eax
		    net_pkt_skip(pkt, net_pkt_ipv4_opts_len(pkt))) {
  109bd9:	5a                   	pop    %edx
  109bda:	89 c6                	mov    %eax,%esi
		    net_pkt_acknowledge_data(pkt, &ipv4_access) ||
  109bdc:	75 49                	jne    109c27 <zsock_recvfrom_ctx+0x1cd>
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
  109bde:	8b 55 18             	mov    0x18(%ebp),%edx
  109be1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
  109be4:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
  109be8:	66 83 7d c4 11       	cmpw   $0x11,-0x3c(%ebp)
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
  109bed:	89 5a 04             	mov    %ebx,0x4(%edx)
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
  109bf0:	75 0f                	jne    109c01 <zsock_recvfrom_ctx+0x1a7>
		NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  109bf2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  109bf5:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  109bfc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  109bff:	eb 16                	jmp    109c17 <zsock_recvfrom_ctx+0x1bd>
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
  109c01:	83 f8 06             	cmp    $0x6,%eax
  109c04:	0f 85 7a ff ff ff    	jne    109b84 <zsock_recvfrom_ctx+0x12a>
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
  109c0a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  109c0d:	c7 45 dc 14 00 00 00 	movl   $0x14,-0x24(%ebp)
  109c14:	89 45 d8             	mov    %eax,-0x28(%ebp)
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
  109c17:	8d 45 d8             	lea    -0x28(%ebp),%eax
  109c1a:	50                   	push   %eax
  109c1b:	57                   	push   %edi
  109c1c:	e8 34 68 00 00       	call   110455 <net_pkt_get_data>
  109c21:	5a                   	pop    %edx
		if (!tcp_hdr) {
  109c22:	85 c0                	test   %eax,%eax
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
  109c24:	59                   	pop    %ecx
		if (!tcp_hdr) {
  109c25:	75 07                	jne    109c2e <zsock_recvfrom_ctx+0x1d4>
			ret = -ENOBUFS;
  109c27:	be c9 ff ff ff       	mov    $0xffffffc9,%esi
  109c2c:	eb 0a                	jmp    109c38 <zsock_recvfrom_ctx+0x1de>
		*port = tcp_hdr->src_port;
  109c2e:	8b 55 18             	mov    0x18(%ebp),%edx
  109c31:	66 8b 00             	mov    (%eax),%ax
  109c34:	66 89 42 02          	mov    %ax,0x2(%edx)
	pkt->cursor.buf = backup->buf;
  109c38:	8b 45 d0             	mov    -0x30(%ebp),%eax
		if (rv < 0) {
  109c3b:	85 f6                	test   %esi,%esi
  109c3d:	89 47 14             	mov    %eax,0x14(%edi)
	pkt->cursor.pos = backup->pos;
  109c40:	8b 45 c8             	mov    -0x38(%ebp),%eax
  109c43:	89 47 18             	mov    %eax,0x18(%edi)
  109c46:	74 0d                	je     109c55 <zsock_recvfrom_ctx+0x1fb>
			errno = -rv;
  109c48:	e8 1e f5 ff ff       	call   10916b <z_errno>
  109c4d:	89 f1                	mov    %esi,%ecx
  109c4f:	f7 d9                	neg    %ecx
  109c51:	89 08                	mov    %ecx,(%eax)
			goto fail;
  109c53:	eb 7a                	jmp    109ccf <zsock_recvfrom_ctx+0x275>
		if (src_addr->sa_family == AF_INET) {
  109c55:	8b 45 18             	mov    0x18(%ebp),%eax
  109c58:	66 8b 00             	mov    (%eax),%ax
  109c5b:	66 83 f8 01          	cmp    $0x1,%ax
  109c5f:	75 0b                	jne    109c6c <zsock_recvfrom_ctx+0x212>
			*addrlen = sizeof(struct sockaddr_in);
  109c61:	8b 45 1c             	mov    0x1c(%ebp),%eax
  109c64:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
  109c6a:	eb 1e                	jmp    109c8a <zsock_recvfrom_ctx+0x230>
		} else if (src_addr->sa_family == AF_INET6) {
  109c6c:	66 83 f8 02          	cmp    $0x2,%ax
  109c70:	75 0b                	jne    109c7d <zsock_recvfrom_ctx+0x223>
			*addrlen = sizeof(struct sockaddr_in6);
  109c72:	8b 45 1c             	mov    0x1c(%ebp),%eax
  109c75:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
  109c7b:	eb 0d                	jmp    109c8a <zsock_recvfrom_ctx+0x230>
			errno = ENOTSUP;
  109c7d:	e8 e9 f4 ff ff       	call   10916b <z_errno>
  109c82:	c7 00 23 00 00 00    	movl   $0x23,(%eax)
			goto fail;
  109c88:	eb 45                	jmp    109ccf <zsock_recvfrom_ctx+0x275>
	recv_len = net_pkt_remaining_data(pkt);
  109c8a:	57                   	push   %edi
  109c8b:	e8 e6 64 00 00       	call   110176 <net_pkt_remaining_data>
  109c90:	5b                   	pop    %ebx
	if (recv_len > max_len) {
  109c91:	8b 5d 10             	mov    0x10(%ebp),%ebx
  109c94:	39 c3                	cmp    %eax,%ebx
  109c96:	76 02                	jbe    109c9a <zsock_recvfrom_ctx+0x240>
  109c98:	89 c3                	mov    %eax,%ebx
	if (net_pkt_read(pkt, buf, recv_len)) {
  109c9a:	53                   	push   %ebx
  109c9b:	ff 75 0c             	pushl  0xc(%ebp)
  109c9e:	57                   	push   %edi
  109c9f:	e8 9f 63 00 00       	call   110043 <net_pkt_read>
  109ca4:	83 c4 0c             	add    $0xc,%esp
  109ca7:	85 c0                	test   %eax,%eax
  109ca9:	74 0d                	je     109cb8 <zsock_recvfrom_ctx+0x25e>
		errno = ENOBUFS;
  109cab:	e8 bb f4 ff ff       	call   10916b <z_errno>
  109cb0:	c7 00 37 00 00 00    	movl   $0x37,(%eax)
		goto fail;
  109cb6:	eb 17                	jmp    109ccf <zsock_recvfrom_ctx+0x275>
	if (!(flags & ZSOCK_MSG_PEEK)) {
  109cb8:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  109cbc:	74 1e                	je     109cdc <zsock_recvfrom_ctx+0x282>
	pkt->cursor.buf = backup->buf;
  109cbe:	8b 45 d0             	mov    -0x30(%ebp),%eax
  109cc1:	89 47 14             	mov    %eax,0x14(%edi)
	pkt->cursor.pos = backup->pos;
  109cc4:	8b 45 c8             	mov    -0x38(%ebp),%eax
  109cc7:	89 47 18             	mov    %eax,0x18(%edi)
	return recv_len;
  109cca:	e9 68 01 00 00       	jmp    109e37 <zsock_recvfrom_ctx+0x3dd>
	return -1;
  109ccf:	83 cb ff             	or     $0xffffffff,%ebx
	if (!(flags & ZSOCK_MSG_PEEK)) {
  109cd2:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  109cd6:	0f 85 5b 01 00 00    	jne    109e37 <zsock_recvfrom_ctx+0x3dd>
		net_pkt_unref(pkt);
  109cdc:	57                   	push   %edi
  109cdd:	e8 9a 5d 00 00       	call   10fa7c <net_pkt_unref>
  109ce2:	59                   	pop    %ecx
  109ce3:	e9 4f 01 00 00       	jmp    109e37 <zsock_recvfrom_ctx+0x3dd>
		return 0;
  109ce8:	31 db                	xor    %ebx,%ebx
	} else if (sock_type == SOCK_STREAM) {
  109cea:	48                   	dec    %eax
  109ceb:	0f 85 46 01 00 00    	jne    109e37 <zsock_recvfrom_ctx+0x3dd>
	if (!net_context_is_used(ctx)) {
  109cf1:	80 e2 01             	and    $0x1,%dl
  109cf4:	75 10                	jne    109d06 <zsock_recvfrom_ctx+0x2ac>
		errno = EBADF;
  109cf6:	e8 70 f4 ff ff       	call   10916b <z_errno>
  109cfb:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
		return -1;
  109d01:	e9 2a fe ff ff       	jmp    109b30 <zsock_recvfrom_ctx+0xd6>

static inline uintptr_t sock_get_flag(struct net_context *ctx, uintptr_t mask)
{
	return POINTER_TO_UINT(ctx->socket_data) & mask;
  109d06:	8b 46 68             	mov    0x68(%esi),%eax
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
  109d09:	8b 55 14             	mov    0x14(%ebp),%edx
  109d0c:	83 e0 02             	and    $0x2,%eax
  109d0f:	83 e2 40             	and    $0x40,%edx
  109d12:	09 d0                	or     %edx,%eax
  109d14:	0f 94 c0             	sete   %al
  109d17:	0f b6 c0             	movzbl %al,%eax
  109d1a:	31 d2                	xor    %edx,%edx
  109d1c:	f7 d8                	neg    %eax
  109d1e:	83 d2 00             	adc    $0x0,%edx
  109d21:	89 45 d0             	mov    %eax,-0x30(%ebp)
  109d24:	f7 da                	neg    %edx
  109d26:	89 55 d4             	mov    %edx,-0x2c(%ebp)
		if (sock_is_eof(ctx)) {
  109d29:	8b 46 68             	mov    0x68(%esi),%eax
  109d2c:	83 e0 01             	and    $0x1,%eax
  109d2f:	74 07                	je     109d38 <zsock_recvfrom_ctx+0x2de>
			return 0;
  109d31:	31 db                	xor    %ebx,%ebx
  109d33:	e9 ff 00 00 00       	jmp    109e37 <zsock_recvfrom_ctx+0x3dd>
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
  109d38:	8d 56 6c             	lea    0x6c(%esi),%edx
	struct k_poll_event events[] = {
  109d3b:	8d 7d e0             	lea    -0x20(%ebp),%edi
  109d3e:	b9 04 00 00 00       	mov    $0x4,%ecx
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
  109d43:	89 55 cc             	mov    %edx,-0x34(%ebp)
	struct k_poll_event events[] = {
  109d46:	f3 ab                	rep stos %eax,%es:(%edi)
  109d48:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
  109d4c:	89 55 f0             	mov    %edx,-0x10(%ebp)
	return z_impl_k_poll(events, num_events, timeout);
  109d4f:	ff 75 d4             	pushl  -0x2c(%ebp)
  109d52:	ff 75 d0             	pushl  -0x30(%ebp)
  109d55:	8d 45 e0             	lea    -0x20(%ebp),%eax
  109d58:	6a 01                	push   $0x1
  109d5a:	50                   	push   %eax
  109d5b:	e8 1b 8c 01 00       	call   12297b <z_impl_k_poll>
  109d60:	89 c3                	mov    %eax,%ebx
  109d62:	83 c4 10             	add    $0x10,%esp
		if (res && res != -EAGAIN && res != -EINTR) {
  109d65:	8d 40 04             	lea    0x4(%eax),%eax
  109d68:	83 e0 fb             	and    $0xfffffffb,%eax
  109d6b:	74 13                	je     109d80 <zsock_recvfrom_ctx+0x326>
  109d6d:	83 fb f5             	cmp    $0xfffffff5,%ebx
  109d70:	74 0e                	je     109d80 <zsock_recvfrom_ctx+0x326>
			errno = -res;
  109d72:	e8 f4 f3 ff ff       	call   10916b <z_errno>
  109d77:	f7 db                	neg    %ebx
  109d79:	89 18                	mov    %ebx,(%eax)
			return -1;
  109d7b:	e9 b0 fd ff ff       	jmp    109b30 <zsock_recvfrom_ctx+0xd6>
  109d80:	6a 00                	push   $0x0
  109d82:	ff 76 6c             	pushl  0x6c(%esi)
  109d85:	e8 de 70 01 00       	call   120e68 <z_queue_node_peek>
  109d8a:	5f                   	pop    %edi
		if (!pkt) {
  109d8b:	85 c0                	test   %eax,%eax
  109d8d:	5a                   	pop    %edx
  109d8e:	89 c7                	mov    %eax,%edi
  109d90:	75 0b                	jne    109d9d <zsock_recvfrom_ctx+0x343>
			if (sock_is_eof(ctx)) {
  109d92:	f6 46 68 01          	testb  $0x1,0x68(%esi)
  109d96:	75 99                	jne    109d31 <zsock_recvfrom_ctx+0x2d7>
  109d98:	e9 88 fd ff ff       	jmp    109b25 <zsock_recvfrom_ctx+0xcb>
	backup->buf = pkt->cursor.buf;
  109d9d:	8b 40 14             	mov    0x14(%eax),%eax
  109da0:	89 45 c8             	mov    %eax,-0x38(%ebp)
	backup->pos = pkt->cursor.pos;
  109da3:	8b 47 18             	mov    0x18(%edi),%eax
  109da6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		data_len = net_pkt_remaining_data(pkt);
  109da9:	57                   	push   %edi
  109daa:	e8 c7 63 00 00       	call   110176 <net_pkt_remaining_data>
  109daf:	5b                   	pop    %ebx
  109db0:	8b 5d 10             	mov    0x10(%ebp),%ebx
  109db3:	89 c1                	mov    %eax,%ecx
		if (recv_len > max_len) {
  109db5:	39 c3                	cmp    %eax,%ebx
  109db7:	76 02                	jbe    109dbb <zsock_recvfrom_ctx+0x361>
  109db9:	89 c3                	mov    %eax,%ebx
		if (net_pkt_read(pkt, buf, recv_len)) {
  109dbb:	53                   	push   %ebx
  109dbc:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  109dbf:	ff 75 0c             	pushl  0xc(%ebp)
  109dc2:	57                   	push   %edi
  109dc3:	e8 7b 62 00 00       	call   110043 <net_pkt_read>
  109dc8:	83 c4 0c             	add    $0xc,%esp
  109dcb:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  109dce:	85 c0                	test   %eax,%eax
  109dd0:	74 10                	je     109de2 <zsock_recvfrom_ctx+0x388>
			errno = ENOBUFS;
  109dd2:	e8 94 f3 ff ff       	call   10916b <z_errno>
  109dd7:	c7 00 37 00 00 00    	movl   $0x37,(%eax)
			return -1;
  109ddd:	e9 4e fd ff ff       	jmp    109b30 <zsock_recvfrom_ctx+0xd6>
		if (!(flags & ZSOCK_MSG_PEEK)) {
  109de2:	8b 45 14             	mov    0x14(%ebp),%eax
  109de5:	83 e0 02             	and    $0x2,%eax
  109de8:	89 45 c0             	mov    %eax,-0x40(%ebp)
  109deb:	75 27                	jne    109e14 <zsock_recvfrom_ctx+0x3ba>
			if (recv_len == data_len) {
  109ded:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  109df0:	72 2e                	jb     109e20 <zsock_recvfrom_ctx+0x3c6>
	return z_impl_k_queue_get(queue, timeout);
  109df2:	6a 00                	push   $0x0
  109df4:	6a 00                	push   $0x0
  109df6:	ff 75 cc             	pushl  -0x34(%ebp)
  109df9:	e8 59 71 01 00       	call   120f57 <z_impl_k_queue_get>
  109dfe:	83 c4 0c             	add    $0xc,%esp
				if (net_pkt_eof(pkt)) {
  109e01:	f6 47 3d 02          	testb  $0x2,0x3d(%edi)
  109e05:	74 04                	je     109e0b <zsock_recvfrom_ctx+0x3b1>
	val = (val & ~mask) | flag;
  109e07:	83 4e 68 01          	orl    $0x1,0x68(%esi)
				net_pkt_unref(pkt);
  109e0b:	57                   	push   %edi
  109e0c:	e8 6b 5c 00 00       	call   10fa7c <net_pkt_unref>
  109e11:	59                   	pop    %ecx
  109e12:	eb 0c                	jmp    109e20 <zsock_recvfrom_ctx+0x3c6>
	pkt->cursor.buf = backup->buf;
  109e14:	8b 45 c8             	mov    -0x38(%ebp),%eax
  109e17:	89 47 14             	mov    %eax,0x14(%edi)
	pkt->cursor.pos = backup->pos;
  109e1a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  109e1d:	89 47 18             	mov    %eax,0x18(%edi)
	} while (recv_len == 0);
  109e20:	85 db                	test   %ebx,%ebx
  109e22:	0f 84 01 ff ff ff    	je     109d29 <zsock_recvfrom_ctx+0x2cf>
	if (!(flags & ZSOCK_MSG_PEEK)) {
  109e28:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  109e2c:	75 09                	jne    109e37 <zsock_recvfrom_ctx+0x3dd>
		net_context_update_recv_wnd(ctx, recv_len);
  109e2e:	53                   	push   %ebx
  109e2f:	56                   	push   %esi
  109e30:	e8 b6 58 00 00       	call   10f6eb <net_context_update_recv_wnd>
  109e35:	58                   	pop    %eax
  109e36:	5a                   	pop    %edx
}
  109e37:	8d 65 f4             	lea    -0xc(%ebp),%esp
  109e3a:	89 d8                	mov    %ebx,%eax
  109e3c:	5b                   	pop    %ebx
  109e3d:	5e                   	pop    %esi
  109e3e:	5f                   	pop    %edi
  109e3f:	5d                   	pop    %ebp
  109e40:	c3                   	ret    

00109e41 <sock_recvfrom_vmeth>:
	return zsock_recvfrom_ctx(obj, buf, max_len, flags,
  109e41:	e9 14 fc ff ff       	jmp    109a5a <zsock_recvfrom_ctx>

00109e46 <sock_read_vmeth>:
{
  109e46:	55                   	push   %ebp
  109e47:	89 e5                	mov    %esp,%ebp
	return zsock_recvfrom_ctx(obj, buffer, count, 0, NULL, 0);
  109e49:	6a 00                	push   $0x0
  109e4b:	6a 00                	push   $0x0
  109e4d:	6a 00                	push   $0x0
  109e4f:	ff 75 10             	pushl  0x10(%ebp)
  109e52:	ff 75 0c             	pushl  0xc(%ebp)
  109e55:	ff 75 08             	pushl  0x8(%ebp)
  109e58:	e8 fd fb ff ff       	call   109a5a <zsock_recvfrom_ctx>
  109e5d:	83 c4 18             	add    $0x18,%esp
}
  109e60:	c9                   	leave  
  109e61:	c3                   	ret    

00109e62 <z_impl_zsock_recvfrom>:
{
  109e62:	55                   	push   %ebp
  109e63:	89 e5                	mov    %esp,%ebp
  109e65:	50                   	push   %eax
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
  109e66:	8d 55 fc             	lea    -0x4(%ebp),%edx
  109e69:	8b 45 08             	mov    0x8(%ebp),%eax
  109e6c:	e8 1f f4 ff ff       	call   109290 <get_sock_vtable>
  109e71:	85 c0                	test   %eax,%eax
  109e73:	74 0a                	je     109e7f <z_impl_zsock_recvfrom+0x1d>
  109e75:	8b 55 fc             	mov    -0x4(%ebp),%edx
  109e78:	8b 52 24             	mov    0x24(%edx),%edx
  109e7b:	85 d2                	test   %edx,%edx
  109e7d:	75 10                	jne    109e8f <z_impl_zsock_recvfrom+0x2d>
  109e7f:	e8 e7 f2 ff ff       	call   10916b <z_errno>
  109e84:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
  109e8a:	83 c8 ff             	or     $0xffffffff,%eax
  109e8d:	eb 15                	jmp    109ea4 <z_impl_zsock_recvfrom+0x42>
  109e8f:	ff 75 1c             	pushl  0x1c(%ebp)
  109e92:	ff 75 18             	pushl  0x18(%ebp)
  109e95:	ff 75 14             	pushl  0x14(%ebp)
  109e98:	ff 75 10             	pushl  0x10(%ebp)
  109e9b:	ff 75 0c             	pushl  0xc(%ebp)
  109e9e:	50                   	push   %eax
  109e9f:	ff d2                	call   *%edx
  109ea1:	83 c4 18             	add    $0x18,%esp
}
  109ea4:	c9                   	leave  
  109ea5:	c3                   	ret    

00109ea6 <z_impl_zsock_poll>:
{
  109ea6:	55                   	push   %ebp
  109ea7:	89 e5                	mov    %esp,%ebp
  109ea9:	57                   	push   %edi
  109eaa:	56                   	push   %esi
  109eab:	53                   	push   %ebx
  109eac:	83 ec 64             	sub    $0x64,%esp
	if (poll_timeout < 0) {
  109eaf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  109eb3:	78 1e                	js     109ed3 <z_impl_zsock_poll+0x2d>
		timeout = K_MSEC(poll_timeout);
  109eb5:	8b 45 10             	mov    0x10(%ebp),%eax
			return t / (from_hz / to_hz);
  109eb8:	6a 00                	push   $0x0
  109eba:	99                   	cltd   
		t += off;
  109ebb:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  109ebe:	6a 0a                	push   $0xa
		t += off;
  109ec0:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  109ec3:	52                   	push   %edx
  109ec4:	50                   	push   %eax
  109ec5:	e8 56 63 ff ff       	call   100220 <__udivdi3>
  109eca:	83 c4 10             	add    $0x10,%esp
  109ecd:	89 c6                	mov    %eax,%esi
  109ecf:	89 d7                	mov    %edx,%edi
  109ed1:	eb 0c                	jmp    109edf <z_impl_zsock_poll+0x39>
		timeout = K_FOREVER;
  109ed3:	83 ce ff             	or     $0xffffffff,%esi
		poll_timeout = SYS_FOREVER_MS;
  109ed6:	c7 45 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebp)
		timeout = K_FOREVER;
  109edd:	89 f7                	mov    %esi,%edi
	end = z_timeout_end_calc(timeout);
  109edf:	57                   	push   %edi
  109ee0:	56                   	push   %esi
  109ee1:	e8 a6 84 01 00       	call   12238c <z_timeout_end_calc>
  109ee6:	89 45 9c             	mov    %eax,-0x64(%ebp)
	pev = poll_events;
  109ee9:	8d 45 b8             	lea    -0x48(%ebp),%eax
  109eec:	89 45 b0             	mov    %eax,-0x50(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
  109eef:	8b 45 0c             	mov    0xc(%ebp),%eax
	end = z_timeout_end_calc(timeout);
  109ef2:	59                   	pop    %ecx
	for (pfd = fds, i = nfds; i--; pfd++) {
  109ef3:	89 45 98             	mov    %eax,-0x68(%ebp)
  109ef6:	8b 45 08             	mov    0x8(%ebp),%eax
	end = z_timeout_end_calc(timeout);
  109ef9:	5b                   	pop    %ebx
  109efa:	89 55 a0             	mov    %edx,-0x60(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
  109efd:	89 45 ac             	mov    %eax,-0x54(%ebp)
	void *offl_ctx = NULL;
  109f00:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
	const struct fd_op_vtable *offl_vtable = NULL;
  109f07:	31 c9                	xor    %ecx,%ecx
	bool offload = false;
  109f09:	c6 45 a8 00          	movb   $0x0,-0x58(%ebp)
	for (pfd = fds, i = nfds; i--; pfd++) {
  109f0d:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
  109f11:	74 77                	je     109f8a <z_impl_zsock_poll+0xe4>
		if (pfd->fd < 0) {
  109f13:	8b 45 ac             	mov    -0x54(%ebp),%eax
  109f16:	8b 00                	mov    (%eax),%eax
  109f18:	85 c0                	test   %eax,%eax
  109f1a:	78 65                	js     109f81 <z_impl_zsock_poll+0xdb>
		ctx = get_sock_vtable(pfd->fd,
  109f1c:	8d 55 b4             	lea    -0x4c(%ebp),%edx
  109f1f:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
  109f22:	e8 69 f3 ff ff       	call   109290 <get_sock_vtable>
		if (ctx == NULL) {
  109f27:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
		ctx = get_sock_vtable(pfd->fd,
  109f2a:	89 c2                	mov    %eax,%edx
		if (ctx == NULL) {
  109f2c:	85 c0                	test   %eax,%eax
  109f2e:	74 51                	je     109f81 <z_impl_zsock_poll+0xdb>
		result = z_fdtable_call_ioctl(vtable, ctx,
  109f30:	8d 45 f4             	lea    -0xc(%ebp),%eax
  109f33:	89 4d 90             	mov    %ecx,-0x70(%ebp)
  109f36:	50                   	push   %eax
  109f37:	8d 45 b0             	lea    -0x50(%ebp),%eax
  109f3a:	50                   	push   %eax
  109f3b:	89 55 94             	mov    %edx,-0x6c(%ebp)
  109f3e:	ff 75 ac             	pushl  -0x54(%ebp)
  109f41:	68 02 01 00 00       	push   $0x102
  109f46:	52                   	push   %edx
  109f47:	ff 75 b4             	pushl  -0x4c(%ebp)
  109f4a:	e8 21 f2 ff ff       	call   109170 <z_fdtable_call_ioctl>
  109f4f:	83 c4 18             	add    $0x18,%esp
  109f52:	89 c3                	mov    %eax,%ebx
		if (result == -EALREADY) {
  109f54:	83 f8 bb             	cmp    $0xffffffbb,%eax
  109f57:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  109f5a:	74 21                	je     109f7d <z_impl_zsock_poll+0xd7>
		} else if (result == -EXDEV) {
  109f5c:	83 f8 ee             	cmp    $0xffffffee,%eax
  109f5f:	8b 55 94             	mov    -0x6c(%ebp),%edx
  109f62:	75 10                	jne    109f74 <z_impl_zsock_poll+0xce>
			offload = true;
  109f64:	c6 45 a8 01          	movb   $0x1,-0x58(%ebp)
			if (offl_vtable == NULL || net_socket_is_tls(ctx)) {
  109f68:	85 c9                	test   %ecx,%ecx
  109f6a:	75 15                	jne    109f81 <z_impl_zsock_poll+0xdb>
				offl_vtable = vtable;
  109f6c:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  109f6f:	89 55 a4             	mov    %edx,-0x5c(%ebp)
  109f72:	eb 0d                	jmp    109f81 <z_impl_zsock_poll+0xdb>
		} else if (result != 0) {
  109f74:	85 c0                	test   %eax,%eax
  109f76:	74 09                	je     109f81 <z_impl_zsock_poll+0xdb>
  109f78:	e9 9a 00 00 00       	jmp    10a017 <z_impl_zsock_poll+0x171>
			timeout = K_NO_WAIT;
  109f7d:	31 f6                	xor    %esi,%esi
  109f7f:	31 ff                	xor    %edi,%edi
	for (pfd = fds, i = nfds; i--; pfd++) {
  109f81:	83 45 ac 08          	addl   $0x8,-0x54(%ebp)
  109f85:	ff 4d 98             	decl   -0x68(%ebp)
  109f88:	eb 83                	jmp    109f0d <z_impl_zsock_poll+0x67>
	if (offload) {
  109f8a:	80 7d a8 00          	cmpb   $0x0,-0x58(%ebp)
  109f8e:	74 21                	je     109fb1 <z_impl_zsock_poll+0x10b>
		return z_fdtable_call_ioctl(offl_vtable, offl_ctx,
  109f90:	ff 75 10             	pushl  0x10(%ebp)
  109f93:	ff 75 0c             	pushl  0xc(%ebp)
  109f96:	ff 75 08             	pushl  0x8(%ebp)
  109f99:	68 04 01 00 00       	push   $0x104
  109f9e:	ff 75 a4             	pushl  -0x5c(%ebp)
  109fa1:	51                   	push   %ecx
  109fa2:	e8 c9 f1 ff ff       	call   109170 <z_fdtable_call_ioctl>
  109fa7:	83 c4 18             	add    $0x18,%esp
  109faa:	89 c3                	mov    %eax,%ebx
  109fac:	e9 3f 01 00 00       	jmp    10a0f0 <z_impl_zsock_poll+0x24a>
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  109fb1:	89 f8                	mov    %edi,%eax
  109fb3:	09 f0                	or     %esi,%eax
  109fb5:	74 21                	je     109fd8 <z_impl_zsock_poll+0x132>
  109fb7:	83 ff ff             	cmp    $0xffffffff,%edi
  109fba:	75 05                	jne    109fc1 <z_impl_zsock_poll+0x11b>
  109fbc:	83 fe ff             	cmp    $0xffffffff,%esi
  109fbf:	74 17                	je     109fd8 <z_impl_zsock_poll+0x132>
		int64_t remaining = end - z_tick_get();
  109fc1:	e8 93 83 01 00       	call   122359 <z_tick_get>
  109fc6:	8b 75 9c             	mov    -0x64(%ebp),%esi
  109fc9:	29 c6                	sub    %eax,%esi
  109fcb:	8b 7d a0             	mov    -0x60(%ebp),%edi
  109fce:	19 d7                	sbb    %edx,%edi
  109fd0:	85 ff                	test   %edi,%edi
  109fd2:	79 04                	jns    109fd8 <z_impl_zsock_poll+0x132>
  109fd4:	31 f6                	xor    %esi,%esi
  109fd6:	31 ff                	xor    %edi,%edi
			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  109fd8:	89 f0                	mov    %esi,%eax
  109fda:	09 f8                	or     %edi,%eax
  109fdc:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ret = k_poll(poll_events, pev - poll_events, timeout);
  109fdf:	8d 4d b8             	lea    -0x48(%ebp),%ecx
  109fe2:	8b 45 b0             	mov    -0x50(%ebp),%eax
  109fe5:	29 c8                	sub    %ecx,%eax
  109fe7:	c1 f8 02             	sar    $0x2,%eax
  109fea:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
	return z_impl_k_poll(events, num_events, timeout);
  109ff0:	57                   	push   %edi
  109ff1:	56                   	push   %esi
  109ff2:	50                   	push   %eax
  109ff3:	51                   	push   %ecx
  109ff4:	e8 82 89 01 00       	call   12297b <z_impl_k_poll>
  109ff9:	89 c3                	mov    %eax,%ebx
  109ffb:	83 c4 10             	add    $0x10,%esp
		if (ret != 0 && ret != -EAGAIN && ret != -EINTR) {
  109ffe:	8d 40 04             	lea    0x4(%eax),%eax
  10a001:	8d 4d b8             	lea    -0x48(%ebp),%ecx
  10a004:	83 e0 fb             	and    $0xfffffffb,%eax
  10a007:	0f 95 c2             	setne  %dl
  10a00a:	83 fb f5             	cmp    $0xfffffff5,%ebx
  10a00d:	0f 95 c0             	setne  %al
  10a010:	20 c2                	and    %al,%dl
  10a012:	88 55 ac             	mov    %dl,-0x54(%ebp)
  10a015:	74 0b                	je     10a022 <z_impl_zsock_poll+0x17c>
			errno = -ret;
  10a017:	e8 4f f1 ff ff       	call   10916b <z_errno>
  10a01c:	f7 db                	neg    %ebx
  10a01e:	89 18                	mov    %ebx,(%eax)
			return -1;
  10a020:	eb 44                	jmp    10a066 <z_impl_zsock_poll+0x1c0>
		for (pfd = fds, i = nfds; i--; pfd++) {
  10a022:	8b 45 0c             	mov    0xc(%ebp),%eax
		pev = poll_events;
  10a025:	89 4d b0             	mov    %ecx,-0x50(%ebp)
		for (pfd = fds, i = nfds; i--; pfd++) {
  10a028:	89 45 a8             	mov    %eax,-0x58(%ebp)
  10a02b:	8b 4d 08             	mov    0x8(%ebp),%ecx
		ret = 0;
  10a02e:	31 db                	xor    %ebx,%ebx
		for (pfd = fds, i = nfds; i--; pfd++) {
  10a030:	eb 4e                	jmp    10a080 <z_impl_zsock_poll+0x1da>
			result = z_fdtable_call_ioctl(vtable, ctx,
  10a032:	8d 55 b0             	lea    -0x50(%ebp),%edx
  10a035:	89 4d 98             	mov    %ecx,-0x68(%ebp)
  10a038:	52                   	push   %edx
  10a039:	51                   	push   %ecx
  10a03a:	68 03 01 00 00       	push   $0x103
  10a03f:	50                   	push   %eax
  10a040:	ff 75 b4             	pushl  -0x4c(%ebp)
  10a043:	e8 28 f1 ff ff       	call   109170 <z_fdtable_call_ioctl>
  10a048:	83 c4 14             	add    $0x14,%esp
			if (result == -EAGAIN) {
  10a04b:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  10a04e:	83 f8 f5             	cmp    $0xfffffff5,%eax
  10a051:	74 59                	je     10a0ac <z_impl_zsock_poll+0x206>
			} else if (result != 0) {
  10a053:	85 c0                	test   %eax,%eax
  10a055:	74 4b                	je     10a0a2 <z_impl_zsock_poll+0x1fc>
  10a057:	89 45 ac             	mov    %eax,-0x54(%ebp)
				errno = -result;
  10a05a:	e8 0c f1 ff ff       	call   10916b <z_errno>
  10a05f:	8b 55 ac             	mov    -0x54(%ebp),%edx
  10a062:	f7 da                	neg    %edx
  10a064:	89 10                	mov    %edx,(%eax)
				return -1;
  10a066:	83 cb ff             	or     $0xffffffff,%ebx
  10a069:	e9 82 00 00 00       	jmp    10a0f0 <z_impl_zsock_poll+0x24a>
			if (pfd->fd < 0) {
  10a06e:	8b 01                	mov    (%ecx),%eax
			pfd->revents = 0;
  10a070:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)
			if (pfd->fd < 0) {
  10a076:	85 c0                	test   %eax,%eax
  10a078:	79 0e                	jns    10a088 <z_impl_zsock_poll+0x1e2>
		for (pfd = fds, i = nfds; i--; pfd++) {
  10a07a:	ff 4d a8             	decl   -0x58(%ebp)
  10a07d:	83 c1 08             	add    $0x8,%ecx
  10a080:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
  10a084:	75 e8                	jne    10a06e <z_impl_zsock_poll+0x1c8>
  10a086:	eb 2a                	jmp    10a0b2 <z_impl_zsock_poll+0x20c>
			ctx = get_sock_vtable(pfd->fd,
  10a088:	8d 55 b4             	lea    -0x4c(%ebp),%edx
  10a08b:	89 4d 98             	mov    %ecx,-0x68(%ebp)
  10a08e:	e8 fd f1 ff ff       	call   109290 <get_sock_vtable>
			if (ctx == NULL) {
  10a093:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  10a096:	85 c0                	test   %eax,%eax
  10a098:	75 98                	jne    10a032 <z_impl_zsock_poll+0x18c>
				pfd->revents = ZSOCK_POLLNVAL;
  10a09a:	66 c7 41 06 20 00    	movw   $0x20,0x6(%ecx)
				ret++;
  10a0a0:	eb 07                	jmp    10a0a9 <z_impl_zsock_poll+0x203>
			if (pfd->revents != 0) {
  10a0a2:	66 83 79 06 00       	cmpw   $0x0,0x6(%ecx)
  10a0a7:	74 d1                	je     10a07a <z_impl_zsock_poll+0x1d4>
				ret++;
  10a0a9:	43                   	inc    %ebx
  10a0aa:	eb ce                	jmp    10a07a <z_impl_zsock_poll+0x1d4>
				retry = true;
  10a0ac:	c6 45 ac 01          	movb   $0x1,-0x54(%ebp)
  10a0b0:	eb c8                	jmp    10a07a <z_impl_zsock_poll+0x1d4>
			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10a0b2:	8a 45 ac             	mov    -0x54(%ebp),%al
			if (ret > 0) {
  10a0b5:	85 db                	test   %ebx,%ebx
  10a0b7:	0f 9f c2             	setg   %dl
			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10a0ba:	83 f0 01             	xor    $0x1,%eax
  10a0bd:	08 c2                	or     %al,%dl
  10a0bf:	75 2f                	jne    10a0f0 <z_impl_zsock_poll+0x24a>
  10a0c1:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
  10a0c5:	74 29                	je     10a0f0 <z_impl_zsock_poll+0x24a>
			if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  10a0c7:	83 ff ff             	cmp    $0xffffffff,%edi
  10a0ca:	75 09                	jne    10a0d5 <z_impl_zsock_poll+0x22f>
  10a0cc:	83 fe ff             	cmp    $0xffffffff,%esi
  10a0cf:	0f 84 0a ff ff ff    	je     109fdf <z_impl_zsock_poll+0x139>
				int64_t remaining = end - z_tick_get();
  10a0d5:	e8 7f 82 01 00       	call   122359 <z_tick_get>
  10a0da:	8b 75 9c             	mov    -0x64(%ebp),%esi
  10a0dd:	29 c6                	sub    %eax,%esi
  10a0df:	8b 7d a0             	mov    -0x60(%ebp),%edi
  10a0e2:	19 d7                	sbb    %edx,%edi
				if (remaining <= 0) {
  10a0e4:	31 c0                	xor    %eax,%eax
  10a0e6:	39 f0                	cmp    %esi,%eax
  10a0e8:	19 f8                	sbb    %edi,%eax
  10a0ea:	0f 8c e8 fe ff ff    	jl     109fd8 <z_impl_zsock_poll+0x132>
}
  10a0f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a0f3:	89 d8                	mov    %ebx,%eax
  10a0f5:	5b                   	pop    %ebx
  10a0f6:	5e                   	pop    %esi
  10a0f7:	5f                   	pop    %edi
  10a0f8:	5d                   	pop    %ebp
  10a0f9:	c3                   	ret    

0010a0fa <zsock_setsockopt_ctx>:
{
  10a0fa:	55                   	push   %ebp
  10a0fb:	89 e5                	mov    %esp,%ebp
  10a0fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a100:	8b 55 10             	mov    0x10(%ebp),%edx
	switch (level) {
  10a103:	83 f8 06             	cmp    $0x6,%eax
  10a106:	74 0f                	je     10a117 <zsock_setsockopt_ctx+0x1d>
  10a108:	83 f8 29             	cmp    $0x29,%eax
  10a10b:	74 0f                	je     10a11c <zsock_setsockopt_ctx+0x22>
  10a10d:	48                   	dec    %eax
  10a10e:	75 13                	jne    10a123 <zsock_setsockopt_ctx+0x29>
			return 0;
  10a110:	31 c0                	xor    %eax,%eax
  10a112:	83 fa 02             	cmp    $0x2,%edx
  10a115:	eb 0a                	jmp    10a121 <zsock_setsockopt_ctx+0x27>
  10a117:	31 c0                	xor    %eax,%eax
  10a119:	4a                   	dec    %edx
  10a11a:	eb 05                	jmp    10a121 <zsock_setsockopt_ctx+0x27>
  10a11c:	31 c0                	xor    %eax,%eax
  10a11e:	83 fa 1a             	cmp    $0x1a,%edx
  10a121:	74 0e                	je     10a131 <zsock_setsockopt_ctx+0x37>
	errno = ENOPROTOOPT;
  10a123:	e8 43 f0 ff ff       	call   10916b <z_errno>
  10a128:	c7 00 2a 00 00 00    	movl   $0x2a,(%eax)
  10a12e:	83 c8 ff             	or     $0xffffffff,%eax
}
  10a131:	5d                   	pop    %ebp
  10a132:	c3                   	ret    

0010a133 <sock_setsockopt_vmeth>:
	return zsock_setsockopt_ctx(obj, level, optname, optval, optlen);
  10a133:	e9 c2 ff ff ff       	jmp    10a0fa <zsock_setsockopt_ctx>

0010a138 <zsock_getsockname_ctx>:
{
  10a138:	55                   	push   %ebp
  10a139:	89 e5                	mov    %esp,%ebp
  10a13b:	53                   	push   %ebx
  10a13c:	83 ec 08             	sub    $0x8,%esp
  10a13f:	8b 45 08             	mov    0x8(%ebp),%eax
  10a142:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (!ctx->conn_handler) {
  10a145:	83 78 34 00          	cmpl   $0x0,0x34(%eax)
  10a149:	74 53                	je     10a19e <zsock_getsockname_ctx+0x66>
	if (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.family == AF_INET) {
  10a14b:	66 83 78 24 01       	cmpw   $0x1,0x24(%eax)
  10a150:	75 4c                	jne    10a19e <zsock_getsockname_ctx+0x66>
		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
  10a152:	66 8b 50 26          	mov    0x26(%eax),%dx
		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
  10a156:	6a 04                	push   $0x4
  10a158:	ff 70 28             	pushl  0x28(%eax)
  10a15b:	8d 45 f8             	lea    -0x8(%ebp),%eax
		struct sockaddr_in addr4 = { 0 };
  10a15e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
  10a165:	50                   	push   %eax
		addr4.sin_family = AF_INET;
  10a166:	66 c7 45 f4 01 00    	movw   $0x1,-0xc(%ebp)
		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
  10a16c:	66 89 55 f6          	mov    %dx,-0xa(%ebp)
		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
  10a170:	e8 77 1c 00 00       	call   10bdec <memcpy>
		memcpy(addr, &addr4, MIN(*addrlen, newlen));
  10a175:	8b 03                	mov    (%ebx),%eax
		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
  10a177:	83 c4 0c             	add    $0xc,%esp
		memcpy(addr, &addr4, MIN(*addrlen, newlen));
  10a17a:	83 f8 08             	cmp    $0x8,%eax
  10a17d:	76 05                	jbe    10a184 <zsock_getsockname_ctx+0x4c>
  10a17f:	b8 08 00 00 00       	mov    $0x8,%eax
  10a184:	50                   	push   %eax
  10a185:	8d 45 f4             	lea    -0xc(%ebp),%eax
  10a188:	50                   	push   %eax
  10a189:	ff 75 0c             	pushl  0xc(%ebp)
  10a18c:	e8 5b 1c 00 00       	call   10bdec <memcpy>
  10a191:	83 c4 0c             	add    $0xc,%esp
	*addrlen = newlen;
  10a194:	c7 03 08 00 00 00    	movl   $0x8,(%ebx)
	return 0;
  10a19a:	31 c0                	xor    %eax,%eax
  10a19c:	eb 0e                	jmp    10a1ac <zsock_getsockname_ctx+0x74>
		SET_ERRNO(-EINVAL);
  10a19e:	e8 c8 ef ff ff       	call   10916b <z_errno>
  10a1a3:	c7 00 16 00 00 00    	movl   $0x16,(%eax)
  10a1a9:	83 c8 ff             	or     $0xffffffff,%eax
}
  10a1ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a1af:	c9                   	leave  
  10a1b0:	c3                   	ret    

0010a1b1 <sock_getsockname_vmeth>:
}

static int sock_getsockname_vmeth(void *obj, struct sockaddr *addr,
				  socklen_t *addrlen)
{
	return zsock_getsockname_ctx(obj, addr, addrlen);
  10a1b1:	e9 82 ff ff ff       	jmp    10a138 <zsock_getsockname_ctx>

0010a1b6 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
  10a1b6:	55                   	push   %ebp
  10a1b7:	89 e5                	mov    %esp,%ebp
  10a1b9:	68 d6 50 12 00       	push   $0x1250d6
  10a1be:	e8 41 62 01 00       	call   120404 <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
  10a1c3:	c7 04 24 e5 a1 10 00 	movl   $0x10a1e5,(%esp)

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  10a1ca:	a3 58 eb 12 00       	mov    %eax,0x12eb58
	__stdout_hook_install(console_out);
  10a1cf:	e8 01 1d 00 00       	call   10bed5 <__stdout_hook_install>
	__printk_hook_install(console_out);
  10a1d4:	c7 04 24 e5 a1 10 00 	movl   $0x10a1e5,(%esp)
  10a1db:	e8 da 6d ff ff       	call   100fba <__printk_hook_install>
  10a1e0:	58                   	pop    %eax

	uart_console_hook_install();

	return 0;
}
  10a1e1:	31 c0                	xor    %eax,%eax
  10a1e3:	c9                   	leave  
  10a1e4:	c3                   	ret    

0010a1e5 <console_out>:
{
  10a1e5:	55                   	push   %ebp
  10a1e6:	89 e5                	mov    %esp,%ebp
	if ('\n' == c) {
  10a1e8:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  10a1ec:	75 10                	jne    10a1fe <console_out+0x19>
  10a1ee:	a1 58 eb 12 00       	mov    0x12eb58,%eax
	api->poll_out(dev, out_char);
  10a1f3:	8b 50 08             	mov    0x8(%eax),%edx
  10a1f6:	6a 0d                	push   $0xd
  10a1f8:	50                   	push   %eax
  10a1f9:	ff 52 04             	call   *0x4(%edx)
  10a1fc:	59                   	pop    %ecx
  10a1fd:	58                   	pop    %eax
	uart_poll_out(uart_console_dev, c);
  10a1fe:	a1 58 eb 12 00       	mov    0x12eb58,%eax
  10a203:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
  10a207:	8b 50 08             	mov    0x8(%eax),%edx
  10a20a:	51                   	push   %ecx
  10a20b:	50                   	push   %eax
  10a20c:	ff 52 04             	call   *0x4(%edx)
  10a20f:	58                   	pop    %eax
  10a210:	5a                   	pop    %edx
}
  10a211:	8b 45 08             	mov    0x8(%ebp),%eax
  10a214:	c9                   	leave  
  10a215:	c3                   	ret    

0010a216 <uart_pipe_isr>:
		recv_buf = app_cb(recv_buf, &recv_off);
	}
}

static void uart_pipe_isr(const struct device *dev, void *user_data)
{
  10a216:	55                   	push   %ebp
  10a217:	89 e5                	mov    %esp,%ebp
  10a219:	53                   	push   %ebx
  10a21a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (api->irq_update) {
  10a21d:	8b 43 08             	mov    0x8(%ebx),%eax
  10a220:	8b 40 44             	mov    0x44(%eax),%eax
  10a223:	85 c0                	test   %eax,%eax
  10a225:	74 04                	je     10a22b <uart_pipe_isr+0x15>
		return api->irq_update(dev);
  10a227:	53                   	push   %ebx
  10a228:	ff d0                	call   *%eax
  10a22a:	59                   	pop    %ecx
	if (api->irq_is_pending)	{
  10a22b:	8b 43 08             	mov    0x8(%ebx),%eax
  10a22e:	8b 40 40             	mov    0x40(%eax),%eax
  10a231:	85 c0                	test   %eax,%eax
  10a233:	74 69                	je     10a29e <uart_pipe_isr+0x88>
		return api->irq_is_pending(dev);
  10a235:	53                   	push   %ebx
  10a236:	ff d0                	call   *%eax
  10a238:	5a                   	pop    %edx
	ARG_UNUSED(user_data);

	uart_irq_update(dev);

	if (uart_irq_is_pending(dev)) {
  10a239:	85 c0                	test   %eax,%eax
  10a23b:	74 61                	je     10a29e <uart_pipe_isr+0x88>
	if (api->irq_rx_ready) {
  10a23d:	8b 43 08             	mov    0x8(%ebx),%eax
  10a240:	8b 40 34             	mov    0x34(%eax),%eax
  10a243:	85 c0                	test   %eax,%eax
  10a245:	74 57                	je     10a29e <uart_pipe_isr+0x88>
		return api->irq_rx_ready(dev);
  10a247:	53                   	push   %ebx
  10a248:	ff d0                	call   *%eax
  10a24a:	5b                   	pop    %ebx
		if (uart_irq_rx_ready(dev)) {
  10a24b:	85 c0                	test   %eax,%eax
  10a24d:	74 4f                	je     10a29e <uart_pipe_isr+0x88>
		got = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off, avail);
  10a24f:	8b 1d 6c eb 12 00    	mov    0x12eb6c,%ebx
	if (api->fifo_read) {
  10a255:	8b 43 08             	mov    0x8(%ebx),%eax
  10a258:	8b 48 18             	mov    0x18(%eax),%ecx
  10a25b:	85 c9                	test   %ecx,%ecx
  10a25d:	74 3f                	je     10a29e <uart_pipe_isr+0x88>
		int avail = recv_buf_len - recv_off;
  10a25f:	a1 5c eb 12 00       	mov    0x12eb5c,%eax
  10a264:	8b 15 64 eb 12 00    	mov    0x12eb64,%edx
  10a26a:	29 c2                	sub    %eax,%edx
		got = uart_fifo_read(uart_pipe_dev, recv_buf + recv_off, avail);
  10a26c:	03 05 68 eb 12 00    	add    0x12eb68,%eax
		return api->fifo_read(dev, rx_data, size);
  10a272:	52                   	push   %edx
  10a273:	50                   	push   %eax
  10a274:	53                   	push   %ebx
  10a275:	ff d1                	call   *%ecx
  10a277:	83 c4 0c             	add    $0xc,%esp
		if (got <= 0) {
  10a27a:	85 c0                	test   %eax,%eax
  10a27c:	7e 20                	jle    10a29e <uart_pipe_isr+0x88>
		recv_buf = app_cb(recv_buf, &recv_off);
  10a27e:	68 5c eb 12 00       	push   $0x12eb5c
		recv_off += got;
  10a283:	01 05 5c eb 12 00    	add    %eax,0x12eb5c
		recv_buf = app_cb(recv_buf, &recv_off);
  10a289:	ff 35 68 eb 12 00    	pushl  0x12eb68
  10a28f:	ff 15 60 eb 12 00    	call   *0x12eb60
  10a295:	5a                   	pop    %edx
  10a296:	a3 68 eb 12 00       	mov    %eax,0x12eb68
  10a29b:	59                   	pop    %ecx
	for (;;) {
  10a29c:	eb b1                	jmp    10a24f <uart_pipe_isr+0x39>
			uart_pipe_rx(dev);
		}
	}
}
  10a29e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a2a1:	c9                   	leave  
  10a2a2:	c3                   	ret    

0010a2a3 <uart_pipe_send>:

int uart_pipe_send(const uint8_t *data, int len)
{
  10a2a3:	55                   	push   %ebp
  10a2a4:	89 e5                	mov    %esp,%ebp
  10a2a6:	56                   	push   %esi
  10a2a7:	53                   	push   %ebx
  10a2a8:	8b 75 0c             	mov    0xc(%ebp),%esi
  10a2ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
	LOG_HEXDUMP_DBG(data, len, "TX");

	while (len--)  {
  10a2ae:	01 de                	add    %ebx,%esi
  10a2b0:	39 f3                	cmp    %esi,%ebx
  10a2b2:	74 16                	je     10a2ca <uart_pipe_send+0x27>
		uart_poll_out(uart_pipe_dev, *data++);
  10a2b4:	43                   	inc    %ebx
  10a2b5:	a1 6c eb 12 00       	mov    0x12eb6c,%eax
  10a2ba:	0f b6 4b ff          	movzbl -0x1(%ebx),%ecx
	api->poll_out(dev, out_char);
  10a2be:	8b 50 08             	mov    0x8(%eax),%edx
  10a2c1:	51                   	push   %ecx
  10a2c2:	50                   	push   %eax
  10a2c3:	ff 52 04             	call   *0x4(%edx)
  10a2c6:	58                   	pop    %eax
  10a2c7:	5a                   	pop    %edx
}
  10a2c8:	eb e6                	jmp    10a2b0 <uart_pipe_send+0xd>
	}

	return 0;
}
  10a2ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10a2cd:	31 c0                	xor    %eax,%eax
  10a2cf:	5b                   	pop    %ebx
  10a2d0:	5e                   	pop    %esi
  10a2d1:	5d                   	pop    %ebp
  10a2d2:	c3                   	ret    

0010a2d3 <uart_pipe_register>:

	uart_irq_rx_enable(uart);
}

void uart_pipe_register(uint8_t *buf, size_t len, uart_pipe_recv_cb cb)
{
  10a2d3:	55                   	push   %ebp
  10a2d4:	89 e5                	mov    %esp,%ebp
  10a2d6:	53                   	push   %ebx
  10a2d7:	53                   	push   %ebx
	recv_buf = buf;
  10a2d8:	8b 45 08             	mov    0x8(%ebp),%eax
  10a2db:	a3 68 eb 12 00       	mov    %eax,0x12eb68
	recv_buf_len = len;
  10a2e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a2e3:	a3 64 eb 12 00       	mov    %eax,0x12eb64
	app_cb = cb;
  10a2e8:	8b 45 10             	mov    0x10(%ebp),%eax
  10a2eb:	a3 60 eb 12 00       	mov    %eax,0x12eb60
  10a2f0:	68 90 58 12 00       	push   $0x125890
  10a2f5:	e8 0a 61 01 00       	call   120404 <z_impl_device_get_binding>
  10a2fa:	5a                   	pop    %edx

	uart_pipe_dev = device_get_binding(CONFIG_UART_PIPE_ON_DEV_NAME);
  10a2fb:	a3 6c eb 12 00       	mov    %eax,0x12eb6c

	if (uart_pipe_dev != NULL) {
  10a300:	85 c0                	test   %eax,%eax
  10a302:	74 61                	je     10a365 <uart_pipe_register+0x92>
  10a304:	89 c3                	mov    %eax,%ebx
	if (api->irq_rx_disable) {
  10a306:	8b 40 08             	mov    0x8(%eax),%eax
  10a309:	8b 40 2c             	mov    0x2c(%eax),%eax
  10a30c:	85 c0                	test   %eax,%eax
  10a30e:	74 04                	je     10a314 <uart_pipe_register+0x41>
		api->irq_rx_disable(dev);
  10a310:	53                   	push   %ebx
  10a311:	ff d0                	call   *%eax
  10a313:	59                   	pop    %ecx
	if (api->irq_tx_disable) {
  10a314:	8b 43 08             	mov    0x8(%ebx),%eax
  10a317:	8b 40 20             	mov    0x20(%eax),%eax
  10a31a:	85 c0                	test   %eax,%eax
  10a31c:	74 04                	je     10a322 <uart_pipe_register+0x4f>
		api->irq_tx_disable(dev);
  10a31e:	53                   	push   %ebx
  10a31f:	ff d0                	call   *%eax
  10a321:	5a                   	pop    %edx
	if (api->fifo_read) {
  10a322:	8b 43 08             	mov    0x8(%ebx),%eax
  10a325:	8b 40 18             	mov    0x18(%eax),%eax
  10a328:	85 c0                	test   %eax,%eax
  10a32a:	74 10                	je     10a33c <uart_pipe_register+0x69>
		return api->fifo_read(dev, rx_data, size);
  10a32c:	6a 01                	push   $0x1
  10a32e:	8d 55 fb             	lea    -0x5(%ebp),%edx
  10a331:	52                   	push   %edx
  10a332:	53                   	push   %ebx
  10a333:	ff d0                	call   *%eax
  10a335:	83 c4 0c             	add    $0xc,%esp
	while (uart_fifo_read(uart, &c, 1)) {
  10a338:	85 c0                	test   %eax,%eax
  10a33a:	75 e6                	jne    10a322 <uart_pipe_register+0x4f>
	const struct uart_driver_api *api =
  10a33c:	8b 43 08             	mov    0x8(%ebx),%eax
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
  10a33f:	85 c0                	test   %eax,%eax
  10a341:	74 14                	je     10a357 <uart_pipe_register+0x84>
  10a343:	8b 40 48             	mov    0x48(%eax),%eax
  10a346:	85 c0                	test   %eax,%eax
  10a348:	74 0d                	je     10a357 <uart_pipe_register+0x84>
		api->irq_callback_set(dev, cb, user_data);
  10a34a:	6a 00                	push   $0x0
  10a34c:	68 16 a2 10 00       	push   $0x10a216
  10a351:	53                   	push   %ebx
  10a352:	ff d0                	call   *%eax
  10a354:	83 c4 0c             	add    $0xc,%esp
	if (api->irq_rx_enable) {
  10a357:	8b 43 08             	mov    0x8(%ebx),%eax
  10a35a:	8b 40 28             	mov    0x28(%eax),%eax
  10a35d:	85 c0                	test   %eax,%eax
  10a35f:	74 04                	je     10a365 <uart_pipe_register+0x92>
		api->irq_rx_enable(dev);
  10a361:	53                   	push   %ebx
  10a362:	ff d0                	call   *%eax
  10a364:	58                   	pop    %eax
		uart_pipe_setup(uart_pipe_dev);
	}
}
  10a365:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a368:	c9                   	leave  
  10a369:	c3                   	ret    

0010a36a <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
  10a36a:	55                   	push   %ebp
  10a36b:	89 e5                	mov    %esp,%ebp
  10a36d:	53                   	push   %ebx
  10a36e:	9c                   	pushf  
  10a36f:	fa                   	cli    
  10a370:	5b                   	pop    %ebx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile uint32_t *)(IOAPIC_REG + IOAPIC_IND) = (char)offset;
  10a371:	8b 0d 70 eb 12 00    	mov    0x12eb70,%ecx
  10a377:	0f be c0             	movsbl %al,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a37a:	0f ba e3 09          	bt     $0x9,%ebx
  10a37e:	89 01                	mov    %eax,(%ecx)
	*((volatile uint32_t *)(IOAPIC_REG + IOAPIC_DATA)) = value;
  10a380:	89 51 10             	mov    %edx,0x10(%ecx)
  10a383:	73 01                	jae    10a386 <__IoApicSet+0x1c>
		__asm__ volatile ("sti" ::: "memory");
  10a385:	fb                   	sti    

	irq_unlock(key);
}
  10a386:	5b                   	pop    %ebx
  10a387:	5d                   	pop    %ebp
  10a388:	c3                   	ret    

0010a389 <ioapic_init>:
{
  10a389:	55                   	push   %ebp
  10a38a:	89 e5                	mov    %esp,%ebp
  10a38c:	53                   	push   %ebx
{
#ifdef CONFIG_MMU
	/* Pass along flags and add that we want supervisor mode
	 * read-write access.
	 */
	z_mem_map((uint8_t **)virt_addr, phys_addr, size,
  10a38d:	6a 08                	push   $0x8
  10a38f:	bb 11 00 00 00       	mov    $0x11,%ebx
  10a394:	68 00 10 00 00       	push   $0x1000
  10a399:	68 00 00 c0 fe       	push   $0xfec00000
  10a39e:	68 70 eb 12 00       	push   $0x12eb70
  10a3a3:	e8 26 82 01 00       	call   1225ce <z_mem_map>
  10a3a8:	83 c4 10             	add    $0x10,%esp
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  10a3ab:	89 d8                	mov    %ebx,%eax
  10a3ad:	ba 00 00 00 ff       	mov    $0xff000000,%edx
  10a3b2:	e8 b3 ff ff ff       	call   10a36a <__IoApicSet>
	__IoApicSet(offset, lower32);
  10a3b7:	8d 43 ff             	lea    -0x1(%ebx),%eax
  10a3ba:	ba 00 08 01 00       	mov    $0x10800,%edx
  10a3bf:	83 c3 02             	add    $0x2,%ebx
  10a3c2:	e8 a3 ff ff ff       	call   10a36a <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  10a3c7:	83 fb 41             	cmp    $0x41,%ebx
  10a3ca:	75 df                	jne    10a3ab <ioapic_init+0x22>
}
  10a3cc:	31 c0                	xor    %eax,%eax
  10a3ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a3d1:	c9                   	leave  
  10a3d2:	c3                   	ret    

0010a3d3 <IoApicRedUpdateLo>:
 * @return N/A
 */
static void IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  10a3d3:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  10a3d4:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
{
  10a3d8:	89 e5                	mov    %esp,%ebp
  10a3da:	57                   	push   %edi
  10a3db:	56                   	push   %esi
  10a3dc:	53                   	push   %ebx
  10a3dd:	9c                   	pushf  
  10a3de:	fa                   	cli    
  10a3df:	5e                   	pop    %esi
	*((volatile uint32_t *) (IOAPIC_REG + IOAPIC_IND)) = (char)offset;
  10a3e0:	8b 1d 70 eb 12 00    	mov    0x12eb70,%ebx
  10a3e6:	0f be f8             	movsbl %al,%edi
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a3e9:	0f ba e6 09          	bt     $0x9,%esi
  10a3ed:	89 3b                	mov    %edi,(%ebx)
	value = *((volatile uint32_t *)(IOAPIC_REG + IOAPIC_DATA));
  10a3ef:	8b 5b 10             	mov    0x10(%ebx),%ebx
  10a3f2:	73 01                	jae    10a3f5 <IoApicRedUpdateLo+0x22>
		__asm__ volatile ("sti" ::: "memory");
  10a3f4:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
  10a3f5:	31 da                	xor    %ebx,%edx
  10a3f7:	21 ca                	and    %ecx,%edx
  10a3f9:	31 da                	xor    %ebx,%edx
}
  10a3fb:	5b                   	pop    %ebx
  10a3fc:	5e                   	pop    %esi
  10a3fd:	5f                   	pop    %edi
  10a3fe:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
  10a3ff:	e9 66 ff ff ff       	jmp    10a36a <__IoApicSet>

0010a404 <z_ioapic_irq_enable>:
{
  10a404:	55                   	push   %ebp
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  10a405:	b9 00 00 01 00       	mov    $0x10000,%ecx
{
  10a40a:	89 e5                	mov    %esp,%ebp
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  10a40c:	31 d2                	xor    %edx,%edx
  10a40e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10a411:	5d                   	pop    %ebp
	IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  10a412:	e9 bc ff ff ff       	jmp    10a3d3 <IoApicRedUpdateLo>

0010a417 <z_ioapic_irq_set>:
{
  10a417:	55                   	push   %ebp
	__IoApicSet(offset, upper32);
  10a418:	ba 00 00 00 ff       	mov    $0xff000000,%edx
{
  10a41d:	89 e5                	mov    %esp,%ebp
  10a41f:	57                   	push   %edi
  10a420:	56                   	push   %esi
  10a421:	53                   	push   %ebx
  10a422:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10a425:	01 db                	add    %ebx,%ebx
{
  10a427:	8b 75 0c             	mov    0xc(%ebp),%esi
  10a42a:	8b 7d 10             	mov    0x10(%ebp),%edi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10a42d:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
  10a430:	e8 35 ff ff ff       	call   10a36a <__IoApicSet>
		   (vector & IOAPIC_VEC_MASK) | flags;
  10a435:	89 f0                	mov    %esi,%eax
  10a437:	0f b6 d0             	movzbl %al,%edx
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  10a43a:	8d 43 10             	lea    0x10(%ebx),%eax
}
  10a43d:	5b                   	pop    %ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
  10a43e:	09 fa                	or     %edi,%edx
}
  10a440:	5e                   	pop    %esi
  10a441:	5f                   	pop    %edi
	rteValue = IOAPIC_INT_MASK | IOAPIC_LOGICAL |
  10a442:	81 ca 00 08 01 00    	or     $0x10800,%edx
}
  10a448:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
  10a449:	e9 1c ff ff ff       	jmp    10a36a <__IoApicSet>

0010a44e <loapic_init>:

static int loapic_init(const struct device *unused)
{
	ARG_UNUSED(unused);
	return 0;
}
  10a44e:	31 c0                	xor    %eax,%eax
  10a450:	c3                   	ret    

0010a451 <z_loapic_enable>:
{
  10a451:	55                   	push   %ebp
  10a452:	89 e5                	mov    %esp,%ebp
  10a454:	53                   	push   %ebx
  10a455:	6a 08                	push   $0x8
  10a457:	68 00 10 00 00       	push   $0x1000
  10a45c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10a45f:	68 00 00 e0 fe       	push   $0xfee00000
  10a464:	68 74 eb 12 00       	push   $0x12eb74
  10a469:	e8 60 81 01 00       	call   1225ce <z_mem_map>
	x86_write_xapic(LOAPIC_LDR, 1 << (cpu_number + 24));
  10a46e:	8d 4b 18             	lea    0x18(%ebx),%ecx
  10a471:	b8 01 00 00 00       	mov    $0x1,%eax
  10a476:	83 c4 10             	add    $0x10,%esp
#ifdef DEVICE_MMIO_IS_IN_RAM
	base = z_loapic_regs;
#else
	base = CONFIG_LOAPIC_BASE_ADDRESS;
#endif
	sys_write32(val, base + reg);
  10a479:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a47f:	d3 e0                	shl    %cl,%eax
	__asm__ volatile("movl %0, %1"
  10a481:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
	return sys_read32(base + reg);
  10a487:	a1 74 eb 12 00       	mov    0x12eb74,%eax
	__asm__ volatile("movl %1, %0"
  10a48c:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
	sys_write32(val, base + reg);
  10a492:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
	x86_write_xapic(LOAPIC_SVR,
  10a498:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl %0, %1"
  10a49b:	89 82 f0 00 00 00    	mov    %eax,0xf0(%edx)
	return sys_read32(base + reg);
  10a4a1:	a1 74 eb 12 00       	mov    0x12eb74,%eax
	__asm__ volatile("movl %1, %0"
  10a4a6:	8b 50 30             	mov    0x30(%eax),%edx
	loApicMaxLvt = (x86_read_loapic(LOAPIC_VER) & LOAPIC_MAXLVT_MASK) >> 16;
  10a4a9:	c1 ea 10             	shr    $0x10,%edx
	__asm__ volatile("movl %0, %1"
  10a4ac:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a4b2:	0f b6 ca             	movzbl %dl,%ecx
  10a4b5:	83 c8 ff             	or     $0xffffffff,%eax
  10a4b8:	89 83 e0 00 00 00    	mov    %eax,0xe0(%ebx)
  10a4be:	31 c0                	xor    %eax,%eax
  10a4c0:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a4c6:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	sys_write32(val, base + reg);
  10a4cc:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a4d2:	89 83 e0 03 00 00    	mov    %eax,0x3e0(%ebx)
  10a4d8:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a4de:	89 83 80 03 00 00    	mov    %eax,0x380(%ebx)
	return sys_read32(base + reg);
  10a4e4:	a1 74 eb 12 00       	mov    0x12eb74,%eax
	__asm__ volatile("movl %1, %0"
  10a4e9:	8b 80 50 03 00 00    	mov    0x350(%eax),%eax
	x86_write_loapic(LOAPIC_LINT0, (x86_read_loapic(LOAPIC_LINT0) &
  10a4ef:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
	sys_write32(val, base + reg);
  10a4f4:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a4fa:	80 cc 07             	or     $0x7,%ah
	__asm__ volatile("movl %0, %1"
  10a4fd:	89 83 50 03 00 00    	mov    %eax,0x350(%ebx)
	return sys_read32(base + reg);
  10a503:	a1 74 eb 12 00       	mov    0x12eb74,%eax
	__asm__ volatile("movl %1, %0"
  10a508:	8b 80 60 03 00 00    	mov    0x360(%eax),%eax
	x86_write_loapic(LOAPIC_LINT1, (x86_read_loapic(LOAPIC_LINT1) &
  10a50e:	25 ff 58 fe ff       	and    $0xfffe58ff,%eax
	sys_write32(val, base + reg);
  10a513:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a519:	80 cc 04             	or     $0x4,%ah
	__asm__ volatile("movl %0, %1"
  10a51c:	89 83 60 03 00 00    	mov    %eax,0x360(%ebx)
  10a522:	b8 00 00 01 00       	mov    $0x10000,%eax
  10a527:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a52d:	89 83 20 03 00 00    	mov    %eax,0x320(%ebx)
  10a533:	8b 1d 74 eb 12 00    	mov    0x12eb74,%ebx
  10a539:	89 83 70 03 00 00    	mov    %eax,0x370(%ebx)
	if (loApicMaxLvt >= LOAPIC_LVT_P6) {
  10a53f:	80 e2 fc             	and    $0xfc,%dl
  10a542:	74 0c                	je     10a550 <z_loapic_enable+0xff>
  10a544:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a54a:	89 82 40 03 00 00    	mov    %eax,0x340(%edx)
	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4) {
  10a550:	83 f9 04             	cmp    $0x4,%ecx
  10a553:	7e 11                	jle    10a566 <z_loapic_enable+0x115>
  10a555:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a55b:	b8 00 00 01 00       	mov    $0x10000,%eax
  10a560:	89 82 30 03 00 00    	mov    %eax,0x330(%edx)
  10a566:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a56c:	31 c0                	xor    %eax,%eax
  10a56e:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
}
  10a574:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10a577:	c9                   	leave  
  10a578:	c3                   	ret    

0010a579 <z_loapic_int_vec_set>:
 */

void z_loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  10a579:	55                   	push   %ebp
  10a57a:	89 e5                	mov    %esp,%ebp
  10a57c:	9c                   	pushf  
  10a57d:	fa                   	cli    
  10a57e:	59                   	pop    %ecx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
		     (x86_read_loapic(LOAPIC_TIMER + (irq * 0x10)) &
  10a57f:	8b 45 08             	mov    0x8(%ebp),%eax
	return sys_read32(base + reg);
  10a582:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a588:	83 c0 32             	add    $0x32,%eax
  10a58b:	c1 e0 04             	shl    $0x4,%eax
  10a58e:	01 c2                	add    %eax,%edx
	__asm__ volatile("movl %1, %0"
  10a590:	8b 12                	mov    (%edx),%edx
  10a592:	30 d2                	xor    %dl,%dl
	sys_write32(val, base + reg);
  10a594:	03 05 74 eb 12 00    	add    0x12eb74,%eax
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  10a59a:	0b 55 0c             	or     0xc(%ebp),%edx
	__asm__ volatile("movl %0, %1"
  10a59d:	89 10                	mov    %edx,(%eax)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a59f:	0f ba e1 09          	bt     $0x9,%ecx
  10a5a3:	73 01                	jae    10a5a6 <z_loapic_int_vec_set+0x2d>
		__asm__ volatile ("sti" ::: "memory");
  10a5a5:	fb                   	sti    
		      ~LOAPIC_VECTOR) | vector);
	irq_unlock(oldLevel);
}
  10a5a6:	5d                   	pop    %ebp
  10a5a7:	c3                   	ret    

0010a5a8 <z_loapic_irq_enable>:
 *
 * @return N/A
 */

void z_loapic_irq_enable(unsigned int irq)
{
  10a5a8:	55                   	push   %ebp
  10a5a9:	89 e5                	mov    %esp,%ebp
  10a5ab:	9c                   	pushf  
  10a5ac:	fa                   	cli    
  10a5ad:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
		     x86_read_loapic(LOAPIC_TIMER + (irq * 0x10)) &
  10a5ae:	8b 45 08             	mov    0x8(%ebp),%eax
	return sys_read32(base + reg);
  10a5b1:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a5b7:	83 c0 32             	add    $0x32,%eax
  10a5ba:	c1 e0 04             	shl    $0x4,%eax
  10a5bd:	01 c2                	add    %eax,%edx
	__asm__ volatile("movl %1, %0"
  10a5bf:	8b 12                	mov    (%edx),%edx
	sys_write32(val, base + reg);
  10a5c1:	03 05 74 eb 12 00    	add    0x12eb74,%eax
	x86_write_loapic(LOAPIC_TIMER + (irq * 0x10),
  10a5c7:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
	__asm__ volatile("movl %0, %1"
  10a5cd:	89 10                	mov    %edx,(%eax)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10a5cf:	0f ba e1 09          	bt     $0x9,%ecx
  10a5d3:	73 01                	jae    10a5d6 <z_loapic_irq_enable+0x2e>
		__asm__ volatile ("sti" ::: "memory");
  10a5d5:	fb                   	sti    
		     ~LOAPIC_LVT_MASKED);
	irq_unlock(oldLevel);
}
  10a5d6:	5d                   	pop    %ebp
  10a5d7:	c3                   	ret    

0010a5d8 <z_irq_controller_isr_vector_get>:
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
  10a5d8:	b8 07 00 00 00       	mov    $0x7,%eax
	return sys_read32(base + reg);
  10a5dd:	89 c1                	mov    %eax,%ecx
  10a5df:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
  10a5e5:	c1 e1 04             	shl    $0x4,%ecx
  10a5e8:	8d 94 11 00 01 00 00 	lea    0x100(%ecx,%edx,1),%edx
	__asm__ volatile("movl %1, %0"
  10a5ef:	8b 12                	mov    (%edx),%edx
		pReg = x86_read_loapic(LOAPIC_ISR + (block * 0x10));
		if (pReg) {
  10a5f1:	85 d2                	test   %edx,%edx
  10a5f3:	74 0f                	je     10a604 <z_irq_controller_isr_vector_get+0x2c>
{
	if (op == 0) {
		return 0;
	}

	return 32 - __builtin_clz(op);
  10a5f5:	0f bd d2             	bsr    %edx,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
  10a5f8:	c1 e0 05             	shl    $0x5,%eax
  10a5fb:	83 f2 1f             	xor    $0x1f,%edx
  10a5fe:	29 d0                	sub    %edx,%eax
  10a600:	83 c0 1f             	add    $0x1f,%eax
  10a603:	c3                   	ret    
	for (block = 7; likely(block > 0); block--) {
  10a604:	48                   	dec    %eax
  10a605:	75 d6                	jne    10a5dd <z_irq_controller_isr_vector_get+0x5>
		}

	}
	return -1;
  10a607:	83 c8 ff             	or     $0xffffffff,%eax
}
  10a60a:	c3                   	ret    

0010a60b <z_irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void z_irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
  10a60b:	55                   	push   %ebp
  10a60c:	89 e5                	mov    %esp,%ebp
  10a60e:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a611:	8b 55 08             	mov    0x8(%ebp),%edx
	__ASSERT(irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
		z_ioapic_irq_set(irq, vector, flags);
  10a614:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (IS_IOAPIC_IRQ(irq)) {
  10a617:	83 f8 17             	cmp    $0x17,%eax
  10a61a:	77 09                	ja     10a625 <z_irq_controller_irq_config+0x1a>
		z_ioapic_irq_set(irq, vector, flags);
  10a61c:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
  10a61f:	5d                   	pop    %ebp
		z_ioapic_irq_set(irq, vector, flags);
  10a620:	e9 f2 fd ff ff       	jmp    10a417 <z_ioapic_irq_set>
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  10a625:	83 e8 18             	sub    $0x18,%eax
  10a628:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10a62b:	5d                   	pop    %ebp
		z_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  10a62c:	e9 48 ff ff ff       	jmp    10a579 <z_loapic_int_vec_set>

0010a631 <arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void arch_irq_enable(unsigned int irq)
{
  10a631:	55                   	push   %ebp
  10a632:	89 e5                	mov    %esp,%ebp
  10a634:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  10a637:	83 f8 17             	cmp    $0x17,%eax
  10a63a:	77 06                	ja     10a642 <arch_irq_enable+0x11>
		z_ioapic_irq_enable(irq);
	} else {
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
  10a63c:	5d                   	pop    %ebp
		z_ioapic_irq_enable(irq);
  10a63d:	e9 c2 fd ff ff       	jmp    10a404 <z_ioapic_irq_enable>
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  10a642:	83 e8 18             	sub    $0x18,%eax
  10a645:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10a648:	5d                   	pop    %ebp
		z_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  10a649:	e9 5a ff ff ff       	jmp    10a5a8 <z_loapic_irq_enable>

0010a64e <eth_capabilities>:
	return ETHERNET_HW_VLAN
#if defined(CONFIG_NET_LLDP)
		| ETHERNET_LLDP
#endif
		;
}
  10a64e:	b8 04 00 00 00       	mov    $0x4,%eax
  10a653:	c3                   	ret    

0010a654 <slip_writeb>:
{
  10a654:	55                   	push   %ebp
  10a655:	89 e5                	mov    %esp,%ebp
  10a657:	52                   	push   %edx
	uart_pipe_send(&buf[0], 1);
  10a658:	6a 01                	push   $0x1
	uint8_t buf[1] = { c };
  10a65a:	88 45 ff             	mov    %al,-0x1(%ebp)
	uart_pipe_send(&buf[0], 1);
  10a65d:	8d 45 ff             	lea    -0x1(%ebp),%eax
  10a660:	50                   	push   %eax
  10a661:	e8 3d fc ff ff       	call   10a2a3 <uart_pipe_send>
  10a666:	59                   	pop    %ecx
  10a667:	58                   	pop    %eax
}
  10a668:	c9                   	leave  
  10a669:	c3                   	ret    

0010a66a <slip_send>:
{
  10a66a:	55                   	push   %ebp
  10a66b:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
  10a670:	89 e5                	mov    %esp,%ebp
  10a672:	57                   	push   %edi
  10a673:	56                   	push   %esi
  10a674:	53                   	push   %ebx
  10a675:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!pkt->buffer) {
  10a678:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  10a67c:	74 60                	je     10a6de <slip_send+0x74>
	slip_writeb(SLIP_END);
  10a67e:	b8 c0 00 00 00       	mov    $0xc0,%eax
  10a683:	e8 cc ff ff ff       	call   10a654 <slip_writeb>
	for (buf = pkt->buffer; buf; buf = buf->frags) {
  10a688:	8b 5b 10             	mov    0x10(%ebx),%ebx
  10a68b:	85 db                	test   %ebx,%ebx
  10a68d:	74 43                	je     10a6d2 <slip_send+0x68>
		ptr = buf->data;
  10a68f:	8b 7b 08             	mov    0x8(%ebx),%edi
		for (i = 0U; i < buf->len; ++i) {
  10a692:	31 f6                	xor    %esi,%esi
  10a694:	66 39 73 0c          	cmp    %si,0xc(%ebx)
  10a698:	76 34                	jbe    10a6ce <slip_send+0x64>
			c = *ptr++;
  10a69a:	0f b6 04 37          	movzbl (%edi,%esi,1),%eax
	switch (c) {
  10a69e:	3c c0                	cmp    $0xc0,%al
  10a6a0:	74 15                	je     10a6b7 <slip_send+0x4d>
  10a6a2:	3c db                	cmp    $0xdb,%al
  10a6a4:	75 20                	jne    10a6c6 <slip_send+0x5c>
		slip_writeb(SLIP_ESC);
  10a6a6:	b8 db 00 00 00       	mov    $0xdb,%eax
  10a6ab:	e8 a4 ff ff ff       	call   10a654 <slip_writeb>
		slip_writeb(SLIP_ESC_ESC);
  10a6b0:	b8 dd 00 00 00       	mov    $0xdd,%eax
  10a6b5:	eb 0f                	jmp    10a6c6 <slip_send+0x5c>
		slip_writeb(SLIP_ESC);
  10a6b7:	b8 db 00 00 00       	mov    $0xdb,%eax
  10a6bc:	e8 93 ff ff ff       	call   10a654 <slip_writeb>
		slip_writeb(SLIP_ESC_END);
  10a6c1:	b8 dc 00 00 00       	mov    $0xdc,%eax
		slip_writeb(c);
  10a6c6:	e8 89 ff ff ff       	call   10a654 <slip_writeb>
		for (i = 0U; i < buf->len; ++i) {
  10a6cb:	46                   	inc    %esi
  10a6cc:	eb c6                	jmp    10a694 <slip_send+0x2a>
	for (buf = pkt->buffer; buf; buf = buf->frags) {
  10a6ce:	8b 1b                	mov    (%ebx),%ebx
  10a6d0:	eb b9                	jmp    10a68b <slip_send+0x21>
	slip_writeb(SLIP_END);
  10a6d2:	b8 c0 00 00 00       	mov    $0xc0,%eax
  10a6d7:	e8 78 ff ff ff       	call   10a654 <slip_writeb>
	return 0;
  10a6dc:	31 c0                	xor    %eax,%eax
}
  10a6de:	5b                   	pop    %ebx
  10a6df:	5e                   	pop    %esi
  10a6e0:	5f                   	pop    %edi
  10a6e1:	5d                   	pop    %ebp
  10a6e2:	c3                   	ret    

0010a6e3 <slip_init>:
{
  10a6e3:	55                   	push   %ebp
  10a6e4:	89 e5                	mov    %esp,%ebp
	struct slip_context *slip = dev->data;
  10a6e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10a6e9:	8b 40 0c             	mov    0xc(%eax),%eax
	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
  10a6ec:	83 c0 02             	add    $0x2,%eax
	slip->state = STATE_OK;
  10a6ef:	c6 40 12 01          	movb   $0x1,0x12(%eax)
	slip->rx = NULL;
  10a6f3:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	slip->first = false;
  10a6fa:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
	uart_pipe_register(slip->buf, sizeof(slip->buf), recv_cb);
  10a6fe:	68 12 a7 10 00       	push   $0x10a712
  10a703:	6a 01                	push   $0x1
  10a705:	50                   	push   %eax
  10a706:	e8 c8 fb ff ff       	call   10a2d3 <uart_pipe_register>
  10a70b:	83 c4 0c             	add    $0xc,%esp
}
  10a70e:	31 c0                	xor    %eax,%eax
  10a710:	c9                   	leave  
  10a711:	c3                   	ret    

0010a712 <recv_cb>:
{
  10a712:	55                   	push   %ebp
  10a713:	89 e5                	mov    %esp,%ebp
  10a715:	57                   	push   %edi
  10a716:	56                   	push   %esi
  10a717:	53                   	push   %ebx
  10a718:	83 ec 0c             	sub    $0xc,%esp
  10a71b:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!slip->init_done) {
  10a71e:	80 7e fe 00          	cmpb   $0x0,-0x2(%esi)
  10a722:	0f 84 40 02 00 00    	je     10a968 <recv_cb+0x256>
  10a728:	b8 d0 31 12 00       	mov    $0x1231d0,%eax
	struct slip_context *slip =
  10a72d:	8d 7e fe             	lea    -0x2(%esi),%edi
  10a730:	2d b0 30 12 00       	sub    $0x1230b0,%eax
	for (i = 0; i < *off; i++) {
  10a735:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10a73c:	c1 e8 03             	shr    $0x3,%eax
			LOG_ERR("[%p] cannot allocate next data buf", slip);
  10a73f:	c1 e0 06             	shl    $0x6,%eax
  10a742:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	for (i = 0; i < *off; i++) {
  10a746:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a749:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10a74c:	3b 10                	cmp    (%eax),%edx
  10a74e:	0f 83 14 02 00 00    	jae    10a968 <recv_cb+0x256>
		if (slip_input_byte(slip, buf[i])) {
  10a754:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10a757:	0f b6 1c 06          	movzbl (%esi,%eax,1),%ebx
	switch (slip->state) {
  10a75b:	8a 46 12             	mov    0x12(%esi),%al
  10a75e:	3c 01                	cmp    $0x1,%al
  10a760:	74 4a                	je     10a7ac <recv_cb+0x9a>
  10a762:	3c 02                	cmp    $0x2,%al
  10a764:	74 1a                	je     10a780 <recv_cb+0x6e>
  10a766:	84 c0                	test   %al,%al
  10a768:	0f 85 1b 01 00 00    	jne    10a889 <recv_cb+0x177>
		if (c == SLIP_END) {
  10a76e:	80 fb c0             	cmp    $0xc0,%bl
  10a771:	0f 85 e9 01 00 00    	jne    10a960 <recv_cb+0x24e>
			slip->state = STATE_OK;
  10a777:	c6 46 12 01          	movb   $0x1,0x12(%esi)
  10a77b:	e9 e0 01 00 00       	jmp    10a960 <recv_cb+0x24e>
		if (c == SLIP_ESC_END) {
  10a780:	80 fb dc             	cmp    $0xdc,%bl
  10a783:	74 12                	je     10a797 <recv_cb+0x85>
		} else if (c == SLIP_ESC_ESC) {
  10a785:	80 fb dd             	cmp    $0xdd,%bl
  10a788:	74 14                	je     10a79e <recv_cb+0x8c>
			SLIP_STATS(slip->garbage++);
  10a78a:	66 ff 46 22          	incw   0x22(%esi)
			slip->state = STATE_GARBAGE;
  10a78e:	c6 46 12 00          	movb   $0x0,0x12(%esi)
			return 0;
  10a792:	e9 c9 01 00 00       	jmp    10a960 <recv_cb+0x24e>
			c = SLIP_END;
  10a797:	bb c0 00 00 00       	mov    $0xc0,%ebx
  10a79c:	eb 05                	jmp    10a7a3 <recv_cb+0x91>
			c = SLIP_ESC;
  10a79e:	bb db 00 00 00       	mov    $0xdb,%ebx
		slip->state = STATE_OK;
  10a7a3:	c6 46 12 01          	movb   $0x1,0x12(%esi)
		break;
  10a7a7:	e9 dd 00 00 00       	jmp    10a889 <recv_cb+0x177>
		if (c == SLIP_ESC) {
  10a7ac:	80 fb db             	cmp    $0xdb,%bl
  10a7af:	75 09                	jne    10a7ba <recv_cb+0xa8>
			slip->state = STATE_ESC;
  10a7b1:	c6 46 12 02          	movb   $0x2,0x12(%esi)
			return 0;
  10a7b5:	e9 a6 01 00 00       	jmp    10a960 <recv_cb+0x24e>
		if (c == SLIP_END) {
  10a7ba:	80 fb c0             	cmp    $0xc0,%bl
  10a7bd:	75 14                	jne    10a7d3 <recv_cb+0xc1>
			if (slip->rx) {
  10a7bf:	8b 5e 02             	mov    0x2(%esi),%ebx
			slip->first = false;
  10a7c2:	c6 46 ff 00          	movb   $0x0,-0x1(%esi)
			if (slip->rx) {
  10a7c6:	85 db                	test   %ebx,%ebx
  10a7c8:	0f 85 58 01 00 00    	jne    10a926 <recv_cb+0x214>
  10a7ce:	e9 8d 01 00 00       	jmp    10a960 <recv_cb+0x24e>
		if (slip->first && !slip->rx) {
  10a7d3:	80 7e ff 00          	cmpb   $0x0,-0x1(%esi)
  10a7d7:	74 0f                	je     10a7e8 <recv_cb+0xd6>
  10a7d9:	83 7e 02 00          	cmpl   $0x0,0x2(%esi)
  10a7dd:	0f 85 a6 00 00 00    	jne    10a889 <recv_cb+0x177>
  10a7e3:	e9 78 01 00 00       	jmp    10a960 <recv_cb+0x24e>
			slip->first = true;
  10a7e8:	c6 46 ff 01          	movb   $0x1,-0x1(%esi)
			slip->rx = net_pkt_rx_alloc_on_iface(slip->iface,
  10a7ec:	6a 00                	push   $0x0
  10a7ee:	6a 00                	push   $0x0
  10a7f0:	ff 76 0e             	pushl  0xe(%esi)
  10a7f3:	e8 c6 54 00 00       	call   10fcbe <net_pkt_rx_alloc_on_iface>
  10a7f8:	83 c4 0c             	add    $0xc,%esp
  10a7fb:	89 46 02             	mov    %eax,0x2(%esi)
			if (!slip->rx) {
  10a7fe:	85 c0                	test   %eax,%eax
  10a800:	75 28                	jne    10a82a <recv_cb+0x118>
				LOG_ERR("[%p] cannot allocate pkt", slip);
  10a802:	f6 05 28 5c 14 00 07 	testb  $0x7,0x145c28
  10a809:	0f 84 51 01 00 00    	je     10a960 <recv_cb+0x24e>
  10a80f:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  10a813:	83 c8 01             	or     $0x1,%eax
  10a816:	50                   	push   %eax
  10a817:	57                   	push   %edi
  10a818:	68 a1 58 12 00       	push   $0x1258a1
  10a81d:	e8 54 8d ff ff       	call   103576 <log_1>
  10a822:	83 c4 0c             	add    $0xc,%esp
  10a825:	e9 36 01 00 00       	jmp    10a960 <recv_cb+0x24e>
			slip->last = net_pkt_get_frag(slip->rx, K_NO_WAIT);
  10a82a:	6a 00                	push   $0x0
  10a82c:	6a 00                	push   $0x0
  10a82e:	50                   	push   %eax
  10a82f:	e8 ea 51 00 00       	call   10fa1e <net_pkt_get_frag>
  10a834:	83 c4 0c             	add    $0xc,%esp
  10a837:	89 46 06             	mov    %eax,0x6(%esi)
			if (!slip->last) {
  10a83a:	85 c0                	test   %eax,%eax
  10a83c:	75 34                	jne    10a872 <recv_cb+0x160>
				LOG_ERR("[%p] cannot allocate 1st data buffer",
  10a83e:	f6 05 28 5c 14 00 07 	testb  $0x7,0x145c28
  10a845:	74 16                	je     10a85d <recv_cb+0x14b>
  10a847:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  10a84b:	83 c8 01             	or     $0x1,%eax
  10a84e:	50                   	push   %eax
  10a84f:	57                   	push   %edi
  10a850:	68 ba 58 12 00       	push   $0x1258ba
  10a855:	e8 1c 8d ff ff       	call   103576 <log_1>
  10a85a:	83 c4 0c             	add    $0xc,%esp
				net_pkt_unref(slip->rx);
  10a85d:	ff 76 02             	pushl  0x2(%esi)
  10a860:	e8 17 52 00 00       	call   10fa7c <net_pkt_unref>
  10a865:	58                   	pop    %eax
				slip->rx = NULL;
  10a866:	c7 46 02 00 00 00 00 	movl   $0x0,0x2(%esi)
				return 0;
  10a86d:	e9 ee 00 00 00       	jmp    10a960 <recv_cb+0x24e>
			net_pkt_append_buffer(slip->rx, slip->last);
  10a872:	50                   	push   %eax
  10a873:	ff 76 02             	pushl  0x2(%esi)
  10a876:	e8 62 54 00 00       	call   10fcdd <net_pkt_append_buffer>
  10a87b:	59                   	pop    %ecx
  10a87c:	58                   	pop    %eax
			slip->ptr = net_pkt_ip_data(slip->rx);
  10a87d:	8b 46 02             	mov    0x2(%esi),%eax
	return pkt->frags->data;
  10a880:	8b 40 10             	mov    0x10(%eax),%eax
  10a883:	8b 40 08             	mov    0x8(%eax),%eax
  10a886:	89 46 0a             	mov    %eax,0xa(%esi)
	if (!slip->last) {
  10a889:	8b 46 06             	mov    0x6(%esi),%eax
  10a88c:	85 c0                	test   %eax,%eax
  10a88e:	0f 84 cc 00 00 00    	je     10a960 <recv_cb+0x24e>
	if (!net_buf_tailroom(slip->last)) {
  10a894:	83 c0 08             	add    $0x8,%eax
  10a897:	50                   	push   %eax
  10a898:	e8 be 19 00 00       	call   10c25b <net_buf_simple_tailroom>
  10a89d:	5a                   	pop    %edx
  10a89e:	85 c0                	test   %eax,%eax
  10a8a0:	75 61                	jne    10a903 <recv_cb+0x1f1>
		buf = net_pkt_get_reserve_rx_data(K_NO_WAIT);
  10a8a2:	6a 00                	push   $0x0
  10a8a4:	6a 00                	push   $0x0
  10a8a6:	e8 43 51 00 00       	call   10f9ee <net_pkt_get_reserve_rx_data>
  10a8ab:	5a                   	pop    %edx
		if (!buf) {
  10a8ac:	85 c0                	test   %eax,%eax
		buf = net_pkt_get_reserve_rx_data(K_NO_WAIT);
  10a8ae:	59                   	pop    %ecx
		if (!buf) {
  10a8af:	75 38                	jne    10a8e9 <recv_cb+0x1d7>
			LOG_ERR("[%p] cannot allocate next data buf", slip);
  10a8b1:	f6 05 28 5c 14 00 07 	testb  $0x7,0x145c28
  10a8b8:	74 16                	je     10a8d0 <recv_cb+0x1be>
  10a8ba:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  10a8be:	83 c8 01             	or     $0x1,%eax
  10a8c1:	50                   	push   %eax
  10a8c2:	57                   	push   %edi
  10a8c3:	68 df 58 12 00       	push   $0x1258df
  10a8c8:	e8 a9 8c ff ff       	call   103576 <log_1>
  10a8cd:	83 c4 0c             	add    $0xc,%esp
			net_pkt_unref(slip->rx);
  10a8d0:	ff 76 02             	pushl  0x2(%esi)
  10a8d3:	e8 a4 51 00 00       	call   10fa7c <net_pkt_unref>
  10a8d8:	58                   	pop    %eax
			slip->rx = NULL;
  10a8d9:	c7 46 02 00 00 00 00 	movl   $0x0,0x2(%esi)
			slip->last = NULL;
  10a8e0:	c7 46 06 00 00 00 00 	movl   $0x0,0x6(%esi)
			return 0;
  10a8e7:	eb 77                	jmp    10a960 <recv_cb+0x24e>
		net_buf_frag_insert(slip->last, buf);
  10a8e9:	50                   	push   %eax
  10a8ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10a8ed:	ff 76 06             	pushl  0x6(%esi)
  10a8f0:	e8 8f 18 00 00       	call   10c184 <net_buf_frag_insert>
  10a8f5:	59                   	pop    %ecx
  10a8f6:	58                   	pop    %eax
		slip->last = buf;
  10a8f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10a8fa:	89 46 06             	mov    %eax,0x6(%esi)
		slip->ptr = slip->last->data;
  10a8fd:	8b 40 08             	mov    0x8(%eax),%eax
  10a900:	89 46 0a             	mov    %eax,0xa(%esi)
	if (slip->ptr < slip->last->data) {
  10a903:	8b 46 06             	mov    0x6(%esi),%eax
  10a906:	8b 4e 0a             	mov    0xa(%esi),%ecx
  10a909:	3b 48 08             	cmp    0x8(%eax),%ecx
  10a90c:	73 04                	jae    10a912 <recv_cb+0x200>
		*slip->ptr = c;
  10a90e:	88 19                	mov    %bl,(%ecx)
  10a910:	eb 0f                	jmp    10a921 <recv_cb+0x20f>
		slip->ptr = net_buf_add_u8(slip->last, c);
  10a912:	53                   	push   %ebx
  10a913:	83 c0 08             	add    $0x8,%eax
  10a916:	50                   	push   %eax
  10a917:	e8 12 19 00 00       	call   10c22e <net_buf_simple_add_u8>
  10a91c:	5b                   	pop    %ebx
  10a91d:	5a                   	pop    %edx
  10a91e:	89 46 0a             	mov    %eax,0xa(%esi)
	slip->ptr++;
  10a921:	ff 46 0a             	incl   0xa(%esi)
	return 0;
  10a924:	eb 3a                	jmp    10a960 <recv_cb+0x24e>
	if (slip->last && slip->last->len) {
  10a926:	8b 46 06             	mov    0x6(%esi),%eax
  10a929:	85 c0                	test   %eax,%eax
  10a92b:	74 3b                	je     10a968 <recv_cb+0x256>
  10a92d:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  10a932:	74 34                	je     10a968 <recv_cb+0x256>
	if (!pkt || !pkt->buffer) {
  10a934:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  10a938:	74 2e                	je     10a968 <recv_cb+0x256>
	if (net_recv_data(get_iface(slip, vlan_tag), pkt) < 0) {
  10a93a:	53                   	push   %ebx
  10a93b:	ff 76 0e             	pushl  0xe(%esi)
  10a93e:	e8 14 29 00 00       	call   10d257 <net_recv_data>
  10a943:	5a                   	pop    %edx
  10a944:	85 c0                	test   %eax,%eax
  10a946:	59                   	pop    %ecx
  10a947:	79 07                	jns    10a950 <recv_cb+0x23e>
		net_pkt_unref(pkt);
  10a949:	53                   	push   %ebx
  10a94a:	e8 2d 51 00 00       	call   10fa7c <net_pkt_unref>
  10a94f:	58                   	pop    %eax
	slip->rx = NULL;
  10a950:	c7 46 02 00 00 00 00 	movl   $0x0,0x2(%esi)
	slip->last = NULL;
  10a957:	c7 46 06 00 00 00 00 	movl   $0x0,0x6(%esi)
  10a95e:	eb 08                	jmp    10a968 <recv_cb+0x256>
	for (i = 0; i < *off; i++) {
  10a960:	ff 45 f0             	incl   -0x10(%ebp)
  10a963:	e9 de fd ff ff       	jmp    10a746 <recv_cb+0x34>
		*off = 0;
  10a968:	8b 45 0c             	mov    0xc(%ebp),%eax
  10a96b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  10a971:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10a974:	89 f0                	mov    %esi,%eax
  10a976:	5b                   	pop    %ebx
  10a977:	5e                   	pop    %esi
  10a978:	5f                   	pop    %edi
  10a979:	5d                   	pop    %ebp
  10a97a:	c3                   	ret    

0010a97b <slip_iface_init>:
{
  10a97b:	55                   	push   %ebp
  10a97c:	89 e5                	mov    %esp,%ebp
  10a97e:	56                   	push   %esi
  10a97f:	53                   	push   %ebx
  10a980:	8b 75 08             	mov    0x8(%ebp),%esi
 *
 * @return a pointer to the device driver instance
 */
static inline const struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
  10a983:	8b 06                	mov    (%esi),%eax
	struct slip_context *slip = net_if_get_device(iface)->data;
  10a985:	8b 00                	mov    (%eax),%eax
  10a987:	8b 58 0c             	mov    0xc(%eax),%ebx
	ethernet_init(iface);
  10a98a:	56                   	push   %esi
  10a98b:	e8 3a 1d 00 00       	call   10c6ca <ethernet_init>
  10a990:	58                   	pop    %eax
	if (slip->init_done) {
  10a991:	80 3b 00             	cmpb   $0x0,(%ebx)
  10a994:	75 3e                	jne    10a9d4 <slip_iface_init+0x59>
	slip->ll_addr.addr = slip->mac_addr;
  10a996:	8d 43 15             	lea    0x15(%ebx),%eax
	slip->ll_addr.len = sizeof(slip->mac_addr);
  10a999:	c6 43 20 06          	movb   $0x6,0x20(%ebx)
	slip->ll_addr.addr = slip->mac_addr;
  10a99d:	89 43 1c             	mov    %eax,0x1c(%ebx)
	slip->init_done = true;
  10a9a0:	c6 03 01             	movb   $0x1,(%ebx)
	slip->iface = iface;
  10a9a3:	89 73 10             	mov    %esi,0x10(%ebx)
		slip->mac_addr[0] = 0x00;
  10a9a6:	c7 43 15 00 00 5e 00 	movl   $0x5e0000,0x15(%ebx)
		slip->mac_addr[4] = 0x53;
  10a9ad:	c6 43 19 53          	movb   $0x53,0x19(%ebx)
  10a9b1:	e8 9c 55 01 00       	call   11ff52 <z_impl_sys_rand32_get>
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
  10a9b6:	8a 53 20             	mov    0x20(%ebx),%dl
		slip->mac_addr[5] = sys_rand32_get();
  10a9b9:	88 43 1a             	mov    %al,0x1a(%ebx)
	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
  10a9bc:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10a9bf:	8b 06                	mov    (%esi),%eax
  10a9c1:	8b 40 0c             	mov    0xc(%eax),%eax
 */
static inline int net_if_set_link_addr(struct net_if *iface,
				       uint8_t *addr, uint8_t len,
				       enum net_link_type type)
{
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
  10a9c4:	a8 01                	test   $0x1,%al
  10a9c6:	75 0c                	jne    10a9d4 <slip_iface_init+0x59>
		return -EPERM;
	}

	net_if_get_link_addr(iface)->addr = addr;
  10a9c8:	8b 06                	mov    (%esi),%eax
  10a9ca:	89 48 10             	mov    %ecx,0x10(%eax)
	net_if_get_link_addr(iface)->len = len;
  10a9cd:	88 50 14             	mov    %dl,0x14(%eax)
	net_if_get_link_addr(iface)->type = type;
  10a9d0:	c6 40 15 03          	movb   $0x3,0x15(%eax)
}
  10a9d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10a9d7:	5b                   	pop    %ebx
  10a9d8:	5e                   	pop    %esi
  10a9d9:	5d                   	pop    %ebp
  10a9da:	c3                   	ret    

0010a9db <hpet_isr>:
static unsigned int max_ticks;
static unsigned int cyc_per_tick;
static unsigned int last_count;

static void hpet_isr(const void *arg)
{
  10a9db:	55                   	push   %ebp
  10a9dc:	89 e5                	mov    %esp,%ebp
  10a9de:	53                   	push   %ebx
  10a9df:	9c                   	pushf  
  10a9e0:	fa                   	cli    
  10a9e1:	5b                   	pop    %ebx
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);

	uint32_t now = MAIN_COUNTER_REG;
  10a9e2:	a1 98 eb 12 00       	mov    0x12eb98,%eax

		if (last_count && diff < 0) {
			now = last_count;
		}
	}
	uint32_t dticks = (now - last_count) / cyc_per_tick;
  10a9e7:	8b 0d 90 eb 12 00    	mov    0x12eb90,%ecx
  10a9ed:	31 d2                	xor    %edx,%edx
	uint32_t now = MAIN_COUNTER_REG;
  10a9ef:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
	uint32_t dticks = (now - last_count) / cyc_per_tick;
  10a9f5:	2b 05 8c eb 12 00    	sub    0x12eb8c,%eax
  10a9fb:	f7 f1                	div    %ecx

	last_count += dticks * cyc_per_tick;
  10a9fd:	0f af c8             	imul   %eax,%ecx
  10aa00:	03 0d 8c eb 12 00    	add    0x12eb8c,%ecx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10aa06:	0f ba e3 09          	bt     $0x9,%ebx
  10aa0a:	89 0d 8c eb 12 00    	mov    %ecx,0x12eb8c
  10aa10:	73 01                	jae    10aa13 <hpet_isr+0x38>
		__asm__ volatile ("sti" ::: "memory");
  10aa12:	fb                   	sti    
		TIMER0_COMPARATOR_REG = next;
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
  10aa13:	5b                   	pop    %ebx
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
  10aa14:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10aa17:	5d                   	pop    %ebp
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
  10aa18:	e9 47 78 01 00       	jmp    122264 <z_clock_announce>

0010aa1d <z_clock_driver_init>:

	TIMER0_CONF_REG = val;
}

int z_clock_driver_init(const struct device *device)
{
  10aa1d:	55                   	push   %ebp
  10aa1e:	89 e5                	mov    %esp,%ebp
  10aa20:	56                   	push   %esi
  10aa21:	53                   	push   %ebx
  10aa22:	6a 08                	push   $0x8
  10aa24:	68 00 04 00 00       	push   $0x400
  10aa29:	68 00 00 d0 fe       	push   $0xfed00000
  10aa2e:	68 98 eb 12 00       	push   $0x12eb98
  10aa33:	e8 96 7b 01 00       	call   1225ce <z_mem_map>
  10aa38:	83 c4 10             	add    $0x10,%esp

	ARG_UNUSED(device);

	DEVICE_MMIO_TOPLEVEL_MAP(hpet_regs, K_MEM_CACHE_NONE);

	IRQ_CONNECT(DT_INST_IRQN(0),
  10aa3b:	0f b6 05 12 93 12 00 	movzbl 0x129312,%eax
  10aa42:	6a 00                	push   $0x0
  10aa44:	6a 02                	push   $0x2
  10aa46:	50                   	push   %eax
  10aa47:	e8 bf fb ff ff       	call   10a60b <z_irq_controller_irq_config>
	uint32_t val = (TIMER0_CONF_REG & ~(0x1f << 9)) | ((irq & 0x1f) << 9);
  10aa4c:	8b 15 98 eb 12 00    	mov    0x12eb98,%edx
	IRQ_CONNECT(DT_INST_IRQN(0),
  10aa52:	83 c4 0c             	add    $0xc,%esp
	uint32_t val = (TIMER0_CONF_REG & ~(0x1f << 9)) | ((irq & 0x1f) << 9);
  10aa55:	8b 82 00 01 00 00    	mov    0x100(%edx),%eax
  10aa5b:	80 e4 c1             	and    $0xc1,%ah
  10aa5e:	80 cc 04             	or     $0x4,%ah
	TIMER0_CONF_REG = val;
  10aa61:	89 82 00 01 00 00    	mov    %eax,0x100(%edx)
		    DT_INST_IRQ(0, priority),
		    hpet_isr, 0, DT_INST_IRQ(0, sense));
	set_timer0_irq(DT_INST_IRQN(0));
	irq_enable(DT_INST_IRQN(0));
  10aa67:	6a 02                	push   $0x2
  10aa69:	e8 c3 fb ff ff       	call   10a631 <arch_irq_enable>

	/* CLK_PERIOD_REG is in femtoseconds (1e-15 sec) */
	hz = (uint32_t)(1000000000000000ull / CLK_PERIOD_REG);
  10aa6e:	8b 1d 98 eb 12 00    	mov    0x12eb98,%ebx
  10aa74:	31 d2                	xor    %edx,%edx
  10aa76:	8b 43 04             	mov    0x4(%ebx),%eax
  10aa79:	89 14 24             	mov    %edx,(%esp)
  10aa7c:	50                   	push   %eax
  10aa7d:	68 7e 8d 03 00       	push   $0x38d7e
  10aa82:	68 00 80 c6 a4       	push   $0xa4c68000
  10aa87:	e8 94 57 ff ff       	call   100220 <__udivdi3>
	z_clock_hw_cycles_per_sec = hz;
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  10aa8c:	b9 64 00 00 00       	mov    $0x64,%ecx
  10aa91:	31 d2                	xor    %edx,%edx
	z_clock_hw_cycles_per_sec = hz;
  10aa93:	a3 44 5b 14 00       	mov    %eax,0x145b44
	hz = (uint32_t)(1000000000000000ull / CLK_PERIOD_REG);
  10aa98:	83 c4 10             	add    $0x10,%esp
	cyc_per_tick = hz / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  10aa9b:	f7 f1                	div    %ecx
  10aa9d:	89 c1                	mov    %eax,%ecx
  10aa9f:	a3 90 eb 12 00       	mov    %eax,0x12eb90
	 * nothing in Zephyr disables the PIT which then fires
	 * interrupts into the same IRQ.  But that means we're then
	 * forced to use IRQ2 contra the way the kconfig IRQ selection
	 * is supposed to work.  Should fix this.
	 */
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
  10aaa4:	8b 43 10             	mov    0x10(%ebx),%eax
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
	TIMER0_CONF_REG &= ~TCONF_FSB_EN;
	TIMER0_CONF_REG |= TCONF_MODE32;

	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
  10aaa7:	31 d2                	xor    %edx,%edx
	GENERAL_CONF_REG |= GCONF_LR | GCONF_ENABLE;
  10aaa9:	83 c8 03             	or     $0x3,%eax
  10aaac:	89 43 10             	mov    %eax,0x10(%ebx)
	TIMER0_CONF_REG &= ~TCONF_PERIODIC;
  10aaaf:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
  10aab5:	83 e0 f7             	and    $0xfffffff7,%eax
  10aab8:	89 83 00 01 00 00    	mov    %eax,0x100(%ebx)
	TIMER0_CONF_REG &= ~TCONF_FSB_EN;
  10aabe:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
  10aac4:	80 e4 bf             	and    $0xbf,%ah
  10aac7:	89 83 00 01 00 00    	mov    %eax,0x100(%ebx)
	TIMER0_CONF_REG |= TCONF_MODE32;
  10aacd:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
  10aad3:	80 cc 01             	or     $0x1,%ah
  10aad6:	89 83 00 01 00 00    	mov    %eax,0x100(%ebx)
	max_ticks = (0x7fffffff - cyc_per_tick) / cyc_per_tick;
  10aadc:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  10aae1:	29 c8                	sub    %ecx,%eax
  10aae3:	f7 f1                	div    %ecx
  10aae5:	a3 94 eb 12 00       	mov    %eax,0x12eb94
	last_count = MAIN_COUNTER_REG;
  10aaea:	8b 83 f0 00 00 00    	mov    0xf0(%ebx),%eax
  10aaf0:	a3 8c eb 12 00       	mov    %eax,0x12eb8c

	TIMER0_CONF_REG |= TCONF_INT_ENABLE;
  10aaf5:	8b 83 00 01 00 00    	mov    0x100(%ebx),%eax
  10aafb:	83 c8 04             	or     $0x4,%eax
  10aafe:	89 83 00 01 00 00    	mov    %eax,0x100(%ebx)
	TIMER0_COMPARATOR_REG = MAIN_COUNTER_REG + cyc_per_tick;
  10ab04:	8b 83 f0 00 00 00    	mov    0xf0(%ebx),%eax
  10ab0a:	01 c1                	add    %eax,%ecx

	return 0;
}
  10ab0c:	31 c0                	xor    %eax,%eax
	TIMER0_COMPARATOR_REG = MAIN_COUNTER_REG + cyc_per_tick;
  10ab0e:	89 8b 08 01 00 00    	mov    %ecx,0x108(%ebx)
}
  10ab14:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10ab17:	5b                   	pop    %ebx
  10ab18:	5e                   	pop    %esi
  10ab19:	5d                   	pop    %ebp
  10ab1a:	c3                   	ret    

0010ab1b <hpet_isr_irq2_stub>:
  10ab1b:	6a 00                	push   $0x0
  10ab1d:	68 db a9 10 00       	push   $0x10a9db
  10ab22:	e9 5c 0c 00 00       	jmp    10b783 <_interrupt_enter>

0010ab27 <z_clock_set_timeout>:
	 * nothing to do at initialization on auxiliary CPUs.
	 */
}

void z_clock_set_timeout(int32_t ticks, bool idle)
{
  10ab27:	55                   	push   %ebp
  10ab28:	89 e5                	mov    %esp,%ebp
  10ab2a:	57                   	push   %edi
  10ab2b:	56                   	push   %esi
  10ab2c:	53                   	push   %ebx
  10ab2d:	83 ec 0c             	sub    $0xc,%esp
  10ab30:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10ab33:	8b 45 0c             	mov    0xc(%ebp),%eax
	ARG_UNUSED(idle);

#if defined(CONFIG_TICKLESS_KERNEL)
	if (ticks == K_TICKS_FOREVER && idle) {
  10ab36:	83 f9 ff             	cmp    $0xffffffff,%ecx
  10ab39:	75 18                	jne    10ab53 <z_clock_set_timeout+0x2c>
  10ab3b:	84 c0                	test   %al,%al
  10ab3d:	74 14                	je     10ab53 <z_clock_set_timeout+0x2c>
		GENERAL_CONF_REG &= ~GCONF_ENABLE;
  10ab3f:	8b 15 98 eb 12 00    	mov    0x12eb98,%edx
  10ab45:	8b 42 10             	mov    0x10(%edx),%eax
  10ab48:	83 e0 fe             	and    $0xfffffffe,%eax
  10ab4b:	89 42 10             	mov    %eax,0x10(%edx)
		return;
  10ab4e:	e9 83 00 00 00       	jmp    10abd6 <z_clock_set_timeout+0xaf>
	}

	ticks = ticks == K_TICKS_FOREVER ? max_ticks : ticks;
  10ab53:	8b 15 94 eb 12 00    	mov    0x12eb94,%edx
  10ab59:	83 f9 ff             	cmp    $0xffffffff,%ecx
  10ab5c:	75 02                	jne    10ab60 <z_clock_set_timeout+0x39>
  10ab5e:	89 d1                	mov    %edx,%ecx
  10ab60:	9c                   	pushf  
  10ab61:	fa                   	cli    
  10ab62:	8f 45 e8             	popl   -0x18(%ebp)
	ticks = MAX(MIN(ticks - 1, (int32_t)max_ticks), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t now = MAIN_COUNTER_REG, cyc, adj;
  10ab65:	8b 35 98 eb 12 00    	mov    0x12eb98,%esi
	uint32_t max_cyc = max_ticks * cyc_per_tick;
  10ab6b:	8b 1d 90 eb 12 00    	mov    0x12eb90,%ebx
  10ab71:	a1 94 eb 12 00       	mov    0x12eb94,%eax
	ticks = MAX(MIN(ticks - 1, (int32_t)max_ticks), 0);
  10ab76:	49                   	dec    %ecx
	uint32_t max_cyc = max_ticks * cyc_per_tick;
  10ab77:	0f af c3             	imul   %ebx,%eax
	uint32_t now = MAIN_COUNTER_REG, cyc, adj;
  10ab7a:	8b be f0 00 00 00    	mov    0xf0(%esi),%edi
	ticks = MAX(MIN(ticks - 1, (int32_t)max_ticks), 0);
  10ab80:	39 d1                	cmp    %edx,%ecx
  10ab82:	7e 02                	jle    10ab86 <z_clock_set_timeout+0x5f>
  10ab84:	89 d1                	mov    %edx,%ecx
  10ab86:	85 c9                	test   %ecx,%ecx
  10ab88:	79 02                	jns    10ab8c <z_clock_set_timeout+0x65>
  10ab8a:	31 c9                	xor    %ecx,%ecx

	/* Round up to next tick boundary. */
	cyc = ticks * cyc_per_tick;
  10ab8c:	0f af cb             	imul   %ebx,%ecx
	adj = (now - last_count) + (cyc_per_tick - 1);
  10ab8f:	8d 53 ff             	lea    -0x1(%ebx),%edx
	cyc = ticks * cyc_per_tick;
  10ab92:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	adj = (now - last_count) + (cyc_per_tick - 1);
  10ab95:	8b 0d 8c eb 12 00    	mov    0x12eb8c,%ecx
  10ab9b:	29 ca                	sub    %ecx,%edx
  10ab9d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10aba0:	01 fa                	add    %edi,%edx
	if (cyc <= max_cyc - adj) {
  10aba2:	89 c1                	mov    %eax,%ecx
  10aba4:	29 d1                	sub    %edx,%ecx
  10aba6:	3b 4d ec             	cmp    -0x14(%ebp),%ecx
  10aba9:	72 05                	jb     10abb0 <z_clock_set_timeout+0x89>
		cyc += adj;
  10abab:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10abae:	01 d0                	add    %edx,%eax
	} else {
		cyc = max_cyc;
	}
	cyc = (cyc / cyc_per_tick) * cyc_per_tick;
  10abb0:	31 d2                	xor    %edx,%edx
  10abb2:	f7 f3                	div    %ebx
  10abb4:	0f af c3             	imul   %ebx,%eax
	cyc += last_count;
  10abb7:	03 45 f0             	add    -0x10(%ebp),%eax

	if ((cyc - now) < MIN_DELAY) {
  10abba:	89 c2                	mov    %eax,%edx
  10abbc:	29 fa                	sub    %edi,%edx
  10abbe:	81 fa e7 03 00 00    	cmp    $0x3e7,%edx
  10abc4:	77 02                	ja     10abc8 <z_clock_set_timeout+0xa1>
		cyc += cyc_per_tick;
  10abc6:	01 d8                	add    %ebx,%eax
	}

	TIMER0_COMPARATOR_REG = cyc;
  10abc8:	89 86 08 01 00 00    	mov    %eax,0x108(%esi)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10abce:	0f ba 65 e8 09       	btl    $0x9,-0x18(%ebp)
  10abd3:	73 01                	jae    10abd6 <z_clock_set_timeout+0xaf>
		__asm__ volatile ("sti" ::: "memory");
  10abd5:	fb                   	sti    
	k_spin_unlock(&lock, key);
#endif
}
  10abd6:	83 c4 0c             	add    $0xc,%esp
  10abd9:	5b                   	pop    %ebx
  10abda:	5e                   	pop    %esi
  10abdb:	5f                   	pop    %edi
  10abdc:	5d                   	pop    %ebp
  10abdd:	c3                   	ret    

0010abde <z_clock_elapsed>:
  10abde:	9c                   	pushf  
  10abdf:	fa                   	cli    
  10abe0:	59                   	pop    %ecx
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (MAIN_COUNTER_REG - last_count) / cyc_per_tick;
  10abe1:	a1 98 eb 12 00       	mov    0x12eb98,%eax
  10abe6:	31 d2                	xor    %edx,%edx
  10abe8:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
  10abee:	2b 05 8c eb 12 00    	sub    0x12eb8c,%eax
  10abf4:	f7 35 90 eb 12 00    	divl   0x12eb90
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10abfa:	0f ba e1 09          	bt     $0x9,%ecx
  10abfe:	73 01                	jae    10ac01 <z_clock_elapsed+0x23>
		__asm__ volatile ("sti" ::: "memory");
  10ac00:	fb                   	sti    

	k_spin_unlock(&lock, key);
	return ret;
}
  10ac01:	c3                   	ret    

0010ac02 <z_timer_cycle_get_32>:

uint32_t z_timer_cycle_get_32(void)
{
	return MAIN_COUNTER_REG;
  10ac02:	a1 98 eb 12 00       	mov    0x12eb98,%eax
  10ac07:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
}
  10ac0d:	c3                   	ret    

0010ac0e <arch_cpu_idle>:
#include <arch/cpu.h>

void arch_cpu_idle(void)
{
	sys_trace_idle();
	__asm__ volatile (
  10ac0e:	fb                   	sti    
  10ac0f:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  10ac10:	c3                   	ret    

0010ac11 <z_x86_prep_c>:

/* Early global initialization functions, C domain. This runs only on the first
 * CPU for SMP systems.
 */
FUNC_NORETURN void z_x86_prep_c(void *arg)
{
  10ac11:	55                   	push   %ebp
	struct multiboot_info *info = arg;

	_kernel.cpus[0].nested = 0;
  10ac12:	c7 05 c0 e9 12 00 00 	movl   $0x0,0x12e9c0
  10ac19:	00 00 00 
{
  10ac1c:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_X86_VERY_EARLY_CONSOLE
	z_x86_early_serial_init();
  10ac1e:	e8 c4 0a 00 00       	call   10b6e7 <z_x86_early_serial_init>

#if defined(CONFIG_SMP)
	z_x86_ipi_setup();
#endif

	z_cstart();
  10ac23:	e8 93 59 01 00       	call   1205bb <z_cstart>

0010ac28 <arch_system_halt>:
#include <x86_mmu.h>
LOG_MODULE_DECLARE(os);

#if defined(CONFIG_BOARD_QEMU_X86) || defined(CONFIG_BOARD_QEMU_X86_64)
FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  10ac28:	55                   	push   %ebp
  10ac29:	89 e5                	mov    %esp,%ebp
	__asm__ volatile("outl %0, %w1" :: "a"(data), "Nd"(port));
  10ac2b:	8b 45 08             	mov    0x8(%ebp),%eax
  10ac2e:	e7 f4                	out    %eax,$0xf4

0010ac30 <z_x86_check_stack_bounds>:
}
#endif

#ifdef CONFIG_THREAD_STACK_INFO
bool z_x86_check_stack_bounds(uintptr_t addr, size_t size, uint16_t cs)
{
  10ac30:	55                   	push   %ebp
	uintptr_t start, end;

	if (_current == NULL || arch_is_in_isr()) {
  10ac31:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
{
  10ac36:	89 e5                	mov    %esp,%ebp
	if (_current == NULL || arch_is_in_isr()) {
  10ac38:	85 c0                	test   %eax,%eax
{
  10ac3a:	53                   	push   %ebx
  10ac3b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (_current == NULL || arch_is_in_isr()) {
  10ac3e:	74 09                	je     10ac49 <z_x86_check_stack_bounds+0x19>
  10ac40:	83 3d c0 e9 12 00 00 	cmpl   $0x0,0x12e9c0
  10ac47:	74 0c                	je     10ac55 <z_x86_check_stack_bounds+0x25>
#ifdef CONFIG_SMP
		cpu_id = arch_curr_cpu()->id;
#else
		cpu_id = 0;
#endif
		start = (uintptr_t)Z_KERNEL_STACK_BUFFER(
  10ac49:	bb ec 4b 14 00       	mov    $0x144bec,%ebx
		    z_interrupt_stacks[cpu_id]);
		end = start + CONFIG_ISR_STACK_SIZE;
  10ac4e:	ba ec 53 14 00       	mov    $0x1453ec,%edx
	if (_current == NULL || arch_is_in_isr()) {
  10ac53:	eb 11                	jmp    10ac66 <z_x86_check_stack_bounds+0x36>
		start = _current->stack_info.start - CONFIG_MMU_PAGE_SIZE;
		end = _current->stack_info.start;
#endif /* CONFIG_USERSPACE */
	} else {
		/* Normal thread operation, check its stack buffer */
		start = _current->stack_info.start;
  10ac55:	8b 98 80 00 00 00    	mov    0x80(%eax),%ebx
		end = Z_STACK_PTR_ALIGN(_current->stack_info.start +
  10ac5b:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
  10ac61:	01 da                	add    %ebx,%edx
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
  10ac63:	83 e2 fc             	and    $0xfffffffc,%edx
					_current->stack_info.size);
	}

	return (addr <= start) || (addr + size > end);
  10ac66:	b8 01 00 00 00       	mov    $0x1,%eax
  10ac6b:	39 cb                	cmp    %ecx,%ebx
  10ac6d:	73 0a                	jae    10ac79 <z_x86_check_stack_bounds+0x49>
  10ac6f:	03 4d 0c             	add    0xc(%ebp),%ecx
  10ac72:	31 c0                	xor    %eax,%eax
  10ac74:	39 d1                	cmp    %edx,%ecx
  10ac76:	0f 97 c0             	seta   %al
}
  10ac79:	5b                   	pop    %ebx
	return (addr <= start) || (addr + size > end);
  10ac7a:	83 e0 01             	and    $0x1,%eax
}
  10ac7d:	5d                   	pop    %ebp
  10ac7e:	c3                   	ret    

0010ac7f <z_x86_fatal_error>:
}
#endif /* CONFIG_EXCEPTION_DEBUG */

FUNC_NORETURN void z_x86_fatal_error(unsigned int reason,
				     const z_arch_esf_t *esf)
{
  10ac7f:	55                   	push   %ebp
  10ac80:	89 e5                	mov    %esp,%ebp
  10ac82:	57                   	push   %edi
  10ac83:	56                   	push   %esi
  10ac84:	53                   	push   %ebx
  10ac85:	83 ec 1c             	sub    $0x1c,%esp
  10ac88:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (esf != NULL) {
  10ac8b:	85 db                	test   %ebx,%ebx
  10ac8d:	0f 84 ba 01 00 00    	je     10ae4d <z_x86_fatal_error+0x1ce>
	LOG_ERR("EAX: 0x%08x, EBX: 0x%08x, ECX: 0x%08x, EDX: 0x%08x",
  10ac93:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ac9a:	0f 84 c4 00 00 00    	je     10ad64 <z_x86_fatal_error+0xe5>
  10aca0:	be b8 31 12 00       	mov    $0x1231b8,%esi
  10aca5:	8b 43 18             	mov    0x18(%ebx),%eax
  10aca8:	81 ee b0 30 12 00    	sub    $0x1230b0,%esi
  10acae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10acb1:	c1 ee 03             	shr    $0x3,%esi
  10acb4:	8b 43 08             	mov    0x8(%ebx),%eax
  10acb7:	c1 e6 06             	shl    $0x6,%esi
  10acba:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10acbd:	83 ce 01             	or     $0x1,%esi
  10acc0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  10acc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10acc6:	8b 43 14             	mov    0x14(%ebx),%eax
  10acc9:	56                   	push   %esi
  10acca:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  10accd:	6a 04                	push   $0x4
  10accf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10acd2:	57                   	push   %edi
  10acd3:	68 11 59 12 00       	push   $0x125911
  10acd8:	e8 75 89 ff ff       	call   103652 <log_n>
  10acdd:	83 c4 10             	add    $0x10,%esp
	LOG_ERR("ESI: 0x%08x, EDI: 0x%08x, EBP: 0x%08x, ESP: 0x%08x",
  10ace0:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ace7:	74 7b                	je     10ad64 <z_x86_fatal_error+0xe5>
  10ace9:	8b 43 0c             	mov    0xc(%ebx),%eax
  10acec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10acef:	8b 43 10             	mov    0x10(%ebx),%eax
  10acf2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10acf5:	8b 43 04             	mov    0x4(%ebx),%eax
  10acf8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10acfb:	8b 03                	mov    (%ebx),%eax
  10acfd:	56                   	push   %esi
  10acfe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10ad01:	6a 04                	push   $0x4
  10ad03:	57                   	push   %edi
  10ad04:	68 44 59 12 00       	push   $0x125944
  10ad09:	e8 44 89 ff ff       	call   103652 <log_n>
  10ad0e:	83 c4 10             	add    $0x10,%esp
	LOG_ERR("EFLAGS: 0x%08x CS: 0x%04x CR3: 0x%08lx", esf->eflags,
  10ad11:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ad18:	74 4a                	je     10ad64 <z_x86_fatal_error+0xe5>
{
	uintptr_t cr3;
#ifdef CONFIG_X86_64
	__asm__ volatile("movq %%cr3, %0\n\t" : "=r" (cr3));
#else
	__asm__ volatile("movl %%cr3, %0\n\t" : "=r" (cr3));
  10ad1a:	0f 20 d8             	mov    %cr3,%eax
  10ad1d:	56                   	push   %esi
  10ad1e:	50                   	push   %eax
  10ad1f:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  10ad23:	50                   	push   %eax
  10ad24:	ff 73 2c             	pushl  0x2c(%ebx)
  10ad27:	68 77 59 12 00       	push   $0x125977
  10ad2c:	e8 c8 88 ff ff       	call   1035f9 <log_3>
  10ad31:	83 c4 14             	add    $0x14,%esp
	LOG_ERR("call trace:");
  10ad34:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ad3b:	74 27                	je     10ad64 <z_x86_fatal_error+0xe5>
  10ad3d:	56                   	push   %esi
  10ad3e:	68 9e 59 12 00       	push   $0x12599e
  10ad43:	e8 05 88 ff ff       	call   10354d <log_0>
  10ad48:	5f                   	pop    %edi
	LOG_ERR("EIP: 0x%08x", esf->eip);
  10ad49:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
	LOG_ERR("call trace:");
  10ad50:	58                   	pop    %eax
	LOG_ERR("EIP: 0x%08x", esf->eip);
  10ad51:	74 11                	je     10ad64 <z_x86_fatal_error+0xe5>
  10ad53:	56                   	push   %esi
  10ad54:	ff 73 24             	pushl  0x24(%ebx)
  10ad57:	68 aa 59 12 00       	push   $0x1259aa
  10ad5c:	e8 15 88 ff ff       	call   103576 <log_1>
  10ad61:	83 c4 0c             	add    $0xc,%esp
	unwind_stack(esf->ebp, esf->cs);
  10ad64:	8b 7b 04             	mov    0x4(%ebx),%edi
	if (base_ptr == 0U) {
  10ad67:	85 ff                	test   %edi,%edi
  10ad69:	75 28                	jne    10ad93 <z_x86_fatal_error+0x114>
		LOG_ERR("NULL base ptr");
  10ad6b:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ad72:	0f 84 d5 00 00 00    	je     10ae4d <z_x86_fatal_error+0x1ce>
  10ad78:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10ad7d:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10ad82:	c1 e8 03             	shr    $0x3,%eax
  10ad85:	c1 e0 06             	shl    $0x6,%eax
  10ad88:	83 c8 01             	or     $0x1,%eax
  10ad8b:	50                   	push   %eax
  10ad8c:	68 b6 59 12 00       	push   $0x1259b6
  10ad91:	eb 45                	jmp    10add8 <z_x86_fatal_error+0x159>
  10ad93:	be b8 31 12 00       	mov    $0x1231b8,%esi
	unwind_stack(esf->ebp, esf->cs);
  10ad98:	8b 43 28             	mov    0x28(%ebx),%eax
  10ad9b:	81 ee b0 30 12 00    	sub    $0x1230b0,%esi
  10ada1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10ada4:	c1 ee 03             	shr    $0x3,%esi
  10ada7:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
		LOG_ERR("     0x%08lx (0x%lx)", frame->ret_addr, frame->args);
  10adae:	89 f0                	mov    %esi,%eax
  10adb0:	c1 e0 06             	shl    $0x6,%eax
  10adb3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		if (base_ptr % sizeof(base_ptr) != 0U) {
  10adb7:	f7 c7 03 00 00 00    	test   $0x3,%edi
  10adbd:	74 22                	je     10ade1 <z_x86_fatal_error+0x162>
			LOG_ERR("unaligned frame ptr");
  10adbf:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10adc6:	0f 84 81 00 00 00    	je     10ae4d <z_x86_fatal_error+0x1ce>
  10adcc:	c1 e6 06             	shl    $0x6,%esi
  10adcf:	83 ce 01             	or     $0x1,%esi
  10add2:	56                   	push   %esi
  10add3:	68 c4 59 12 00       	push   $0x1259c4
  10add8:	e8 70 87 ff ff       	call   10354d <log_0>
  10addd:	59                   	pop    %ecx
  10adde:	5e                   	pop    %esi
  10addf:	eb 6c                	jmp    10ae4d <z_x86_fatal_error+0x1ce>
		if (frame == NULL) {
  10ade1:	85 ff                	test   %edi,%edi
  10ade3:	74 68                	je     10ae4d <z_x86_fatal_error+0x1ce>
	unwind_stack(esf->ebp, esf->cs);
  10ade5:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
		if (z_x86_check_stack_bounds((uintptr_t)frame,
  10ade9:	50                   	push   %eax
  10adea:	6a 0c                	push   $0xc
  10adec:	57                   	push   %edi
  10aded:	e8 3e fe ff ff       	call   10ac30 <z_x86_check_stack_bounds>
  10adf2:	83 c4 0c             	add    $0xc,%esp
  10adf5:	84 c0                	test   %al,%al
  10adf7:	74 20                	je     10ae19 <z_x86_fatal_error+0x19a>
			LOG_ERR("     corrupted? (bp=%p)", frame);
  10adf9:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ae00:	74 4b                	je     10ae4d <z_x86_fatal_error+0x1ce>
  10ae02:	c1 e6 06             	shl    $0x6,%esi
  10ae05:	83 ce 01             	or     $0x1,%esi
  10ae08:	56                   	push   %esi
  10ae09:	57                   	push   %edi
  10ae0a:	68 d8 59 12 00       	push   $0x1259d8
  10ae0f:	e8 62 87 ff ff       	call   103576 <log_1>
  10ae14:	83 c4 0c             	add    $0xc,%esp
  10ae17:	eb 34                	jmp    10ae4d <z_x86_fatal_error+0x1ce>
		if (frame->ret_addr == 0U) {
  10ae19:	8b 47 04             	mov    0x4(%edi),%eax
  10ae1c:	85 c0                	test   %eax,%eax
  10ae1e:	74 2d                	je     10ae4d <z_x86_fatal_error+0x1ce>
		LOG_ERR("     0x%08lx (0x%lx)", frame->ret_addr, frame->args);
  10ae20:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ae27:	74 19                	je     10ae42 <z_x86_fatal_error+0x1c3>
  10ae29:	66 8b 4d da          	mov    -0x26(%ebp),%cx
  10ae2d:	83 c9 01             	or     $0x1,%ecx
  10ae30:	51                   	push   %ecx
  10ae31:	ff 77 08             	pushl  0x8(%edi)
  10ae34:	50                   	push   %eax
  10ae35:	68 f0 59 12 00       	push   $0x1259f0
  10ae3a:	e8 71 87 ff ff       	call   1035b0 <log_2>
  10ae3f:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < MAX_STACK_FRAMES; i++) {
  10ae42:	ff 4d dc             	decl   -0x24(%ebp)
		base_ptr = frame->next;
  10ae45:	8b 3f                	mov    (%edi),%edi
	for (i = 0; i < MAX_STACK_FRAMES; i++) {
  10ae47:	0f 85 6a ff ff ff    	jne    10adb7 <z_x86_fatal_error+0x138>
			LOG_ERR("Attempt to resume un-suspended thread object");
			reason = K_ERR_KERNEL_PANIC;
		}
#endif
	}
	z_fatal_error(reason, esf);
  10ae4d:	53                   	push   %ebx
  10ae4e:	ff 75 08             	pushl  0x8(%ebp)
  10ae51:	e8 51 56 01 00       	call   1204a7 <z_fatal_error>
  10ae56:	58                   	pop    %eax
  10ae57:	5a                   	pop    %edx

0010ae58 <z_x86_unhandled_cpu_exception>:
	CODE_UNREACHABLE;
}

FUNC_NORETURN void z_x86_unhandled_cpu_exception(uintptr_t vector,
						 const z_arch_esf_t *esf)
{
  10ae58:	55                   	push   %ebp
  10ae59:	89 e5                	mov    %esp,%ebp
  10ae5b:	53                   	push   %ebx
  10ae5c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10ae5f:	8b 45 08             	mov    0x8(%ebp),%eax
  10ae62:	83 f8 1e             	cmp    $0x1e,%eax
#ifdef CONFIG_EXCEPTION_DEBUG
	log_exception(vector, esf_get_code(esf));
  10ae65:	8b 53 20             	mov    0x20(%ebx),%edx
	switch (vector) {
  10ae68:	0f 87 54 03 00 00    	ja     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10ae6e:	ff 24 85 bc 42 12 00 	jmp    *0x1242bc(,%eax,4)
		LOG_ERR("Divide by zero");
  10ae75:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10ae7c:	0f 84 40 03 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10ae82:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10ae87:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10ae8c:	c1 e8 03             	shr    $0x3,%eax
  10ae8f:	c1 e0 06             	shl    $0x6,%eax
  10ae92:	83 c8 01             	or     $0x1,%eax
  10ae95:	50                   	push   %eax
  10ae96:	68 05 5a 12 00       	push   $0x125a05
  10ae9b:	e9 1b 03 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Debug");
  10aea0:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10aea7:	0f 84 15 03 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10aead:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10aeb2:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10aeb7:	c1 e8 03             	shr    $0x3,%eax
  10aeba:	c1 e0 06             	shl    $0x6,%eax
  10aebd:	83 c8 01             	or     $0x1,%eax
  10aec0:	50                   	push   %eax
  10aec1:	68 14 5a 12 00       	push   $0x125a14
  10aec6:	e9 f0 02 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Non-maskable interrupt");
  10aecb:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10aed2:	0f 84 ea 02 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10aed8:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10aedd:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10aee2:	c1 e8 03             	shr    $0x3,%eax
  10aee5:	c1 e0 06             	shl    $0x6,%eax
  10aee8:	83 c8 01             	or     $0x1,%eax
  10aeeb:	50                   	push   %eax
  10aeec:	68 1a 5a 12 00       	push   $0x125a1a
  10aef1:	e9 c5 02 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Breakpoint");
  10aef6:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10aefd:	0f 84 bf 02 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10af03:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10af08:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10af0d:	c1 e8 03             	shr    $0x3,%eax
  10af10:	c1 e0 06             	shl    $0x6,%eax
  10af13:	83 c8 01             	or     $0x1,%eax
  10af16:	50                   	push   %eax
  10af17:	68 31 5a 12 00       	push   $0x125a31
  10af1c:	e9 9a 02 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Overflow");
  10af21:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10af28:	0f 84 94 02 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10af2e:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10af33:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10af38:	c1 e8 03             	shr    $0x3,%eax
  10af3b:	c1 e0 06             	shl    $0x6,%eax
  10af3e:	83 c8 01             	or     $0x1,%eax
  10af41:	50                   	push   %eax
  10af42:	68 3c 5a 12 00       	push   $0x125a3c
  10af47:	e9 6f 02 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Bound range exceeded");
  10af4c:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10af53:	0f 84 69 02 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10af59:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10af5e:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10af63:	c1 e8 03             	shr    $0x3,%eax
  10af66:	c1 e0 06             	shl    $0x6,%eax
  10af69:	83 c8 01             	or     $0x1,%eax
  10af6c:	50                   	push   %eax
  10af6d:	68 45 5a 12 00       	push   $0x125a45
  10af72:	e9 44 02 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Invalid opcode");
  10af77:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10af7e:	0f 84 3e 02 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10af84:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10af89:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10af8e:	c1 e8 03             	shr    $0x3,%eax
  10af91:	c1 e0 06             	shl    $0x6,%eax
  10af94:	83 c8 01             	or     $0x1,%eax
  10af97:	50                   	push   %eax
  10af98:	68 5a 5a 12 00       	push   $0x125a5a
  10af9d:	e9 19 02 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Floating point unit device not available");
  10afa2:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10afa9:	0f 84 13 02 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10afaf:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10afb4:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10afb9:	c1 e8 03             	shr    $0x3,%eax
  10afbc:	c1 e0 06             	shl    $0x6,%eax
  10afbf:	83 c8 01             	or     $0x1,%eax
  10afc2:	50                   	push   %eax
  10afc3:	68 69 5a 12 00       	push   $0x125a69
  10afc8:	e9 ee 01 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Double fault (code 0x%lx)", code);
  10afcd:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10afd4:	0f 84 e8 01 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10afda:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10afdf:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10afe4:	c1 e8 03             	shr    $0x3,%eax
  10afe7:	c1 e0 06             	shl    $0x6,%eax
  10afea:	83 c8 01             	or     $0x1,%eax
  10afed:	50                   	push   %eax
  10afee:	52                   	push   %edx
  10afef:	68 92 5a 12 00       	push   $0x125a92
  10aff4:	e9 cf 00 00 00       	jmp    10b0c8 <z_x86_unhandled_cpu_exception+0x270>
		LOG_ERR("Co-processor segment overrun");
  10aff9:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b000:	0f 84 bc 01 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b006:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b00b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b010:	c1 e8 03             	shr    $0x3,%eax
  10b013:	c1 e0 06             	shl    $0x6,%eax
  10b016:	83 c8 01             	or     $0x1,%eax
  10b019:	50                   	push   %eax
  10b01a:	68 ac 5a 12 00       	push   $0x125aac
  10b01f:	e9 97 01 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Invalid TSS (code 0x%lx)", code);
  10b024:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b02b:	0f 84 91 01 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b031:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b036:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b03b:	c1 e8 03             	shr    $0x3,%eax
  10b03e:	c1 e0 06             	shl    $0x6,%eax
  10b041:	83 c8 01             	or     $0x1,%eax
  10b044:	50                   	push   %eax
  10b045:	52                   	push   %edx
  10b046:	68 c9 5a 12 00       	push   $0x125ac9
  10b04b:	eb 7b                	jmp    10b0c8 <z_x86_unhandled_cpu_exception+0x270>
		LOG_ERR("Segment not present (code 0x%lx)", code);
  10b04d:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b054:	0f 84 68 01 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b05a:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b05f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b064:	c1 e8 03             	shr    $0x3,%eax
  10b067:	c1 e0 06             	shl    $0x6,%eax
  10b06a:	83 c8 01             	or     $0x1,%eax
  10b06d:	50                   	push   %eax
  10b06e:	52                   	push   %edx
  10b06f:	68 e2 5a 12 00       	push   $0x125ae2
  10b074:	eb 52                	jmp    10b0c8 <z_x86_unhandled_cpu_exception+0x270>
		LOG_ERR("Stack segment fault");
  10b076:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b07d:	0f 84 3f 01 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b083:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b088:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b08d:	c1 e8 03             	shr    $0x3,%eax
  10b090:	c1 e0 06             	shl    $0x6,%eax
  10b093:	83 c8 01             	or     $0x1,%eax
  10b096:	50                   	push   %eax
  10b097:	68 03 5b 12 00       	push   $0x125b03
  10b09c:	e9 1a 01 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("General protection fault (code 0x%lx)", code);
  10b0a1:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b0a8:	0f 84 14 01 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b0ae:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b0b3:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b0b8:	c1 e8 03             	shr    $0x3,%eax
  10b0bb:	c1 e0 06             	shl    $0x6,%eax
  10b0be:	83 c8 01             	or     $0x1,%eax
  10b0c1:	50                   	push   %eax
  10b0c2:	52                   	push   %edx
  10b0c3:	68 17 5b 12 00       	push   $0x125b17
  10b0c8:	e8 a9 84 ff ff       	call   103576 <log_1>
  10b0cd:	83 c4 0c             	add    $0xc,%esp
  10b0d0:	e9 ed 00 00 00       	jmp    10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
		LOG_ERR("x87 floating point exception");
  10b0d5:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b0dc:	0f 84 e0 00 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b0e2:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b0e7:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b0ec:	c1 e8 03             	shr    $0x3,%eax
  10b0ef:	c1 e0 06             	shl    $0x6,%eax
  10b0f2:	83 c8 01             	or     $0x1,%eax
  10b0f5:	50                   	push   %eax
  10b0f6:	68 3d 5b 12 00       	push   $0x125b3d
  10b0fb:	e9 bb 00 00 00       	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Alignment check (code 0x%lx)", code);
  10b100:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b107:	0f 84 b5 00 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b10d:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b112:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b117:	c1 e8 03             	shr    $0x3,%eax
  10b11a:	c1 e0 06             	shl    $0x6,%eax
  10b11d:	83 c8 01             	or     $0x1,%eax
  10b120:	50                   	push   %eax
  10b121:	52                   	push   %edx
  10b122:	68 5a 5b 12 00       	push   $0x125b5a
  10b127:	eb 9f                	jmp    10b0c8 <z_x86_unhandled_cpu_exception+0x270>
		LOG_ERR("Machine check");
  10b129:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b130:	0f 84 8c 00 00 00    	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b136:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b13b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b140:	c1 e8 03             	shr    $0x3,%eax
  10b143:	c1 e0 06             	shl    $0x6,%eax
  10b146:	83 c8 01             	or     $0x1,%eax
  10b149:	50                   	push   %eax
  10b14a:	68 77 5b 12 00       	push   $0x125b77
  10b14f:	eb 6a                	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("SIMD floating point exception");
  10b151:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b158:	74 68                	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b15a:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b15f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b164:	c1 e8 03             	shr    $0x3,%eax
  10b167:	c1 e0 06             	shl    $0x6,%eax
  10b16a:	83 c8 01             	or     $0x1,%eax
  10b16d:	50                   	push   %eax
  10b16e:	68 85 5b 12 00       	push   $0x125b85
  10b173:	eb 46                	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Virtualization exception");
  10b175:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b17c:	74 44                	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b17e:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b183:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b188:	c1 e8 03             	shr    $0x3,%eax
  10b18b:	c1 e0 06             	shl    $0x6,%eax
  10b18e:	83 c8 01             	or     $0x1,%eax
  10b191:	50                   	push   %eax
  10b192:	68 a3 5b 12 00       	push   $0x125ba3
  10b197:	eb 22                	jmp    10b1bb <z_x86_unhandled_cpu_exception+0x363>
		LOG_ERR("Security exception");
  10b199:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b1a0:	74 20                	je     10b1c2 <z_x86_unhandled_cpu_exception+0x36a>
  10b1a2:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b1a7:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b1ac:	c1 e8 03             	shr    $0x3,%eax
  10b1af:	c1 e0 06             	shl    $0x6,%eax
  10b1b2:	83 c8 01             	or     $0x1,%eax
  10b1b5:	50                   	push   %eax
  10b1b6:	68 bc 5b 12 00       	push   $0x125bbc
  10b1bb:	e8 8d 83 ff ff       	call   10354d <log_0>
  10b1c0:	58                   	pop    %eax
  10b1c1:	5a                   	pop    %edx
#else
	ARG_UNUSED(vector);
#endif
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, esf);
  10b1c2:	53                   	push   %ebx
  10b1c3:	6a 00                	push   $0x0
  10b1c5:	e8 b5 fa ff ff       	call   10ac7f <z_x86_fatal_error>

0010b1ca <z_x86_page_fault_handler>:
	Z_EXC_HANDLE(z_x86_user_string_nlen)
};
#endif

void z_x86_page_fault_handler(z_arch_esf_t *esf)
{
  10b1ca:	55                   	push   %ebp
  10b1cb:	89 e5                	mov    %esp,%ebp
  10b1cd:	57                   	push   %edi
  10b1ce:	56                   	push   %esi
  10b1cf:	53                   	push   %ebx
  10b1d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__asm__ ("mov %%cr2, %0" : "=r" (cr2));
  10b1d3:	0f 20 d6             	mov    %cr2,%esi
	err = esf_get_code(esf);
  10b1d6:	8b 7b 20             	mov    0x20(%ebx),%edi
	LOG_ERR("Page fault at address 0x%lx (error code 0x%lx)", cr2, err);
  10b1d9:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b1e0:	74 23                	je     10b205 <z_x86_page_fault_handler+0x3b>
  10b1e2:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b1e7:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b1ec:	c1 e8 03             	shr    $0x3,%eax
  10b1ef:	c1 e0 06             	shl    $0x6,%eax
  10b1f2:	83 c8 01             	or     $0x1,%eax
  10b1f5:	50                   	push   %eax
  10b1f6:	57                   	push   %edi
  10b1f7:	56                   	push   %esi
  10b1f8:	68 cf 5b 12 00       	push   $0x125bcf
  10b1fd:	e8 ae 83 ff ff       	call   1035b0 <log_2>
  10b202:	83 c4 10             	add    $0x10,%esp
	if ((err & RSVD) != 0) {
  10b205:	a1 1c 5c 14 00       	mov    0x145c1c,%eax
  10b20a:	83 e0 07             	and    $0x7,%eax
  10b20d:	f7 c7 08 00 00 00    	test   $0x8,%edi
  10b213:	74 26                	je     10b23b <z_x86_page_fault_handler+0x71>
		LOG_ERR("Reserved bits set in page tables");
  10b215:	85 c0                	test   %eax,%eax
  10b217:	0f 84 02 01 00 00    	je     10b31f <z_x86_page_fault_handler+0x155>
  10b21d:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b222:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b227:	c1 e8 03             	shr    $0x3,%eax
  10b22a:	c1 e0 06             	shl    $0x6,%eax
  10b22d:	83 c8 01             	or     $0x1,%eax
  10b230:	50                   	push   %eax
  10b231:	68 fe 5b 12 00       	push   $0x125bfe
  10b236:	e9 dd 00 00 00       	jmp    10b318 <z_x86_page_fault_handler+0x14e>
		if ((err & PRESENT) == 0) {
  10b23b:	f7 c7 01 00 00 00    	test   $0x1,%edi
  10b241:	75 24                	jne    10b267 <z_x86_page_fault_handler+0x9d>
			LOG_ERR("Linear address not present in page tables");
  10b243:	85 c0                	test   %eax,%eax
  10b245:	74 7d                	je     10b2c4 <z_x86_page_fault_handler+0xfa>
  10b247:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b24c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b251:	c1 e8 03             	shr    $0x3,%eax
  10b254:	c1 e0 06             	shl    $0x6,%eax
  10b257:	83 c8 01             	or     $0x1,%eax
  10b25a:	50                   	push   %eax
  10b25b:	68 1f 5c 12 00       	push   $0x125c1f
  10b260:	e8 e8 82 ff ff       	call   10354d <log_0>
  10b265:	58                   	pop    %eax
  10b266:	5a                   	pop    %edx
		LOG_ERR("Access violation: %s thread not allowed to %s",
  10b267:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b26e:	74 54                	je     10b2c4 <z_x86_page_fault_handler+0xfa>
  10b270:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b275:	ba 4f 5c 12 00       	mov    $0x125c4f,%edx
  10b27a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b27f:	c1 e8 03             	shr    $0x3,%eax
  10b282:	c1 e0 06             	shl    $0x6,%eax
  10b285:	83 c8 01             	or     $0x1,%eax
  10b288:	f7 c7 10 00 00 00    	test   $0x10,%edi
  10b28e:	75 12                	jne    10b2a2 <z_x86_page_fault_handler+0xd8>
  10b290:	ba 7c 47 12 00       	mov    $0x12477c,%edx
  10b295:	f7 c7 02 00 00 00    	test   $0x2,%edi
  10b29b:	74 05                	je     10b2a2 <z_x86_page_fault_handler+0xd8>
  10b29d:	ba 49 5c 12 00       	mov    $0x125c49,%edx
  10b2a2:	b9 5c 5c 12 00       	mov    $0x125c5c,%ecx
  10b2a7:	f7 c7 04 00 00 00    	test   $0x4,%edi
  10b2ad:	74 05                	je     10b2b4 <z_x86_page_fault_handler+0xea>
  10b2af:	b9 57 5c 12 00       	mov    $0x125c57,%ecx
  10b2b4:	50                   	push   %eax
  10b2b5:	52                   	push   %edx
  10b2b6:	51                   	push   %ecx
  10b2b7:	68 67 5c 12 00       	push   $0x125c67
  10b2bc:	e8 ef 82 ff ff       	call   1035b0 <log_2>
  10b2c1:	83 c4 10             	add    $0x10,%esp
		if ((err & PK) != 0) {
  10b2c4:	f7 c7 20 00 00 00    	test   $0x20,%edi
  10b2ca:	74 24                	je     10b2f0 <z_x86_page_fault_handler+0x126>
			LOG_ERR("Protection key disallowed");
  10b2cc:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b2d3:	74 4a                	je     10b31f <z_x86_page_fault_handler+0x155>
  10b2d5:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b2da:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b2df:	c1 e8 03             	shr    $0x3,%eax
  10b2e2:	c1 e0 06             	shl    $0x6,%eax
  10b2e5:	83 c8 01             	or     $0x1,%eax
  10b2e8:	50                   	push   %eax
  10b2e9:	68 95 5c 12 00       	push   $0x125c95
  10b2ee:	eb 28                	jmp    10b318 <z_x86_page_fault_handler+0x14e>
		} else if ((err & SGX) != 0) {
  10b2f0:	0f ba e7 0f          	bt     $0xf,%edi
  10b2f4:	73 29                	jae    10b31f <z_x86_page_fault_handler+0x155>
			LOG_ERR("SGX access control violation");
  10b2f6:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b2fd:	74 20                	je     10b31f <z_x86_page_fault_handler+0x155>
  10b2ff:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b304:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b309:	c1 e8 03             	shr    $0x3,%eax
  10b30c:	c1 e0 06             	shl    $0x6,%eax
  10b30f:	83 c8 01             	or     $0x1,%eax
  10b312:	50                   	push   %eax
  10b313:	68 af 5c 12 00       	push   $0x125caf
  10b318:	e8 30 82 ff ff       	call   10354d <log_0>
  10b31d:	59                   	pop    %ecx
  10b31e:	5f                   	pop    %edi
  10b31f:	0f 20 d8             	mov    %cr3,%eax
	z_x86_dump_mmu_flags(get_ptables(esf), (void *)cr2);
  10b322:	56                   	push   %esi
  10b323:	50                   	push   %eax
  10b324:	e8 b9 00 00 00       	call   10b3e2 <z_x86_dump_mmu_flags>
  10b329:	58                   	pop    %eax
#endif
#ifdef CONFIG_EXCEPTION_DEBUG
	dump_page_fault(esf);
#endif
#ifdef CONFIG_THREAD_STACK_INFO
	if (z_x86_check_stack_bounds(esf_get_sp(esf), 0, esf->cs)) {
  10b32a:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
	z_x86_dump_mmu_flags(get_ptables(esf), (void *)cr2);
  10b32e:	5a                   	pop    %edx
	if (z_x86_check_stack_bounds(esf_get_sp(esf), 0, esf->cs)) {
  10b32f:	50                   	push   %eax
  10b330:	6a 00                	push   $0x0
  10b332:	ff 33                	pushl  (%ebx)
  10b334:	e8 f7 f8 ff ff       	call   10ac30 <z_x86_check_stack_bounds>
  10b339:	83 c4 0c             	add    $0xc,%esp
  10b33c:	84 c0                	test   %al,%al
  10b33e:	74 05                	je     10b345 <z_x86_page_fault_handler+0x17b>
		z_x86_fatal_error(K_ERR_STACK_CHK_FAIL, esf);
  10b340:	53                   	push   %ebx
  10b341:	6a 02                	push   $0x2
  10b343:	eb 03                	jmp    10b348 <z_x86_page_fault_handler+0x17e>
	}
#endif
	z_x86_fatal_error(K_ERR_CPU_EXCEPTION, esf);
  10b345:	53                   	push   %ebx
  10b346:	6a 00                	push   $0x0
  10b348:	e8 32 f9 ff ff       	call   10ac7f <z_x86_fatal_error>

0010b34d <z_x86_do_kernel_oops>:
	CODE_UNREACHABLE;
}

void z_x86_do_kernel_oops(const z_arch_esf_t *esf)
{
  10b34d:	55                   	push   %ebp
  10b34e:	89 e5                	mov    %esp,%ebp
  10b350:	8b 45 08             	mov    0x8(%ebp),%eax
				      reason == K_ERR_STACK_CHK_FAIL)) {
		reason = K_ERR_KERNEL_OOPS;
	}
#endif

	z_x86_fatal_error(reason, esf);
  10b353:	50                   	push   %eax
	reason = *stack_ptr;
  10b354:	8b 00                	mov    (%eax),%eax
	z_x86_fatal_error(reason, esf);
  10b356:	ff 30                	pushl  (%eax)
  10b358:	e8 22 f9 ff ff       	call   10ac7f <z_x86_fatal_error>

0010b35d <str_append>:

SYS_INIT(dump_kernel_tables, APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
#endif

static void str_append(char **buf, size_t *size, const char *str)
{
  10b35d:	55                   	push   %ebp
  10b35e:	89 e5                	mov    %esp,%ebp
  10b360:	56                   	push   %esi
  10b361:	53                   	push   %ebx
  10b362:	89 c6                	mov    %eax,%esi
	int ret = snprintk(*buf, *size, "%s", str);
  10b364:	51                   	push   %ecx
{
  10b365:	89 d3                	mov    %edx,%ebx
	int ret = snprintk(*buf, *size, "%s", str);
  10b367:	68 f8 4e 12 00       	push   $0x124ef8
  10b36c:	ff 32                	pushl  (%edx)
  10b36e:	ff 30                	pushl  (%eax)
  10b370:	e8 8a 5f ff ff       	call   1012ff <snprintk>

	if (ret >= *size) {
  10b375:	8b 13                	mov    (%ebx),%edx
	int ret = snprintk(*buf, *size, "%s", str);
  10b377:	83 c4 10             	add    $0x10,%esp
	if (ret >= *size) {
  10b37a:	39 c2                	cmp    %eax,%edx
  10b37c:	77 08                	ja     10b386 <str_append+0x29>
		/* Truncated */
		*size = 0U;
  10b37e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  10b384:	eb 06                	jmp    10b38c <str_append+0x2f>
	} else {
		*size -= ret;
  10b386:	29 c2                	sub    %eax,%edx
  10b388:	89 13                	mov    %edx,(%ebx)
		*buf += ret;
  10b38a:	01 06                	add    %eax,(%esi)
	}

}
  10b38c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10b38f:	5b                   	pop    %ebx
  10b390:	5e                   	pop    %esi
  10b391:	5d                   	pop    %ebp
  10b392:	c3                   	ret    

0010b393 <z_x86_pentry_get>:
	#undef DUMP_BIT
}

void z_x86_pentry_get(int *paging_level, pentry_t *val, pentry_t *ptables,
		      void *virt)
{
  10b393:	55                   	push   %ebp
  10b394:	89 e5                	mov    %esp,%ebp
  10b396:	57                   	push   %edi
  10b397:	56                   	push   %esi
	pentry_t *table = ptables;

	for (int level = 0; level < NUM_LEVELS; level++) {
  10b398:	31 f6                	xor    %esi,%esi
{
  10b39a:	53                   	push   %ebx
  10b39b:	8b 7d 10             	mov    0x10(%ebp),%edi
	for (int level = 0; level < NUM_LEVELS; level++) {
  10b39e:	bb 80 36 12 00       	mov    $0x123680,%ebx
	return (((uintptr_t)virt >> paging_levels[level].shift) %
  10b3a3:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  10b3a6:	8b 45 14             	mov    0x14(%ebp),%eax
  10b3a9:	d3 e8                	shr    %cl,%eax
  10b3ab:	31 d2                	xor    %edx,%edx
  10b3ad:	f7 73 08             	divl   0x8(%ebx)
	return ptables[get_index(virt, level)];
  10b3b0:	8b 0c d7             	mov    (%edi,%edx,8),%ecx
  10b3b3:	8b 44 d7 04          	mov    0x4(%edi,%edx,8),%eax
		pentry_t entry = get_entry(table, virt, level);

		if ((entry & MMU_P) == 0 || is_leaf(level, entry)) {
  10b3b7:	f6 c1 01             	test   $0x1,%cl
  10b3ba:	74 0a                	je     10b3c6 <z_x86_pentry_get+0x33>
	if (level == NUM_LEVELS - 1) {
  10b3bc:	83 fe 02             	cmp    $0x2,%esi
  10b3bf:	74 05                	je     10b3c6 <z_x86_pentry_get+0x33>
		if ((entry & MMU_P) == 0 || is_leaf(level, entry)) {
  10b3c1:	f6 c1 80             	test   $0x80,%cl
  10b3c4:	74 12                	je     10b3d8 <z_x86_pentry_get+0x45>
			*val = entry;
  10b3c6:	8b 55 0c             	mov    0xc(%ebp),%edx
  10b3c9:	89 42 04             	mov    %eax,0x4(%edx)
			*paging_level = level;
  10b3cc:	8b 45 08             	mov    0x8(%ebp),%eax
			*val = entry;
  10b3cf:	89 0a                	mov    %ecx,(%edx)
			*paging_level = level;
  10b3d1:	89 30                	mov    %esi,(%eax)
			break;
		} else {
			table = next_table(entry, level);
		}
	}
}
  10b3d3:	5b                   	pop    %ebx
  10b3d4:	5e                   	pop    %esi
  10b3d5:	5f                   	pop    %edi
  10b3d6:	5d                   	pop    %ebp
  10b3d7:	c3                   	ret    
	return entry & paging_levels[level].mask;
  10b3d8:	8b 3b                	mov    (%ebx),%edi
	for (int level = 0; level < NUM_LEVELS; level++) {
  10b3da:	46                   	inc    %esi
	return entry & paging_levels[level].mask;
  10b3db:	21 cf                	and    %ecx,%edi
	for (int level = 0; level < NUM_LEVELS; level++) {
  10b3dd:	83 c3 14             	add    $0x14,%ebx
  10b3e0:	eb c1                	jmp    10b3a3 <z_x86_pentry_get+0x10>

0010b3e2 <z_x86_dump_mmu_flags>:
/*
 * Debug function for dumping out MMU table information to the LOG for a
 * specific virtual address, such as when we get an unexpected page fault.
 */
void z_x86_dump_mmu_flags(pentry_t *ptables, void *virt)
{
  10b3e2:	55                   	push   %ebp
  10b3e3:	89 e5                	mov    %esp,%ebp
  10b3e5:	57                   	push   %edi
  10b3e6:	56                   	push   %esi
  10b3e7:	53                   	push   %ebx
	pentry_t entry;
	int level;

	z_x86_pentry_get(&level, &entry, ptables, virt);
  10b3e8:	8d 45 c4             	lea    -0x3c(%ebp),%eax
{
  10b3eb:	83 ec 40             	sub    $0x40,%esp
	z_x86_pentry_get(&level, &entry, ptables, virt);
  10b3ee:	ff 75 0c             	pushl  0xc(%ebp)
  10b3f1:	ff 75 08             	pushl  0x8(%ebp)
  10b3f4:	50                   	push   %eax
  10b3f5:	8d 45 b8             	lea    -0x48(%ebp),%eax
  10b3f8:	50                   	push   %eax
  10b3f9:	e8 95 ff ff ff       	call   10b393 <z_x86_pentry_get>

	if ((entry & MMU_P) == 0) {
  10b3fe:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
	z_x86_pentry_get(&level, &entry, ptables, virt);
  10b401:	83 c4 10             	add    $0x10,%esp
	if ((entry & MMU_P) == 0) {
  10b404:	8b 75 c8             	mov    -0x38(%ebp),%esi
  10b407:	f6 c3 01             	test   $0x1,%bl
  10b40a:	75 3d                	jne    10b449 <z_x86_dump_mmu_flags+0x67>
		LOG_ERR("%sE: not present", paging_levels[level].name);
  10b40c:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b413:	0f 84 6b 01 00 00    	je     10b584 <z_x86_dump_mmu_flags+0x1a2>
  10b419:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  10b41e:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10b423:	c1 e8 03             	shr    $0x3,%eax
  10b426:	c1 e0 06             	shl    $0x6,%eax
  10b429:	83 c8 01             	or     $0x1,%eax
  10b42c:	50                   	push   %eax
  10b42d:	6b 45 b8 14          	imul   $0x14,-0x48(%ebp),%eax
  10b431:	ff b0 90 36 12 00    	pushl  0x123690(%eax)
  10b437:	68 cc 5c 12 00       	push   $0x125ccc
  10b43c:	e8 35 81 ff ff       	call   103576 <log_1>
  10b441:	83 c4 0c             	add    $0xc,%esp
  10b444:	e9 3b 01 00 00       	jmp    10b584 <z_x86_dump_mmu_flags+0x1a2>
	} else {
		dump_entry(level, virt, entry);
  10b449:	8b 45 b8             	mov    -0x48(%ebp),%eax
	char buf[24] = { 0 };
  10b44c:	8d 7d e0             	lea    -0x20(%ebp),%edi
		dump_entry(level, virt, entry);
  10b44f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	char buf[24] = { 0 };
  10b452:	b9 05 00 00 00       	mov    $0x5,%ecx
  10b457:	31 c0                	xor    %eax,%eax
  10b459:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  10b460:	f3 ab                	rep stos %eax,%es:(%edi)
	char *pos = buf;
  10b462:	8d 45 dc             	lea    -0x24(%ebp),%eax
	size_t sz = sizeof(buf);
  10b465:	c7 45 c0 18 00 00 00 	movl   $0x18,-0x40(%ebp)
	char *pos = buf;
  10b46c:	89 45 bc             	mov    %eax,-0x44(%ebp)
	return (1UL << paging_levels[level].shift);
  10b46f:	6b 45 b4 14          	imul   $0x14,-0x4c(%ebp),%eax
	DUMP_BIT(RW);
  10b473:	f6 c3 02             	test   $0x2,%bl
	return (1UL << paging_levels[level].shift);
  10b476:	8b b8 8c 36 12 00    	mov    0x12368c(%eax),%edi
	DUMP_BIT(RW);
  10b47c:	74 10                	je     10b48e <z_x86_dump_mmu_flags+0xac>
  10b47e:	b9 dd 5c 12 00       	mov    $0x125cdd,%ecx
  10b483:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b486:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b489:	e8 cf fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(US);
  10b48e:	f6 c3 04             	test   $0x4,%bl
  10b491:	74 10                	je     10b4a3 <z_x86_dump_mmu_flags+0xc1>
  10b493:	b9 e1 5c 12 00       	mov    $0x125ce1,%ecx
  10b498:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b49b:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b49e:	e8 ba fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(PWT);
  10b4a3:	f6 c3 08             	test   $0x8,%bl
  10b4a6:	74 10                	je     10b4b8 <z_x86_dump_mmu_flags+0xd6>
  10b4a8:	b9 e5 5c 12 00       	mov    $0x125ce5,%ecx
  10b4ad:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b4b0:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b4b3:	e8 a5 fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(PCD);
  10b4b8:	f6 c3 10             	test   $0x10,%bl
  10b4bb:	74 10                	je     10b4cd <z_x86_dump_mmu_flags+0xeb>
  10b4bd:	b9 ea 5c 12 00       	mov    $0x125cea,%ecx
  10b4c2:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b4c5:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b4c8:	e8 90 fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(A);
  10b4cd:	f6 c3 20             	test   $0x20,%bl
  10b4d0:	74 10                	je     10b4e2 <z_x86_dump_mmu_flags+0x100>
  10b4d2:	b9 ef 5c 12 00       	mov    $0x125cef,%ecx
  10b4d7:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b4da:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b4dd:	e8 7b fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(D);
  10b4e2:	f6 c3 40             	test   $0x40,%bl
  10b4e5:	74 10                	je     10b4f7 <z_x86_dump_mmu_flags+0x115>
  10b4e7:	b9 ec 5c 12 00       	mov    $0x125cec,%ecx
  10b4ec:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b4ef:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b4f2:	e8 66 fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(G);
  10b4f7:	0f ba e3 08          	bt     $0x8,%ebx
  10b4fb:	73 10                	jae    10b50d <z_x86_dump_mmu_flags+0x12b>
  10b4fd:	b9 f2 5c 12 00       	mov    $0x125cf2,%ecx
  10b502:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b505:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b508:	e8 50 fe ff ff       	call   10b35d <str_append>
	DUMP_BIT(XD);
  10b50d:	85 f6                	test   %esi,%esi
  10b50f:	79 10                	jns    10b521 <z_x86_dump_mmu_flags+0x13f>
  10b511:	b9 f5 5c 12 00       	mov    $0x125cf5,%ecx
  10b516:	8d 55 c0             	lea    -0x40(%ebp),%edx
  10b519:	8d 45 bc             	lea    -0x44(%ebp),%eax
  10b51c:	e8 3c fe ff ff       	call   10b35d <str_append>
	LOG_ERR("%sE: %p -> " PRI_ENTRY ": %s", info->name,
  10b521:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b528:	74 5a                	je     10b584 <z_x86_dump_mmu_flags+0x1a2>
  10b52a:	6b 45 b4 14          	imul   $0x14,-0x4c(%ebp),%eax
	uint8_t *virtmap = (uint8_t *)ROUND_DOWN(virt, get_entry_scope(level));
  10b52e:	89 f9                	mov    %edi,%ecx
  10b530:	be b8 31 12 00       	mov    $0x1231b8,%esi
	LOG_ERR("%sE: %p -> " PRI_ENTRY ": %s", info->name,
  10b535:	8b 90 90 36 12 00    	mov    0x123690(%eax),%edx
  10b53b:	23 98 80 36 12 00    	and    0x123680(%eax),%ebx
  10b541:	89 55 cc             	mov    %edx,-0x34(%ebp)
	return (1UL << paging_levels[level].shift);
  10b544:	83 ca ff             	or     $0xffffffff,%edx
	uint8_t *virtmap = (uint8_t *)ROUND_DOWN(virt, get_entry_scope(level));
  10b547:	d3 e2                	shl    %cl,%edx
  10b549:	23 55 0c             	and    0xc(%ebp),%edx
	LOG_ERR("%sE: %p -> " PRI_ENTRY ": %s", info->name,
  10b54c:	8d 45 dc             	lea    -0x24(%ebp),%eax
  10b54f:	50                   	push   %eax
	uint8_t *virtmap = (uint8_t *)ROUND_DOWN(virt, get_entry_scope(level));
  10b550:	89 55 d0             	mov    %edx,-0x30(%ebp)
	LOG_ERR("%sE: %p -> " PRI_ENTRY ": %s", info->name,
  10b553:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  10b556:	e8 fc 7c ff ff       	call   103257 <log_strdup>
  10b55b:	81 ee b0 30 12 00    	sub    $0x1230b0,%esi
  10b561:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10b564:	c1 ee 03             	shr    $0x3,%esi
  10b567:	8d 45 cc             	lea    -0x34(%ebp),%eax
  10b56a:	c1 e6 06             	shl    $0x6,%esi
  10b56d:	83 ce 01             	or     $0x1,%esi
  10b570:	66 89 34 24          	mov    %si,(%esp)
  10b574:	6a 04                	push   $0x4
  10b576:	50                   	push   %eax
  10b577:	68 f9 5c 12 00       	push   $0x125cf9
  10b57c:	e8 d1 80 ff ff       	call   103652 <log_n>
  10b581:	83 c4 10             	add    $0x10,%esp
	}
}
  10b584:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b587:	5b                   	pop    %ebx
  10b588:	5e                   	pop    %esi
  10b589:	5f                   	pop    %edi
  10b58a:	5d                   	pop    %ebp
  10b58b:	c3                   	ret    

0010b58c <arch_mem_map>:
	return 0;
}

/* map region virt..virt+size to phys with provided arch-neutral flags */
int arch_mem_map(void *virt, uintptr_t phys, size_t size, uint32_t flags)
{
  10b58c:	55                   	push   %ebp
		entry_flags |= MMU_PWT;
		break;
	case K_MEM_CACHE_WB:
		break;
	default:
		return -ENOTSUP;
  10b58d:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
{
  10b592:	89 e5                	mov    %esp,%ebp
  10b594:	57                   	push   %edi
  10b595:	56                   	push   %esi
  10b596:	53                   	push   %ebx
  10b597:	83 ec 14             	sub    $0x14,%esp
  10b59a:	8b 4d 14             	mov    0x14(%ebp),%ecx
	switch (flags & K_MEM_CACHE_MASK) {
  10b59d:	89 cb                	mov    %ecx,%ebx
  10b59f:	83 e3 07             	and    $0x7,%ebx
  10b5a2:	83 fb 02             	cmp    $0x2,%ebx
  10b5a5:	0f 87 01 01 00 00    	ja     10b6ac <arch_mem_map+0x120>
  10b5ab:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  10b5b0:	f7 e3                	mul    %ebx
  10b5b2:	29 da                	sub    %ebx,%edx
  10b5b4:	83 c0 11             	add    $0x11,%eax
  10b5b7:	83 d2 00             	adc    $0x0,%edx
  10b5ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10b5bd:	89 55 f0             	mov    %edx,-0x10(%ebp)
	}
	if ((flags & K_MEM_PERM_RW) != 0U) {
  10b5c0:	f6 c1 08             	test   $0x8,%cl
  10b5c3:	74 09                	je     10b5ce <arch_mem_map+0x42>
		entry_flags |= MMU_RW;
  10b5c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10b5c8:	83 ca 02             	or     $0x2,%edx
  10b5cb:	89 55 ec             	mov    %edx,-0x14(%ebp)
	}
	if ((flags & K_MEM_PERM_USER) != 0U) {
  10b5ce:	89 cf                	mov    %ecx,%edi
		return -ENOTSUP;
  10b5d0:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	if ((flags & K_MEM_PERM_USER) != 0U) {
  10b5d5:	83 e7 20             	and    $0x20,%edi
  10b5d8:	0f 85 ce 00 00 00    	jne    10b6ac <arch_mem_map+0x120>
		/* TODO: user mode support
		 * entry_flags |= MMU_US;
		 */
		return -ENOTSUP;
	}
	if ((flags & K_MEM_PERM_EXEC) == 0U) {
  10b5de:	80 e1 10             	and    $0x10,%cl
  10b5e1:	0f 85 96 00 00 00    	jne    10b67d <arch_mem_map+0xf1>
		entry_flags |= MMU_XD;
  10b5e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b5ea:	0d 00 00 00 80       	or     $0x80000000,%eax
  10b5ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}

	for (size_t offset = 0; offset < size; offset += CONFIG_MMU_PAGE_SIZE) {
  10b5f2:	e9 86 00 00 00       	jmp    10b67d <arch_mem_map+0xf1>
		if ((*entryp & MMU_P) == 0U) {
  10b5f7:	8b 1a                	mov    (%edx),%ebx
  10b5f9:	f6 c3 01             	test   $0x1,%bl
  10b5fc:	0f 85 9d 00 00 00    	jne    10b69f <arch_mem_map+0x113>
  10b602:	9c                   	pushf  
  10b603:	fa                   	cli    
  10b604:	59                   	pop    %ecx
	if (page_pos == page_pool) {
  10b605:	a1 fc 5a 14 00       	mov    0x145afc,%eax
		ret = NULL;
  10b60a:	31 db                	xor    %ebx,%ebx
	if (page_pos == page_pool) {
  10b60c:	3d 00 f0 12 00       	cmp    $0x12f000,%eax
  10b611:	74 0c                	je     10b61f <arch_mem_map+0x93>
		page_pos -= CONFIG_MMU_PAGE_SIZE;
  10b613:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx
  10b619:	89 1d fc 5a 14 00    	mov    %ebx,0x145afc
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10b61f:	0f ba e1 09          	bt     $0x9,%ecx
  10b623:	73 01                	jae    10b626 <arch_mem_map+0x9a>
		__asm__ volatile ("sti" ::: "memory");
  10b625:	fb                   	sti    
  10b626:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (ret != NULL) {
  10b629:	85 db                	test   %ebx,%ebx
  10b62b:	74 7a                	je     10b6a7 <arch_mem_map+0x11b>
		memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
  10b62d:	68 00 10 00 00       	push   $0x1000
  10b632:	6a 00                	push   $0x0
  10b634:	53                   	push   %ebx
  10b635:	e8 21 08 00 00       	call   10be5b <memset>
			*entryp = ((uintptr_t)new_table) | INT_FLAGS;
  10b63a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10b63d:	89 d8                	mov    %ebx,%eax
  10b63f:	83 c8 07             	or     $0x7,%eax
		memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
  10b642:	83 c4 0c             	add    $0xc,%esp
			*entryp = ((uintptr_t)new_table) | INT_FLAGS;
  10b645:	89 02                	mov    %eax,(%edx)
  10b647:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	for (int level = 0; level < NUM_LEVELS; level++) {
  10b64e:	83 c6 14             	add    $0x14,%esi
	return (((uintptr_t)virt >> paging_levels[level].shift) %
  10b651:	8b 45 08             	mov    0x8(%ebp),%eax
  10b654:	8b 4e 0c             	mov    0xc(%esi),%ecx
  10b657:	01 f8                	add    %edi,%eax
  10b659:	31 d2                	xor    %edx,%edx
  10b65b:	d3 e8                	shr    %cl,%eax
  10b65d:	f7 76 08             	divl   0x8(%esi)
		if (level == (NUM_LEVELS - 1)) {
  10b660:	b8 a8 36 12 00       	mov    $0x1236a8,%eax
		entryp = &table[index];
  10b665:	8d 14 d3             	lea    (%ebx,%edx,8),%edx
		if (level == (NUM_LEVELS - 1)) {
  10b668:	39 f0                	cmp    %esi,%eax
  10b66a:	75 8b                	jne    10b5f7 <arch_mem_map+0x6b>
			*entryp = entry_val;
  10b66c:	8b 45 e8             	mov    -0x18(%ebp),%eax
	for (size_t offset = 0; offset < size; offset += CONFIG_MMU_PAGE_SIZE) {
  10b66f:	81 c7 00 10 00 00    	add    $0x1000,%edi
			*entryp = entry_val;
  10b675:	89 02                	mov    %eax,(%edx)
  10b677:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10b67a:	89 42 04             	mov    %eax,0x4(%edx)
	for (size_t offset = 0; offset < size; offset += CONFIG_MMU_PAGE_SIZE) {
  10b67d:	39 7d 10             	cmp    %edi,0x10(%ebp)
  10b680:	76 21                	jbe    10b6a3 <arch_mem_map+0x117>
		int ret;
		pentry_t entry_val = (phys + offset) | entry_flags;
  10b682:	8b 45 0c             	mov    0xc(%ebp),%eax
  10b685:	be 80 36 12 00       	mov    $0x123680,%esi
  10b68a:	01 f8                	add    %edi,%eax
	pentry_t *table = ptables;
  10b68c:	bb 00 90 14 00       	mov    $0x149000,%ebx
		pentry_t entry_val = (phys + offset) | entry_flags;
  10b691:	0b 45 ec             	or     -0x14(%ebp),%eax
  10b694:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10b697:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10b69a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static int page_map_set(pentry_t *ptables, void *virt, pentry_t entry_val,
  10b69d:	eb b2                	jmp    10b651 <arch_mem_map+0xc5>
	return entry & paging_levels[level].mask;
  10b69f:	23 1e                	and    (%esi),%ebx
  10b6a1:	eb ab                	jmp    10b64e <arch_mem_map+0xc2>
			 */
			return ret;
		}
	}

	return 0;
  10b6a3:	31 c0                	xor    %eax,%eax
  10b6a5:	eb 05                	jmp    10b6ac <arch_mem_map+0x120>
  10b6a7:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
  10b6ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10b6af:	5b                   	pop    %ebx
  10b6b0:	5e                   	pop    %esi
  10b6b1:	5f                   	pop    %edi
  10b6b2:	5d                   	pop    %ebp
  10b6b3:	c3                   	ret    

0010b6b4 <arch_printk_char_out>:
	}
	OUT(REG_THR, c);
}

int arch_printk_char_out(int c)
{
  10b6b4:	55                   	push   %ebp
  10b6b5:	89 e5                	mov    %esp,%ebp
	if (c == '\n') {
  10b6b7:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
  10b6bb:	75 12                	jne    10b6cf <arch_printk_char_out+0x1b>
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10b6bd:	ba fd 03 00 00       	mov    $0x3fd,%edx
  10b6c2:	ec                   	in     (%dx),%al
	while ((IN(REG_LSR) & LSR_THRE) == 0) {
  10b6c3:	a8 20                	test   $0x20,%al
  10b6c5:	74 fb                	je     10b6c2 <arch_printk_char_out+0xe>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10b6c7:	b0 0d                	mov    $0xd,%al
  10b6c9:	ba f8 03 00 00       	mov    $0x3f8,%edx
  10b6ce:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  10b6cf:	ba fd 03 00 00       	mov    $0x3fd,%edx
  10b6d4:	ec                   	in     (%dx),%al
  10b6d5:	a8 20                	test   $0x20,%al
  10b6d7:	74 fb                	je     10b6d4 <arch_printk_char_out+0x20>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  10b6d9:	ba f8 03 00 00       	mov    $0x3f8,%edx
  10b6de:	8a 45 08             	mov    0x8(%ebp),%al
  10b6e1:	ee                   	out    %al,(%dx)
		serout('\r');
	}
	serout(c);
	return c;
}
  10b6e2:	8b 45 08             	mov    0x8(%ebp),%eax
  10b6e5:	5d                   	pop    %ebp
  10b6e6:	c3                   	ret    

0010b6e7 <z_x86_early_serial_init>:

void z_x86_early_serial_init(void)
{
  10b6e7:	55                   	push   %ebp
  10b6e8:	89 e5                	mov    %esp,%ebp
  10b6ea:	56                   	push   %esi
  10b6eb:	53                   	push   %ebx
  10b6ec:	be f9 03 00 00       	mov    $0x3f9,%esi
  10b6f1:	31 db                	xor    %ebx,%ebx
  10b6f3:	89 f2                	mov    %esi,%edx
  10b6f5:	88 d8                	mov    %bl,%al
  10b6f7:	ee                   	out    %al,(%dx)
  10b6f8:	b9 fb 03 00 00       	mov    $0x3fb,%ecx
  10b6fd:	b0 80                	mov    $0x80,%al
  10b6ff:	89 ca                	mov    %ecx,%edx
  10b701:	ee                   	out    %al,(%dx)
  10b702:	b0 01                	mov    $0x1,%al
  10b704:	ba f8 03 00 00       	mov    $0x3f8,%edx
  10b709:	ee                   	out    %al,(%dx)
  10b70a:	88 d8                	mov    %bl,%al
  10b70c:	89 f2                	mov    %esi,%edx
  10b70e:	ee                   	out    %al,(%dx)
  10b70f:	b0 03                	mov    $0x3,%al
  10b711:	89 ca                	mov    %ecx,%edx
  10b713:	ee                   	out    %al,(%dx)
  10b714:	ba fc 03 00 00       	mov    $0x3fc,%edx
  10b719:	ee                   	out    %al,(%dx)
  10b71a:	b0 07                	mov    $0x7,%al
  10b71c:	ba fa 03 00 00       	mov    $0x3fa,%edx
  10b721:	ee                   	out    %al,(%dx)
	OUT(REG_LCR, LCR_8N1);         /* LCR = 8n1 + DLAB off */
	OUT(REG_MCR, MCR_DTR | MCR_RTS);

	/* Turn on FIFO. Some hardware needs this before transmitting */
	OUT(REG_FCR, FCR_FIFO | FCR_FIFO_1 | FCR_RCVRCLR | FCR_XMITCLR);
}
  10b722:	5b                   	pop    %ebx
  10b723:	5e                   	pop    %esi
  10b724:	5d                   	pop    %ebp
  10b725:	c3                   	ret    

0010b726 <init_cache>:
	return 0;
#endif
}

static int init_cache(const struct device *unused)
{
  10b726:	55                   	push   %ebp
  10b727:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = z_cache_line_size_get();
  10b729:	e8 09 00 00 00       	call   10b737 <z_cache_line_size_get>

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
    init_cache_line_size();
#endif
	return 0;
}
  10b72e:	5d                   	pop    %ebp
	sys_cache_line_size = z_cache_line_size_get();
  10b72f:	a3 9c eb 12 00       	mov    %eax,0x12eb9c
}
  10b734:	31 c0                	xor    %eax,%eax
  10b736:	c3                   	ret    

0010b737 <z_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(z_cache_line_size_get)

SECTION_FUNC(TEXT, z_cache_line_size_get)
	pushl %ebx
  10b737:	53                   	push   %ebx
	movl $1, %eax
  10b738:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  10b73d:	0f a2                	cpuid  
	movl %ebx, %eax
  10b73f:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  10b741:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  10b746:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  10b749:	5b                   	pop    %ebx
	ret
  10b74a:	c3                   	ret    

0010b74b <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  10b74b:	fc                   	cld    
	call z_x86_trampoline_to_kernel
#endif
	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  10b74c:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  10b74f:	50                   	push   %eax
	pushl	%edx
  10b750:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  10b751:	57                   	push   %edi
	pushl	%esi
  10b752:	56                   	push   %esi
	pushl	%ebx
  10b753:	53                   	push   %ebx
	pushl	%ebp
  10b754:	55                   	push   %ebp
	 */
	pushl	44(%esp)
	jmp 2f
1:
#endif
	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  10b755:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  10b759:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __z_arch_esf_t_eflags_OFFSET(%esp)
  10b75a:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  10b761:	00 
	je	allDone
  10b762:	74 01                	je     10b765 <allDone>
	sti
  10b764:	fb                   	sti    

0010b765 <allDone>:

allDone:
	pushl	%esp			/* push z_arch_esf_t * parameter */
  10b765:	54                   	push   %esp
	call	*%ecx			/* call exception handler */
  10b766:	ff d1                	call   *%ecx
	addl	$0x4, %esp
  10b768:	83 c4 04             	add    $0x4,%esp
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  10b76b:	5d                   	pop    %ebp
	popl	%ebp
  10b76c:	5d                   	pop    %ebp
	popl	%ebx
  10b76d:	5b                   	pop    %ebx
	popl	%esi
  10b76e:	5e                   	pop    %esi
	popl	%edi
  10b76f:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  10b770:	5a                   	pop    %edx
	popl	%eax
  10b771:	58                   	pop    %eax
	popl	%ecx
  10b772:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  10b773:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
  10b776:	cf                   	iret   

0010b777 <_kernel_oops_handler>:

SECTION_FUNC(TEXT, _kernel_oops_handler)
	push $0 /* dummy error code */
  10b777:	6a 00                	push   $0x0
	push $z_x86_do_kernel_oops
  10b779:	68 4d b3 10 00       	push   $0x10b34d
	jmp _exception_enter
  10b77e:	e9 c8 ff ff ff       	jmp    10b74b <_exception_enter>

0010b783 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  10b783:	fc                   	cld    
#endif
	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  10b784:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  10b788:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  10b78b:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, arch_swap(), etc)
	 */
	pushl	%edi
  10b78c:	57                   	push   %edi

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  10b78d:	b9 c0 e9 12 00       	mov    $0x12e9c0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  10b792:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  10b794:	83 39 01             	cmpl   $0x1,(%ecx)
	jne	alreadyOnIntStack
  10b797:	75 06                	jne    10b79f <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  10b799:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  10b79b:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  10b79e:	57                   	push   %edi

0010b79f <alreadyOnIntStack>:

	/* fall through to nested case */

alreadyOnIntStack:

	push	%eax	/* interrupt handler argument */
  10b79f:	50                   	push   %eax
	popl	%edx
	popl	%eax
#endif

#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  10b7a0:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  10b7a1:	ff d2                	call   *%edx
	/* Discard ISR argument */
	addl	$0x4, %esp
  10b7a3:	83 c4 04             	add    $0x4,%esp
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  10b7a6:	fa                   	cli    
	pushl	%eax
	call	sys_trace_isr_exit
	popl	%eax
#endif

	xorl	%eax, %eax
  10b7a7:	31 c0                	xor    %eax,%eax
	xorl	%edx, %edx
	movl	$(X86_X2APIC_BASE_MSR + (LOAPIC_EOI >> 4)), %ecx
	wrmsr
#else /* xAPIC */
#ifdef DEVICE_MMIO_IS_IN_RAM
	movl	z_loapic_regs, %edx
  10b7a9:	8b 15 74 eb 12 00    	mov    0x12eb74,%edx
	movl	%eax, LOAPIC_EOI(%edx)
  10b7af:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
	movl	%eax, (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI)
#endif /* DEVICE_MMIO_IS_IN_RAM */
#endif /* CONFIG_X2APIC */

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  10b7b5:	b9 c0 e9 12 00       	mov    $0x12e9c0,%ecx
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  10b7ba:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  10b7bc:	75 18                	jne    10b7d6 <nestedInterrupt>

#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  10b7be:	8b 51 08             	mov    0x8(%ecx),%edx

	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  10b7c1:	39 51 24             	cmp    %edx,0x24(%ecx)
	je	noReschedule
  10b7c4:	74 0f                	je     10b7d5 <noReschedule>
	 * the existing arch_swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  10b7c6:	5c                   	pop    %esp

#ifdef CONFIG_STACK_SENTINEL
	call	z_check_stack_sentinel
#endif
	pushfl			/* push KERNEL_LOCK_KEY argument */
  10b7c7:	9c                   	pushf  
	call	arch_swap
  10b7c8:	e8 24 00 00 00       	call   10b7f1 <arch_swap>
	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
  10b7cd:	83 c4 04             	add    $0x4,%esp
	movl	_kernel + _kernel_offset_to_current, %eax
	andb	$~X86_THREAD_FLAG_INT, _thread_offset_to_flags(%eax)
#endif /* CONFIG_LAZY_FPU_SHARING */

	/* Restore volatile registers and return to the interrupted thread */
	popl	%edi
  10b7d0:	5f                   	pop    %edi
	popl	%ecx
  10b7d1:	59                   	pop    %ecx
	popl	%edx
  10b7d2:	5a                   	pop    %edx
	popl	%eax
  10b7d3:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
  10b7d4:	cf                   	iret   

0010b7d5 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  10b7d5:	5c                   	pop    %esp

0010b7d6 <nestedInterrupt>:
	 * utilized, and more importantly, a rescheduling decision must
	 * not be performed.
	 */

nestedInterrupt:
	popl	%edi
  10b7d6:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  10b7d7:	59                   	pop    %ecx
	popl	%edx
  10b7d8:	5a                   	pop    %edx
	popl	%eax
  10b7d9:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	KPTI_IRET
  10b7da:	cf                   	iret   

0010b7db <z_SpuriousIntNoErrCodeHandler>:
 * thus z_SpuriousIntNoErrCodeHandler()/z_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, z_SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  10b7db:	6a 00                	push   $0x0

0010b7dd <z_SpuriousIntHandler>:
	/* fall through to z_SpuriousIntHandler */


SECTION_FUNC(TEXT, z_SpuriousIntHandler)

	cld				/* Clear direction flag */
  10b7dd:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  10b7de:	50                   	push   %eax
	pushl %ecx
  10b7df:	51                   	push   %ecx
	pushl %edx
  10b7e0:	52                   	push   %edx
	pushl %edi
  10b7e1:	57                   	push   %edi
	pushl %esi
  10b7e2:	56                   	push   %esi
	pushl %ebx
  10b7e3:	53                   	push   %ebx
	pushl %ebp
  10b7e4:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  10b7e5:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  10b7e9:	51                   	push   %ecx

	pushl	%esp		/* push cur stack pointer: pEsf arg */
  10b7ea:	54                   	push   %esp

	/* re-enable interrupts */
	sti
  10b7eb:	fb                   	sti    

	/* call the fatal error handler */
	call	z_x86_spurious_irq
  10b7ec:	e8 ab 00 00 00       	call   10b89c <z_x86_spurious_irq>

0010b7f1 <arch_swap>:
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  10b7f1:	57                   	push   %edi

	movl	$_kernel, %edi
  10b7f2:	bf c0 e9 12 00       	mov    $0x12e9c0,%edi

	pushl	%esi
  10b7f7:	56                   	push   %esi
	pushl	%ebx
  10b7f8:	53                   	push   %ebx
	pushl	%ebp
  10b7f9:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * arch_thread_return_value_set().
	 */

	pushl   _k_neg_eagain
  10b7fa:	ff 35 b8 46 12 00    	pushl  0x1246b8


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %edx
  10b800:	8b 57 08             	mov    0x8(%edi),%edx
	movl	%esp, _thread_offset_to_esp(%edx)
  10b803:	89 62 3c             	mov    %esp,0x3c(%edx)
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  10b806:	8b 47 24             	mov    0x24(%edi),%eax

#endif /* CONFIG_LAZY_FPU_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  10b809:	89 47 08             	mov    %eax,0x8(%edi)
	popl	%eax
#endif

	/* recover thread stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  10b80c:	8b 60 3c             	mov    0x3c(%eax),%esp


	/* load return value from a possible arch_thread_return_value_set() */

	popl	%eax
  10b80f:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  10b810:	5d                   	pop    %ebp
	popl	%ebx
  10b811:	5b                   	pop    %ebx
	popl	%esi
  10b812:	5e                   	pop    %esi
	popl	%edi
  10b813:	5f                   	pop    %edi
	 * - -EINVAL
	 */

	/* Utilize the 'eflags' parameter to arch_swap() */

	pushl	4(%esp)
  10b814:	ff 74 24 04          	pushl  0x4(%esp)
	popfl
  10b818:	9d                   	popf   
#if defined(CONFIG_TRACING)
	pushl	%eax
	call	sys_trace_thread_switched_in
	popl	%eax
#endif
	ret
  10b819:	c3                   	ret    

0010b81a <z_x86_thread_entry_wrapper>:
 *
 * @return this routine does NOT return.
 */

SECTION_FUNC(TEXT, z_x86_thread_entry_wrapper)
	movl	$0, (%esp)
  10b81a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	jmp	*%edi
  10b821:	ff e7                	jmp    *%edi

0010b823 <arch_new_thread>:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  10b823:	55                   	push   %ebp
  10b824:	89 e5                	mov    %esp,%ebp
  10b826:	8b 45 10             	mov    0x10(%ebp),%eax
	/* Create an initial context on the stack expected by z_swap() */
	initial_frame = Z_STACK_PTR_TO_FRAME(struct _x86_initial_frame,
					     stack_ptr);

	/* z_thread_entry() arguments */
	initial_frame->entry = entry;
  10b829:	8b 4d 14             	mov    0x14(%ebp),%ecx
{
  10b82c:	8b 55 08             	mov    0x8(%ebp),%edx
	initial_frame = Z_STACK_PTR_TO_FRAME(struct _x86_initial_frame,
  10b82f:	83 e8 2c             	sub    $0x2c,%eax
	initial_frame->entry = entry;
  10b832:	89 48 1c             	mov    %ecx,0x1c(%eax)
	initial_frame->p1 = p1;
  10b835:	8b 4d 18             	mov    0x18(%ebp),%ecx
  10b838:	89 48 20             	mov    %ecx,0x20(%eax)
	initial_frame->p2 = p2;
  10b83b:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  10b83e:	89 48 24             	mov    %ecx,0x24(%eax)
	initial_frame->p3 = p3;
  10b841:	8b 4d 20             	mov    0x20(%ebp),%ecx
  10b844:	89 48 28             	mov    %ecx,0x28(%eax)
	initial_frame->eflags = EFLAGS_INITIAL;
  10b847:	c7 40 18 00 02 00 00 	movl   $0x200,0x18(%eax)
#ifdef _THREAD_WRAPPER_REQUIRED
	initial_frame->edi = (uint32_t)swap_entry;
  10b84e:	c7 40 10 c7 19 10 00 	movl   $0x1019c7,0x10(%eax)
	initial_frame->thread_entry = z_x86_thread_entry_wrapper;
  10b855:	c7 40 14 1a b8 10 00 	movl   $0x10b81a,0x14(%eax)
	initial_frame = Z_STACK_PTR_TO_FRAME(struct _x86_initial_frame,
  10b85c:	89 42 3c             	mov    %eax,0x3c(%edx)
	 */
	thread->callee_saved.esp = (unsigned long)initial_frame;
#if defined(CONFIG_LAZY_FPU_SHARING)
	thread->arch.excNestCount = 0;
#endif /* CONFIG_LAZY_FPU_SHARING */
	thread->arch.flags = 0;
  10b85f:	c6 82 90 00 00 00 00 	movb   $0x0,0x90(%edx)
}
  10b866:	5d                   	pop    %ebp
  10b867:	c3                   	ret    

0010b868 <arch_switch_to_main_thread>:
 * Use some sufficiently aligned bytes in the lower memory of the interrupt
 * stack instead, otherwise the logic is more or less the same.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
  10b868:	55                   	push   %ebp
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
  10b869:	66 c7 05 f8 4b 14 00 	movw   $0x101,0x144bf8
  10b870:	01 01 
  10b872:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
  10b874:	c7 05 6c 4c 14 00 00 	movl   $0x0,0x144c6c
  10b87b:	00 00 00 
	dummy_thread->stack_info.size = 0U;
  10b87e:	c7 05 70 4c 14 00 00 	movl   $0x0,0x144c70
  10b885:	00 00 00 
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
  10b888:	c7 05 c8 e9 12 00 ec 	movl   $0x144bec,0x12e9c8
  10b88f:	4b 14 00 
  10b892:	9c                   	pushf  
  10b893:	fa                   	cli    
  10b894:	58                   	pop    %eax
	ret = arch_swap(key);
  10b895:	50                   	push   %eax
  10b896:	e8 56 ff ff ff       	call   10b7f1 <arch_swap>
  10b89b:	58                   	pop    %eax

0010b89c <z_x86_spurious_irq>:
#endif

__weak void z_debug_fatal_hook(const z_arch_esf_t *esf) { ARG_UNUSED(esf); }

void z_x86_spurious_irq(const z_arch_esf_t *esf)
{
  10b89c:	55                   	push   %ebp
  10b89d:	89 e5                	mov    %esp,%ebp
	int vector = z_irq_controller_isr_vector_get();
  10b89f:	e8 34 ed ff ff       	call   10a5d8 <z_irq_controller_isr_vector_get>

	if (vector >= 0) {
  10b8a4:	85 c0                	test   %eax,%eax
  10b8a6:	78 2c                	js     10b8d4 <z_x86_spurious_irq+0x38>
		LOG_ERR("IRQ vector: %d", vector);
  10b8a8:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  10b8af:	74 23                	je     10b8d4 <z_x86_spurious_irq+0x38>
  10b8b1:	ba b8 31 12 00       	mov    $0x1231b8,%edx
  10b8b6:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  10b8bc:	c1 ea 03             	shr    $0x3,%edx
  10b8bf:	c1 e2 06             	shl    $0x6,%edx
  10b8c2:	83 ca 01             	or     $0x1,%edx
  10b8c5:	52                   	push   %edx
  10b8c6:	50                   	push   %eax
  10b8c7:	68 1a 5d 12 00       	push   $0x125d1a
  10b8cc:	e8 a5 7c ff ff       	call   103576 <log_1>
  10b8d1:	83 c4 0c             	add    $0xc,%esp
	}

	z_x86_fatal_error(K_ERR_SPURIOUS_IRQ, esf);
  10b8d4:	ff 75 08             	pushl  0x8(%ebp)
  10b8d7:	6a 01                	push   $0x1
  10b8d9:	e8 a1 f3 ff ff       	call   10ac7f <z_x86_fatal_error>

0010b8de <handle_exc_0>:
	Z_EXC_FUNC_NOCODE(vector, dpl)

#define EXC_FUNC_CODE(vector, dpl)		\
	Z_EXC_FUNC_CODE(vector, dpl)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR, 0);
  10b8de:	55                   	push   %ebp
  10b8df:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b8e1:	ff 75 08             	pushl  0x8(%ebp)
  10b8e4:	6a 00                	push   $0x0
  10b8e6:	e8 6d f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b8eb <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT, 0);
  10b8eb:	55                   	push   %ebp
  10b8ec:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b8ee:	ff 75 08             	pushl  0x8(%ebp)
  10b8f1:	6a 02                	push   $0x2
  10b8f3:	e8 60 f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b8f8 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW, 0);
  10b8f8:	55                   	push   %ebp
  10b8f9:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b8fb:	ff 75 08             	pushl  0x8(%ebp)
  10b8fe:	6a 04                	push   $0x4
  10b900:	e8 53 f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b905 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE, 0);
  10b905:	55                   	push   %ebp
  10b906:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b908:	ff 75 08             	pushl  0x8(%ebp)
  10b90b:	6a 05                	push   $0x5
  10b90d:	e8 46 f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b912 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE, 0);
  10b912:	55                   	push   %ebp
  10b913:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b915:	ff 75 08             	pushl  0x8(%ebp)
  10b918:	6a 06                	push   $0x6
  10b91a:	e8 39 f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b91f <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE, 0);
  10b91f:	55                   	push   %ebp
  10b920:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b922:	ff 75 08             	pushl  0x8(%ebp)
  10b925:	6a 07                	push   $0x7
  10b927:	e8 2c f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b92c <handle_exc_8>:
#ifndef CONFIG_X86_ENABLE_TSS
EXC_FUNC_NOCODE(IV_DOUBLE_FAULT, 0);
  10b92c:	55                   	push   %ebp
  10b92d:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b92f:	ff 75 08             	pushl  0x8(%ebp)
  10b932:	6a 08                	push   $0x8
  10b934:	e8 1f f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b939 <handle_exc_10>:
#endif
EXC_FUNC_CODE(IV_INVALID_TSS, 0);
  10b939:	55                   	push   %ebp
  10b93a:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b93c:	ff 75 08             	pushl  0x8(%ebp)
  10b93f:	6a 0a                	push   $0xa
  10b941:	e8 12 f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b946 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT, 0);
  10b946:	55                   	push   %ebp
  10b947:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b949:	ff 75 08             	pushl  0x8(%ebp)
  10b94c:	6a 0b                	push   $0xb
  10b94e:	e8 05 f5 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b953 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT, 0);
  10b953:	55                   	push   %ebp
  10b954:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b956:	ff 75 08             	pushl  0x8(%ebp)
  10b959:	6a 0c                	push   $0xc
  10b95b:	e8 f8 f4 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b960 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION, 0);
  10b960:	55                   	push   %ebp
  10b961:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b963:	ff 75 08             	pushl  0x8(%ebp)
  10b966:	6a 0d                	push   $0xd
  10b968:	e8 eb f4 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b96d <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR, 0);
  10b96d:	55                   	push   %ebp
  10b96e:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b970:	ff 75 08             	pushl  0x8(%ebp)
  10b973:	6a 10                	push   $0x10
  10b975:	e8 de f4 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b97a <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK, 0);
  10b97a:	55                   	push   %ebp
  10b97b:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b97d:	ff 75 08             	pushl  0x8(%ebp)
  10b980:	6a 11                	push   $0x11
  10b982:	e8 d1 f4 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b987 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK, 0);
  10b987:	55                   	push   %ebp
  10b988:	89 e5                	mov    %esp,%ebp
	z_x86_unhandled_cpu_exception(vector, pEsf);
  10b98a:	ff 75 08             	pushl  0x8(%ebp)
  10b98d:	6a 12                	push   $0x12
  10b98f:	e8 c4 f4 ff ff       	call   10ae58 <z_x86_unhandled_cpu_exception>

0010b994 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
  10b994:	55                   	push   %ebp
  10b995:	89 e5                	mov    %esp,%ebp
  10b997:	57                   	push   %edi
  10b998:	56                   	push   %esi
  10b999:	53                   	push   %ebx
  10b99a:	83 ec 10             	sub    $0x10,%esp
  10b99d:	8b 75 10             	mov    0x10(%ebp),%esi
	register const char *s = nptr;
  10b9a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
  10b9a3:	89 d8                	mov    %ebx,%eax
  10b9a5:	43                   	inc    %ebx
  10b9a6:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
  10b9aa:	8d 51 f7             	lea    -0x9(%ecx),%edx
	} while (isspace(c));
  10b9ad:	83 fa 04             	cmp    $0x4,%edx
  10b9b0:	76 f1                	jbe    10b9a3 <strtol+0xf>
  10b9b2:	83 f9 20             	cmp    $0x20,%ecx
  10b9b5:	74 ec                	je     10b9a3 <strtol+0xf>
	if (c == '-') {
  10b9b7:	83 f9 2d             	cmp    $0x2d,%ecx
  10b9ba:	75 0f                	jne    10b9cb <strtol+0x37>
		neg = 1;
		c = *s++;
  10b9bc:	0f be 0b             	movsbl (%ebx),%ecx
		neg = 1;
  10b9bf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
  10b9c6:	8d 58 02             	lea    0x2(%eax),%ebx
  10b9c9:	eb 12                	jmp    10b9dd <strtol+0x49>
	register int neg = 0, any, cutlim;
  10b9cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	} else if (c == '+') {
  10b9d2:	83 f9 2b             	cmp    $0x2b,%ecx
  10b9d5:	75 06                	jne    10b9dd <strtol+0x49>
		c = *s++;
  10b9d7:	0f be 0b             	movsbl (%ebx),%ecx
  10b9da:	8d 58 02             	lea    0x2(%eax),%ebx
	}

	if ((base == 0 || base == 16) &&
  10b9dd:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
  10b9e3:	75 22                	jne    10ba07 <strtol+0x73>
  10b9e5:	83 f9 30             	cmp    $0x30,%ecx
  10b9e8:	0f 85 c8 00 00 00    	jne    10bab6 <strtol+0x122>
	    c == '0' && (*s == 'x' || *s == 'X')) {
  10b9ee:	8a 03                	mov    (%ebx),%al
  10b9f0:	83 e0 df             	and    $0xffffffdf,%eax
  10b9f3:	3c 58                	cmp    $0x58,%al
  10b9f5:	0f 85 cd 00 00 00    	jne    10bac8 <strtol+0x134>
		c = s[1];
  10b9fb:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
		s += 2;
		base = 16;
  10b9ff:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
  10ba04:	83 c3 02             	add    $0x2,%ebx
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  10ba07:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10ba0a:	31 d2                	xor    %edx,%edx
  10ba0c:	05 ff ff ff 7f       	add    $0x7fffffff,%eax
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
  10ba11:	31 ff                	xor    %edi,%edi
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  10ba13:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cutlim = cutoff % (unsigned long)base;
  10ba16:	f7 f6                	div    %esi
  10ba18:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (acc = 0, any = 0;; c = *s++) {
  10ba1b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10ba1e:	31 c0                	xor    %eax,%eax
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  10ba20:	8d 51 d0             	lea    -0x30(%ecx),%edx
		if (isdigit(c)) {
  10ba23:	83 fa 09             	cmp    $0x9,%edx
  10ba26:	77 04                	ja     10ba2c <strtol+0x98>
			c -= '0';
  10ba28:	89 d1                	mov    %edx,%ecx
  10ba2a:	eb 1d                	jmp    10ba49 <strtol+0xb5>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  10ba2c:	89 ca                	mov    %ecx,%edx
  10ba2e:	83 ca 20             	or     $0x20,%edx
  10ba31:	83 ea 61             	sub    $0x61,%edx
		} else if (isalpha(c)) {
  10ba34:	83 fa 19             	cmp    $0x19,%edx
  10ba37:	77 40                	ja     10ba79 <strtol+0xe5>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  10ba39:	8d 51 bf             	lea    -0x41(%ecx),%edx
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
  10ba3c:	83 fa 1a             	cmp    $0x1a,%edx
  10ba3f:	19 d2                	sbb    %edx,%edx
  10ba41:	83 e2 e0             	and    $0xffffffe0,%edx
  10ba44:	83 c2 57             	add    $0x57,%edx
  10ba47:	29 d1                	sub    %edx,%ecx
		} else {
			break;
		}
		if (c >= base) {
  10ba49:	39 ce                	cmp    %ecx,%esi
  10ba4b:	7e 2c                	jle    10ba79 <strtol+0xe5>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  10ba4d:	85 ff                	test   %edi,%edi
  10ba4f:	78 1e                	js     10ba6f <strtol+0xdb>
  10ba51:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10ba54:	77 19                	ja     10ba6f <strtol+0xdb>
  10ba56:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  10ba59:	75 08                	jne    10ba63 <strtol+0xcf>
			any = -1;
  10ba5b:	83 cf ff             	or     $0xffffffff,%edi
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  10ba5e:	3b 4d e4             	cmp    -0x1c(%ebp),%ecx
  10ba61:	7f 0f                	jg     10ba72 <strtol+0xde>
		} else {
			any = 1;
			acc *= base;
  10ba63:	0f af c6             	imul   %esi,%eax
			any = 1;
  10ba66:	bf 01 00 00 00       	mov    $0x1,%edi
			acc += c;
  10ba6b:	01 c8                	add    %ecx,%eax
  10ba6d:	eb 03                	jmp    10ba72 <strtol+0xde>
			any = -1;
  10ba6f:	83 cf ff             	or     $0xffffffff,%edi
	for (acc = 0, any = 0;; c = *s++) {
  10ba72:	43                   	inc    %ebx
  10ba73:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
		if (isdigit(c)) {
  10ba77:	eb a7                	jmp    10ba20 <strtol+0x8c>
		}
	}

	if (any < 0) {
  10ba79:	83 ff ff             	cmp    $0xffffffff,%edi
  10ba7c:	75 16                	jne    10ba94 <strtol+0x100>
  10ba7e:	e8 e2 49 01 00       	call   120465 <z_impl_z_errno>
		errno = ERANGE;
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
  10ba83:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
		errno = ERANGE;
  10ba87:	c7 00 26 00 00 00    	movl   $0x26,(%eax)
		acc = neg ? LONG_MIN : LONG_MAX;
  10ba8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if (endptr != NULL) {
  10ba90:	75 14                	jne    10baa6 <strtol+0x112>
  10ba92:	eb 46                	jmp    10bada <strtol+0x146>
	} else if (neg) {
  10ba94:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10ba98:	74 02                	je     10ba9c <strtol+0x108>
		acc = -acc;
  10ba9a:	f7 d8                	neg    %eax
	if (endptr != NULL) {
  10ba9c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10baa0:	74 38                	je     10bada <strtol+0x146>
		*endptr = (char *)(any ? s - 1 : nptr);
  10baa2:	85 ff                	test   %edi,%edi
  10baa4:	74 06                	je     10baac <strtol+0x118>
  10baa6:	8d 7b ff             	lea    -0x1(%ebx),%edi
  10baa9:	89 7d 08             	mov    %edi,0x8(%ebp)
  10baac:	8b 75 0c             	mov    0xc(%ebp),%esi
  10baaf:	8b 7d 08             	mov    0x8(%ebp),%edi
  10bab2:	89 3e                	mov    %edi,(%esi)
	}
	return acc;
  10bab4:	eb 24                	jmp    10bada <strtol+0x146>
	if (base == 0) {
  10bab6:	85 f6                	test   %esi,%esi
  10bab8:	0f 85 49 ff ff ff    	jne    10ba07 <strtol+0x73>
		base = c == '0' ? 8 : 10;
  10babe:	be 0a 00 00 00       	mov    $0xa,%esi
  10bac3:	e9 3f ff ff ff       	jmp    10ba07 <strtol+0x73>
	if (base == 0) {
  10bac8:	85 f6                	test   %esi,%esi
  10baca:	0f 85 37 ff ff ff    	jne    10ba07 <strtol+0x73>
		base = c == '0' ? 8 : 10;
  10bad0:	be 08 00 00 00       	mov    $0x8,%esi
  10bad5:	e9 2d ff ff ff       	jmp    10ba07 <strtol+0x73>
}
  10bada:	83 c4 10             	add    $0x10,%esp
  10badd:	5b                   	pop    %ebx
  10bade:	5e                   	pop    %esi
  10badf:	5f                   	pop    %edi
  10bae0:	5d                   	pop    %ebp
  10bae1:	c3                   	ret    

0010bae2 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
  10bae2:	55                   	push   %ebp
  10bae3:	89 e5                	mov    %esp,%ebp
  10bae5:	57                   	push   %edi
  10bae6:	56                   	push   %esi
  10bae7:	53                   	push   %ebx
  10bae8:	83 ec 0c             	sub    $0xc,%esp
  10baeb:	8b 75 10             	mov    0x10(%ebp),%esi
	register const char *s = nptr;
  10baee:	8b 5d 08             	mov    0x8(%ebp),%ebx

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
  10baf1:	89 d8                	mov    %ebx,%eax
  10baf3:	43                   	inc    %ebx
  10baf4:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
  10baf8:	8d 51 f7             	lea    -0x9(%ecx),%edx
	} while (isspace(c));
  10bafb:	83 fa 04             	cmp    $0x4,%edx
  10bafe:	76 f1                	jbe    10baf1 <strtoul+0xf>
  10bb00:	83 f9 20             	cmp    $0x20,%ecx
  10bb03:	74 ec                	je     10baf1 <strtoul+0xf>
	if (c == '-') {
  10bb05:	83 f9 2d             	cmp    $0x2d,%ecx
  10bb08:	75 0f                	jne    10bb19 <strtoul+0x37>
		neg = 1;
		c = *s++;
  10bb0a:	0f be 0b             	movsbl (%ebx),%ecx
		neg = 1;
  10bb0d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		c = *s++;
  10bb14:	8d 58 02             	lea    0x2(%eax),%ebx
  10bb17:	eb 12                	jmp    10bb2b <strtoul+0x49>
	register int neg = 0, any, cutlim;
  10bb19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	} else if (c == '+') {
  10bb20:	83 f9 2b             	cmp    $0x2b,%ecx
  10bb23:	75 06                	jne    10bb2b <strtoul+0x49>
		c = *s++;
  10bb25:	0f be 0b             	movsbl (%ebx),%ecx
  10bb28:	8d 58 02             	lea    0x2(%eax),%ebx
	}

	if ((base == 0 || base == 16) &&
  10bb2b:	f7 c6 ef ff ff ff    	test   $0xffffffef,%esi
  10bb31:	75 22                	jne    10bb55 <strtoul+0x73>
  10bb33:	83 f9 30             	cmp    $0x30,%ecx
  10bb36:	0f 85 d2 00 00 00    	jne    10bc0e <strtoul+0x12c>
	    c == '0' && (*s == 'x' || *s == 'X')) {
  10bb3c:	8a 03                	mov    (%ebx),%al
  10bb3e:	83 e0 df             	and    $0xffffffdf,%eax
  10bb41:	3c 58                	cmp    $0x58,%al
  10bb43:	0f 85 b3 00 00 00    	jne    10bbfc <strtoul+0x11a>
		c = s[1];
  10bb49:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
		s += 2;
		base = 16;
  10bb4d:	be 10 00 00 00       	mov    $0x10,%esi
		s += 2;
  10bb52:	83 c3 02             	add    $0x2,%ebx

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
  10bb55:	83 c8 ff             	or     $0xffffffff,%eax
  10bb58:	31 d2                	xor    %edx,%edx
  10bb5a:	f7 f6                	div    %esi
  10bb5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bb5f:	89 55 e8             	mov    %edx,-0x18(%ebp)
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
  10bb62:	31 ff                	xor    %edi,%edi
  10bb64:	31 c0                	xor    %eax,%eax
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  10bb66:	8d 51 d0             	lea    -0x30(%ecx),%edx
		if (isdigit(c)) {
  10bb69:	83 fa 09             	cmp    $0x9,%edx
  10bb6c:	77 04                	ja     10bb72 <strtoul+0x90>
			c -= '0';
  10bb6e:	89 d1                	mov    %edx,%ecx
  10bb70:	eb 1d                	jmp    10bb8f <strtoul+0xad>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
  10bb72:	89 ca                	mov    %ecx,%edx
  10bb74:	83 ca 20             	or     $0x20,%edx
  10bb77:	83 ea 61             	sub    $0x61,%edx
		} else if (isalpha(c)) {
  10bb7a:	83 fa 19             	cmp    $0x19,%edx
  10bb7d:	77 40                	ja     10bbbf <strtoul+0xdd>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
  10bb7f:	8d 51 bf             	lea    -0x41(%ecx),%edx
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
  10bb82:	83 fa 1a             	cmp    $0x1a,%edx
  10bb85:	19 d2                	sbb    %edx,%edx
  10bb87:	83 e2 e0             	and    $0xffffffe0,%edx
  10bb8a:	83 c2 57             	add    $0x57,%edx
  10bb8d:	29 d1                	sub    %edx,%ecx
		} else {
			break;
		}
		if (c >= base) {
  10bb8f:	39 ce                	cmp    %ecx,%esi
  10bb91:	7e 2c                	jle    10bbbf <strtoul+0xdd>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  10bb93:	85 ff                	test   %edi,%edi
  10bb95:	78 1e                	js     10bbb5 <strtoul+0xd3>
  10bb97:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10bb9a:	77 19                	ja     10bbb5 <strtoul+0xd3>
  10bb9c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10bb9f:	75 08                	jne    10bba9 <strtoul+0xc7>
			any = -1;
  10bba1:	83 cf ff             	or     $0xffffffff,%edi
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
  10bba4:	3b 4d e8             	cmp    -0x18(%ebp),%ecx
  10bba7:	7f 0f                	jg     10bbb8 <strtoul+0xd6>
		} else {
			any = 1;
			acc *= base;
  10bba9:	0f af c6             	imul   %esi,%eax
			any = 1;
  10bbac:	bf 01 00 00 00       	mov    $0x1,%edi
			acc += c;
  10bbb1:	01 c8                	add    %ecx,%eax
  10bbb3:	eb 03                	jmp    10bbb8 <strtoul+0xd6>
			any = -1;
  10bbb5:	83 cf ff             	or     $0xffffffff,%edi
	for (acc = 0, any = 0;; c = *s++) {
  10bbb8:	43                   	inc    %ebx
  10bbb9:	0f be 4b ff          	movsbl -0x1(%ebx),%ecx
		if (isdigit(c)) {
  10bbbd:	eb a7                	jmp    10bb66 <strtoul+0x84>
		}
	}
	if (any < 0) {
  10bbbf:	83 ff ff             	cmp    $0xffffffff,%edi
  10bbc2:	75 16                	jne    10bbda <strtoul+0xf8>
  10bbc4:	e8 9c 48 01 00       	call   120465 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
  10bbc9:	c7 00 26 00 00 00    	movl   $0x26,(%eax)
		acc = ULONG_MAX;
  10bbcf:	83 c8 ff             	or     $0xffffffff,%eax
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
  10bbd2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bbd6:	75 14                	jne    10bbec <strtoul+0x10a>
  10bbd8:	eb 46                	jmp    10bc20 <strtoul+0x13e>
	} else if (neg) {
  10bbda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10bbde:	74 02                	je     10bbe2 <strtoul+0x100>
		acc = -acc;
  10bbe0:	f7 d8                	neg    %eax
	if (endptr != NULL) {
  10bbe2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10bbe6:	74 38                	je     10bc20 <strtoul+0x13e>
		*endptr = (char *)(any ? s - 1 : nptr);
  10bbe8:	85 ff                	test   %edi,%edi
  10bbea:	74 06                	je     10bbf2 <strtoul+0x110>
  10bbec:	8d 7b ff             	lea    -0x1(%ebx),%edi
  10bbef:	89 7d 08             	mov    %edi,0x8(%ebp)
  10bbf2:	8b 75 0c             	mov    0xc(%ebp),%esi
  10bbf5:	8b 7d 08             	mov    0x8(%ebp),%edi
  10bbf8:	89 3e                	mov    %edi,(%esi)
	}
	return acc;
  10bbfa:	eb 24                	jmp    10bc20 <strtoul+0x13e>
	if (base == 0) {
  10bbfc:	85 f6                	test   %esi,%esi
  10bbfe:	0f 85 51 ff ff ff    	jne    10bb55 <strtoul+0x73>
		base = c == '0' ? 8 : 10;
  10bc04:	be 08 00 00 00       	mov    $0x8,%esi
  10bc09:	e9 47 ff ff ff       	jmp    10bb55 <strtoul+0x73>
	if (base == 0) {
  10bc0e:	85 f6                	test   %esi,%esi
  10bc10:	0f 85 3f ff ff ff    	jne    10bb55 <strtoul+0x73>
		base = c == '0' ? 8 : 10;
  10bc16:	be 0a 00 00 00       	mov    $0xa,%esi
  10bc1b:	e9 35 ff ff ff       	jmp    10bb55 <strtoul+0x73>
}
  10bc20:	83 c4 0c             	add    $0xc,%esp
  10bc23:	5b                   	pop    %ebx
  10bc24:	5e                   	pop    %esi
  10bc25:	5f                   	pop    %edi
  10bc26:	5d                   	pop    %ebp
  10bc27:	c3                   	ret    

0010bc28 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
  10bc28:	55                   	push   %ebp
  10bc29:	89 e5                	mov    %esp,%ebp
  10bc2b:	57                   	push   %edi
  10bc2c:	56                   	push   %esi
  10bc2d:	53                   	push   %ebx
  10bc2e:	83 ec 08             	sub    $0x8,%esp
  10bc31:	8b 75 0c             	mov    0xc(%ebp),%esi
  10bc34:	8b 7d 08             	mov    0x8(%ebp),%edi
	char c, sc;
	size_t len;

	c = *find++;
  10bc37:	8a 1e                	mov    (%esi),%bl
	if (c != 0) {
  10bc39:	84 db                	test   %bl,%bl
  10bc3b:	74 3a                	je     10bc77 <strstr+0x4f>
	c = *find++;
  10bc3d:	46                   	inc    %esi
		len = strlen(find);
  10bc3e:	56                   	push   %esi
  10bc3f:	e8 d8 00 00 00       	call   10bd1c <strlen>
  10bc44:	5a                   	pop    %edx
  10bc45:	89 c1                	mov    %eax,%ecx
		do {
			do {
				sc = *s++;
  10bc47:	8a 07                	mov    (%edi),%al
  10bc49:	8d 57 01             	lea    0x1(%edi),%edx
				if (sc == 0) {
  10bc4c:	84 c0                	test   %al,%al
  10bc4e:	74 25                	je     10bc75 <strstr+0x4d>
					return NULL;
				}
			} while (sc != c);
  10bc50:	38 c3                	cmp    %al,%bl
  10bc52:	74 04                	je     10bc58 <strstr+0x30>
{
  10bc54:	89 d7                	mov    %edx,%edi
  10bc56:	eb ef                	jmp    10bc47 <strstr+0x1f>
		} while (strncmp(s, find, len) != 0);
  10bc58:	51                   	push   %ecx
  10bc59:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10bc5c:	56                   	push   %esi
  10bc5d:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10bc60:	52                   	push   %edx
  10bc61:	e8 e9 00 00 00       	call   10bd4f <strncmp>
  10bc66:	83 c4 0c             	add    $0xc,%esp
  10bc69:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10bc6c:	85 c0                	test   %eax,%eax
  10bc6e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10bc71:	75 e1                	jne    10bc54 <strstr+0x2c>
  10bc73:	eb 02                	jmp    10bc77 <strstr+0x4f>
					return NULL;
  10bc75:	31 ff                	xor    %edi,%edi
	s--;
	}
	return (char *)s;
}
  10bc77:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10bc7a:	89 f8                	mov    %edi,%eax
  10bc7c:	5b                   	pop    %ebx
  10bc7d:	5e                   	pop    %esi
  10bc7e:	5f                   	pop    %edi
  10bc7f:	5d                   	pop    %ebp
  10bc80:	c3                   	ret    

0010bc81 <strcpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
  10bc81:	55                   	push   %ebp
	char *dest = d;

	while (*s != '\0') {
  10bc82:	31 c0                	xor    %eax,%eax
{
  10bc84:	89 e5                	mov    %esp,%ebp
  10bc86:	53                   	push   %ebx
  10bc87:	8b 55 08             	mov    0x8(%ebp),%edx
	while (*s != '\0') {
  10bc8a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10bc8d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  10bc90:	8a 0c 01             	mov    (%ecx,%eax,1),%cl
  10bc93:	84 c9                	test   %cl,%cl
  10bc95:	74 06                	je     10bc9d <strcpy+0x1c>
		*d = *s;
  10bc97:	88 0c 02             	mov    %cl,(%edx,%eax,1)
		d++;
		s++;
  10bc9a:	40                   	inc    %eax
  10bc9b:	eb ed                	jmp    10bc8a <strcpy+0x9>
	}

	*d = '\0';
  10bc9d:	c6 03 00             	movb   $0x0,(%ebx)

	return dest;
}
  10bca0:	89 d0                	mov    %edx,%eax
  10bca2:	5b                   	pop    %ebx
  10bca3:	5d                   	pop    %ebp
  10bca4:	c3                   	ret    

0010bca5 <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
  10bca5:	55                   	push   %ebp
  10bca6:	89 e5                	mov    %esp,%ebp
  10bca8:	57                   	push   %edi
  10bca9:	56                   	push   %esi
  10bcaa:	8b 45 08             	mov    0x8(%ebp),%eax
  10bcad:	53                   	push   %ebx
  10bcae:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dest = d;

	while ((n > 0) && *s != '\0') {
  10bcb1:	89 c1                	mov    %eax,%ecx
  10bcb3:	85 d2                	test   %edx,%edx
  10bcb5:	74 26                	je     10bcdd <strncpy+0x38>
  10bcb7:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10bcba:	8d 71 01             	lea    0x1(%ecx),%esi
  10bcbd:	8a 1f                	mov    (%edi),%bl
  10bcbf:	8d 7a ff             	lea    -0x1(%edx),%edi
  10bcc2:	84 db                	test   %bl,%bl
  10bcc4:	74 0c                	je     10bcd2 <strncpy+0x2d>
		*d = *s;
		s++;
  10bcc6:	ff 45 0c             	incl   0xc(%ebp)
		*d = *s;
  10bcc9:	88 5e ff             	mov    %bl,-0x1(%esi)
		d++;
		n--;
  10bccc:	89 fa                	mov    %edi,%edx
		s++;
  10bcce:	89 f1                	mov    %esi,%ecx
  10bcd0:	eb e1                	jmp    10bcb3 <strncpy+0xe>
  10bcd2:	31 db                	xor    %ebx,%ebx
	}

	while (n > 0) {
		*d = '\0';
  10bcd4:	c6 04 19 00          	movb   $0x0,(%ecx,%ebx,1)
	while (n > 0) {
  10bcd8:	43                   	inc    %ebx
  10bcd9:	39 da                	cmp    %ebx,%edx
  10bcdb:	75 f7                	jne    10bcd4 <strncpy+0x2f>
		d++;
		n--;
	}

	return dest;
}
  10bcdd:	5b                   	pop    %ebx
  10bcde:	5e                   	pop    %esi
  10bcdf:	5f                   	pop    %edi
  10bce0:	5d                   	pop    %ebp
  10bce1:	c3                   	ret    

0010bce2 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
  10bce2:	55                   	push   %ebp
  10bce3:	89 e5                	mov    %esp,%ebp
  10bce5:	53                   	push   %ebx
  10bce6:	8b 55 0c             	mov    0xc(%ebp),%edx
	char tmp = (char) c;

	while ((*s != tmp) && (*s != '\0')) {
  10bce9:	8b 45 08             	mov    0x8(%ebp),%eax
	char tmp = (char) c;
  10bcec:	88 d3                	mov    %dl,%bl
	while ((*s != tmp) && (*s != '\0')) {
  10bcee:	8a 08                	mov    (%eax),%cl
  10bcf0:	38 d9                	cmp    %bl,%cl
  10bcf2:	74 0d                	je     10bd01 <strchr+0x1f>
  10bcf4:	84 c9                	test   %cl,%cl
  10bcf6:	74 03                	je     10bcfb <strchr+0x19>
		s++;
  10bcf8:	40                   	inc    %eax
  10bcf9:	eb f3                	jmp    10bcee <strchr+0xc>
	}

	return (*s == tmp) ? (char *) s : NULL;
  10bcfb:	84 d2                	test   %dl,%dl
  10bcfd:	74 02                	je     10bd01 <strchr+0x1f>
  10bcff:	31 c0                	xor    %eax,%eax
}
  10bd01:	5b                   	pop    %ebx
  10bd02:	5d                   	pop    %ebp
  10bd03:	c3                   	ret    

0010bd04 <strrchr>:
 *
 * @return pointer to last instance of found byte, or NULL if not found
 */

char *strrchr(const char *s, int c)
{
  10bd04:	55                   	push   %ebp
	char *match = NULL;
  10bd05:	31 c0                	xor    %eax,%eax
{
  10bd07:	89 e5                	mov    %esp,%ebp
  10bd09:	8b 55 08             	mov    0x8(%ebp),%edx

	do {
		if (*s == (char)c) {
  10bd0c:	8a 0a                	mov    (%edx),%cl
  10bd0e:	3a 4d 0c             	cmp    0xc(%ebp),%cl
  10bd11:	75 02                	jne    10bd15 <strrchr+0x11>
  10bd13:	89 d0                	mov    %edx,%eax
			match = (char *)s;
		}
	} while (*s++);
  10bd15:	42                   	inc    %edx
  10bd16:	84 c9                	test   %cl,%cl
  10bd18:	75 f2                	jne    10bd0c <strrchr+0x8>

	return match;
}
  10bd1a:	5d                   	pop    %ebp
  10bd1b:	c3                   	ret    

0010bd1c <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
  10bd1c:	55                   	push   %ebp
	size_t n = 0;
  10bd1d:	31 c0                	xor    %eax,%eax
{
  10bd1f:	89 e5                	mov    %esp,%ebp
  10bd21:	8b 55 08             	mov    0x8(%ebp),%edx

	while (*s != '\0') {
  10bd24:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  10bd28:	74 03                	je     10bd2d <strlen+0x11>
		s++;
		n++;
  10bd2a:	40                   	inc    %eax
  10bd2b:	eb f7                	jmp    10bd24 <strlen+0x8>
	}

	return n;
}
  10bd2d:	5d                   	pop    %ebp
  10bd2e:	c3                   	ret    

0010bd2f <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  10bd2f:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  10bd30:	31 c9                	xor    %ecx,%ecx
{
  10bd32:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  10bd34:	8b 45 08             	mov    0x8(%ebp),%eax
  10bd37:	8b 55 0c             	mov    0xc(%ebp),%edx
  10bd3a:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  10bd3e:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
  10bd42:	38 d0                	cmp    %dl,%al
  10bd44:	75 05                	jne    10bd4b <strcmp+0x1c>
  10bd46:	41                   	inc    %ecx
  10bd47:	84 c0                	test   %al,%al
  10bd49:	75 e9                	jne    10bd34 <strcmp+0x5>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  10bd4b:	29 d0                	sub    %edx,%eax
}
  10bd4d:	5d                   	pop    %ebp
  10bd4e:	c3                   	ret    

0010bd4f <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
  10bd4f:	55                   	push   %ebp
  10bd50:	89 e5                	mov    %esp,%ebp
  10bd52:	56                   	push   %esi
  10bd53:	53                   	push   %ebx
  10bd54:	8b 55 08             	mov    0x8(%ebp),%edx
  10bd57:	8b 75 10             	mov    0x10(%ebp),%esi
  10bd5a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
  10bd5d:	01 d6                	add    %edx,%esi
  10bd5f:	39 f2                	cmp    %esi,%edx
  10bd61:	74 12                	je     10bd75 <strncmp+0x26>
  10bd63:	0f be 02             	movsbl (%edx),%eax
  10bd66:	0f be 0b             	movsbl (%ebx),%ecx
  10bd69:	84 c0                	test   %al,%al
  10bd6b:	74 0c                	je     10bd79 <strncmp+0x2a>
  10bd6d:	38 c8                	cmp    %cl,%al
  10bd6f:	75 08                	jne    10bd79 <strncmp+0x2a>
		s1++;
  10bd71:	42                   	inc    %edx
		s2++;
  10bd72:	43                   	inc    %ebx
		n--;
  10bd73:	eb ea                	jmp    10bd5f <strncmp+0x10>
	}

	return (n == 0) ? 0 : (*s1 - *s2);
  10bd75:	31 c0                	xor    %eax,%eax
  10bd77:	eb 02                	jmp    10bd7b <strncmp+0x2c>
  10bd79:	29 c8                	sub    %ecx,%eax
}
  10bd7b:	5b                   	pop    %ebx
  10bd7c:	5e                   	pop    %esi
  10bd7d:	5d                   	pop    %ebp
  10bd7e:	c3                   	ret    

0010bd7f <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
  10bd7f:	55                   	push   %ebp
  10bd80:	31 c0                	xor    %eax,%eax
  10bd82:	89 e5                	mov    %esp,%ebp
  10bd84:	56                   	push   %esi
  10bd85:	53                   	push   %ebx
  10bd86:	8b 75 10             	mov    0x10(%ebp),%esi
  10bd89:	8b 55 08             	mov    0x8(%ebp),%edx
  10bd8c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
  10bd8f:	85 f6                	test   %esi,%esi
  10bd91:	74 1a                	je     10bdad <memcmp+0x2e>
  10bd93:	8d 4a 01             	lea    0x1(%edx),%ecx
  10bd96:	01 d6                	add    %edx,%esi
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
  10bd98:	0f be 41 ff          	movsbl -0x1(%ecx),%eax
  10bd9c:	0f be 13             	movsbl (%ebx),%edx
  10bd9f:	39 f1                	cmp    %esi,%ecx
  10bda1:	74 08                	je     10bdab <memcmp+0x2c>
  10bda3:	41                   	inc    %ecx
  10bda4:	38 d0                	cmp    %dl,%al
  10bda6:	75 03                	jne    10bdab <memcmp+0x2c>
		c1++;
		c2++;
  10bda8:	43                   	inc    %ebx
  10bda9:	eb ed                	jmp    10bd98 <memcmp+0x19>
	}

	return *c1 - *c2;
  10bdab:	29 d0                	sub    %edx,%eax
}
  10bdad:	5b                   	pop    %ebx
  10bdae:	5e                   	pop    %esi
  10bdaf:	5d                   	pop    %ebp
  10bdb0:	c3                   	ret    

0010bdb1 <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
  10bdb1:	55                   	push   %ebp
  10bdb2:	89 e5                	mov    %esp,%ebp
  10bdb4:	56                   	push   %esi
  10bdb5:	53                   	push   %ebx
  10bdb6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bdb9:	8b 55 0c             	mov    0xc(%ebp),%edx
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
  10bdbc:	89 cb                	mov    %ecx,%ebx
{
  10bdbe:	8b 45 10             	mov    0x10(%ebp),%eax
	if ((size_t) (dest - src) < n) {
  10bdc1:	29 d3                	sub    %edx,%ebx
  10bdc3:	39 c3                	cmp    %eax,%ebx
  10bdc5:	72 07                	jb     10bdce <memmove+0x1d>
  10bdc7:	8d 34 10             	lea    (%eax,%edx,1),%esi
  10bdca:	89 cb                	mov    %ecx,%ebx
  10bdcc:	eb 0b                	jmp    10bdd9 <memmove+0x28>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
  10bdce:	48                   	dec    %eax
			dest[n] = src[n];
  10bdcf:	8a 1c 02             	mov    (%edx,%eax,1),%bl
  10bdd2:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
		while (n > 0) {
  10bdd5:	75 f7                	jne    10bdce <memmove+0x1d>
  10bdd7:	eb 0d                	jmp    10bde6 <memmove+0x35>
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
  10bdd9:	39 f2                	cmp    %esi,%edx
  10bddb:	74 09                	je     10bde6 <memmove+0x35>
			*dest = *src;
  10bddd:	8a 02                	mov    (%edx),%al
			dest++;
  10bddf:	43                   	inc    %ebx
			*dest = *src;
  10bde0:	88 43 ff             	mov    %al,-0x1(%ebx)
			src++;
  10bde3:	42                   	inc    %edx
			n--;
  10bde4:	eb f3                	jmp    10bdd9 <memmove+0x28>
		}
	}

	return d;
}
  10bde6:	5b                   	pop    %ebx
  10bde7:	89 c8                	mov    %ecx,%eax
  10bde9:	5e                   	pop    %esi
  10bdea:	5d                   	pop    %ebp
  10bdeb:	c3                   	ret    

0010bdec <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  10bdec:	55                   	push   %ebp
  10bded:	89 e5                	mov    %esp,%ebp
  10bdef:	57                   	push   %edi
  10bdf0:	56                   	push   %esi

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
  10bdf1:	8b 45 08             	mov    0x8(%ebp),%eax
{
  10bdf4:	53                   	push   %ebx
	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
  10bdf5:	33 45 0c             	xor    0xc(%ebp),%eax
{
  10bdf8:	8b 55 10             	mov    0x10(%ebp),%edx
	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
  10bdfb:	a8 03                	test   $0x3,%al
  10bdfd:	74 05                	je     10be04 <memcpy+0x18>
	unsigned char *d_byte = (unsigned char *)d;
  10bdff:	8b 7d 08             	mov    0x8(%ebp),%edi
  10be02:	eb 40                	jmp    10be44 <memcpy+0x58>
  10be04:	8b 45 08             	mov    0x8(%ebp),%eax

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
  10be07:	a8 03                	test   $0x3,%al
  10be09:	74 12                	je     10be1d <memcpy+0x31>
			if (n == 0) {
  10be0b:	85 d2                	test   %edx,%edx
  10be0d:	74 44                	je     10be53 <memcpy+0x67>
				return d;
			}
			*(d_byte++) = *(s_byte++);
  10be0f:	89 c7                	mov    %eax,%edi
  10be11:	8b 75 0c             	mov    0xc(%ebp),%esi
  10be14:	a4                   	movsb  %ds:(%esi),%es:(%edi)
			n--;
  10be15:	4a                   	dec    %edx
			*(d_byte++) = *(s_byte++);
  10be16:	89 75 0c             	mov    %esi,0xc(%ebp)
  10be19:	89 f8                	mov    %edi,%eax
			n--;
  10be1b:	eb ea                	jmp    10be07 <memcpy+0x1b>
  10be1d:	8b 75 0c             	mov    0xc(%ebp),%esi
  10be20:	89 c7                	mov    %eax,%edi
  10be22:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
		/* do word-sized copying as long as possible */

		mem_word_t *d_word = (mem_word_t *)d_byte;
		const mem_word_t *s_word = (const mem_word_t *)s_byte;

		while (n >= sizeof(mem_word_t)) {
  10be25:	89 cb                	mov    %ecx,%ebx
  10be27:	29 fb                	sub    %edi,%ebx
  10be29:	83 fb 03             	cmp    $0x3,%ebx
  10be2c:	76 03                	jbe    10be31 <memcpy+0x45>
			*(d_word++) = *(s_word++);
  10be2e:	a5                   	movsl  %ds:(%esi),%es:(%edi)
			n -= sizeof(mem_word_t);
  10be2f:	eb f4                	jmp    10be25 <memcpy+0x39>
  10be31:	89 d3                	mov    %edx,%ebx
  10be33:	c1 eb 02             	shr    $0x2,%ebx
  10be36:	6b f3 fc             	imul   $0xfffffffc,%ebx,%esi
  10be39:	c1 e3 02             	shl    $0x2,%ebx
  10be3c:	01 f2                	add    %esi,%edx
  10be3e:	01 5d 0c             	add    %ebx,0xc(%ebp)
  10be41:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
  10be44:	01 fa                	add    %edi,%edx
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
  10be46:	39 d7                	cmp    %edx,%edi
  10be48:	74 09                	je     10be53 <memcpy+0x67>
		*(d_byte++) = *(s_byte++);
  10be4a:	8b 75 0c             	mov    0xc(%ebp),%esi
  10be4d:	a4                   	movsb  %ds:(%esi),%es:(%edi)
  10be4e:	89 75 0c             	mov    %esi,0xc(%ebp)
		n--;
  10be51:	eb f3                	jmp    10be46 <memcpy+0x5a>
	}

	return d;
}
  10be53:	5b                   	pop    %ebx
  10be54:	8b 45 08             	mov    0x8(%ebp),%eax
  10be57:	5e                   	pop    %esi
  10be58:	5f                   	pop    %edi
  10be59:	5d                   	pop    %ebp
  10be5a:	c3                   	ret    

0010be5b <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
  10be5b:	55                   	push   %ebp
  10be5c:	89 e5                	mov    %esp,%ebp
  10be5e:	57                   	push   %edi
  10be5f:	56                   	push   %esi
  10be60:	53                   	push   %ebx
  10be61:	51                   	push   %ecx
  10be62:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10be65:	8b 55 10             	mov    0x10(%ebp),%edx
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
  10be68:	88 5d f3             	mov    %bl,-0xd(%ebp)
	unsigned char *d_byte = (unsigned char *)buf;
  10be6b:	8b 4d 08             	mov    0x8(%ebp),%ecx

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
  10be6e:	f6 c1 03             	test   $0x3,%cl
  10be71:	74 0e                	je     10be81 <memset+0x26>
		if (n == 0) {
  10be73:	85 d2                	test   %edx,%edx
  10be75:	74 51                	je     10bec8 <memset+0x6d>
			return buf;
		}
		*(d_byte++) = c_byte;
  10be77:	41                   	inc    %ecx
  10be78:	8a 45 f3             	mov    -0xd(%ebp),%al
		n--;
  10be7b:	4a                   	dec    %edx
		*(d_byte++) = c_byte;
  10be7c:	88 41 ff             	mov    %al,-0x1(%ecx)
		n--;
  10be7f:	eb ed                	jmp    10be6e <memset+0x13>
	};

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
  10be81:	0f b6 db             	movzbl %bl,%ebx

	c_word |= c_word << 8;
  10be84:	89 df                	mov    %ebx,%edi
  10be86:	8d 34 11             	lea    (%ecx,%edx,1),%esi
  10be89:	c1 e7 08             	shl    $0x8,%edi
  10be8c:	09 fb                	or     %edi,%ebx
	c_word |= c_word << 16;
  10be8e:	89 df                	mov    %ebx,%edi
  10be90:	c1 e7 10             	shl    $0x10,%edi
  10be93:	09 df                	or     %ebx,%edi
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
  10be95:	89 cb                	mov    %ecx,%ebx
  10be97:	89 f0                	mov    %esi,%eax
  10be99:	29 d8                	sub    %ebx,%eax
  10be9b:	83 f8 03             	cmp    $0x3,%eax
  10be9e:	76 08                	jbe    10bea8 <memset+0x4d>
		*(d_word++) = c_word;
  10bea0:	83 c3 04             	add    $0x4,%ebx
  10bea3:	89 7b fc             	mov    %edi,-0x4(%ebx)
		n -= sizeof(mem_word_t);
  10bea6:	eb ef                	jmp    10be97 <memset+0x3c>
  10bea8:	89 d3                	mov    %edx,%ebx
  10beaa:	89 d7                	mov    %edx,%edi
  10beac:	c1 eb 02             	shr    $0x2,%ebx
  10beaf:	83 e7 fc             	and    $0xfffffffc,%edi
  10beb2:	6b db fc             	imul   $0xfffffffc,%ebx,%ebx
  10beb5:	01 f9                	add    %edi,%ecx
  10beb7:	01 da                	add    %ebx,%edx
  10beb9:	01 ca                	add    %ecx,%edx

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
  10bebb:	39 d1                	cmp    %edx,%ecx
  10bebd:	74 09                	je     10bec8 <memset+0x6d>
		*(d_byte++) = c_byte;
  10bebf:	41                   	inc    %ecx
  10bec0:	8a 45 f3             	mov    -0xd(%ebp),%al
  10bec3:	88 41 ff             	mov    %al,-0x1(%ecx)
		n--;
  10bec6:	eb f3                	jmp    10bebb <memset+0x60>
	}

	return buf;
}
  10bec8:	8b 45 08             	mov    0x8(%ebp),%eax
  10becb:	5a                   	pop    %edx
  10becc:	5b                   	pop    %ebx
  10becd:	5e                   	pop    %esi
  10bece:	5f                   	pop    %edi
  10becf:	5d                   	pop    %ebp
  10bed0:	c3                   	ret    

0010bed1 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
  10bed1:	83 c8 ff             	or     $0xffffffff,%eax
  10bed4:	c3                   	ret    

0010bed5 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
  10bed5:	55                   	push   %ebp
  10bed6:	89 e5                	mov    %esp,%ebp
	_stdout_hook = hook;
  10bed8:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10bedb:	5d                   	pop    %ebp
	_stdout_hook = hook;
  10bedc:	a3 00 5b 14 00       	mov    %eax,0x145b00
}
  10bee1:	c3                   	ret    

0010bee2 <sprintf_out>:
	char *ptr;
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
  10bee2:	55                   	push   %ebp
  10bee3:	89 e5                	mov    %esp,%ebp
  10bee5:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (p->len > 1) { /* need to reserve a byte for EOS */
  10bee8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  10beec:	7e 0c                	jle    10befa <sprintf_out+0x18>
		*(p->ptr) = c;
  10beee:	8b 10                	mov    (%eax),%edx
  10bef0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bef3:	88 0a                	mov    %cl,(%edx)
		p->ptr += 1;
  10bef5:	ff 00                	incl   (%eax)
		p->len -= 1;
  10bef7:	ff 48 04             	decl   0x4(%eax)
	}
	return 0; /* indicate keep going so we get the total count */
}
  10befa:	31 c0                	xor    %eax,%eax
  10befc:	5d                   	pop    %ebp
  10befd:	c3                   	ret    

0010befe <snprintf>:

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
  10befe:	55                   	push   %ebp
  10beff:	89 e5                	mov    %esp,%ebp
  10bf01:	83 ec 0c             	sub    $0xc,%esp
  10bf04:	8b 45 0c             	mov    0xc(%ebp),%eax
  10bf07:	8b 55 08             	mov    0x8(%ebp),%edx

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
  10bf0a:	85 c0                	test   %eax,%eax
  10bf0c:	75 03                	jne    10bf11 <snprintf+0x13>
		s = &dummy; /* write final NUL to dummy, can't change *s */
  10bf0e:	8d 55 f7             	lea    -0x9(%ebp),%edx
	}

	p.ptr = s;
	p.len = (int) len;
  10bf11:	89 45 fc             	mov    %eax,-0x4(%ebp)

	va_start(vargs, format);
  10bf14:	8d 45 14             	lea    0x14(%ebp),%eax
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  10bf17:	50                   	push   %eax
  10bf18:	8d 45 f8             	lea    -0x8(%ebp),%eax
  10bf1b:	ff 75 10             	pushl  0x10(%ebp)
	p.ptr = s;
  10bf1e:	89 55 f8             	mov    %edx,-0x8(%ebp)
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  10bf21:	50                   	push   %eax
  10bf22:	68 e2 be 10 00       	push   $0x10bee2
  10bf27:	e8 37 62 ff ff       	call   102163 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
  10bf2c:	8b 55 f8             	mov    -0x8(%ebp),%edx
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
  10bf2f:	83 c4 10             	add    $0x10,%esp
	*(p.ptr) = 0;
  10bf32:	c6 02 00             	movb   $0x0,(%edx)
	return r;
}
  10bf35:	c9                   	leave  
  10bf36:	c3                   	ret    

0010bf37 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
  10bf37:	c3                   	ret    

0010bf38 <net_buf_id>:
{
  10bf38:	55                   	push   %ebp
  10bf39:	89 e5                	mov    %esp,%ebp
  10bf3b:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10bf3e:	5d                   	pop    %ebp
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  10bf3f:	0f b6 50 06          	movzbl 0x6(%eax),%edx
	return buf - pool->__bufs;
  10bf43:	6b d2 34             	imul   $0x34,%edx,%edx
  10bf46:	2b 82 08 5e 14 00    	sub    0x145e08(%edx),%eax
  10bf4c:	c1 f8 03             	sar    $0x3,%eax
  10bf4f:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
}
  10bf55:	c3                   	ret    

0010bf56 <fixed_data_alloc>:
{
  10bf56:	55                   	push   %ebp
  10bf57:	89 e5                	mov    %esp,%ebp
  10bf59:	56                   	push   %esi
  10bf5a:	53                   	push   %ebx
  10bf5b:	8b 55 08             	mov    0x8(%ebp),%edx
  10bf5e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  10bf61:	0f b6 42 06          	movzbl 0x6(%edx),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  10bf65:	6b c0 34             	imul   $0x34,%eax,%eax
  10bf68:	8b 80 04 5e 14 00    	mov    0x145e04(%eax),%eax
  10bf6e:	8b 48 04             	mov    0x4(%eax),%ecx
	*size = MIN(fixed->data_size, *size);
  10bf71:	8b 03                	mov    (%ebx),%eax
  10bf73:	8b 31                	mov    (%ecx),%esi
  10bf75:	39 f0                	cmp    %esi,%eax
  10bf77:	76 02                	jbe    10bf7b <fixed_data_alloc+0x25>
  10bf79:	89 f0                	mov    %esi,%eax
  10bf7b:	89 03                	mov    %eax,(%ebx)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
  10bf7d:	52                   	push   %edx
  10bf7e:	e8 b5 ff ff ff       	call   10bf38 <net_buf_id>
  10bf83:	5a                   	pop    %edx
  10bf84:	0f af 01             	imul   (%ecx),%eax
  10bf87:	03 41 04             	add    0x4(%ecx),%eax
}
  10bf8a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10bf8d:	5b                   	pop    %ebx
  10bf8e:	5e                   	pop    %esi
  10bf8f:	5d                   	pop    %ebp
  10bf90:	c3                   	ret    

0010bf91 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
  10bf91:	55                   	push   %ebp
  10bf92:	89 e5                	mov    %esp,%ebp
  10bf94:	57                   	push   %edi
  10bf95:	56                   	push   %esi
  10bf96:	53                   	push   %ebx
  10bf97:	83 ec 0c             	sub    $0xc,%esp
  10bf9a:	8b 7d 14             	mov    0x14(%ebp),%edi
	uint64_t end = z_timeout_end_calc(timeout);
  10bf9d:	8b 75 10             	mov    0x10(%ebp),%esi
  10bfa0:	57                   	push   %edi
  10bfa1:	56                   	push   %esi
  10bfa2:	e8 e5 63 01 00       	call   12238c <z_timeout_end_calc>
  10bfa7:	59                   	pop    %ecx
  10bfa8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10bfab:	5b                   	pop    %ebx
  10bfac:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10bfaf:	9c                   	pushf  
  10bfb0:	fa                   	cli    
  10bfb1:	5a                   	pop    %edx
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
  10bfb2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bfb5:	66 8b 41 26          	mov    0x26(%ecx),%ax
  10bfb9:	66 85 c0             	test   %ax,%ax
  10bfbc:	74 62                	je     10c020 <net_buf_alloc_len+0x8f>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
  10bfbe:	81 e2 00 02 00 00    	and    $0x200,%edx
  10bfc4:	66 3b 41 24          	cmp    0x24(%ecx),%ax
  10bfc8:	73 26                	jae    10bff0 <net_buf_alloc_len+0x5f>
  10bfca:	89 55 e8             	mov    %edx,-0x18(%ebp)
	return z_impl_k_queue_get(queue, timeout);
  10bfcd:	6a 00                	push   $0x0
  10bfcf:	89 4d 08             	mov    %ecx,0x8(%ebp)
  10bfd2:	6a 00                	push   $0x0
  10bfd4:	51                   	push   %ecx
  10bfd5:	e8 7d 4f 01 00       	call   120f57 <z_impl_k_queue_get>
  10bfda:	83 c4 0c             	add    $0xc,%esp
  10bfdd:	89 c3                	mov    %eax,%ebx
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
  10bfdf:	85 c0                	test   %eax,%eax
  10bfe1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10bfe4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10bfe7:	74 07                	je     10bff0 <net_buf_alloc_len+0x5f>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10bfe9:	85 d2                	test   %edx,%edx
  10bfeb:	74 53                	je     10c040 <net_buf_alloc_len+0xaf>
		__asm__ volatile ("sti" ::: "memory");
  10bfed:	fb                   	sti    
				irq_unlock(key);
				goto success;
  10bfee:	eb 50                	jmp    10c040 <net_buf_alloc_len+0xaf>
			}
		}

		uninit_count = pool->uninit_count--;
  10bff0:	0f b7 41 26          	movzwl 0x26(%ecx),%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10bff4:	85 d2                	test   %edx,%edx
  10bff6:	8d 58 ff             	lea    -0x1(%eax),%ebx
  10bff9:	66 89 59 26          	mov    %bx,0x26(%ecx)
  10bffd:	74 01                	je     10c000 <net_buf_alloc_len+0x6f>
		__asm__ volatile ("sti" ::: "memory");
  10bfff:	fb                   	sti    
	buf = &pool->__bufs[pool->buf_count - uninit_count];
  10c000:	0f b7 59 24          	movzwl 0x24(%ecx),%ebx
  10c004:	29 c3                	sub    %eax,%ebx
  10c006:	6b db 18             	imul   $0x18,%ebx,%ebx
  10c009:	03 59 30             	add    0x30(%ecx),%ebx
	return pool - _net_buf_pool_list;
  10c00c:	81 e9 d8 5d 14 00    	sub    $0x145dd8,%ecx
  10c012:	c1 f9 02             	sar    $0x2,%ecx
  10c015:	69 c9 c5 4e ec c4    	imul   $0xc4ec4ec5,%ecx,%ecx
	buf->pool_id = pool_id(pool);
  10c01b:	88 4b 06             	mov    %cl,0x6(%ebx)
		irq_unlock(key);

		buf = pool_get_uninit(pool, uninit_count);
		goto success;
  10c01e:	eb 20                	jmp    10c040 <net_buf_alloc_len+0xaf>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  10c020:	0f ba e2 09          	bt     $0x9,%edx
  10c024:	73 01                	jae    10c027 <net_buf_alloc_len+0x96>
		__asm__ volatile ("sti" ::: "memory");
  10c026:	fb                   	sti    
  10c027:	ff 75 14             	pushl  0x14(%ebp)
  10c02a:	ff 75 10             	pushl  0x10(%ebp)
  10c02d:	51                   	push   %ecx
  10c02e:	e8 24 4f 01 00       	call   120f57 <z_impl_k_queue_get>
  10c033:	83 c4 0c             	add    $0xc,%esp
  10c036:	89 c3                	mov    %eax,%ebx
		buf = k_lifo_get(&pool->free, timeout);
	}
#else
	buf = k_lifo_get(&pool->free, timeout);
#endif
	if (!buf) {
  10c038:	85 c0                	test   %eax,%eax
  10c03a:	0f 84 92 00 00 00    	je     10c0d2 <net_buf_alloc_len+0x141>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
  10c040:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10c044:	74 66                	je     10c0ac <net_buf_alloc_len+0x11b>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  10c046:	8b 45 14             	mov    0x14(%ebp),%eax
  10c049:	0b 45 10             	or     0x10(%ebp),%eax
  10c04c:	74 23                	je     10c071 <net_buf_alloc_len+0xe0>
  10c04e:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
  10c052:	75 06                	jne    10c05a <net_buf_alloc_len+0xc9>
  10c054:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  10c058:	74 17                	je     10c071 <net_buf_alloc_len+0xe0>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - z_tick_get();
  10c05a:	e8 fa 62 01 00       	call   122359 <z_tick_get>
  10c05f:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10c062:	29 c6                	sub    %eax,%esi
  10c064:	8b 7d f0             	mov    -0x10(%ebp),%edi
  10c067:	19 d7                	sbb    %edx,%edi
  10c069:	85 ff                	test   %edi,%edi
  10c06b:	79 04                	jns    10c071 <net_buf_alloc_len+0xe0>
  10c06d:	31 f6                	xor    %esi,%esi
  10c06f:	31 ff                	xor    %edi,%edi
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  10c071:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
	return pool->alloc->cb->alloc(buf, size, timeout);
  10c075:	6b c0 34             	imul   $0x34,%eax,%eax
  10c078:	8d 55 0c             	lea    0xc(%ebp),%edx
  10c07b:	8b 80 04 5e 14 00    	mov    0x145e04(%eax),%eax
  10c081:	8b 00                	mov    (%eax),%eax
  10c083:	57                   	push   %edi
  10c084:	56                   	push   %esi
  10c085:	52                   	push   %edx
  10c086:	53                   	push   %ebx
  10c087:	ff 10                	call   *(%eax)
  10c089:	83 c4 10             	add    $0x10,%esp
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
  10c08c:	89 43 10             	mov    %eax,0x10(%ebx)
		if (!buf->__buf) {
  10c08f:	85 c0                	test   %eax,%eax
  10c091:	75 20                	jne    10c0b3 <net_buf_alloc_len+0x122>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
  10c093:	53                   	push   %ebx
  10c094:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
  10c098:	6b c0 34             	imul   $0x34,%eax,%eax
  10c09b:	05 d8 5d 14 00       	add    $0x145dd8,%eax
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
  10c0a0:	31 db                	xor    %ebx,%ebx
  10c0a2:	50                   	push   %eax
  10c0a3:	e8 90 4e 01 00       	call   120f38 <k_queue_prepend>
  10c0a8:	58                   	pop    %eax
  10c0a9:	5a                   	pop    %edx
}
  10c0aa:	eb 26                	jmp    10c0d2 <net_buf_alloc_len+0x141>
		}

		NET_BUF_ASSERT(req_size <= size);
	} else {
		buf->__buf = NULL;
  10c0ac:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	}

	buf->ref   = 1U;
	buf->flags = 0U;
	buf->frags = NULL;
	buf->size  = size;
  10c0b3:	8b 45 0c             	mov    0xc(%ebp),%eax
	buf->frags = NULL;
  10c0b6:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	buf->size  = size;
  10c0bc:	66 89 43 0e          	mov    %ax,0xe(%ebx)
	buf->data = buf->__buf;
  10c0c0:	8b 43 10             	mov    0x10(%ebx),%eax
	buf->ref   = 1U;
  10c0c3:	66 c7 43 04 01 00    	movw   $0x1,0x4(%ebx)
	buf->len  = 0U;
  10c0c9:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	buf->data = buf->__buf;
  10c0cf:	89 43 08             	mov    %eax,0x8(%ebx)
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
  10c0d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c0d5:	89 d8                	mov    %ebx,%eax
  10c0d7:	5b                   	pop    %ebx
  10c0d8:	5e                   	pop    %esi
  10c0d9:	5f                   	pop    %edi
  10c0da:	5d                   	pop    %ebp
  10c0db:	c3                   	ret    

0010c0dc <net_buf_alloc_fixed>:
				       line);
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
  10c0dc:	55                   	push   %ebp
  10c0dd:	89 e5                	mov    %esp,%ebp
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
  10c0df:	ff 75 10             	pushl  0x10(%ebp)
  10c0e2:	ff 75 0c             	pushl  0xc(%ebp)
{
  10c0e5:	8b 45 08             	mov    0x8(%ebp),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  10c0e8:	8b 50 2c             	mov    0x2c(%eax),%edx
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
  10c0eb:	8b 52 04             	mov    0x4(%edx),%edx
  10c0ee:	ff 32                	pushl  (%edx)
  10c0f0:	50                   	push   %eax
  10c0f1:	e8 9b fe ff ff       	call   10bf91 <net_buf_alloc_len>
  10c0f6:	83 c4 10             	add    $0x10,%esp
}
  10c0f9:	c9                   	leave  
  10c0fa:	c3                   	ret    

0010c0fb <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  10c0fb:	55                   	push   %ebp
  10c0fc:	89 e5                	mov    %esp,%ebp
  10c0fe:	56                   	push   %esi
  10c0ff:	53                   	push   %ebx
  10c100:	8b 5d 08             	mov    0x8(%ebp),%ebx
	__ASSERT_NO_MSG(buf);

	while (buf) {
  10c103:	85 db                	test   %ebx,%ebx
  10c105:	74 64                	je     10c16b <net_buf_unref+0x70>
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
  10c107:	fe 4b 04             	decb   0x4(%ebx)
		struct net_buf *frags = buf->frags;
  10c10a:	8b 33                	mov    (%ebx),%esi
		if (--buf->ref > 0) {
  10c10c:	75 5d                	jne    10c16b <net_buf_unref+0x70>
			return;
		}

		if (buf->__buf) {
  10c10e:	8b 53 10             	mov    0x10(%ebx),%edx
  10c111:	85 d2                	test   %edx,%edx
  10c113:	74 23                	je     10c138 <net_buf_unref+0x3d>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
  10c115:	f6 43 05 02          	testb  $0x2,0x5(%ebx)
  10c119:	75 16                	jne    10c131 <net_buf_unref+0x36>
	pool->alloc->cb->unref(buf, data);
  10c11b:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
  10c11f:	6b c0 34             	imul   $0x34,%eax,%eax
  10c122:	8b 80 04 5e 14 00    	mov    0x145e04(%eax),%eax
  10c128:	8b 00                	mov    (%eax),%eax
  10c12a:	52                   	push   %edx
  10c12b:	53                   	push   %ebx
  10c12c:	ff 50 08             	call   *0x8(%eax)
  10c12f:	58                   	pop    %eax
  10c130:	5a                   	pop    %edx
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
  10c131:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
  10c138:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
  10c13c:	6b c0 34             	imul   $0x34,%eax,%eax
  10c13f:	05 d8 5d 14 00       	add    $0x145dd8,%eax
		buf->data = NULL;
  10c144:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		buf->frags = NULL;
  10c14b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		if (pool->destroy) {
  10c151:	8b 50 28             	mov    0x28(%eax),%edx
  10c154:	85 d2                	test   %edx,%edx
  10c156:	74 06                	je     10c15e <net_buf_unref+0x63>
			pool->destroy(buf);
  10c158:	53                   	push   %ebx
  10c159:	ff d2                	call   *%edx
  10c15b:	59                   	pop    %ecx
  10c15c:	eb 09                	jmp    10c167 <net_buf_unref+0x6c>
	k_lifo_put(&pool->free, buf);
  10c15e:	53                   	push   %ebx
  10c15f:	50                   	push   %eax
  10c160:	e8 d3 4d 01 00       	call   120f38 <k_queue_prepend>
  10c165:	58                   	pop    %eax
  10c166:	5a                   	pop    %edx
{
  10c167:	89 f3                	mov    %esi,%ebx
  10c169:	eb 98                	jmp    10c103 <net_buf_unref+0x8>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  10c16b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10c16e:	5b                   	pop    %ebx
  10c16f:	5e                   	pop    %esi
  10c170:	5d                   	pop    %ebp
  10c171:	c3                   	ret    

0010c172 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
  10c172:	55                   	push   %ebp
  10c173:	89 e5                	mov    %esp,%ebp
  10c175:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
  10c178:	89 c2                	mov    %eax,%edx
  10c17a:	8b 00                	mov    (%eax),%eax
  10c17c:	85 c0                	test   %eax,%eax
  10c17e:	75 f8                	jne    10c178 <net_buf_frag_last+0x6>
		buf = buf->frags;
	}

	return buf;
}
  10c180:	89 d0                	mov    %edx,%eax
  10c182:	5d                   	pop    %ebp
  10c183:	c3                   	ret    

0010c184 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
  10c184:	55                   	push   %ebp
  10c185:	89 e5                	mov    %esp,%ebp
  10c187:	56                   	push   %esi
  10c188:	53                   	push   %ebx
  10c189:	8b 55 08             	mov    0x8(%ebp),%edx
  10c18c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
  10c18f:	8b 1a                	mov    (%edx),%ebx
  10c191:	85 db                	test   %ebx,%ebx
  10c193:	74 0c                	je     10c1a1 <net_buf_frag_insert+0x1d>
  10c195:	89 c8                	mov    %ecx,%eax
	while (buf->frags) {
  10c197:	89 c6                	mov    %eax,%esi
  10c199:	8b 00                	mov    (%eax),%eax
  10c19b:	85 c0                	test   %eax,%eax
  10c19d:	75 f8                	jne    10c197 <net_buf_frag_insert+0x13>
		net_buf_frag_last(frag)->frags = parent->frags;
  10c19f:	89 1e                	mov    %ebx,(%esi)
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
  10c1a1:	89 0a                	mov    %ecx,(%edx)
}
  10c1a3:	5b                   	pop    %ebx
  10c1a4:	5e                   	pop    %esi
  10c1a5:	5d                   	pop    %ebp
  10c1a6:	c3                   	ret    

0010c1a7 <net_buf_linearize>:
	return next_frag;
}

size_t net_buf_linearize(void *dst, size_t dst_len, struct net_buf *src,
			 size_t offset, size_t len)
{
  10c1a7:	55                   	push   %ebp
  10c1a8:	89 e5                	mov    %esp,%ebp
  10c1aa:	57                   	push   %edi
  10c1ab:	56                   	push   %esi
  10c1ac:	53                   	push   %ebx
  10c1ad:	50                   	push   %eax
  10c1ae:	8b 5d 10             	mov    0x10(%ebp),%ebx
  10c1b1:	8b 45 14             	mov    0x14(%ebp),%eax
  10c1b4:	8b 55 18             	mov    0x18(%ebp),%edx
	len = MIN(len, dst_len);

	frag = src;

	/* find the right fragment to start copying from */
	while (frag && offset >= frag->len) {
  10c1b7:	85 db                	test   %ebx,%ebx
  10c1b9:	74 50                	je     10c20b <net_buf_linearize+0x64>
  10c1bb:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  10c1bf:	39 c1                	cmp    %eax,%ecx
  10c1c1:	77 06                	ja     10c1c9 <net_buf_linearize+0x22>
		offset -= frag->len;
  10c1c3:	29 c8                	sub    %ecx,%eax
		frag = frag->frags;
  10c1c5:	8b 1b                	mov    (%ebx),%ebx
  10c1c7:	eb ee                	jmp    10c1b7 <net_buf_linearize+0x10>
	len = MIN(len, dst_len);
  10c1c9:	8b 75 0c             	mov    0xc(%ebp),%esi
  10c1cc:	39 d6                	cmp    %edx,%esi
  10c1ce:	76 02                	jbe    10c1d2 <net_buf_linearize+0x2b>
  10c1d0:	89 d6                	mov    %edx,%esi
  10c1d2:	31 d2                	xor    %edx,%edx
	}

	/* traverse the fragment chain until len bytes are copied */
	copied = 0;
	while (frag && len > 0) {
  10c1d4:	85 db                	test   %ebx,%ebx
  10c1d6:	74 35                	je     10c20d <net_buf_linearize+0x66>
  10c1d8:	85 f6                	test   %esi,%esi
  10c1da:	74 31                	je     10c20d <net_buf_linearize+0x66>
		to_copy = MIN(len, frag->len - offset);
  10c1dc:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  10c1e0:	29 c7                	sub    %eax,%edi
  10c1e2:	39 f7                	cmp    %esi,%edi
  10c1e4:	76 02                	jbe    10c1e8 <net_buf_linearize+0x41>
  10c1e6:	89 f7                	mov    %esi,%edi
		memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
  10c1e8:	03 43 08             	add    0x8(%ebx),%eax
  10c1eb:	57                   	push   %edi
  10c1ec:	50                   	push   %eax
  10c1ed:	89 d0                	mov    %edx,%eax
  10c1ef:	03 45 08             	add    0x8(%ebp),%eax
  10c1f2:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10c1f5:	50                   	push   %eax
  10c1f6:	e8 f1 fb ff ff       	call   10bdec <memcpy>

		copied += to_copy;
  10c1fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
		memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
  10c1fe:	83 c4 0c             	add    $0xc,%esp
		copied += to_copy;
  10c201:	01 fa                	add    %edi,%edx

		/* to_copy is always <= len */
		len -= to_copy;
  10c203:	29 fe                	sub    %edi,%esi
		frag = frag->frags;
  10c205:	8b 1b                	mov    (%ebx),%ebx

		/* after the first iteration, this value will be 0 */
		offset = 0;
  10c207:	31 c0                	xor    %eax,%eax
  10c209:	eb c9                	jmp    10c1d4 <net_buf_linearize+0x2d>
  10c20b:	31 d2                	xor    %edx,%edx
	}

	return copied;
}
  10c20d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c210:	89 d0                	mov    %edx,%eax
  10c212:	5b                   	pop    %ebx
  10c213:	5e                   	pop    %esi
  10c214:	5f                   	pop    %edi
  10c215:	5d                   	pop    %ebp
  10c216:	c3                   	ret    

0010c217 <net_buf_simple_add>:
{
	memcpy(clone, original, sizeof(struct net_buf_simple));
}

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
  10c217:	55                   	push   %ebp
  10c218:	89 e5                	mov    %esp,%ebp
  10c21a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return buf->data + buf->len;
  10c21d:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
  10c221:	89 c2                	mov    %eax,%edx
  10c223:	03 01                	add    (%ecx),%eax

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
  10c225:	03 55 0c             	add    0xc(%ebp),%edx
  10c228:	66 89 51 04          	mov    %dx,0x4(%ecx)
	return tail;
}
  10c22c:	5d                   	pop    %ebp
  10c22d:	c3                   	ret    

0010c22e <net_buf_simple_add_u8>:

	return memcpy(net_buf_simple_add(buf, len), mem, len);
}

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
  10c22e:	55                   	push   %ebp
  10c22f:	89 e5                	mov    %esp,%ebp
  10c231:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10c234:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
  10c238:	89 c2                	mov    %eax,%edx
  10c23a:	03 01                	add    (%ecx),%eax
	buf->len += len;
  10c23c:	42                   	inc    %edx
  10c23d:	66 89 51 04          	mov    %dx,0x4(%ecx)
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
  10c241:	8b 55 0c             	mov    0xc(%ebp),%edx
  10c244:	88 10                	mov    %dl,(%eax)

	return u8;
}
  10c246:	5d                   	pop    %ebp
  10c247:	c3                   	ret    

0010c248 <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
  10c248:	55                   	push   %ebp
  10c249:	89 e5                	mov    %esp,%ebp
  10c24b:	8b 55 08             	mov    0x8(%ebp),%edx
  10c24e:	8b 45 0c             	mov    0xc(%ebp),%eax
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
  10c251:	66 29 42 04          	sub    %ax,0x4(%edx)
	return buf->data += len;
  10c255:	03 02                	add    (%edx),%eax
  10c257:	89 02                	mov    %eax,(%edx)
}
  10c259:	5d                   	pop    %ebp
  10c25a:	c3                   	ret    

0010c25b <net_buf_simple_tailroom>:
{
	return buf->data - buf->__buf;
}

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
  10c25b:	55                   	push   %ebp
  10c25c:	89 e5                	mov    %esp,%ebp
  10c25e:	8b 55 08             	mov    0x8(%ebp),%edx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
}
  10c261:	5d                   	pop    %ebp
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  10c262:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  10c266:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  10c26a:	29 c8                	sub    %ecx,%eax
	return buf->data - buf->__buf;
  10c26c:	8b 0a                	mov    (%edx),%ecx
  10c26e:	2b 4a 08             	sub    0x8(%edx),%ecx
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  10c271:	29 c8                	sub    %ecx,%eax
}
  10c273:	c3                   	ret    

0010c274 <net_ipv4_is_addr_mcast>:
 *
 * @return True if address is multicast address, False otherwise.
 */
static inline bool net_ipv4_is_addr_mcast(const struct in_addr *addr)
{
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  10c274:	8b 00                	mov    (%eax),%eax
  10c276:	25 f0 00 00 00       	and    $0xf0,%eax
  10c27b:	3d e0 00 00 00       	cmp    $0xe0,%eax
  10c280:	0f 94 c0             	sete   %al
}
  10c283:	c3                   	ret    

0010c284 <net_eth_get_hw_capabilities>:
	return iface->if_dev->dev;
  10c284:	8b 00                	mov    (%eax),%eax
  10c286:	8b 10                	mov    (%eax),%edx
enum ethernet_hw_caps net_eth_get_hw_capabilities(struct net_if *iface)
{
	const struct ethernet_api *eth =
		(struct ethernet_api *)net_if_get_device(iface)->api;

	if (!eth->get_capabilities) {
  10c288:	8b 42 08             	mov    0x8(%edx),%eax
  10c28b:	8b 40 0c             	mov    0xc(%eax),%eax
  10c28e:	85 c0                	test   %eax,%eax
  10c290:	74 09                	je     10c29b <net_eth_get_hw_capabilities+0x17>
{
  10c292:	55                   	push   %ebp
  10c293:	89 e5                	mov    %esp,%ebp
		return (enum ethernet_hw_caps)0;
	}

	return eth->get_capabilities(net_if_get_device(iface));
  10c295:	52                   	push   %edx
  10c296:	ff d0                	call   *%eax
  10c298:	5a                   	pop    %edx
}
  10c299:	c9                   	leave  
  10c29a:	c3                   	ret    
		return (enum ethernet_hw_caps)0;
  10c29b:	31 c0                	xor    %eax,%eax
}
  10c29d:	c3                   	ret    

0010c29e <ethernet_flags>:

	return 0;
}

enum net_l2_flags ethernet_flags(struct net_if *iface)
{
  10c29e:	55                   	push   %ebp
  10c29f:	89 e5                	mov    %esp,%ebp
	return iface->if_dev->l2_data;
  10c2a1:	8b 45 08             	mov    0x8(%ebp),%eax
	struct ethernet_context *ctx = net_if_l2_data(iface);

	return ctx->ethernet_l2_flags;
}
  10c2a4:	5d                   	pop    %ebp
  10c2a5:	8b 00                	mov    (%eax),%eax
	return ctx->ethernet_l2_flags;
  10c2a7:	8b 40 08             	mov    0x8(%eax),%eax
  10c2aa:	8a 40 10             	mov    0x10(%eax),%al
}
  10c2ad:	c3                   	ret    

0010c2ae <ethernet_enable>:
{
  10c2ae:	55                   	push   %ebp
  10c2af:	89 e5                	mov    %esp,%ebp
  10c2b1:	56                   	push   %esi
  10c2b2:	53                   	push   %ebx
  10c2b3:	8b 75 08             	mov    0x8(%ebp),%esi
  10c2b6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return iface->if_dev->dev;
  10c2b9:	8b 06                	mov    (%esi),%eax
  10c2bb:	8b 10                	mov    (%eax),%edx
		return -ENOENT;
  10c2bd:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	const struct ethernet_api *eth =
  10c2c2:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!eth) {
  10c2c5:	85 db                	test   %ebx,%ebx
  10c2c7:	74 25                	je     10c2ee <ethernet_enable+0x40>
	if (!state) {
  10c2c9:	84 c9                	test   %cl,%cl
  10c2cb:	75 14                	jne    10c2e1 <ethernet_enable+0x33>
		net_arp_clear_cache(iface);
  10c2cd:	56                   	push   %esi
  10c2ce:	e8 47 0c 00 00       	call   10cf1a <net_arp_clear_cache>
		if (eth->stop) {
  10c2d3:	8b 43 08             	mov    0x8(%ebx),%eax
		net_arp_clear_cache(iface);
  10c2d6:	5a                   	pop    %edx
		if (eth->stop) {
  10c2d7:	85 c0                	test   %eax,%eax
  10c2d9:	74 11                	je     10c2ec <ethernet_enable+0x3e>
  10c2db:	8b 16                	mov    (%esi),%edx
			eth->stop(net_if_get_device(iface));
  10c2dd:	ff 32                	pushl  (%edx)
  10c2df:	eb 08                	jmp    10c2e9 <ethernet_enable+0x3b>
		if (eth->start) {
  10c2e1:	8b 43 04             	mov    0x4(%ebx),%eax
  10c2e4:	85 c0                	test   %eax,%eax
  10c2e6:	74 04                	je     10c2ec <ethernet_enable+0x3e>
			eth->start(net_if_get_device(iface));
  10c2e8:	52                   	push   %edx
  10c2e9:	ff d0                	call   *%eax
  10c2eb:	58                   	pop    %eax
	return 0;
  10c2ec:	31 c0                	xor    %eax,%eax
}
  10c2ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10c2f1:	5b                   	pop    %ebx
  10c2f2:	5e                   	pop    %esi
  10c2f3:	5d                   	pop    %ebp
  10c2f4:	c3                   	ret    

0010c2f5 <net_eth_is_addr_broadcast>:
	return false;
  10c2f5:	31 d2                	xor    %edx,%edx
	if (addr->addr[0] == 0xff &&
  10c2f7:	80 38 ff             	cmpb   $0xff,(%eax)
  10c2fa:	75 1f                	jne    10c31b <net_eth_is_addr_broadcast+0x26>
  10c2fc:	80 78 01 ff          	cmpb   $0xff,0x1(%eax)
  10c300:	75 19                	jne    10c31b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[1] == 0xff &&
  10c302:	80 78 02 ff          	cmpb   $0xff,0x2(%eax)
  10c306:	75 13                	jne    10c31b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[2] == 0xff &&
  10c308:	80 78 03 ff          	cmpb   $0xff,0x3(%eax)
  10c30c:	75 0d                	jne    10c31b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[3] == 0xff &&
  10c30e:	80 78 04 ff          	cmpb   $0xff,0x4(%eax)
  10c312:	75 07                	jne    10c31b <net_eth_is_addr_broadcast+0x26>
	    addr->addr[4] == 0xff &&
  10c314:	80 78 05 ff          	cmpb   $0xff,0x5(%eax)
  10c318:	0f 94 c2             	sete   %dl
}
  10c31b:	88 d0                	mov    %dl,%al
  10c31d:	c3                   	ret    

0010c31e <ethernet_recv>:
{
  10c31e:	55                   	push   %ebp
  10c31f:	89 e5                	mov    %esp,%ebp
  10c321:	57                   	push   %edi
  10c322:	56                   	push   %esi
  10c323:	53                   	push   %ebx
  10c324:	83 ec 0c             	sub    $0xc,%esp
  10c327:	8b 75 0c             	mov    0xc(%ebp),%esi
  10c32a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct net_eth_hdr *hdr = NET_ETH_HDR(pkt);
  10c32d:	8b 46 10             	mov    0x10(%esi),%eax
	return pkt->frags->data;
  10c330:	8b 58 08             	mov    0x8(%eax),%ebx
	if (hdr == NULL || pkt->buffer->len < hdr_len) {
  10c333:	85 db                	test   %ebx,%ebx
  10c335:	0f 84 92 01 00 00    	je     10c4cd <ethernet_recv+0x1af>
  10c33b:	66 83 78 0c 0d       	cmpw   $0xd,0xc(%eax)
  10c340:	0f 86 87 01 00 00    	jbe    10c4cd <ethernet_recv+0x1af>
	type = ntohs(hdr->type);
  10c346:	66 8b 43 0c          	mov    0xc(%ebx),%ax
  10c34a:	86 e0                	xchg   %ah,%al
	switch (type) {
  10c34c:	66 3d dd 86          	cmp    $0x86dd,%ax
	type = ntohs(hdr->type);
  10c350:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	switch (type) {
  10c354:	74 2a                	je     10c380 <ethernet_recv+0x62>
  10c356:	0f 87 71 01 00 00    	ja     10c4cd <ethernet_recv+0x1af>
  10c35c:	66 3d 00 08          	cmp    $0x800,%ax
  10c360:	74 0a                	je     10c36c <ethernet_recv+0x4e>
  10c362:	66 3d 06 08          	cmp    $0x806,%ax
  10c366:	0f 85 61 01 00 00    	jne    10c4cd <ethernet_recv+0x1af>
	pkt->family = family;
  10c36c:	8a 46 3f             	mov    0x3f(%esi),%al
		family = AF_INET;
  10c36f:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
  10c375:	83 e0 f1             	and    $0xfffffff1,%eax
  10c378:	83 c8 02             	or     $0x2,%eax
  10c37b:	88 46 3f             	mov    %al,0x3f(%esi)
		break;
  10c37e:	eb 12                	jmp    10c392 <ethernet_recv+0x74>
  10c380:	8a 46 3f             	mov    0x3f(%esi),%al
		family = AF_INET6;
  10c383:	66 c7 45 f0 02 00    	movw   $0x2,-0x10(%ebp)
  10c389:	83 e0 f1             	and    $0xfffffff1,%eax
  10c38c:	83 c8 04             	or     $0x4,%eax
  10c38f:	88 46 3f             	mov    %al,0x3f(%esi)
	lladdr->addr = hdr->src.addr;
  10c392:	8d 43 06             	lea    0x6(%ebx),%eax
	lladdr->len = sizeof(struct net_eth_addr);
  10c395:	66 c7 46 2c 06 03    	movw   $0x306,0x2c(%esi)
	lladdr->addr = hdr->src.addr;
  10c39b:	89 46 28             	mov    %eax,0x28(%esi)
	lladdr->addr = hdr->dst.addr;
  10c39e:	89 5e 30             	mov    %ebx,0x30(%esi)
	lladdr->len = sizeof(struct net_eth_addr);
  10c3a1:	66 c7 46 34 06 03    	movw   $0x306,0x34(%esi)
	if (!net_eth_is_addr_broadcast((struct net_eth_addr *)lladdr->addr) &&
  10c3a7:	89 d8                	mov    %ebx,%eax
  10c3a9:	e8 47 ff ff ff       	call   10c2f5 <net_eth_is_addr_broadcast>
  10c3ae:	84 c0                	test   %al,%al
  10c3b0:	74 1a                	je     10c3cc <ethernet_recv+0xae>
	net_buf_pull(pkt->frags, hdr_len);
  10c3b2:	6a 0e                	push   $0xe
  10c3b4:	8b 46 10             	mov    0x10(%esi),%eax
  10c3b7:	83 c0 08             	add    $0x8,%eax
  10c3ba:	50                   	push   %eax
  10c3bb:	e8 88 fe ff ff       	call   10c248 <net_buf_simple_pull>
  10c3c0:	5f                   	pop    %edi
	if (IS_ENABLED(CONFIG_NET_IPV4) && type == NET_ETH_PTYPE_IP &&
  10c3c1:	66 81 7d f2 00 08    	cmpw   $0x800,-0xe(%ebp)
	net_buf_pull(pkt->frags, hdr_len);
  10c3c7:	58                   	pop    %eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && type == NET_ETH_PTYPE_IP &&
  10c3c8:	75 53                	jne    10c41d <ethernet_recv+0xff>
  10c3ca:	eb 46                	jmp    10c412 <ethernet_recv+0xf4>
	if (addr->addr[0] == 0x01 &&
  10c3cc:	80 3b 01             	cmpb   $0x1,(%ebx)
  10c3cf:	75 0c                	jne    10c3dd <ethernet_recv+0xbf>
  10c3d1:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
  10c3d5:	75 06                	jne    10c3dd <ethernet_recv+0xbf>
	    addr->addr[1] == 0x00 &&
  10c3d7:	80 7b 02 5e          	cmpb   $0x5e,0x2(%ebx)
  10c3db:	74 d5                	je     10c3b2 <ethernet_recv+0x94>
	    !net_linkaddr_cmp(net_if_get_link_addr(iface), lladdr)) {
  10c3dd:	8b 01                	mov    (%ecx),%eax
 * @return True if the addresses are the same, false otherwise.
 */
static inline bool net_linkaddr_cmp(struct net_linkaddr *lladdr1,
				    struct net_linkaddr *lladdr2)
{
	if (!lladdr1 || !lladdr2) {
  10c3df:	83 f8 f0             	cmp    $0xfffffff0,%eax
  10c3e2:	0f 84 e5 00 00 00    	je     10c4cd <ethernet_recv+0x1af>
  10c3e8:	83 fe d0             	cmp    $0xffffffd0,%esi
  10c3eb:	0f 84 dc 00 00 00    	je     10c4cd <ethernet_recv+0x1af>
		return false;
	}

	if (lladdr1->len != lladdr2->len) {
  10c3f1:	80 78 14 06          	cmpb   $0x6,0x14(%eax)
  10c3f5:	0f 85 d2 00 00 00    	jne    10c4cd <ethernet_recv+0x1af>
		return false;
	}

	return !memcmp(lladdr1->addr, lladdr2->addr, lladdr1->len);
  10c3fb:	6a 06                	push   $0x6
  10c3fd:	53                   	push   %ebx
  10c3fe:	ff 70 10             	pushl  0x10(%eax)
  10c401:	e8 79 f9 ff ff       	call   10bd7f <memcmp>
  10c406:	83 c4 0c             	add    $0xc,%esp
		    (struct net_eth_addr *)lladdr->addr) &&
  10c409:	85 c0                	test   %eax,%eax
  10c40b:	74 a5                	je     10c3b2 <ethernet_recv+0x94>
  10c40d:	e9 bb 00 00 00       	jmp    10c4cd <ethernet_recv+0x1af>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
  10c412:	89 d8                	mov    %ebx,%eax
  10c414:	e8 dc fe ff ff       	call   10c2f5 <net_eth_is_addr_broadcast>
  10c419:	84 c0                	test   %al,%al
  10c41b:	75 07                	jne    10c424 <ethernet_recv+0x106>
	ethernet_update_rx_stats(iface, pkt, net_pkt_get_len(pkt) + hdr_len);
  10c41d:	8b 4e 10             	mov    0x10(%esi),%ecx
  10c420:	89 c8                	mov    %ecx,%eax
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;

	while (buf) {
  10c422:	eb 3b                	jmp    10c45f <ethernet_recv+0x141>
	return pkt->frags->data;
  10c424:	8b 46 10             	mov    0x10(%esi),%eax
  10c427:	8b 78 08             	mov    0x8(%eax),%edi
	    !(net_ipv4_is_addr_mcast(&NET_IPV4_HDR(pkt)->dst) ||
  10c42a:	8d 47 10             	lea    0x10(%edi),%eax
  10c42d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10c430:	e8 3f fe ff ff       	call   10c274 <net_ipv4_is_addr_mcast>
	if (net_eth_is_addr_broadcast(&hdr->dst) &&
  10c435:	84 c0                	test   %al,%al
  10c437:	75 e4                	jne    10c41d <ethernet_recv+0xff>
	      net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
  10c439:	8b 4e 20             	mov    0x20(%esi),%ecx
  10c43c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
 */
#if defined(CONFIG_NET_NATIVE_IPV4)
static inline bool net_ipv4_is_addr_bcast(struct net_if *iface,
					  const struct in_addr *addr)
{
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  10c43f:	e8 15 21 00 00       	call   10e559 <net_ipv4_broadcast_address>
  10c444:	8b 00                	mov    (%eax),%eax
  10c446:	39 47 10             	cmp    %eax,0x10(%edi)
  10c449:	74 d2                	je     10c41d <ethernet_recv+0xff>
		return true;
	}

	return net_if_ipv4_is_addr_bcast(iface, addr);
  10c44b:	ff 75 ec             	pushl  -0x14(%ebp)
  10c44e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10c451:	51                   	push   %ecx
  10c452:	e8 bd 12 00 00       	call   10d714 <net_if_ipv4_is_addr_bcast>
  10c457:	5a                   	pop    %edx
	    !(net_ipv4_is_addr_mcast(&NET_IPV4_HDR(pkt)->dst) ||
  10c458:	84 c0                	test   %al,%al
  10c45a:	59                   	pop    %ecx
  10c45b:	75 c0                	jne    10c41d <ethernet_recv+0xff>
  10c45d:	eb 6e                	jmp    10c4cd <ethernet_recv+0x1af>
  10c45f:	85 c0                	test   %eax,%eax
  10c461:	74 04                	je     10c467 <ethernet_recv+0x149>
		bytes += buf->len;
		buf = buf->frags;
  10c463:	8b 00                	mov    (%eax),%eax
  10c465:	eb f8                	jmp    10c45f <ethernet_recv+0x141>
	if (IS_ENABLED(CONFIG_NET_ARP) &&
  10c467:	66 83 7d f0 01       	cmpw   $0x1,-0x10(%ebp)
  10c46c:	75 1a                	jne    10c488 <ethernet_recv+0x16a>
  10c46e:	66 81 7d f2 06 08    	cmpw   $0x806,-0xe(%ebp)
  10c474:	75 12                	jne    10c488 <ethernet_recv+0x16a>
		return net_arp_input(pkt, hdr);
  10c476:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  10c479:	89 75 08             	mov    %esi,0x8(%ebp)
}
  10c47c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c47f:	5b                   	pop    %ebx
  10c480:	5e                   	pop    %esi
  10c481:	5f                   	pop    %edi
  10c482:	5d                   	pop    %ebp
		return net_arp_input(pkt, hdr);
  10c483:	e9 1c 08 00 00       	jmp    10cca4 <net_arp_input>
	return pkt->family;
  10c488:	8a 46 3f             	mov    0x3f(%esi),%al
  10c48b:	8b 59 08             	mov    0x8(%ecx),%ebx
  10c48e:	d0 e8                	shr    %al
  10c490:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET) {
  10c493:	fe c8                	dec    %al
  10c495:	75 08                	jne    10c49f <ethernet_recv+0x181>
		len = ntohs(NET_IPV4_HDR(pkt)->len);
  10c497:	66 8b 43 02          	mov    0x2(%ebx),%ax
  10c49b:	86 e0                	xchg   %ah,%al
  10c49d:	eb 09                	jmp    10c4a8 <ethernet_recv+0x18a>
		len = ntohs(NET_IPV6_HDR(pkt)->len) + NET_IPV6H_LEN;
  10c49f:	66 8b 43 04          	mov    0x4(%ebx),%ax
  10c4a3:	86 e0                	xchg   %ah,%al
  10c4a5:	83 c0 28             	add    $0x28,%eax
	if (len < NET_ETH_MINIMAL_FRAME_SIZE - sizeof(struct net_eth_hdr)) {
  10c4a8:	66 83 f8 2d          	cmp    $0x2d,%ax
  10c4ac:	76 13                	jbe    10c4c1 <ethernet_recv+0x1a3>
	return NET_CONTINUE;
  10c4ae:	b8 01 00 00 00       	mov    $0x1,%eax
  10c4b3:	eb 1d                	jmp    10c4d2 <ethernet_recv+0x1b4>
				frag->len = len;
  10c4b5:	66 89 41 0c          	mov    %ax,0xc(%ecx)
				len = 0U;
  10c4b9:	31 c0                	xor    %eax,%eax
		for (frag = pkt->frags; frag; frag = frag->frags) {
  10c4bb:	8b 09                	mov    (%ecx),%ecx
  10c4bd:	85 c9                	test   %ecx,%ecx
  10c4bf:	74 ed                	je     10c4ae <ethernet_recv+0x190>
			if (frag->len < len) {
  10c4c1:	8b 51 0c             	mov    0xc(%ecx),%edx
  10c4c4:	66 39 d0             	cmp    %dx,%ax
  10c4c7:	76 ec                	jbe    10c4b5 <ethernet_recv+0x197>
				len -= frag->len;
  10c4c9:	29 d0                	sub    %edx,%eax
  10c4cb:	eb ee                	jmp    10c4bb <ethernet_recv+0x19d>
	switch (type) {
  10c4cd:	b8 02 00 00 00       	mov    $0x2,%eax
}
  10c4d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c4d5:	5b                   	pop    %ebx
  10c4d6:	5e                   	pop    %esi
  10c4d7:	5f                   	pop    %edi
  10c4d8:	5d                   	pop    %ebp
  10c4d9:	c3                   	ret    

0010c4da <ethernet_send>:
{
  10c4da:	55                   	push   %ebp
  10c4db:	89 e5                	mov    %esp,%ebp
  10c4dd:	57                   	push   %edi
  10c4de:	56                   	push   %esi
		ret = -ENOENT;
  10c4df:	be fe ff ff ff       	mov    $0xfffffffe,%esi
{
  10c4e4:	53                   	push   %ebx
  10c4e5:	83 ec 08             	sub    $0x8,%esp
  10c4e8:	8b 45 08             	mov    0x8(%ebp),%eax
  10c4eb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10c4ee:	8b 00                	mov    (%eax),%eax
	const struct ethernet_api *api = net_if_get_device(iface)->api;
  10c4f0:	8b 00                	mov    (%eax),%eax
  10c4f2:	8b 40 08             	mov    0x8(%eax),%eax
  10c4f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!api) {
  10c4f8:	85 c0                	test   %eax,%eax
  10c4fa:	0f 84 ba 01 00 00    	je     10c6ba <ethernet_send+0x1e0>
  10c500:	8a 47 3f             	mov    0x3f(%edi),%al
  10c503:	88 c2                	mov    %al,%dl
  10c505:	d0 ea                	shr    %dl
  10c507:	83 e2 07             	and    $0x7,%edx
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10c50a:	fe ca                	dec    %dl
  10c50c:	75 7d                	jne    10c58b <ethernet_send+0xb1>
	return pkt->frags->data;
  10c50e:	8b 47 10             	mov    0x10(%edi),%eax
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
  10c511:	8b 77 20             	mov    0x20(%edi),%esi
  10c514:	8b 58 08             	mov    0x8(%eax),%ebx
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  10c517:	e8 3d 20 00 00       	call   10e559 <net_ipv4_broadcast_address>
  10c51c:	8b 00                	mov    (%eax),%eax
  10c51e:	39 43 10             	cmp    %eax,0x10(%ebx)
  10c521:	0f 84 86 01 00 00    	je     10c6ad <ethernet_send+0x1d3>
				   &NET_IPV4_HDR(pkt)->dst) ||
  10c527:	83 c3 10             	add    $0x10,%ebx
	return net_if_ipv4_is_addr_bcast(iface, addr);
  10c52a:	53                   	push   %ebx
  10c52b:	56                   	push   %esi
  10c52c:	e8 e3 11 00 00       	call   10d714 <net_if_ipv4_is_addr_bcast>
  10c531:	5a                   	pop    %edx
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
  10c532:	84 c0                	test   %al,%al
  10c534:	59                   	pop    %ecx
  10c535:	0f 85 72 01 00 00    	jne    10c6ad <ethernet_send+0x1d3>
  10c53b:	8b 47 10             	mov    0x10(%edi),%eax
	    net_ipv4_is_addr_mcast(&NET_IPV4_HDR(pkt)->dst)) {
  10c53e:	8b 50 08             	mov    0x8(%eax),%edx
  10c541:	83 c2 10             	add    $0x10,%edx
  10c544:	89 d0                	mov    %edx,%eax
  10c546:	e8 29 fd ff ff       	call   10c274 <net_ipv4_is_addr_mcast>
				   &NET_IPV4_HDR(pkt)->dst) ||
  10c54b:	84 c0                	test   %al,%al
  10c54d:	0f 85 5a 01 00 00    	jne    10c6ad <ethernet_send+0x1d3>
		arp_pkt = net_arp_prepare(pkt, &NET_IPV4_HDR(pkt)->dst, NULL);
  10c553:	6a 00                	push   $0x0
				ret = -ENOMEM;
  10c555:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
		arp_pkt = net_arp_prepare(pkt, &NET_IPV4_HDR(pkt)->dst, NULL);
  10c55a:	52                   	push   %edx
  10c55b:	57                   	push   %edi
  10c55c:	e8 d0 04 00 00       	call   10ca31 <net_arp_prepare>
  10c561:	83 c4 0c             	add    $0xc,%esp
  10c564:	89 c3                	mov    %eax,%ebx
		if (!arp_pkt) {
  10c566:	85 c0                	test   %eax,%eax
  10c568:	0f 84 4c 01 00 00    	je     10c6ba <ethernet_send+0x1e0>
		if (pkt != arp_pkt) {
  10c56e:	39 c7                	cmp    %eax,%edi
  10c570:	0f 84 39 01 00 00    	je     10c6af <ethernet_send+0x1d5>
			net_pkt_unref(pkt);
  10c576:	57                   	push   %edi
  10c577:	e8 00 35 00 00       	call   10fa7c <net_pkt_unref>
	pkt->family = family;
  10c57c:	8a 43 3f             	mov    0x3f(%ebx),%al
  10c57f:	5e                   	pop    %esi
  10c580:	83 e0 f1             	and    $0xfffffff1,%eax
  10c583:	83 c8 02             	or     $0x2,%eax
  10c586:	88 43 3f             	mov    %al,0x3f(%ebx)
  10c589:	eb 0b                	jmp    10c596 <ethernet_send+0xbc>
  10c58b:	83 e0 f1             	and    $0xfffffff1,%eax
}
  10c58e:	89 fb                	mov    %edi,%ebx
	pkt->family = family;
  10c590:	83 c8 02             	or     $0x2,%eax
  10c593:	88 47 3f             	mov    %al,0x3f(%edi)
		ptype = htons(NET_ETH_PTYPE_ARP);
  10c596:	66 c7 45 f2 08 06    	movw   $0x608,-0xe(%ebp)
	if (!net_pkt_lladdr_dst(pkt)->addr) {
  10c59c:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
  10c5a0:	75 0b                	jne    10c5ad <ethernet_send+0xd3>
		net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)broadcast_eth_addr.addr;
  10c5a2:	c7 43 30 44 43 12 00 	movl   $0x124344,0x30(%ebx)
		net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
  10c5a9:	c6 43 34 06          	movb   $0x6,0x34(%ebx)
	hdr_frag = net_pkt_get_frag(pkt, NET_BUF_TIMEOUT);
  10c5ad:	6a 00                	push   $0x0
  10c5af:	6a 0a                	push   $0xa
  10c5b1:	53                   	push   %ebx
  10c5b2:	e8 67 34 00 00       	call   10fa1e <net_pkt_get_frag>
  10c5b7:	83 c4 0c             	add    $0xc,%esp
  10c5ba:	89 c6                	mov    %eax,%esi
	if (!hdr_frag) {
  10c5bc:	85 c0                	test   %eax,%eax
  10c5be:	75 0a                	jne    10c5ca <ethernet_send+0xf0>
		ret = -ENOMEM;
  10c5c0:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
  10c5c5:	e9 f0 00 00 00       	jmp    10c6ba <ethernet_send+0x1e0>
		hdr = (struct net_eth_hdr *)(hdr_frag->data);
  10c5ca:	8b 78 08             	mov    0x8(%eax),%edi
	return pkt->family;
  10c5cd:	8a 43 3f             	mov    0x3f(%ebx),%al
  10c5d0:	d0 e8                	shr    %al
  10c5d2:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET &&
  10c5d5:	fe c8                	dec    %al
  10c5d7:	75 32                	jne    10c60b <ethernet_send+0x131>
	return pkt->frags->data;
  10c5d9:	8b 43 10             	mov    0x10(%ebx),%eax
  10c5dc:	8b 48 08             	mov    0x8(%eax),%ecx
	    net_ipv4_is_addr_mcast(&NET_IPV4_HDR(pkt)->dst)) {
  10c5df:	8d 41 10             	lea    0x10(%ecx),%eax
  10c5e2:	e8 8d fc ff ff       	call   10c274 <net_ipv4_is_addr_mcast>
	if (net_pkt_family(pkt) == AF_INET &&
  10c5e7:	84 c0                	test   %al,%al
  10c5e9:	74 20                	je     10c60b <ethernet_send+0x131>
		dst->addr[0] = 0x01;
  10c5eb:	66 c7 07 01 00       	movw   $0x1,(%edi)
		dst->addr[2] = 0x5e;
  10c5f0:	c6 47 02 5e          	movb   $0x5e,0x2(%edi)
		dst->addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
  10c5f4:	8a 51 12             	mov    0x12(%ecx),%dl
		dst->addr[3] = NET_IPV4_HDR(pkt)->dst.s4_addr[1];
  10c5f7:	8a 41 11             	mov    0x11(%ecx),%al
		dst->addr[4] = NET_IPV4_HDR(pkt)->dst.s4_addr[2];
  10c5fa:	88 57 04             	mov    %dl,0x4(%edi)
		dst->addr[3] &= 0x7f;
  10c5fd:	83 e0 7f             	and    $0x7f,%eax
		dst->addr[5] = NET_IPV4_HDR(pkt)->dst.s4_addr[3];
  10c600:	8a 49 13             	mov    0x13(%ecx),%cl
		dst->addr[3] &= 0x7f;
  10c603:	88 47 03             	mov    %al,0x3(%edi)
		dst->addr[5] = NET_IPV4_HDR(pkt)->dst.s4_addr[3];
  10c606:	88 4f 05             	mov    %cl,0x5(%edi)
		return true;
  10c609:	eb 0e                	jmp    10c619 <ethernet_send+0x13f>
			memcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,
  10c60b:	6a 06                	push   $0x6
  10c60d:	ff 73 30             	pushl  0x30(%ebx)
  10c610:	57                   	push   %edi
  10c611:	e8 d6 f7 ff ff       	call   10bdec <memcpy>
  10c616:	83 c4 0c             	add    $0xc,%esp
		memcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,
  10c619:	6a 06                	push   $0x6
  10c61b:	8d 47 06             	lea    0x6(%edi),%eax
  10c61e:	ff 73 28             	pushl  0x28(%ebx)
  10c621:	50                   	push   %eax
  10c622:	e8 c5 f7 ff ff       	call   10bdec <memcpy>
  10c627:	83 c4 0c             	add    $0xc,%esp
		hdr->type = ptype;
  10c62a:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
  10c62e:	66 89 47 0c          	mov    %ax,0xc(%edi)
		net_buf_add(hdr_frag, sizeof(struct net_eth_hdr));
  10c632:	8d 46 08             	lea    0x8(%esi),%eax
  10c635:	6a 0e                	push   $0xe
  10c637:	50                   	push   %eax
  10c638:	e8 da fb ff ff       	call   10c217 <net_buf_simple_add>
  10c63d:	5a                   	pop    %edx
  10c63e:	59                   	pop    %ecx
	net_pkt_frag_insert(pkt, hdr_frag);
  10c63f:	56                   	push   %esi
  10c640:	53                   	push   %ebx
  10c641:	e8 83 34 00 00       	call   10fac9 <net_pkt_frag_insert>
  10c646:	5e                   	pop    %esi
  10c647:	5f                   	pop    %edi
	net_pkt_cursor_init(pkt);
  10c648:	53                   	push   %ebx
  10c649:	e8 9c 35 00 00       	call   10fbea <net_pkt_cursor_init>
  10c64e:	8b 45 08             	mov    0x8(%ebp),%eax
	ret = api->send(net_if_get_device(iface), pkt);
  10c651:	89 1c 24             	mov    %ebx,(%esp)
  10c654:	8b 00                	mov    (%eax),%eax
  10c656:	ff 30                	pushl  (%eax)
  10c658:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10c65b:	ff 50 18             	call   *0x18(%eax)
  10c65e:	5a                   	pop    %edx
  10c65f:	59                   	pop    %ecx
  10c660:	89 c6                	mov    %eax,%esi
	if (ret != 0) {
  10c662:	85 c0                	test   %eax,%eax
  10c664:	74 16                	je     10c67c <ethernet_send+0x1a2>
	buf = pkt->buffer;
  10c666:	8b 43 10             	mov    0x10(%ebx),%eax
	pkt->buffer = buf->frags;
  10c669:	8b 10                	mov    (%eax),%edx
  10c66b:	89 53 10             	mov    %edx,0x10(%ebx)
	buf->frags = NULL;
  10c66e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	net_pkt_frag_unref(buf);
  10c674:	50                   	push   %eax
  10c675:	e8 f1 33 00 00       	call   10fa6b <net_pkt_frag_unref>
  10c67a:	eb 2e                	jmp    10c6aa <ethernet_send+0x1d0>
	ret = net_pkt_get_len(pkt);
  10c67c:	8b 53 10             	mov    0x10(%ebx),%edx
	size_t bytes = 0;
  10c67f:	31 f6                	xor    %esi,%esi
  10c681:	89 d1                	mov    %edx,%ecx
	while (buf) {
  10c683:	85 c9                	test   %ecx,%ecx
  10c685:	74 0a                	je     10c691 <ethernet_send+0x1b7>
		bytes += buf->len;
  10c687:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
		buf = buf->frags;
  10c68b:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
  10c68d:	01 c6                	add    %eax,%esi
		buf = buf->frags;
  10c68f:	eb f2                	jmp    10c683 <ethernet_send+0x1a9>
	pkt->buffer = buf->frags;
  10c691:	8b 02                	mov    (%edx),%eax
  10c693:	89 43 10             	mov    %eax,0x10(%ebx)
	buf->frags = NULL;
  10c696:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	net_pkt_frag_unref(buf);
  10c69c:	52                   	push   %edx
  10c69d:	e8 c9 33 00 00       	call   10fa6b <net_pkt_frag_unref>
	net_pkt_unref(pkt);
  10c6a2:	89 1c 24             	mov    %ebx,(%esp)
  10c6a5:	e8 d2 33 00 00       	call   10fa7c <net_pkt_unref>
  10c6aa:	58                   	pop    %eax
  10c6ab:	eb 0d                	jmp    10c6ba <ethernet_send+0x1e0>
				ret = -ENOMEM;
  10c6ad:	89 fb                	mov    %edi,%ebx
				ptype = htons(NET_ETH_PTYPE_IP);
  10c6af:	66 c7 45 f2 08 00    	movw   $0x8,-0xe(%ebp)
  10c6b5:	e9 e2 fe ff ff       	jmp    10c59c <ethernet_send+0xc2>
}
  10c6ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c6bd:	89 f0                	mov    %esi,%eax
  10c6bf:	5b                   	pop    %ebx
  10c6c0:	5e                   	pop    %esi
  10c6c1:	5f                   	pop    %edi
  10c6c2:	5d                   	pop    %ebp
  10c6c3:	c3                   	ret    

0010c6c4 <net_eth_broadcast_addr>:
}
  10c6c4:	b8 44 43 12 00       	mov    $0x124344,%eax
  10c6c9:	c3                   	ret    

0010c6ca <ethernet_init>:
	return net_mgmt(NET_REQUEST_ETHERNET_SET_PROMISC_MODE, iface,
			&params, sizeof(struct ethernet_req_params));
}

void ethernet_init(struct net_if *iface)
{
  10c6ca:	55                   	push   %ebp
  10c6cb:	89 e5                	mov    %esp,%ebp
  10c6cd:	53                   	push   %ebx
  10c6ce:	8b 45 08             	mov    0x8(%ebp),%eax
	return iface->if_dev->l2_data;
  10c6d1:	8b 10                	mov    (%eax),%edx
  10c6d3:	8b 5a 08             	mov    0x8(%edx),%ebx
	int i;
#endif

	NET_DBG("Initializing Ethernet L2 %p for iface %p", ctx, iface);

	ctx->ethernet_l2_flags = NET_L2_MULTICAST;
  10c6d6:	c6 43 10 01          	movb   $0x1,0x10(%ebx)

	if (net_eth_get_hw_capabilities(iface) & ETHERNET_PROMISC_MODE) {
  10c6da:	e8 a5 fb ff ff       	call   10c284 <net_eth_get_hw_capabilities>
  10c6df:	0f ba e0 0a          	bt     $0xa,%eax
  10c6e3:	73 04                	jae    10c6e9 <ethernet_init+0x1f>
		ctx->ethernet_l2_flags |= NET_L2_PROMISC_MODE;
  10c6e5:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
			break;
		}
	}
#endif

	net_arp_init();
  10c6e9:	e8 29 09 00 00       	call   10d017 <net_arp_init>

	ctx->is_init = true;
  10c6ee:	c6 43 11 01          	movb   $0x1,0x11(%ebx)
}
  10c6f2:	5b                   	pop    %ebx
  10c6f3:	5d                   	pop    %ebp
  10c6f4:	c3                   	ret    

0010c6f5 <sys_slist_prepend>:
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node);

Z_GENLIST_PREPEND(slist, snode)
  10c6f5:	8b 08                	mov    (%eax),%ecx
	parent->next = child;
  10c6f7:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
  10c6f9:	89 10                	mov    %edx,(%eax)
Z_GENLIST_PREPEND(slist, snode)
  10c6fb:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  10c6ff:	75 03                	jne    10c704 <sys_slist_prepend+0xf>
	list->tail = node;
  10c701:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_PREPEND(slist, snode)
  10c704:	c3                   	ret    

0010c705 <sys_slist_remove>:
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
  10c705:	55                   	push   %ebp
  10c706:	85 d2                	test   %edx,%edx
  10c708:	89 e5                	mov    %esp,%ebp
  10c70a:	53                   	push   %ebx
  10c70b:	8b 19                	mov    (%ecx),%ebx
  10c70d:	75 0c                	jne    10c71b <sys_slist_remove+0x16>
  10c70f:	3b 48 04             	cmp    0x4(%eax),%ecx
	list->head = node;
  10c712:	89 18                	mov    %ebx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
  10c714:	75 0f                	jne    10c725 <sys_slist_remove+0x20>
	list->tail = node;
  10c716:	89 58 04             	mov    %ebx,0x4(%eax)
}
  10c719:	eb 0a                	jmp    10c725 <sys_slist_remove+0x20>
	parent->next = child;
  10c71b:	89 1a                	mov    %ebx,(%edx)
Z_GENLIST_REMOVE(slist, snode)
  10c71d:	3b 48 04             	cmp    0x4(%eax),%ecx
  10c720:	75 03                	jne    10c725 <sys_slist_remove+0x20>
	list->tail = node;
  10c722:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_REMOVE(slist, snode)
  10c725:	5b                   	pop    %ebx
	parent->next = child;
  10c726:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
  10c72c:	5d                   	pop    %ebp
  10c72d:	c3                   	ret    

0010c72e <arp_entry_find>:

static struct arp_entry *arp_entry_find(sys_slist_t *list,
					struct net_if *iface,
					struct in_addr *dst,
					sys_snode_t **previous)
{
  10c72e:	55                   	push   %ebp
  10c72f:	89 e5                	mov    %esp,%ebp
  10c731:	56                   	push   %esi
  10c732:	53                   	push   %ebx
  10c733:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return list->head;
  10c736:	8b 00                	mov    (%eax),%eax
	struct arp_entry *entry;

	SYS_SLIST_FOR_EACH_CONTAINER(list, entry, node) {
  10c738:	85 c0                	test   %eax,%eax
  10c73a:	74 14                	je     10c750 <arp_entry_find+0x22>
		NET_DBG("iface %p dst %s",
			iface, log_strdup(net_sprint_ipv4_addr(&entry->ip)));

		if (entry->iface == iface &&
  10c73c:	3b 50 08             	cmp    0x8(%eax),%edx
  10c73f:	75 07                	jne    10c748 <arp_entry_find+0x1a>
  10c741:	8b 31                	mov    (%ecx),%esi
  10c743:	39 70 0c             	cmp    %esi,0xc(%eax)
  10c746:	74 0a                	je     10c752 <arp_entry_find+0x24>
		    net_ipv4_addr_cmp(&entry->ip, dst)) {
			return entry;
		}

		if (previous) {
  10c748:	85 db                	test   %ebx,%ebx
  10c74a:	74 ea                	je     10c736 <arp_entry_find+0x8>
			*previous = &entry->node;
  10c74c:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10c74e:	eb e6                	jmp    10c736 <arp_entry_find+0x8>
		}
	}

	return NULL;
  10c750:	31 c0                	xor    %eax,%eax
}
  10c752:	5b                   	pop    %ebx
  10c753:	5e                   	pop    %esi
  10c754:	5d                   	pop    %ebp
  10c755:	c3                   	ret    

0010c756 <k_uptime_get_32>:
{
  10c756:	55                   	push   %ebp
  10c757:	89 e5                	mov    %esp,%ebp
	return z_impl_k_uptime_ticks();
  10c759:	e8 29 5c 01 00       	call   122387 <z_impl_k_uptime_ticks>
			return t * (to_hz / from_hz);
  10c75e:	ba 0a 00 00 00       	mov    $0xa,%edx
  10c763:	f7 e2                	mul    %edx
}
  10c765:	5d                   	pop    %ebp
  10c766:	c3                   	ret    

0010c767 <arp_entry_cleanup>:
{
  10c767:	55                   	push   %ebp
	if (pending) {
  10c768:	84 d2                	test   %dl,%dl
{
  10c76a:	89 e5                	mov    %esp,%ebp
  10c76c:	53                   	push   %ebx
  10c76d:	89 c3                	mov    %eax,%ebx
	if (pending) {
  10c76f:	74 10                	je     10c781 <arp_entry_cleanup+0x1a>
		net_pkt_unref(entry->pending);
  10c771:	ff 70 10             	pushl  0x10(%eax)
  10c774:	e8 03 33 00 00       	call   10fa7c <net_pkt_unref>
  10c779:	58                   	pop    %eax
		entry->pending = NULL;
  10c77a:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	entry->iface = NULL;
  10c781:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	(void)memset(&entry->ip, 0, sizeof(struct in_addr));
  10c788:	6a 04                	push   $0x4
  10c78a:	6a 00                	push   $0x0
  10c78c:	8d 43 0c             	lea    0xc(%ebx),%eax
  10c78f:	50                   	push   %eax
  10c790:	e8 c6 f6 ff ff       	call   10be5b <memset>
  10c795:	83 c4 0c             	add    $0xc,%esp
	(void)memset(&entry->eth, 0, sizeof(struct net_eth_addr));
  10c798:	83 c3 10             	add    $0x10,%ebx
  10c79b:	6a 06                	push   $0x6
  10c79d:	6a 00                	push   $0x0
  10c79f:	53                   	push   %ebx
  10c7a0:	e8 b6 f6 ff ff       	call   10be5b <memset>
  10c7a5:	83 c4 0c             	add    $0xc,%esp
}
  10c7a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10c7ab:	c9                   	leave  
  10c7ac:	c3                   	ret    

0010c7ad <if_get_addr.isra.0>:
					  struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	int i;

	if (!ipv4) {
  10c7ad:	85 c0                	test   %eax,%eax
  10c7af:	75 01                	jne    10c7b2 <if_get_addr.isra.0+0x5>
  10c7b1:	c3                   	ret    
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (ipv4->unicast[i].is_used &&
  10c7b2:	f6 40 16 02          	testb  $0x2,0x16(%eax)
  10c7b6:	74 1b                	je     10c7d3 <if_get_addr.isra.0+0x26>
  10c7b8:	66 83 38 01          	cmpw   $0x1,(%eax)
  10c7bc:	75 15                	jne    10c7d3 <if_get_addr.isra.0+0x26>
		    ipv4->unicast[i].address.family == AF_INET &&
  10c7be:	80 78 15 01          	cmpb   $0x1,0x15(%eax)
  10c7c2:	75 0f                	jne    10c7d3 <if_get_addr.isra.0+0x26>
		    ipv4->unicast[i].addr_state == NET_ADDR_PREFERRED &&
  10c7c4:	85 d2                	test   %edx,%edx
  10c7c6:	74 07                	je     10c7cf <if_get_addr.isra.0+0x22>
		    (!addr ||
  10c7c8:	8b 48 04             	mov    0x4(%eax),%ecx
  10c7cb:	39 0a                	cmp    %ecx,(%edx)
  10c7cd:	75 04                	jne    10c7d3 <if_get_addr.isra.0+0x26>
		     net_ipv4_addr_cmp(addr,
				       &ipv4->unicast[i].address.in_addr))) {
			return &ipv4->unicast[i].address.in_addr;
  10c7cf:	83 c0 04             	add    $0x4,%eax
  10c7d2:	c3                   	ret    
		}
	}

	return NULL;
  10c7d3:	31 c0                	xor    %eax,%eax
}
  10c7d5:	c3                   	ret    

0010c7d6 <arp_entry_get_last_from_table>:
	node = sys_slist_peek_tail(&arp_table);
  10c7d6:	8b 0d a4 eb 12 00    	mov    0x12eba4,%ecx
	if (!node) {
  10c7dc:	85 c9                	test   %ecx,%ecx
  10c7de:	74 26                	je     10c806 <arp_entry_get_last_from_table+0x30>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10c7e0:	a1 a0 eb 12 00       	mov    0x12eba0,%eax
  10c7e5:	31 d2                	xor    %edx,%edx
  10c7e7:	85 c0                	test   %eax,%eax
  10c7e9:	74 1b                	je     10c806 <arp_entry_get_last_from_table+0x30>
  10c7eb:	39 c1                	cmp    %eax,%ecx
  10c7ed:	75 11                	jne    10c800 <arp_entry_get_last_from_table+0x2a>
{
  10c7ef:	55                   	push   %ebp
  10c7f0:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
  10c7f5:	89 e5                	mov    %esp,%ebp
  10c7f7:	e8 09 ff ff ff       	call   10c705 <sys_slist_remove>
}
  10c7fc:	5d                   	pop    %ebp
  10c7fd:	89 c8                	mov    %ecx,%eax
  10c7ff:	c3                   	ret    
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10c800:	89 c2                	mov    %eax,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10c802:	8b 00                	mov    (%eax),%eax
  10c804:	eb e1                	jmp    10c7e7 <arp_entry_get_last_from_table+0x11>
  10c806:	89 c8                	mov    %ecx,%eax
  10c808:	c3                   	ret    

0010c809 <arp_request_timeout>:
{
  10c809:	55                   	push   %ebp
  10c80a:	89 e5                	mov    %esp,%ebp
  10c80c:	57                   	push   %edi
  10c80d:	56                   	push   %esi
  10c80e:	53                   	push   %ebx
	uint32_t current = k_uptime_get_32();
  10c80f:	e8 42 ff ff ff       	call   10c756 <k_uptime_get_32>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
  10c814:	8b 1d a8 eb 12 00    	mov    0x12eba8,%ebx
  10c81a:	85 db                	test   %ebx,%ebx
  10c81c:	0f 84 94 00 00 00    	je     10c8b6 <arp_request_timeout+0xad>
  10c822:	89 c7                	mov    %eax,%edi
	return node->next;
  10c824:	8b 33                	mov    (%ebx),%esi
			    ARP_REQUEST_TIMEOUT - current) > 0) {
  10c826:	8b 53 04             	mov    0x4(%ebx),%edx
  10c829:	29 fa                	sub    %edi,%edx
  10c82b:	8d 82 d0 07 00 00    	lea    0x7d0(%edx),%eax
		if ((int32_t)(entry->req_start +
  10c831:	85 c0                	test   %eax,%eax
  10c833:	7f 49                	jg     10c87e <arp_request_timeout+0x75>
		arp_entry_cleanup(entry, true);
  10c835:	ba 01 00 00 00       	mov    $0x1,%edx
  10c83a:	89 d8                	mov    %ebx,%eax
  10c83c:	e8 26 ff ff ff       	call   10c767 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, NULL, &entry->node);
  10c841:	31 d2                	xor    %edx,%edx
  10c843:	b8 a8 eb 12 00       	mov    $0x12eba8,%eax
  10c848:	89 d9                	mov    %ebx,%ecx
  10c84a:	e8 b6 fe ff ff       	call   10c705 <sys_slist_remove>
	parent->next = child;
  10c84f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_APPEND(slist, snode)
  10c855:	a1 b4 eb 12 00       	mov    0x12ebb4,%eax
  10c85a:	85 c0                	test   %eax,%eax
  10c85c:	75 0e                	jne    10c86c <arp_request_timeout+0x63>
	list->tail = node;
  10c85e:	89 1d b4 eb 12 00    	mov    %ebx,0x12ebb4
	list->head = node;
  10c864:	89 1d b0 eb 12 00    	mov    %ebx,0x12ebb0
}
  10c86a:	eb 08                	jmp    10c874 <arp_request_timeout+0x6b>
	parent->next = child;
  10c86c:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10c86e:	89 1d b4 eb 12 00    	mov    %ebx,0x12ebb4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
  10c874:	85 f6                	test   %esi,%esi
  10c876:	74 3e                	je     10c8b6 <arp_request_timeout+0xad>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10c878:	89 f3                	mov    %esi,%ebx
  10c87a:	8b 36                	mov    (%esi),%esi
  10c87c:	eb a8                	jmp    10c826 <arp_request_timeout+0x1d>
				      K_MSEC(entry->req_start +
  10c87e:	81 fa 30 f8 ff ff    	cmp    $0xfffff830,%edx
  10c884:	74 2c                	je     10c8b2 <arp_request_timeout+0xa9>
			return t / (from_hz / to_hz);
  10c886:	6a 00                	push   $0x0
		t += off;
  10c888:	31 d2                	xor    %edx,%edx
  10c88a:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  10c88d:	6a 0a                	push   $0xa
		t += off;
  10c88f:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  10c892:	52                   	push   %edx
  10c893:	50                   	push   %eax
  10c894:	e8 87 39 ff ff       	call   100220 <__udivdi3>
  10c899:	83 c4 10             	add    $0x10,%esp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
  10c89c:	52                   	push   %edx
  10c89d:	50                   	push   %eax
  10c89e:	68 e0 a7 12 00       	push   $0x12a7e0
  10c8a3:	68 00 ea 12 00       	push   $0x12ea00
  10c8a8:	e8 2a 56 01 00       	call   121ed7 <k_delayed_work_submit_to_queue>
  10c8ad:	83 c4 10             	add    $0x10,%esp
}
  10c8b0:	eb 04                	jmp    10c8b6 <arp_request_timeout+0xad>
  10c8b2:	31 c0                	xor    %eax,%eax
  10c8b4:	eb d0                	jmp    10c886 <arp_request_timeout+0x7d>
  10c8b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10c8b9:	5b                   	pop    %ebx
  10c8ba:	5e                   	pop    %esi
  10c8bb:	5f                   	pop    %edi
  10c8bc:	5d                   	pop    %ebp
  10c8bd:	c3                   	ret    

0010c8be <arp_update>:
static void arp_update(struct net_if *iface,
		       struct in_addr *src,
		       struct net_eth_addr *hwaddr,
		       bool gratuitous,
		       bool force)
{
  10c8be:	55                   	push   %ebp
  10c8bf:	89 e5                	mov    %esp,%ebp
  10c8c1:	57                   	push   %edi
  10c8c2:	56                   	push   %esi
  10c8c3:	89 d7                	mov    %edx,%edi
  10c8c5:	53                   	push   %ebx
  10c8c6:	89 c3                	mov    %eax,%ebx
  10c8c8:	83 ec 10             	sub    $0x10,%esp
  10c8cb:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10c8ce:	8b 45 08             	mov    0x8(%ebp),%eax
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
  10c8d1:	89 d1                	mov    %edx,%ecx
{
  10c8d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10c8d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  10c8d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
  10c8dc:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10c8df:	50                   	push   %eax
  10c8e0:	89 da                	mov    %ebx,%edx
  10c8e2:	b8 a8 eb 12 00       	mov    $0x12eba8,%eax
	sys_snode_t *prev = NULL;
  10c8e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	entry = arp_entry_find(&arp_pending_entries, iface, dst, &prev);
  10c8ee:	e8 3b fe ff ff       	call   10c72e <arp_entry_find>
  10c8f3:	5a                   	pop    %edx
  10c8f4:	89 c6                	mov    %eax,%esi
	if (entry) {
  10c8f6:	85 c0                	test   %eax,%eax
  10c8f8:	74 0f                	je     10c909 <arp_update+0x4b>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
  10c8fa:	89 c1                	mov    %eax,%ecx
  10c8fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10c8ff:	b8 a8 eb 12 00       	mov    $0x12eba8,%eax
  10c904:	e8 fc fd ff ff       	call   10c705 <sys_slist_remove>
	if (sys_slist_is_empty(&arp_pending_entries)) {
  10c909:	83 3d a8 eb 12 00 00 	cmpl   $0x0,0x12eba8
  10c910:	75 0b                	jne    10c91d <arp_update+0x5f>
		k_delayed_work_cancel(&arp_request_timer);
  10c912:	68 e0 a7 12 00       	push   $0x12a7e0
  10c917:	e8 42 56 01 00       	call   121f5e <k_delayed_work_cancel>
  10c91c:	58                   	pop    %eax
	struct net_pkt *pkt;

	NET_DBG("src %s", log_strdup(net_sprint_ipv4_addr(src)));

	entry = arp_entry_get_pending(iface, src);
	if (!entry) {
  10c91d:	85 f6                	test   %esi,%esi
  10c91f:	0f 85 c7 00 00 00    	jne    10c9ec <arp_update+0x12e>
		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS) && gratuitous) {
  10c925:	80 7d e8 00          	cmpb   $0x0,-0x18(%ebp)
  10c929:	74 2f                	je     10c95a <arp_update+0x9c>
	entry = arp_entry_find(&arp_table, iface, src, &prev);
  10c92b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10c92e:	89 f9                	mov    %edi,%ecx
  10c930:	50                   	push   %eax
  10c931:	89 da                	mov    %ebx,%edx
  10c933:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
	sys_snode_t *prev = NULL;
  10c938:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	entry = arp_entry_find(&arp_table, iface, src, &prev);
  10c93f:	e8 ea fd ff ff       	call   10c72e <arp_entry_find>
  10c944:	5e                   	pop    %esi
	if (entry) {
  10c945:	85 c0                	test   %eax,%eax
  10c947:	74 11                	je     10c95a <arp_update+0x9c>
		memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
  10c949:	6a 06                	push   $0x6
  10c94b:	83 c0 10             	add    $0x10,%eax
  10c94e:	ff 75 ec             	pushl  -0x14(%ebp)
  10c951:	50                   	push   %eax
  10c952:	e8 95 f4 ff ff       	call   10bdec <memcpy>
  10c957:	83 c4 0c             	add    $0xc,%esp
			arp_gratuitous(iface, src, hwaddr);
		}

		if (force) {
  10c95a:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  10c95e:	0f 84 c5 00 00 00    	je     10ca29 <arp_update+0x16b>
			sys_snode_t *prev = NULL;
			struct arp_entry *entry;

			entry = arp_entry_find(&arp_table, iface, src, &prev);
  10c964:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10c967:	89 f9                	mov    %edi,%ecx
  10c969:	50                   	push   %eax
  10c96a:	89 da                	mov    %ebx,%edx
  10c96c:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
			sys_snode_t *prev = NULL;
  10c971:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			entry = arp_entry_find(&arp_table, iface, src, &prev);
  10c978:	e8 b1 fd ff ff       	call   10c72e <arp_entry_find>
  10c97d:	59                   	pop    %ecx
			if (entry) {
  10c97e:	85 c0                	test   %eax,%eax
  10c980:	74 16                	je     10c998 <arp_update+0xda>
				memcpy(&entry->eth, hwaddr,
  10c982:	6a 06                	push   $0x6
  10c984:	83 c0 10             	add    $0x10,%eax
  10c987:	ff 75 ec             	pushl  -0x14(%ebp)
  10c98a:	50                   	push   %eax
  10c98b:	e8 5c f4 ff ff       	call   10bdec <memcpy>
  10c990:	83 c4 0c             	add    $0xc,%esp
  10c993:	e9 91 00 00 00       	jmp    10ca29 <arp_update+0x16b>
	node = sys_slist_peek_head(&arp_free_entries);
  10c998:	8b 35 b0 eb 12 00    	mov    0x12ebb0,%esi
	if (!node) {
  10c99e:	85 f6                	test   %esi,%esi
  10c9a0:	75 0d                	jne    10c9af <arp_update+0xf1>
				 * was set.
				 */
				entry = arp_entry_get_free();
				if (!entry) {
					/* Then let's take one from table? */
					entry = arp_entry_get_last_from_table();
  10c9a2:	e8 2f fe ff ff       	call   10c7d6 <arp_entry_get_last_from_table>
  10c9a7:	89 c6                	mov    %eax,%esi
				}

				if (entry) {
  10c9a9:	85 c0                	test   %eax,%eax
  10c9ab:	74 7c                	je     10ca29 <arp_update+0x16b>
  10c9ad:	eb 0e                	jmp    10c9bd <arp_update+0xff>
	sys_slist_remove(&arp_free_entries, NULL, node);
  10c9af:	89 f1                	mov    %esi,%ecx
  10c9b1:	31 d2                	xor    %edx,%edx
  10c9b3:	b8 b0 eb 12 00       	mov    $0x12ebb0,%eax
  10c9b8:	e8 48 fd ff ff       	call   10c705 <sys_slist_remove>
					entry->req_start = k_uptime_get_32();
  10c9bd:	e8 94 fd ff ff       	call   10c756 <k_uptime_get_32>
					entry->iface = iface;
  10c9c2:	89 5e 08             	mov    %ebx,0x8(%esi)
					entry->req_start = k_uptime_get_32();
  10c9c5:	89 46 04             	mov    %eax,0x4(%esi)
					net_ipaddr_copy(&entry->ip, src);
  10c9c8:	8b 07                	mov    (%edi),%eax
  10c9ca:	89 46 0c             	mov    %eax,0xc(%esi)
					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
  10c9cd:	6a 06                	push   $0x6
  10c9cf:	ff 75 ec             	pushl  -0x14(%ebp)
  10c9d2:	8d 46 10             	lea    0x10(%esi),%eax
  10c9d5:	50                   	push   %eax
  10c9d6:	e8 11 f4 ff ff       	call   10bdec <memcpy>
  10c9db:	83 c4 0c             	add    $0xc,%esp
					sys_slist_prepend(&arp_table, &entry->node);
  10c9de:	89 f2                	mov    %esi,%edx
  10c9e0:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
  10c9e5:	e8 0b fd ff ff       	call   10c6f5 <sys_slist_prepend>
  10c9ea:	eb 3d                	jmp    10ca29 <arp_update+0x16b>

		return;
	}

	/* Set the dst in the pending packet */
	net_pkt_lladdr_dst(entry->pending)->len = sizeof(struct net_eth_addr);
  10c9ec:	8b 7e 10             	mov    0x10(%esi),%edi
	return pkt->frags->data;
  10c9ef:	8b 47 10             	mov    0x10(%edi),%eax
  10c9f2:	c6 47 34 06          	movb   $0x6,0x34(%edi)
	net_pkt_lladdr_dst(entry->pending)->addr =
  10c9f6:	8b 40 08             	mov    0x8(%eax),%eax
  10c9f9:	89 47 30             	mov    %eax,0x30(%edi)
	NET_DBG("dst %s pending %p frag %p",
		log_strdup(net_sprint_ipv4_addr(&entry->ip)),
		entry->pending, entry->pending->frags);

	pkt = entry->pending;
	entry->pending = NULL;
  10c9fc:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)

	memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
  10ca03:	6a 06                	push   $0x6
  10ca05:	8d 46 10             	lea    0x10(%esi),%eax
  10ca08:	ff 75 ec             	pushl  -0x14(%ebp)
  10ca0b:	50                   	push   %eax
  10ca0c:	e8 db f3 ff ff       	call   10bdec <memcpy>
  10ca11:	83 c4 0c             	add    $0xc,%esp

	/* Inserting entry into the table */
	sys_slist_prepend(&arp_table, &entry->node);
  10ca14:	89 f2                	mov    %esi,%edx
  10ca16:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
  10ca1b:	e8 d5 fc ff ff       	call   10c6f5 <sys_slist_prepend>

	net_if_queue_tx(iface, pkt);
  10ca20:	57                   	push   %edi
  10ca21:	53                   	push   %ebx
  10ca22:	e8 d8 0b 00 00       	call   10d5ff <net_if_queue_tx>
  10ca27:	58                   	pop    %eax
  10ca28:	5a                   	pop    %edx
}
  10ca29:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ca2c:	5b                   	pop    %ebx
  10ca2d:	5e                   	pop    %esi
  10ca2e:	5f                   	pop    %edi
  10ca2f:	5d                   	pop    %ebp
  10ca30:	c3                   	ret    

0010ca31 <net_arp_prepare>:
{
  10ca31:	55                   	push   %ebp
  10ca32:	89 e5                	mov    %esp,%ebp
  10ca34:	57                   	push   %edi
  10ca35:	56                   	push   %esi
  10ca36:	53                   	push   %ebx
  10ca37:	83 ec 0c             	sub    $0xc,%esp
  10ca3a:	8b 7d 08             	mov    0x8(%ebp),%edi
	if (!pkt || !pkt->buffer) {
  10ca3d:	85 ff                	test   %edi,%edi
  10ca3f:	74 5e                	je     10ca9f <net_arp_prepare+0x6e>
  10ca41:	83 7f 10 00          	cmpl   $0x0,0x10(%edi)
  10ca45:	74 58                	je     10ca9f <net_arp_prepare+0x6e>
	if (!current_ip &&
  10ca47:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10ca4b:	75 59                	jne    10caa6 <net_arp_prepare+0x75>
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
  10ca4d:	ff 75 0c             	pushl  0xc(%ebp)
  10ca50:	ff 77 20             	pushl  0x20(%edi)
  10ca53:	e8 52 0c 00 00       	call   10d6aa <net_if_ipv4_addr_mask_cmp>
  10ca58:	5b                   	pop    %ebx
	if (!current_ip &&
  10ca59:	84 c0                	test   %al,%al
	    !net_if_ipv4_addr_mask_cmp(net_pkt_iface(pkt), request_ip)) {
  10ca5b:	5e                   	pop    %esi
	if (!current_ip &&
  10ca5c:	75 48                	jne    10caa6 <net_arp_prepare+0x75>
		struct net_if_ipv4 *ipv4 = net_pkt_iface(pkt)->config.ip.ipv4;
  10ca5e:	8b 57 20             	mov    0x20(%edi),%edx
  10ca61:	8b 42 04             	mov    0x4(%edx),%eax
		if (ipv4) {
  10ca64:	85 c0                	test   %eax,%eax
  10ca66:	74 3e                	je     10caa6 <net_arp_prepare+0x75>
			addr = &ipv4->gw;
  10ca68:	8d 48 30             	lea    0x30(%eax),%ecx
			if (net_ipv4_is_addr_unspecified(addr)) {
  10ca6b:	83 78 30 00          	cmpl   $0x0,0x30(%eax)
			addr = &ipv4->gw;
  10ca6f:	89 4d 0c             	mov    %ecx,0xc(%ebp)
			if (net_ipv4_is_addr_unspecified(addr)) {
  10ca72:	75 32                	jne    10caa6 <net_arp_prepare+0x75>
				NET_ERR("Gateway not set for iface %p",
  10ca74:	f6 05 a4 5b 14 00 07 	testb  $0x7,0x145ba4
  10ca7b:	74 22                	je     10ca9f <net_arp_prepare+0x6e>
  10ca7d:	b8 c8 30 12 00       	mov    $0x1230c8,%eax
  10ca82:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10ca87:	c1 e8 03             	shr    $0x3,%eax
  10ca8a:	c1 e0 06             	shl    $0x6,%eax
  10ca8d:	83 c8 01             	or     $0x1,%eax
  10ca90:	50                   	push   %eax
  10ca91:	52                   	push   %edx
  10ca92:	68 3e 5d 12 00       	push   $0x125d3e
  10ca97:	e8 da 6a ff ff       	call   103576 <log_1>
  10ca9c:	83 c4 0c             	add    $0xc,%esp
				return NULL;
  10ca9f:	31 f6                	xor    %esi,%esi
  10caa1:	e9 f4 01 00 00       	jmp    10cc9a <net_arp_prepare+0x269>
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
  10caa6:	8d 45 f0             	lea    -0x10(%ebp),%eax
	entry = arp_entry_find_move_first(net_pkt_iface(pkt), addr);
  10caa9:	8b 57 20             	mov    0x20(%edi),%edx
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
  10caac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10caaf:	50                   	push   %eax
  10cab0:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
	sys_snode_t *prev = NULL;
  10cab5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	entry = arp_entry_find(&arp_table, iface, dst, &prev);
  10cabc:	e8 6d fc ff ff       	call   10c72e <arp_entry_find>
  10cac1:	59                   	pop    %ecx
  10cac2:	89 c3                	mov    %eax,%ebx
	if (entry) {
  10cac4:	85 c0                	test   %eax,%eax
  10cac6:	74 43                	je     10cb0b <net_arp_prepare+0xda>
		if (&entry->node != sys_slist_peek_head(&arp_table)) {
  10cac8:	3b 05 a0 eb 12 00    	cmp    0x12eba0,%eax
  10cace:	74 1b                	je     10caeb <net_arp_prepare+0xba>
			sys_slist_remove(&arp_table, prev, &entry->node);
  10cad0:	89 c1                	mov    %eax,%ecx
  10cad2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10cad5:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
  10cada:	e8 26 fc ff ff       	call   10c705 <sys_slist_remove>
			sys_slist_prepend(&arp_table, &entry->node);
  10cadf:	89 da                	mov    %ebx,%edx
  10cae1:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
  10cae6:	e8 0a fc ff ff       	call   10c6f5 <sys_slist_prepend>
		(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
  10caeb:	8b 43 08             	mov    0x8(%ebx),%eax
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
  10caee:	83 c3 10             	add    $0x10,%ebx
	return pkt;
  10caf1:	89 fe                	mov    %edi,%esi
		(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
  10caf3:	8b 00                	mov    (%eax),%eax
  10caf5:	8b 40 10             	mov    0x10(%eax),%eax
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
  10caf8:	c6 47 2c 06          	movb   $0x6,0x2c(%edi)
	net_pkt_lladdr_src(pkt)->addr =
  10cafc:	89 47 28             	mov    %eax,0x28(%edi)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&entry->eth;
  10caff:	89 5f 30             	mov    %ebx,0x30(%edi)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
  10cb02:	c6 47 34 06          	movb   $0x6,0x34(%edi)
	return pkt;
  10cb06:	e9 8f 01 00 00       	jmp    10cc9a <net_arp_prepare+0x269>
	return arp_entry_find(&arp_pending_entries, iface, dst, NULL);
  10cb0b:	8b 57 20             	mov    0x20(%edi),%edx
  10cb0e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10cb11:	b8 a8 eb 12 00       	mov    $0x12eba8,%eax
  10cb16:	6a 00                	push   $0x0
  10cb18:	e8 11 fc ff ff       	call   10c72e <arp_entry_find>
  10cb1d:	5a                   	pop    %edx
		if (!entry) {
  10cb1e:	85 c0                	test   %eax,%eax
  10cb20:	75 21                	jne    10cb43 <net_arp_prepare+0x112>
	node = sys_slist_peek_head(&arp_free_entries);
  10cb22:	8b 1d b0 eb 12 00    	mov    0x12ebb0,%ebx
	if (!node) {
  10cb28:	85 db                	test   %ebx,%ebx
  10cb2a:	75 09                	jne    10cb35 <net_arp_prepare+0x104>
				entry = arp_entry_get_last_from_table();
  10cb2c:	e8 a5 fc ff ff       	call   10c7d6 <arp_entry_get_last_from_table>
  10cb31:	89 c3                	mov    %eax,%ebx
  10cb33:	eb 0e                	jmp    10cb43 <net_arp_prepare+0x112>
	sys_slist_remove(&arp_free_entries, NULL, node);
  10cb35:	89 d9                	mov    %ebx,%ecx
  10cb37:	31 d2                	xor    %edx,%edx
  10cb39:	b8 b0 eb 12 00       	mov    $0x12ebb0,%eax
  10cb3e:	e8 c2 fb ff ff       	call   10c705 <sys_slist_remove>
		req = arp_prepare(net_pkt_iface(pkt), addr, entry, pkt,
  10cb43:	8b 47 20             	mov    0x20(%edi),%eax
  10cb46:	89 fe                	mov    %edi,%esi
	if (current_ip) {
  10cb48:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
		req = arp_prepare(net_pkt_iface(pkt), addr, entry, pkt,
  10cb4c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (current_ip) {
  10cb4f:	75 1d                	jne    10cb6e <net_arp_prepare+0x13d>
		pkt = net_pkt_alloc_with_buffer(iface,
  10cb51:	6a 00                	push   $0x0
  10cb53:	6a 0a                	push   $0xa
  10cb55:	6a 00                	push   $0x0
  10cb57:	6a 00                	push   $0x0
  10cb59:	6a 1c                	push   $0x1c
  10cb5b:	50                   	push   %eax
  10cb5c:	e8 75 34 00 00       	call   10ffd6 <net_pkt_alloc_with_buffer>
  10cb61:	83 c4 18             	add    $0x18,%esp
  10cb64:	89 c6                	mov    %eax,%esi
		if (!pkt) {
  10cb66:	85 c0                	test   %eax,%eax
  10cb68:	0f 84 2c 01 00 00    	je     10cc9a <net_arp_prepare+0x269>
	net_buf_add(pkt->buffer, sizeof(struct net_arp_hdr));
  10cb6e:	8b 46 10             	mov    0x10(%esi),%eax
  10cb71:	6a 1c                	push   $0x1c
  10cb73:	83 c0 08             	add    $0x8,%eax
  10cb76:	50                   	push   %eax
  10cb77:	e8 9b f6 ff ff       	call   10c217 <net_buf_simple_add>
  10cb7c:	58                   	pop    %eax
  10cb7d:	8b 46 10             	mov    0x10(%esi),%eax
  10cb80:	5a                   	pop    %edx
	if (entry) {
  10cb81:	85 db                	test   %ebx,%ebx
  10cb83:	8b 40 08             	mov    0x8(%eax),%eax
  10cb86:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10cb89:	74 7a                	je     10cc05 <net_arp_prepare+0x1d4>
		entry->pending = net_pkt_ref(pending);
  10cb8b:	57                   	push   %edi
  10cb8c:	e8 b4 2e 00 00       	call   10fa45 <net_pkt_ref>
  10cb91:	5f                   	pop    %edi
  10cb92:	89 43 10             	mov    %eax,0x10(%ebx)
		entry->iface = net_pkt_iface(pkt);
  10cb95:	8b 46 20             	mov    0x20(%esi),%eax
		net_ipaddr_copy(&entry->ip, next_addr);
  10cb98:	8b 4d 0c             	mov    0xc(%ebp),%ecx
		entry->iface = net_pkt_iface(pkt);
  10cb9b:	89 43 08             	mov    %eax,0x8(%ebx)
			(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
  10cb9e:	8b 00                	mov    (%eax),%eax
		net_ipaddr_copy(&entry->ip, next_addr);
  10cba0:	8b 11                	mov    (%ecx),%edx
  10cba2:	89 53 0c             	mov    %edx,0xc(%ebx)
			(uint8_t *)net_if_get_link_addr(entry->iface)->addr;
  10cba5:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_lladdr_src(pkt)->addr =
  10cba8:	89 46 28             	mov    %eax,0x28(%esi)
	parent->next = child;
  10cbab:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_APPEND(slist, snode)
  10cbb1:	a1 ac eb 12 00       	mov    0x12ebac,%eax
  10cbb6:	85 c0                	test   %eax,%eax
  10cbb8:	75 0e                	jne    10cbc8 <net_arp_prepare+0x197>
	list->tail = node;
  10cbba:	89 1d ac eb 12 00    	mov    %ebx,0x12ebac
	list->head = node;
  10cbc0:	89 1d a8 eb 12 00    	mov    %ebx,0x12eba8
}
  10cbc6:	eb 08                	jmp    10cbd0 <net_arp_prepare+0x19f>
	parent->next = child;
  10cbc8:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  10cbca:	89 1d ac eb 12 00    	mov    %ebx,0x12ebac
	entry->req_start = k_uptime_get_32();
  10cbd0:	e8 81 fb ff ff       	call   10c756 <k_uptime_get_32>
  10cbd5:	89 43 04             	mov    %eax,0x4(%ebx)
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
  10cbd8:	68 ec a7 12 00       	push   $0x12a7ec
  10cbdd:	e8 12 56 01 00       	call   1221f4 <z_timeout_remaining>
  10cbe2:	59                   	pop    %ecx
			return ((uint32_t)t) * (to_hz / from_hz);
  10cbe3:	6b c0 0a             	imul   $0xa,%eax,%eax
	if (!k_delayed_work_remaining_get(&arp_request_timer)) {
  10cbe6:	85 c0                	test   %eax,%eax
  10cbe8:	75 26                	jne    10cc10 <net_arp_prepare+0x1df>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
  10cbea:	6a 00                	push   $0x0
  10cbec:	68 c8 00 00 00       	push   $0xc8
  10cbf1:	68 e0 a7 12 00       	push   $0x12a7e0
  10cbf6:	68 00 ea 12 00       	push   $0x12ea00
  10cbfb:	e8 d7 52 01 00       	call   121ed7 <k_delayed_work_submit_to_queue>
  10cc00:	83 c4 10             	add    $0x10,%esp
  10cc03:	eb 0b                	jmp    10cc10 <net_arp_prepare+0x1df>
			(uint8_t *)net_if_get_link_addr(iface)->addr;
  10cc05:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10cc08:	8b 00                	mov    (%eax),%eax
  10cc0a:	8b 40 10             	mov    0x10(%eax),%eax
		net_pkt_lladdr_src(pkt)->addr =
  10cc0d:	89 46 28             	mov    %eax,0x28(%esi)
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
  10cc10:	c6 46 2c 06          	movb   $0x6,0x2c(%esi)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)net_eth_broadcast_addr();
  10cc14:	e8 ab fa ff ff       	call   10c6c4 <net_eth_broadcast_addr>
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
  10cc19:	c6 46 34 06          	movb   $0x6,0x34(%esi)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)net_eth_broadcast_addr();
  10cc1d:	89 46 30             	mov    %eax,0x30(%esi)
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
  10cc20:	8b 45 ec             	mov    -0x14(%ebp),%eax
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
  10cc23:	83 c0 12             	add    $0x12,%eax
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
  10cc26:	c7 40 ee 00 01 08 00 	movl   $0x80100,-0x12(%eax)
	hdr->hwlen = sizeof(struct net_eth_addr);
  10cc2d:	c7 40 f2 06 04 00 01 	movl   $0x1000406,-0xe(%eax)
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
  10cc34:	6a 06                	push   $0x6
  10cc36:	6a 00                	push   $0x0
  10cc38:	50                   	push   %eax
  10cc39:	e8 1d f2 ff ff       	call   10be5b <memset>
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
  10cc3e:	8b 45 0c             	mov    0xc(%ebp),%eax
	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
  10cc41:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
  10cc44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10cc47:	8b 00                	mov    (%eax),%eax
  10cc49:	89 41 18             	mov    %eax,0x18(%ecx)
	memcpy(hdr->src_hwaddr.addr, net_pkt_lladdr_src(pkt)->addr,
  10cc4c:	6a 06                	push   $0x6
  10cc4e:	ff 76 28             	pushl  0x28(%esi)
  10cc51:	89 c8                	mov    %ecx,%eax
  10cc53:	83 c0 08             	add    $0x8,%eax
  10cc56:	50                   	push   %eax
  10cc57:	e8 90 f1 ff ff       	call   10bdec <memcpy>
  10cc5c:	83 c4 0c             	add    $0xc,%esp
	if (!entry || net_pkt_ipv4_auto(pkt)) {
  10cc5f:	85 db                	test   %ebx,%ebx
  10cc61:	74 11                	je     10cc74 <net_arp_prepare+0x243>
		my_addr = if_get_addr(entry->iface, current_ip);
  10cc63:	8b 43 08             	mov    0x8(%ebx),%eax
  10cc66:	8b 55 10             	mov    0x10(%ebp),%edx
  10cc69:	8b 40 04             	mov    0x4(%eax),%eax
  10cc6c:	e8 3c fb ff ff       	call   10c7ad <if_get_addr.isra.0>
  10cc71:	89 45 10             	mov    %eax,0x10(%ebp)
	if (my_addr) {
  10cc74:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10cc78:	74 0d                	je     10cc87 <net_arp_prepare+0x256>
		net_ipaddr_copy(&hdr->src_ipaddr, my_addr);
  10cc7a:	8b 45 10             	mov    0x10(%ebp),%eax
  10cc7d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10cc80:	8b 00                	mov    (%eax),%eax
  10cc82:	89 41 0e             	mov    %eax,0xe(%ecx)
  10cc85:	eb 13                	jmp    10cc9a <net_arp_prepare+0x269>
		(void)memset(&hdr->src_ipaddr, 0, sizeof(struct in_addr));
  10cc87:	6a 04                	push   $0x4
  10cc89:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10cc8c:	6a 00                	push   $0x0
  10cc8e:	83 c0 0e             	add    $0xe,%eax
  10cc91:	50                   	push   %eax
  10cc92:	e8 c4 f1 ff ff       	call   10be5b <memset>
  10cc97:	83 c4 0c             	add    $0xc,%esp
}
  10cc9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10cc9d:	89 f0                	mov    %esi,%eax
  10cc9f:	5b                   	pop    %ebx
  10cca0:	5e                   	pop    %esi
  10cca1:	5f                   	pop    %edi
  10cca2:	5d                   	pop    %ebp
  10cca3:	c3                   	ret    

0010cca4 <net_arp_input>:
	return true;
}

enum net_verdict net_arp_input(struct net_pkt *pkt,
			       struct net_eth_hdr *eth_hdr)
{
  10cca4:	55                   	push   %ebp
	size_t bytes = 0;
  10cca5:	31 d2                	xor    %edx,%edx
  10cca7:	89 e5                	mov    %esp,%ebp
  10cca9:	57                   	push   %edi
  10ccaa:	56                   	push   %esi
  10ccab:	53                   	push   %ebx
  10ccac:	83 ec 10             	sub    $0x10,%esp
  10ccaf:	8b 75 08             	mov    0x8(%ebp),%esi
	struct net_eth_addr *dst_hw_addr;
	struct net_arp_hdr *arp_hdr;
	struct net_pkt *reply;
	struct in_addr *addr;

	if (net_pkt_get_len(pkt) < (sizeof(struct net_arp_hdr) -
  10ccb2:	8b 4e 10             	mov    0x10(%esi),%ecx
	while (buf) {
  10ccb5:	89 c8                	mov    %ecx,%eax
  10ccb7:	85 c0                	test   %eax,%eax
  10ccb9:	74 0a                	je     10ccc5 <net_arp_input+0x21>
		bytes += buf->len;
  10ccbb:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
		buf = buf->frags;
  10ccbf:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  10ccc1:	01 da                	add    %ebx,%edx
		buf = buf->frags;
  10ccc3:	eb f2                	jmp    10ccb7 <net_arp_input+0x13>
	return pkt->frags->data;
  10ccc5:	8b 79 08             	mov    0x8(%ecx),%edi
  10ccc8:	8b 45 0c             	mov    0xc(%ebp),%eax
  10cccb:	29 f8                	sub    %edi,%eax
  10cccd:	83 c0 1c             	add    $0x1c,%eax
  10ccd0:	39 d0                	cmp    %edx,%eax
  10ccd2:	76 0a                	jbe    10ccde <net_arp_input+0x3a>
				    (net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr))) {
		NET_DBG("Invalid ARP header (len %zu, min %zu bytes) %p",
			net_pkt_get_len(pkt), sizeof(struct net_arp_hdr) -
			(net_pkt_ip_data(pkt) - (uint8_t *)eth_hdr), pkt);
		return NET_DROP;
  10ccd4:	b8 02 00 00 00       	mov    $0x2,%eax
  10ccd9:	e9 34 02 00 00       	jmp    10cf12 <net_arp_input+0x26e>
	if (ntohs(arp_hdr->hwtype) != NET_ARP_HTYPE_ETH ||
  10ccde:	66 81 3f 00 01       	cmpw   $0x100,(%edi)
  10cce3:	75 ef                	jne    10ccd4 <net_arp_input+0x30>
  10cce5:	66 83 7f 02 08       	cmpw   $0x8,0x2(%edi)
  10ccea:	75 e8                	jne    10ccd4 <net_arp_input+0x30>
	    ntohs(arp_hdr->protocol) != NET_ETH_PTYPE_IP ||
  10ccec:	80 7f 04 06          	cmpb   $0x6,0x4(%edi)
  10ccf0:	75 e2                	jne    10ccd4 <net_arp_input+0x30>
	    arp_hdr->hwlen != sizeof(struct net_eth_addr) ||
  10ccf2:	80 7f 05 04          	cmpb   $0x4,0x5(%edi)
  10ccf6:	75 dc                	jne    10ccd4 <net_arp_input+0x30>
	    arp_hdr->protolen != NET_ARP_IPV4_PTYPE_SIZE ||
  10ccf8:	80 7f 0e 7f          	cmpb   $0x7f,0xe(%edi)
  10ccfc:	74 d6                	je     10ccd4 <net_arp_input+0x30>
	arp_hdr = NET_ARP_HDR(pkt);
	if (!arp_hdr_check(arp_hdr)) {
		return NET_DROP;
	}

	switch (ntohs(arp_hdr->opcode)) {
  10ccfe:	66 8b 47 06          	mov    0x6(%edi),%ax
  10cd02:	89 c2                	mov    %eax,%edx
  10cd04:	86 f2                	xchg   %dh,%dl
  10cd06:	66 3d 00 01          	cmp    $0x100,%ax
  10cd0a:	74 0f                	je     10cd1b <net_arp_input+0x77>
  10cd0c:	66 83 fa 02          	cmp    $0x2,%dx
  10cd10:	0f 84 af 01 00 00    	je     10cec5 <net_arp_input+0x221>
  10cd16:	e9 ee 01 00 00       	jmp    10cf09 <net_arp_input+0x265>
	case NET_ARP_REQUEST:
		/* If ARP request sender hw address is our address,
		 * we must drop the packet.
		 */
		if (memcmp(&arp_hdr->src_hwaddr,
  10cd1b:	8d 47 08             	lea    0x8(%edi),%eax
  10cd1e:	6a 06                	push   $0x6
  10cd20:	89 45 f0             	mov    %eax,-0x10(%ebp)
			   net_if_get_link_addr(net_pkt_iface(pkt))->addr,
  10cd23:	8b 46 20             	mov    0x20(%esi),%eax
  10cd26:	8b 00                	mov    (%eax),%eax
		if (memcmp(&arp_hdr->src_hwaddr,
  10cd28:	ff 70 10             	pushl  0x10(%eax)
  10cd2b:	ff 75 f0             	pushl  -0x10(%ebp)
  10cd2e:	e8 4c f0 ff ff       	call   10bd7f <memcmp>
  10cd33:	83 c4 0c             	add    $0xc,%esp
  10cd36:	85 c0                	test   %eax,%eax
  10cd38:	74 9a                	je     10ccd4 <net_arp_input+0x30>
			return NET_DROP;
		}

		if (IS_ENABLED(CONFIG_NET_ARP_GRATUITOUS)) {
			if (memcmp(&eth_hdr->dst,
				   net_eth_broadcast_addr(),
  10cd3a:	e8 85 f9 ff ff       	call   10c6c4 <net_eth_broadcast_addr>
			if (memcmp(&eth_hdr->dst,
  10cd3f:	6a 06                	push   $0x6
  10cd41:	50                   	push   %eax
  10cd42:	ff 75 0c             	pushl  0xc(%ebp)
  10cd45:	e8 35 f0 ff ff       	call   10bd7f <memcmp>
  10cd4a:	83 c4 0c             	add    $0xc,%esp
  10cd4d:	85 c0                	test   %eax,%eax
  10cd4f:	75 43                	jne    10cd94 <net_arp_input+0xf0>
				   sizeof(struct net_eth_addr)) == 0 &&
			    memcmp(&arp_hdr->dst_hwaddr,
				   net_eth_broadcast_addr(),
  10cd51:	e8 6e f9 ff ff       	call   10c6c4 <net_eth_broadcast_addr>
			    memcmp(&arp_hdr->dst_hwaddr,
  10cd56:	6a 06                	push   $0x6
  10cd58:	50                   	push   %eax
  10cd59:	8d 47 12             	lea    0x12(%edi),%eax
  10cd5c:	50                   	push   %eax
  10cd5d:	e8 1d f0 ff ff       	call   10bd7f <memcmp>
  10cd62:	83 c4 0c             	add    $0xc,%esp
				   sizeof(struct net_eth_addr)) == 0 &&
  10cd65:	85 c0                	test   %eax,%eax
  10cd67:	75 2b                	jne    10cd94 <net_arp_input+0xf0>
				   sizeof(struct net_eth_addr)) == 0 &&
			    memcmp(&arp_hdr->dst_ipaddr, &arp_hdr->src_ipaddr,
  10cd69:	8d 57 0e             	lea    0xe(%edi),%edx
  10cd6c:	6a 04                	push   $0x4
  10cd6e:	52                   	push   %edx
  10cd6f:	8d 47 18             	lea    0x18(%edi),%eax
  10cd72:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10cd75:	50                   	push   %eax
  10cd76:	e8 04 f0 ff ff       	call   10bd7f <memcmp>
  10cd7b:	83 c4 0c             	add    $0xc,%esp
				   sizeof(struct net_eth_addr)) == 0 &&
  10cd7e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10cd81:	85 c0                	test   %eax,%eax
  10cd83:	75 0f                	jne    10cd94 <net_arp_input+0xf0>
				   sizeof(struct in_addr)) == 0) {
				/* If the IP address is in our cache,
				 * then update it here.
				 */
				arp_update(net_pkt_iface(pkt),
  10cd85:	8b 46 20             	mov    0x20(%esi),%eax
  10cd88:	6a 00                	push   $0x0
  10cd8a:	6a 01                	push   $0x1
  10cd8c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10cd8f:	e9 5e 01 00 00       	jmp    10cef2 <net_arp_input+0x24e>
		}

		/* Discard ARP request if Ethernet address is broadcast
		 * and Source IP address is Multicast address.
		 */
		if (memcmp(&eth_hdr->dst, net_eth_broadcast_addr(),
  10cd94:	e8 2b f9 ff ff       	call   10c6c4 <net_eth_broadcast_addr>
  10cd99:	6a 06                	push   $0x6
  10cd9b:	50                   	push   %eax
  10cd9c:	ff 75 0c             	pushl  0xc(%ebp)
  10cd9f:	e8 db ef ff ff       	call   10bd7f <memcmp>
  10cda4:	83 c4 0c             	add    $0xc,%esp
  10cda7:	85 c0                	test   %eax,%eax
  10cda9:	75 13                	jne    10cdbe <net_arp_input+0x11a>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  10cdab:	8b 47 0e             	mov    0xe(%edi),%eax
  10cdae:	25 f0 00 00 00       	and    $0xf0,%eax
			   sizeof(struct net_eth_addr)) == 0 &&
  10cdb3:	3d e0 00 00 00       	cmp    $0xe0,%eax
  10cdb8:	0f 84 16 ff ff ff    	je     10ccd4 <net_arp_input+0x30>
			NET_DBG("DROP: eth addr is bcast, src addr is mcast");
			return NET_DROP;
		}

		/* Someone wants to know our ll address */
		addr = if_get_addr(net_pkt_iface(pkt), &arp_hdr->dst_ipaddr);
  10cdbe:	8b 5e 20             	mov    0x20(%esi),%ebx
  10cdc1:	8d 57 18             	lea    0x18(%edi),%edx
  10cdc4:	8b 43 04             	mov    0x4(%ebx),%eax
  10cdc7:	e8 e1 f9 ff ff       	call   10c7ad <if_get_addr.isra.0>
		if (!addr) {
  10cdcc:	85 c0                	test   %eax,%eax
  10cdce:	0f 84 00 ff ff ff    	je     10ccd4 <net_arp_input+0x30>
	if (addr->addr[0] == 0x00 &&
  10cdd4:	80 7f 12 00          	cmpb   $0x0,0x12(%edi)
  10cdd8:	75 33                	jne    10ce0d <net_arp_input+0x169>
  10cdda:	80 7f 13 00          	cmpb   $0x0,0x13(%edi)
  10cdde:	75 2d                	jne    10ce0d <net_arp_input+0x169>
	    addr->addr[1] == 0x00 &&
  10cde0:	80 7f 14 00          	cmpb   $0x0,0x14(%edi)
  10cde4:	75 27                	jne    10ce0d <net_arp_input+0x169>
	    addr->addr[2] == 0x00 &&
  10cde6:	80 7f 15 00          	cmpb   $0x0,0x15(%edi)
  10cdea:	75 21                	jne    10ce0d <net_arp_input+0x169>
	    addr->addr[3] == 0x00 &&
  10cdec:	80 7f 16 00          	cmpb   $0x0,0x16(%edi)
  10cdf0:	75 1b                	jne    10ce0d <net_arp_input+0x169>
	    addr->addr[4] == 0x00 &&
  10cdf2:	80 7f 17 00          	cmpb   $0x0,0x17(%edi)
  10cdf6:	75 15                	jne    10ce0d <net_arp_input+0x169>
						 &arp_hdr->src_ipaddr)),
				log_strdup(net_sprint_ll_addr(
						 (uint8_t *)&arp_hdr->src_hwaddr,
						 arp_hdr->hwlen)));

			arp_update(net_pkt_iface(pkt),
  10cdf8:	6a 01                	push   $0x1
  10cdfa:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10cdfd:	6a 00                	push   $0x0
  10cdff:	89 d8                	mov    %ebx,%eax
  10ce01:	8d 57 0e             	lea    0xe(%edi),%edx
  10ce04:	e8 b5 fa ff ff       	call   10c8be <arp_update>
  10ce09:	59                   	pop    %ecx
  10ce0a:	5b                   	pop    %ebx
				   &arp_hdr->src_ipaddr,
				   &arp_hdr->src_hwaddr,
				   false, true);

			dst_hw_addr = &arp_hdr->src_hwaddr;
  10ce0b:	eb 09                	jmp    10ce16 <net_arp_input+0x172>
		} else {
			dst_hw_addr = &eth_hdr->src;
  10ce0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ce10:	83 c0 06             	add    $0x6,%eax
  10ce13:	89 45 f0             	mov    %eax,-0x10(%ebp)
		}

		/* Send reply */
		reply = arp_prepare_reply(net_pkt_iface(pkt), pkt, eth_hdr,
  10ce16:	8b 7e 20             	mov    0x20(%esi),%edi
	pkt = net_pkt_alloc_with_buffer(iface, sizeof(struct net_arp_hdr),
  10ce19:	6a 00                	push   $0x0
  10ce1b:	6a 0a                	push   $0xa
  10ce1d:	6a 00                	push   $0x0
  10ce1f:	6a 00                	push   $0x0
  10ce21:	6a 1c                	push   $0x1c
  10ce23:	57                   	push   %edi
  10ce24:	e8 ad 31 00 00       	call   10ffd6 <net_pkt_alloc_with_buffer>
  10ce29:	83 c4 18             	add    $0x18,%esp
  10ce2c:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
  10ce2e:	85 c0                	test   %eax,%eax
  10ce30:	0f 84 d3 00 00 00    	je     10cf09 <net_arp_input+0x265>
	net_buf_add(pkt->buffer, sizeof(struct net_arp_hdr));
  10ce36:	8b 40 10             	mov    0x10(%eax),%eax
  10ce39:	6a 1c                	push   $0x1c
  10ce3b:	83 c0 08             	add    $0x8,%eax
  10ce3e:	50                   	push   %eax
  10ce3f:	e8 d3 f3 ff ff       	call   10c217 <net_buf_simple_add>
  10ce44:	58                   	pop    %eax
	return pkt->frags->data;
  10ce45:	8b 43 10             	mov    0x10(%ebx),%eax
  10ce48:	5a                   	pop    %edx
  10ce49:	8b 50 08             	mov    0x8(%eax),%edx
  10ce4c:	8b 46 10             	mov    0x10(%esi),%eax
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
  10ce4f:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10ce52:	8b 48 08             	mov    0x8(%eax),%ecx
	hdr->hwtype = htons(NET_ARP_HTYPE_ETH);
  10ce55:	c7 02 00 01 08 00    	movl   $0x80100,(%edx)
	hdr->hwlen = sizeof(struct net_eth_addr);
  10ce5b:	c7 42 04 06 04 00 02 	movl   $0x2000406,0x4(%edx)
	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
  10ce62:	6a 06                	push   $0x6
  10ce64:	ff 75 f0             	pushl  -0x10(%ebp)
  10ce67:	8d 42 12             	lea    0x12(%edx),%eax
  10ce6a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10ce6d:	50                   	push   %eax
  10ce6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ce71:	e8 76 ef ff ff       	call   10bdec <memcpy>
  10ce76:	83 c4 0c             	add    $0xc,%esp
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
  10ce79:	8b 07                	mov    (%edi),%eax
  10ce7b:	6a 06                	push   $0x6
  10ce7d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10ce80:	ff 70 10             	pushl  0x10(%eax)
  10ce83:	8d 42 08             	lea    0x8(%edx),%eax
  10ce86:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10ce89:	50                   	push   %eax
  10ce8a:	e8 5d ef ff ff       	call   10bdec <memcpy>
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
  10ce8f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10ce92:	8b 55 f0             	mov    -0x10(%ebp),%edx
	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
  10ce95:	83 c4 0c             	add    $0xc,%esp
	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
  10ce98:	8b 41 0e             	mov    0xe(%ecx),%eax
  10ce9b:	89 42 18             	mov    %eax,0x18(%edx)
	net_ipaddr_copy(&hdr->src_ipaddr, &query->dst_ipaddr);
  10ce9e:	8b 41 18             	mov    0x18(%ecx),%eax
  10cea1:	89 42 0e             	mov    %eax,0xe(%edx)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
  10cea4:	8b 07                	mov    (%edi),%eax
  10cea6:	8b 40 10             	mov    0x10(%eax),%eax
	net_pkt_lladdr_src(pkt)->len = sizeof(struct net_eth_addr);
  10cea9:	c6 43 2c 06          	movb   $0x6,0x2c(%ebx)
	net_pkt_lladdr_src(pkt)->addr = net_if_get_link_addr(iface)->addr;
  10cead:	89 43 28             	mov    %eax,0x28(%ebx)
	net_pkt_lladdr_dst(pkt)->addr = (uint8_t *)&hdr->dst_hwaddr.addr;
  10ceb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10ceb3:	89 43 30             	mov    %eax,0x30(%ebx)
	net_pkt_lladdr_dst(pkt)->len = sizeof(struct net_eth_addr);
  10ceb6:	c6 43 34 06          	movb   $0x6,0x34(%ebx)
					  dst_hw_addr);
		if (reply) {
			net_if_queue_tx(net_pkt_iface(reply), reply);
  10ceba:	53                   	push   %ebx
  10cebb:	ff 73 20             	pushl  0x20(%ebx)
  10cebe:	e8 3c 07 00 00       	call   10d5ff <net_if_queue_tx>
  10cec3:	eb 32                	jmp    10cef7 <net_arp_input+0x253>
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
  10cec5:	6a 00                	push   $0x0
			NET_DBG("Cannot send ARP reply");
		}
		break;

	case NET_ARP_REPLY:
		if (net_ipv4_is_my_addr(&arp_hdr->dst_ipaddr)) {
  10cec7:	8d 5f 18             	lea    0x18(%edi),%ebx
  10ceca:	53                   	push   %ebx
  10cecb:	e8 a1 09 00 00       	call   10d871 <net_if_ipv4_addr_lookup>
  10ced0:	5a                   	pop    %edx
  10ced1:	85 c0                	test   %eax,%eax
  10ced3:	59                   	pop    %ecx
  10ced4:	0f 95 c0             	setne  %al
	if (!ret) {
  10ced7:	75 2c                	jne    10cf05 <net_arp_input+0x261>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  10ced9:	e8 7b 16 00 00       	call   10e559 <net_ipv4_broadcast_address>
  10cede:	8b 00                	mov    (%eax),%eax
  10cee0:	39 47 18             	cmp    %eax,0x18(%edi)
  10cee3:	75 16                	jne    10cefb <net_arp_input+0x257>
			arp_update(net_pkt_iface(pkt),
  10cee5:	8b 46 20             	mov    0x20(%esi),%eax
  10cee8:	6a 00                	push   $0x0
  10ceea:	8d 4f 08             	lea    0x8(%edi),%ecx
  10ceed:	8d 57 0e             	lea    0xe(%edi),%edx
  10cef0:	6a 00                	push   $0x0
  10cef2:	e8 c7 f9 ff ff       	call   10c8be <arp_update>
  10cef7:	5b                   	pop    %ebx
  10cef8:	5f                   	pop    %edi
  10cef9:	eb 0e                	jmp    10cf09 <net_arp_input+0x265>
	return net_if_ipv4_is_addr_bcast(iface, addr);
  10cefb:	53                   	push   %ebx
  10cefc:	6a 00                	push   $0x0
  10cefe:	e8 11 08 00 00       	call   10d714 <net_if_ipv4_is_addr_bcast>
  10cf03:	5a                   	pop    %edx
  10cf04:	59                   	pop    %ecx
		if (net_ipv4_is_my_addr(&arp_hdr->dst_ipaddr)) {
  10cf05:	84 c0                	test   %al,%al
  10cf07:	75 dc                	jne    10cee5 <net_arp_input+0x241>
		}

		break;
	}

	net_pkt_unref(pkt);
  10cf09:	56                   	push   %esi
  10cf0a:	e8 6d 2b 00 00       	call   10fa7c <net_pkt_unref>
  10cf0f:	58                   	pop    %eax

	return NET_OK;
  10cf10:	31 c0                	xor    %eax,%eax
}
  10cf12:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10cf15:	5b                   	pop    %ebx
  10cf16:	5e                   	pop    %esi
  10cf17:	5f                   	pop    %edi
  10cf18:	5d                   	pop    %ebp
  10cf19:	c3                   	ret    

0010cf1a <net_arp_clear_cache>:

void net_arp_clear_cache(struct net_if *iface)
{
  10cf1a:	55                   	push   %ebp
  10cf1b:	89 e5                	mov    %esp,%ebp
  10cf1d:	57                   	push   %edi
  10cf1e:	56                   	push   %esi
  10cf1f:	53                   	push   %ebx
  10cf20:	51                   	push   %ecx
	sys_snode_t *prev = NULL;
	struct arp_entry *entry, *next;

	NET_DBG("Flushing ARP table");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
  10cf21:	8b 3d a0 eb 12 00    	mov    0x12eba0,%edi
{
  10cf27:	8b 75 08             	mov    0x8(%ebp),%esi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
  10cf2a:	85 ff                	test   %edi,%edi
  10cf2c:	75 0c                	jne    10cf3a <net_arp_clear_cache+0x20>

	prev = NULL;

	NET_DBG("Flushing ARP pending requests");

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
  10cf2e:	8b 3d a8 eb 12 00    	mov    0x12eba8,%edi
  10cf34:	85 ff                	test   %edi,%edi
  10cf36:	75 5b                	jne    10cf93 <net_arp_clear_cache+0x79>
  10cf38:	eb 48                	jmp    10cf82 <net_arp_clear_cache+0x68>
	return node->next;
  10cf3a:	8b 1f                	mov    (%edi),%ebx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10cf3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (iface && iface != entry->iface) {
  10cf43:	89 f8                	mov    %edi,%eax
  10cf45:	85 f6                	test   %esi,%esi
  10cf47:	74 05                	je     10cf4e <net_arp_clear_cache+0x34>
  10cf49:	3b 77 08             	cmp    0x8(%edi),%esi
  10cf4c:	75 27                	jne    10cf75 <net_arp_clear_cache+0x5b>
		arp_entry_cleanup(entry, false);
  10cf4e:	31 d2                	xor    %edx,%edx
  10cf50:	89 f8                	mov    %edi,%eax
  10cf52:	e8 10 f8 ff ff       	call   10c767 <arp_entry_cleanup>
		sys_slist_remove(&arp_table, prev, &entry->node);
  10cf57:	89 f9                	mov    %edi,%ecx
  10cf59:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10cf5c:	b8 a0 eb 12 00       	mov    $0x12eba0,%eax
  10cf61:	e8 9f f7 ff ff       	call   10c705 <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
  10cf66:	b8 b0 eb 12 00       	mov    $0x12ebb0,%eax
  10cf6b:	89 fa                	mov    %edi,%edx
  10cf6d:	e8 83 f7 ff ff       	call   10c6f5 <sys_slist_prepend>
  10cf72:	8b 45 f0             	mov    -0x10(%ebp),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_table, entry, next, node) {
  10cf75:	85 db                	test   %ebx,%ebx
  10cf77:	74 b5                	je     10cf2e <net_arp_clear_cache+0x14>
  10cf79:	89 df                	mov    %ebx,%edi
  10cf7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10cf7e:	8b 1b                	mov    (%ebx),%ebx
  10cf80:	eb c1                	jmp    10cf43 <net_arp_clear_cache+0x29>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
		sys_slist_prepend(&arp_free_entries, &entry->node);
	}

	if (sys_slist_is_empty(&arp_pending_entries)) {
		k_delayed_work_cancel(&arp_request_timer);
  10cf82:	c7 45 08 e0 a7 12 00 	movl   $0x12a7e0,0x8(%ebp)
	}
}
  10cf89:	5a                   	pop    %edx
  10cf8a:	5b                   	pop    %ebx
  10cf8b:	5e                   	pop    %esi
  10cf8c:	5f                   	pop    %edi
  10cf8d:	5d                   	pop    %ebp
		k_delayed_work_cancel(&arp_request_timer);
  10cf8e:	e9 cb 4f 01 00       	jmp    121f5e <k_delayed_work_cancel>
	return node->next;
  10cf93:	8b 1f                	mov    (%edi),%ebx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10cf95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (iface && iface != entry->iface) {
  10cf9c:	89 f8                	mov    %edi,%eax
  10cf9e:	85 f6                	test   %esi,%esi
  10cfa0:	74 05                	je     10cfa7 <net_arp_clear_cache+0x8d>
  10cfa2:	3b 77 08             	cmp    0x8(%edi),%esi
  10cfa5:	75 2a                	jne    10cfd1 <net_arp_clear_cache+0xb7>
		arp_entry_cleanup(entry, true);
  10cfa7:	ba 01 00 00 00       	mov    $0x1,%edx
  10cfac:	89 f8                	mov    %edi,%eax
  10cfae:	e8 b4 f7 ff ff       	call   10c767 <arp_entry_cleanup>
		sys_slist_remove(&arp_pending_entries, prev, &entry->node);
  10cfb3:	89 f9                	mov    %edi,%ecx
  10cfb5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10cfb8:	b8 a8 eb 12 00       	mov    $0x12eba8,%eax
  10cfbd:	e8 43 f7 ff ff       	call   10c705 <sys_slist_remove>
		sys_slist_prepend(&arp_free_entries, &entry->node);
  10cfc2:	b8 b0 eb 12 00       	mov    $0x12ebb0,%eax
  10cfc7:	89 fa                	mov    %edi,%edx
  10cfc9:	e8 27 f7 ff ff       	call   10c6f5 <sys_slist_prepend>
  10cfce:	8b 45 f0             	mov    -0x10(%ebp),%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&arp_pending_entries,
  10cfd1:	85 db                	test   %ebx,%ebx
  10cfd3:	74 09                	je     10cfde <net_arp_clear_cache+0xc4>
  10cfd5:	89 df                	mov    %ebx,%edi
  10cfd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10cfda:	8b 1b                	mov    (%ebx),%ebx
  10cfdc:	eb be                	jmp    10cf9c <net_arp_clear_cache+0x82>
	if (sys_slist_is_empty(&arp_pending_entries)) {
  10cfde:	83 3d a8 eb 12 00 00 	cmpl   $0x0,0x12eba8
  10cfe5:	74 9b                	je     10cf82 <net_arp_clear_cache+0x68>
}
  10cfe7:	58                   	pop    %eax
  10cfe8:	5b                   	pop    %ebx
  10cfe9:	5e                   	pop    %esi
  10cfea:	5f                   	pop    %edi
  10cfeb:	5d                   	pop    %ebp
  10cfec:	c3                   	ret    

0010cfed <net_arp_foreach>:

int net_arp_foreach(net_arp_cb_t cb, void *user_data)
{
  10cfed:	55                   	push   %ebp
	int ret = 0;
	struct arp_entry *entry;

	SYS_SLIST_FOR_EACH_CONTAINER(&arp_table, entry, node) {
  10cfee:	31 c0                	xor    %eax,%eax
{
  10cff0:	89 e5                	mov    %esp,%ebp
  10cff2:	53                   	push   %ebx
  10cff3:	51                   	push   %ecx
  10cff4:	8b 1d a0 eb 12 00    	mov    0x12eba0,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&arp_table, entry, node) {
  10cffa:	85 db                	test   %ebx,%ebx
  10cffc:	74 14                	je     10d012 <net_arp_foreach+0x25>
		ret++;
		cb(entry, user_data);
  10cffe:	ff 75 0c             	pushl  0xc(%ebp)
		ret++;
  10d001:	40                   	inc    %eax
		cb(entry, user_data);
  10d002:	53                   	push   %ebx
		ret++;
  10d003:	89 45 f8             	mov    %eax,-0x8(%ebp)
		cb(entry, user_data);
  10d006:	ff 55 08             	call   *0x8(%ebp)
  10d009:	58                   	pop    %eax
  10d00a:	5a                   	pop    %edx
  10d00b:	8b 1b                	mov    (%ebx),%ebx
  10d00d:	8b 45 f8             	mov    -0x8(%ebp),%eax
	return node->next;
  10d010:	eb e8                	jmp    10cffa <net_arp_foreach+0xd>
	}

	return ret;
}
  10d012:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10d015:	c9                   	leave  
  10d016:	c3                   	ret    

0010d017 <net_arp_init>:

void net_arp_init(void)
{
	int i;

	if (arp_cache_initialized) {
  10d017:	80 3d 78 ed 12 00 00 	cmpb   $0x0,0x12ed78
  10d01e:	75 77                	jne    10d097 <net_arp_init+0x80>
{
  10d020:	55                   	push   %ebp
	sys_slist_init(&arp_pending_entries);
	sys_slist_init(&arp_table);

	for (i = 0; i < CONFIG_NET_ARP_TABLE_SIZE; i++) {
		/* Inserting entry as free */
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
  10d021:	ba 20 a8 12 00       	mov    $0x12a820,%edx
{
  10d026:	89 e5                	mov    %esp,%ebp
		sys_slist_prepend(&arp_free_entries, &arp_entries[i].node);
  10d028:	b8 b0 eb 12 00       	mov    $0x12ebb0,%eax
	list->head = NULL;
  10d02d:	c7 05 b0 eb 12 00 00 	movl   $0x0,0x12ebb0
  10d034:	00 00 00 
	list->tail = NULL;
  10d037:	c7 05 b4 eb 12 00 00 	movl   $0x0,0x12ebb4
  10d03e:	00 00 00 
	list->head = NULL;
  10d041:	c7 05 a8 eb 12 00 00 	movl   $0x0,0x12eba8
  10d048:	00 00 00 
	list->tail = NULL;
  10d04b:	c7 05 ac eb 12 00 00 	movl   $0x0,0x12ebac
  10d052:	00 00 00 
	list->head = NULL;
  10d055:	c7 05 a0 eb 12 00 00 	movl   $0x0,0x12eba0
  10d05c:	00 00 00 
	list->tail = NULL;
  10d05f:	c7 05 a4 eb 12 00 00 	movl   $0x0,0x12eba4
  10d066:	00 00 00 
  10d069:	e8 87 f6 ff ff       	call   10c6f5 <sys_slist_prepend>
  10d06e:	ba 38 a8 12 00       	mov    $0x12a838,%edx
  10d073:	b8 b0 eb 12 00       	mov    $0x12ebb0,%eax
  10d078:	e8 78 f6 ff ff       	call   10c6f5 <sys_slist_prepend>
	}

	k_delayed_work_init(&arp_request_timer, arp_request_timeout);
  10d07d:	68 09 c8 10 00       	push   $0x10c809
  10d082:	68 e0 a7 12 00       	push   $0x12a7e0
  10d087:	e8 1b 4e 01 00       	call   121ea7 <k_delayed_work_init>
  10d08c:	58                   	pop    %eax

	arp_cache_initialized = true;
  10d08d:	c6 05 78 ed 12 00 01 	movb   $0x1,0x12ed78
	k_delayed_work_init(&arp_request_timer, arp_request_timeout);
  10d094:	5a                   	pop    %edx
}
  10d095:	c9                   	leave  
  10d096:	c3                   	ret    
  10d097:	c3                   	ret    

0010d098 <processing_data>:

	return NET_DROP;
}

static void processing_data(struct net_pkt *pkt, bool is_loopback)
{
  10d098:	55                   	push   %ebp
  10d099:	89 e5                	mov    %esp,%ebp
  10d09b:	53                   	push   %ebx
	if (!pkt->frags) {
  10d09c:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
{
  10d0a0:	89 c3                	mov    %eax,%ebx
	if (!pkt->frags) {
  10d0a2:	75 09                	jne    10d0ad <processing_data+0x15>
		NET_DBG("Consumed pkt %p", pkt);
		break;
	case NET_DROP:
	default:
		NET_DBG("Dropping pkt %p", pkt);
		net_pkt_unref(pkt);
  10d0a4:	53                   	push   %ebx
  10d0a5:	e8 d2 29 00 00       	call   10fa7c <net_pkt_unref>
  10d0aa:	5b                   	pop    %ebx
		break;
  10d0ab:	eb 37                	jmp    10d0e4 <processing_data+0x4c>
	if (!is_loopback && !locally_routed) {
  10d0ad:	84 d2                	test   %dl,%dl
  10d0af:	74 1f                	je     10d0d0 <processing_data+0x38>
	net_pkt_cursor_init(pkt);
  10d0b1:	53                   	push   %ebx
  10d0b2:	e8 33 2b 00 00       	call   10fbea <net_pkt_cursor_init>
	return pkt->frags->data;
  10d0b7:	8b 43 10             	mov    0x10(%ebx),%eax
  10d0ba:	59                   	pop    %ecx
	switch (NET_IPV6_HDR(pkt)->vtc & 0xf0) {
  10d0bb:	8b 40 08             	mov    0x8(%eax),%eax
  10d0be:	8a 00                	mov    (%eax),%al
  10d0c0:	83 e0 f0             	and    $0xfffffff0,%eax
  10d0c3:	3c 40                	cmp    $0x40,%al
  10d0c5:	75 dd                	jne    10d0a4 <processing_data+0xc>
		return net_ipv4_input(pkt);
  10d0c7:	53                   	push   %ebx
  10d0c8:	e8 e2 3b 00 00       	call   110caf <net_ipv4_input>
  10d0cd:	5a                   	pop    %edx
  10d0ce:	eb 10                	jmp    10d0e0 <processing_data+0x48>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
  10d0d0:	50                   	push   %eax
  10d0d1:	ff 70 20             	pushl  0x20(%eax)
  10d0d4:	e8 f4 08 00 00       	call   10d9cd <net_if_recv_data>
  10d0d9:	59                   	pop    %ecx
		if (ret != NET_CONTINUE) {
  10d0da:	83 f8 01             	cmp    $0x1,%eax
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
  10d0dd:	5a                   	pop    %edx
		if (ret != NET_CONTINUE) {
  10d0de:	74 d1                	je     10d0b1 <processing_data+0x19>
	switch (process_data(pkt, is_loopback)) {
  10d0e0:	85 c0                	test   %eax,%eax
  10d0e2:	75 c0                	jne    10d0a4 <processing_data+0xc>
	}
}
  10d0e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10d0e7:	c9                   	leave  
  10d0e8:	c3                   	ret    

0010d0e9 <net_init>:

	return status;
}

static int net_init(const struct device *unused)
{
  10d0e9:	55                   	push   %ebp
  10d0ea:	89 e5                	mov    %esp,%ebp
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
  10d0ec:	e8 0f 34 00 00       	call   110500 <net_pkt_init>

	net_context_init();
  10d0f1:	e8 90 26 00 00       	call   10f786 <net_context_init>
	net_icmpv4_init();
  10d0f6:	e8 3c 3a 00 00       	call   110b37 <net_icmpv4_init>
		net_conn_init();
  10d0fb:	e8 6f 43 00 00       	call   11146f <net_conn_init>
	net_tcp_init();
  10d100:	e8 75 63 00 00       	call   11347a <net_tcp_init>

	l3_init();

	net_mgmt_event_init();
  10d105:	e8 b0 17 00 00       	call   10e8ba <net_mgmt_event_init>
	net_if_init();
  10d10a:	e8 ce 0b 00 00       	call   10dcdd <net_if_init>
	net_tc_rx_init();
  10d10f:	e8 c8 34 00 00       	call   1105dc <net_tc_rx_init>
	net_if_post_init();
  10d114:	e8 d0 0c 00 00       	call   10dde9 <net_if_post_init>
	net_coap_init();
  10d119:	e8 2c c0 ff ff       	call   10914a <net_coap_init>
	net_shell_init();
  10d11e:	e8 6f 79 00 00       	call   114a92 <net_shell_init>

	init_rx_queues();

	return services_init();
}
  10d123:	31 c0                	xor    %eax,%eax
  10d125:	5d                   	pop    %ebp
  10d126:	c3                   	ret    

0010d127 <process_rx_packet>:
{
  10d127:	55                   	push   %ebp
  10d128:	89 e5                	mov    %esp,%ebp
  10d12a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	pkt_len = net_pkt_get_len(pkt);
  10d12d:	8b 41 10             	mov    0x10(%ecx),%eax
	while (buf) {
  10d130:	85 c0                	test   %eax,%eax
  10d132:	74 04                	je     10d138 <process_rx_packet+0x11>
		buf = buf->frags;
  10d134:	8b 00                	mov    (%eax),%eax
  10d136:	eb f8                	jmp    10d130 <process_rx_packet+0x9>
	processing_data(pkt, is_loopback);
  10d138:	31 d2                	xor    %edx,%edx
  10d13a:	89 c8                	mov    %ecx,%eax
}
  10d13c:	5d                   	pop    %ebp
	processing_data(pkt, is_loopback);
  10d13d:	e9 56 ff ff ff       	jmp    10d098 <processing_data>

0010d142 <net_send_data>:
{
  10d142:	55                   	push   %ebp
		return -ENODATA;
  10d143:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
{
  10d148:	89 e5                	mov    %esp,%ebp
  10d14a:	57                   	push   %edi
  10d14b:	56                   	push   %esi
  10d14c:	53                   	push   %ebx
  10d14d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!pkt || !pkt->frags) {
  10d150:	85 db                	test   %ebx,%ebx
  10d152:	0f 84 f7 00 00 00    	je     10d24f <net_send_data+0x10d>
  10d158:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  10d15c:	0f 84 ed 00 00 00    	je     10d24f <net_send_data+0x10d>
	if (!net_pkt_iface(pkt)) {
  10d162:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
		return -EINVAL;
  10d166:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!net_pkt_iface(pkt)) {
  10d16b:	0f 84 de 00 00 00    	je     10d24f <net_send_data+0x10d>
	net_pkt_trim_buffer(pkt);
  10d171:	53                   	push   %ebx
  10d172:	e8 2b 2a 00 00       	call   10fba2 <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
  10d177:	89 1c 24             	mov    %ebx,(%esp)
  10d17a:	e8 6b 2a 00 00       	call   10fbea <net_pkt_cursor_init>
  10d17f:	58                   	pop    %eax
	return pkt->family;
  10d180:	8a 43 3f             	mov    0x3f(%ebx),%al
  10d183:	d0 e8                	shr    %al
  10d185:	83 e0 07             	and    $0x7,%eax
	if (net_pkt_family(pkt) == AF_INET) {
  10d188:	fe c8                	dec    %al
  10d18a:	0f 85 a7 00 00 00    	jne    10d237 <net_send_data+0xf5>
		if (net_ipv4_addr_cmp(&NET_IPV4_HDR(pkt)->dst,
  10d190:	e8 be 13 00 00       	call   10e553 <net_ipv4_unspecified_address>
	return pkt->frags->data;
  10d195:	8b 53 10             	mov    0x10(%ebx),%edx
  10d198:	8b 72 08             	mov    0x8(%edx),%esi
  10d19b:	8b 00                	mov    (%eax),%eax
  10d19d:	39 46 10             	cmp    %eax,0x10(%esi)
  10d1a0:	75 0a                	jne    10d1ac <net_send_data+0x6a>
			return -EADDRNOTAVAIL;
  10d1a2:	b8 cf ff ff ff       	mov    $0xffffffcf,%eax
  10d1a7:	e9 a3 00 00 00       	jmp    10d24f <net_send_data+0x10d>
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
  10d1ac:	80 7e 10 7f          	cmpb   $0x7f,0x10(%esi)
  10d1b0:	75 22                	jne    10d1d4 <net_send_data+0x92>
  10d1b2:	8b 43 10             	mov    0x10(%ebx),%eax
  10d1b5:	8b 40 08             	mov    0x8(%eax),%eax
			net_ipaddr_copy(&addr, &NET_IPV4_HDR(pkt)->src);
  10d1b8:	8b 50 0c             	mov    0xc(%eax),%edx
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src,
  10d1bb:	8b 48 10             	mov    0x10(%eax),%ecx
  10d1be:	89 48 0c             	mov    %ecx,0xc(%eax)
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
  10d1c1:	89 50 10             	mov    %edx,0x10(%eax)
		processing_data(pkt, true);
  10d1c4:	89 d8                	mov    %ebx,%eax
  10d1c6:	ba 01 00 00 00       	mov    $0x1,%edx
  10d1cb:	e8 c8 fe ff ff       	call   10d098 <processing_data>
		return 0;
  10d1d0:	31 c0                	xor    %eax,%eax
  10d1d2:	eb 7b                	jmp    10d24f <net_send_data+0x10d>
		    (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
  10d1d4:	8b 7b 20             	mov    0x20(%ebx),%edi
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  10d1d7:	e8 7d 13 00 00       	call   10e559 <net_ipv4_broadcast_address>
  10d1dc:	8b 00                	mov    (%eax),%eax
  10d1de:	39 46 10             	cmp    %eax,0x10(%esi)
  10d1e1:	74 44                	je     10d227 <net_send_data+0xe5>
				     &NET_IPV4_HDR(pkt)->dst) == false &&
  10d1e3:	83 c6 10             	add    $0x10,%esi
	return net_if_ipv4_is_addr_bcast(iface, addr);
  10d1e6:	56                   	push   %esi
  10d1e7:	57                   	push   %edi
  10d1e8:	e8 27 05 00 00       	call   10d714 <net_if_ipv4_is_addr_bcast>
  10d1ed:	5e                   	pop    %esi
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
  10d1ee:	84 c0                	test   %al,%al
  10d1f0:	5f                   	pop    %edi
  10d1f1:	75 34                	jne    10d227 <net_send_data+0xe5>
  10d1f3:	8b 43 10             	mov    0x10(%ebx),%eax
  10d1f6:	8b 78 08             	mov    0x8(%eax),%edi
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
  10d1f9:	6a 00                	push   $0x0
		     net_ipv4_is_my_addr(&NET_IPV4_HDR(pkt)->dst))) {
  10d1fb:	8d 77 10             	lea    0x10(%edi),%esi
  10d1fe:	56                   	push   %esi
  10d1ff:	e8 6d 06 00 00       	call   10d871 <net_if_ipv4_addr_lookup>
  10d204:	5a                   	pop    %edx
  10d205:	85 c0                	test   %eax,%eax
  10d207:	59                   	pop    %ecx
  10d208:	0f 95 c0             	setne  %al
	if (!ret) {
  10d20b:	75 16                	jne    10d223 <net_send_data+0xe1>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  10d20d:	e8 47 13 00 00       	call   10e559 <net_ipv4_broadcast_address>
  10d212:	8b 00                	mov    (%eax),%eax
  10d214:	39 47 10             	cmp    %eax,0x10(%edi)
  10d217:	74 99                	je     10d1b2 <net_send_data+0x70>
	return net_if_ipv4_is_addr_bcast(iface, addr);
  10d219:	56                   	push   %esi
  10d21a:	6a 00                	push   $0x0
  10d21c:	e8 f3 04 00 00       	call   10d714 <net_if_ipv4_is_addr_bcast>
  10d221:	5e                   	pop    %esi
  10d222:	5f                   	pop    %edi
				     &NET_IPV4_HDR(pkt)->dst) == false &&
  10d223:	84 c0                	test   %al,%al
  10d225:	75 8b                	jne    10d1b2 <net_send_data+0x70>
  10d227:	8b 43 10             	mov    0x10(%ebx),%eax
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->src)) {
  10d22a:	8b 40 08             	mov    0x8(%eax),%eax
  10d22d:	80 78 0c 7f          	cmpb   $0x7f,0xc(%eax)
  10d231:	0f 84 6b ff ff ff    	je     10d1a2 <net_send_data+0x60>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
  10d237:	53                   	push   %ebx
  10d238:	ff 73 20             	pushl  0x20(%ebx)
  10d23b:	e8 b2 08 00 00       	call   10daf2 <net_if_send_data>
		return -EIO;
  10d240:	83 f8 02             	cmp    $0x2,%eax
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
  10d243:	5a                   	pop    %edx
		return -EIO;
  10d244:	0f 95 c0             	setne  %al
  10d247:	0f b6 c0             	movzbl %al,%eax
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
  10d24a:	59                   	pop    %ecx
		return -EIO;
  10d24b:	8d 44 80 fb          	lea    -0x5(%eax,%eax,4),%eax
}
  10d24f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10d252:	5b                   	pop    %ebx
  10d253:	5e                   	pop    %esi
  10d254:	5f                   	pop    %edi
  10d255:	5d                   	pop    %ebp
  10d256:	c3                   	ret    

0010d257 <net_recv_data>:
{
  10d257:	55                   	push   %ebp
  10d258:	89 e5                	mov    %esp,%ebp
  10d25a:	56                   	push   %esi
  10d25b:	53                   	push   %ebx
  10d25c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10d25f:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!pkt || !iface) {
  10d262:	85 db                	test   %ebx,%ebx
  10d264:	74 7b                	je     10d2e1 <net_recv_data+0x8a>
  10d266:	85 f6                	test   %esi,%esi
  10d268:	74 77                	je     10d2e1 <net_recv_data+0x8a>
	if (net_pkt_is_empty(pkt)) {
  10d26a:	8b 53 10             	mov    0x10(%ebx),%edx
		return -ENODATA;
  10d26d:	b8 b2 ff ff ff       	mov    $0xffffffb2,%eax
	return !pkt->buffer || !net_pkt_data(pkt) || pkt->buffer->len == 0;
  10d272:	85 d2                	test   %edx,%edx
  10d274:	74 70                	je     10d2e6 <net_recv_data+0x8f>
  10d276:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  10d27a:	74 6a                	je     10d2e6 <net_recv_data+0x8f>
	if (net_pkt_is_empty(pkt)) {
  10d27c:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  10d281:	74 63                	je     10d2e6 <net_recv_data+0x8f>
  10d283:	8b 06                	mov    (%esi),%eax
  10d285:	8b 50 0c             	mov    0xc(%eax),%edx
		return -ENETDOWN;
  10d288:	b8 c2 ff ff ff       	mov    $0xffffffc2,%eax
	if (!net_if_flag_is_set(iface, NET_IF_UP)) {
  10d28d:	80 e2 01             	and    $0x1,%dl
  10d290:	74 54                	je     10d2e6 <net_recv_data+0x8f>
	pkt->overwrite = overwrite;
  10d292:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	net_pkt_cursor_init(pkt);
  10d296:	53                   	push   %ebx
  10d297:	e8 4e 29 00 00       	call   10fbea <net_pkt_cursor_init>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
  10d29c:	8b 06                	mov    (%esi),%eax
	pkt->iface = iface;
  10d29e:	89 73 20             	mov    %esi,0x20(%ebx)
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
  10d2a1:	8a 40 15             	mov    0x15(%eax),%al
  10d2a4:	88 43 2d             	mov    %al,0x2d(%ebx)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
  10d2a7:	8b 06                	mov    (%esi),%eax
  10d2a9:	8a 40 15             	mov    0x15(%eax),%al
  10d2ac:	88 43 35             	mov    %al,0x35(%ebx)
	uint8_t tc = net_rx_priority2tc(prio);
  10d2af:	0f b6 43 44          	movzbl 0x44(%ebx),%eax
  10d2b3:	89 04 24             	mov    %eax,(%esp)
  10d2b6:	e8 d5 32 00 00       	call   110590 <net_rx_priority2tc>
	net_tc_submit_to_rx_queue(tc, pkt);
  10d2bb:	0f b6 c0             	movzbl %al,%eax
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  10d2be:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  10d2c4:	c7 43 04 27 d1 10 00 	movl   $0x10d127,0x4(%ebx)
  10d2cb:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  10d2d2:	89 1c 24             	mov    %ebx,(%esp)
  10d2d5:	50                   	push   %eax
  10d2d6:	e8 81 32 00 00       	call   11055c <net_tc_submit_to_rx_queue>
  10d2db:	58                   	pop    %eax
	return 0;
  10d2dc:	31 c0                	xor    %eax,%eax
	net_tc_submit_to_rx_queue(tc, pkt);
  10d2de:	5a                   	pop    %edx
}
  10d2df:	eb 05                	jmp    10d2e6 <net_recv_data+0x8f>
		return -EINVAL;
  10d2e1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  10d2e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10d2e9:	5b                   	pop    %ebx
  10d2ea:	5e                   	pop    %esi
  10d2eb:	5d                   	pop    %ebp
  10d2ec:	c3                   	ret    

0010d2ed <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  10d2ed:	8b 00                	mov    (%eax),%eax
  10d2ef:	25 f0 00 00 00       	and    $0xf0,%eax
  10d2f4:	3d e0 00 00 00       	cmp    $0xe0,%eax
  10d2f9:	0f 94 c0             	sete   %al
}
  10d2fc:	c3                   	ret    

0010d2fd <net_ipv4_is_ll_addr>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xA9FE0000) == 0xA9FE0000;
  10d2fd:	8b 00                	mov    (%eax),%eax
  10d2ff:	0f c8                	bswap  %eax
  10d301:	25 00 00 fe a9       	and    $0xa9fe0000,%eax
  10d306:	3d 00 00 fe a9       	cmp    $0xa9fe0000,%eax
  10d30b:	0f 94 c0             	sete   %al
}
  10d30e:	c3                   	ret    

0010d30f <net_if_l2>:
	if (!iface || !iface->if_dev) {
  10d30f:	85 c0                	test   %eax,%eax
  10d311:	74 09                	je     10d31c <net_if_l2+0xd>
  10d313:	8b 00                	mov    (%eax),%eax
  10d315:	85 c0                	test   %eax,%eax
  10d317:	74 03                	je     10d31c <net_if_l2+0xd>
	return iface->if_dev->l2;
  10d319:	8b 40 04             	mov    0x4(%eax),%eax
}
  10d31c:	c3                   	ret    

0010d31d <net_context_send_cb>:
#endif

static inline void net_context_send_cb(struct net_context *context,
				       int status)
{
	if (!context) {
  10d31d:	85 c0                	test   %eax,%eax
  10d31f:	74 15                	je     10d336 <net_context_send_cb+0x19>
		return;
	}

	if (context->send_cb) {
  10d321:	8b 48 3c             	mov    0x3c(%eax),%ecx
  10d324:	85 c9                	test   %ecx,%ecx
  10d326:	74 0e                	je     10d336 <net_context_send_cb+0x19>
{
  10d328:	55                   	push   %ebp
  10d329:	89 e5                	mov    %esp,%ebp
		context->send_cb(context, status, context->user_data);
  10d32b:	ff 30                	pushl  (%eax)
  10d32d:	52                   	push   %edx
  10d32e:	50                   	push   %eax
  10d32f:	ff d1                	call   *%ecx
  10d331:	83 c4 0c             	add    $0xc,%esp
		net_stats_update_udp_sent(net_context_get_iface(context));
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_ip_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_seg_sent(net_context_get_iface(context));
	}
}
  10d334:	c9                   	leave  
  10d335:	c3                   	ret    
  10d336:	c3                   	ret    

0010d337 <l2_flags_get>:

	return NULL;
}

static enum net_l2_flags l2_flags_get(struct net_if *iface)
{
  10d337:	55                   	push   %ebp
  10d338:	89 c2                	mov    %eax,%edx
  10d33a:	89 e5                	mov    %esp,%ebp
	enum net_l2_flags flags = 0;

	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
  10d33c:	e8 ce ff ff ff       	call   10d30f <net_if_l2>
  10d341:	85 c0                	test   %eax,%eax
  10d343:	74 0f                	je     10d354 <l2_flags_get+0x1d>
  10d345:	8b 48 0c             	mov    0xc(%eax),%ecx
	enum net_l2_flags flags = 0;
  10d348:	31 c0                	xor    %eax,%eax
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
  10d34a:	85 c9                	test   %ecx,%ecx
  10d34c:	74 08                	je     10d356 <l2_flags_get+0x1f>
		flags = net_if_l2(iface)->get_flags(iface);
  10d34e:	52                   	push   %edx
  10d34f:	ff d1                	call   *%ecx
  10d351:	5a                   	pop    %edx
  10d352:	eb 02                	jmp    10d356 <l2_flags_get+0x1f>
	enum net_l2_flags flags = 0;
  10d354:	31 c0                	xor    %eax,%eax
	}

	return flags;
}
  10d356:	c9                   	leave  
  10d357:	c3                   	ret    

0010d358 <if_ipv4_get_addr>:
	return src;
}

static struct in_addr *if_ipv4_get_addr(struct net_if *iface,
					enum net_addr_state addr_state, bool ll)
{
  10d358:	55                   	push   %ebp
	struct net_if_ipv4 *ipv4;
	int i;

	if (!iface) {
  10d359:	85 c0                	test   %eax,%eax
{
  10d35b:	89 e5                	mov    %esp,%ebp
  10d35d:	53                   	push   %ebx
  10d35e:	89 c3                	mov    %eax,%ebx
	if (!iface) {
  10d360:	74 37                	je     10d399 <if_ipv4_get_addr+0x41>
		return NULL;
	}

	ipv4 = iface->config.ip.ipv4;
  10d362:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!ipv4) {
  10d365:	85 db                	test   %ebx,%ebx
  10d367:	74 30                	je     10d399 <if_ipv4_get_addr+0x41>
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_ADDR; i++) {
		if (!ipv4->unicast[i].is_used ||
  10d369:	f6 43 16 02          	testb  $0x2,0x16(%ebx)
  10d36d:	74 28                	je     10d397 <if_ipv4_get_addr+0x3f>
  10d36f:	80 fa ff             	cmp    $0xff,%dl
  10d372:	74 05                	je     10d379 <if_ipv4_get_addr+0x21>
		    (addr_state != NET_ADDR_ANY_STATE &&
  10d374:	38 53 15             	cmp    %dl,0x15(%ebx)
  10d377:	75 1e                	jne    10d397 <if_ipv4_get_addr+0x3f>
		     ipv4->unicast[i].addr_state != addr_state) ||
  10d379:	66 83 3b 01          	cmpw   $0x1,(%ebx)
  10d37d:	75 18                	jne    10d397 <if_ipv4_get_addr+0x3f>
		    ipv4->unicast[i].address.family != AF_INET) {
			continue;
		}

		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
  10d37f:	83 c3 04             	add    $0x4,%ebx
  10d382:	89 d8                	mov    %ebx,%eax
  10d384:	e8 74 ff ff ff       	call   10d2fd <net_ipv4_is_ll_addr>
  10d389:	84 c0                	test   %al,%al
  10d38b:	74 06                	je     10d393 <if_ipv4_get_addr+0x3b>
			if (!ll) {
  10d38d:	84 c9                	test   %cl,%cl
  10d38f:	75 08                	jne    10d399 <if_ipv4_get_addr+0x41>
  10d391:	eb 04                	jmp    10d397 <if_ipv4_get_addr+0x3f>
				continue;
			}
		} else {
			if (ll) {
  10d393:	84 c9                	test   %cl,%cl
  10d395:	74 02                	je     10d399 <if_ipv4_get_addr+0x41>
		}

		return &ipv4->unicast[i].address.in_addr;
	}

	return NULL;
  10d397:	31 db                	xor    %ebx,%ebx
}
  10d399:	89 d8                	mov    %ebx,%eax
  10d39b:	5b                   	pop    %ebx
  10d39c:	5d                   	pop    %ebp
  10d39d:	c3                   	ret    

0010d39e <ipv4_maddr_find>:

static struct net_if_mcast_addr *ipv4_maddr_find(struct net_if *iface,
						 bool is_used,
						 const struct in_addr *addr)
{
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
  10d39e:	8b 40 04             	mov    0x4(%eax),%eax
	int i;

	if (!ipv4) {
  10d3a1:	85 c0                	test   %eax,%eax
  10d3a3:	75 01                	jne    10d3a6 <ipv4_maddr_find+0x8>
  10d3a5:	c3                   	ret    
{
  10d3a6:	55                   	push   %ebp
  10d3a7:	89 e5                	mov    %esp,%ebp
  10d3a9:	53                   	push   %ebx
  10d3aa:	8a 58 2c             	mov    0x2c(%eax),%bl
  10d3ad:	83 e3 01             	and    $0x1,%ebx
		return NULL;
	}

	for (i = 0; i < NET_IF_MAX_IPV4_MADDR; i++) {
		if ((is_used && !ipv4->mcast[i].is_used) ||
  10d3b0:	84 d2                	test   %dl,%dl
  10d3b2:	74 06                	je     10d3ba <ipv4_maddr_find+0x1c>
  10d3b4:	84 db                	test   %bl,%bl
  10d3b6:	75 06                	jne    10d3be <ipv4_maddr_find+0x20>
  10d3b8:	eb 14                	jmp    10d3ce <ipv4_maddr_find+0x30>
		    (!is_used && ipv4->mcast[i].is_used)) {
  10d3ba:	84 db                	test   %bl,%bl
  10d3bc:	75 10                	jne    10d3ce <ipv4_maddr_find+0x30>
			continue;
		}

		if (addr) {
  10d3be:	85 c9                	test   %ecx,%ecx
  10d3c0:	74 07                	je     10d3c9 <ipv4_maddr_find+0x2b>
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
  10d3c2:	8b 11                	mov    (%ecx),%edx
  10d3c4:	39 50 1c             	cmp    %edx,0x1c(%eax)
  10d3c7:	75 05                	jne    10d3ce <ipv4_maddr_find+0x30>
					       addr)) {
				continue;
			}
		}

		return &ipv4->mcast[i];
  10d3c9:	83 c0 18             	add    $0x18,%eax
  10d3cc:	eb 02                	jmp    10d3d0 <ipv4_maddr_find+0x32>
		return NULL;
  10d3ce:	31 c0                	xor    %eax,%eax
	}

	return NULL;
}
  10d3d0:	5b                   	pop    %ebx
  10d3d1:	5d                   	pop    %ebp
  10d3d2:	c3                   	ret    

0010d3d3 <k_uptime_get_32>:
{
  10d3d3:	55                   	push   %ebp
  10d3d4:	89 e5                	mov    %esp,%ebp
  10d3d6:	e8 ac 4f 01 00       	call   122387 <z_impl_k_uptime_ticks>
			return t * (to_hz / from_hz);
  10d3db:	ba 0a 00 00 00       	mov    $0xa,%edx
  10d3e0:	f7 e2                	mul    %edx
}
  10d3e2:	5d                   	pop    %ebp
  10d3e3:	c3                   	ret    

0010d3e4 <need_calc_checksum.part.0>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
		link->cb(iface, lladdr, status);
	}
}

static bool need_calc_checksum(struct net_if *iface, enum ethernet_hw_caps caps)
  10d3e4:	55                   	push   %ebp
  10d3e5:	89 e5                	mov    %esp,%ebp
  10d3e7:	53                   	push   %ebx
	return iface->if_dev->dev;
  10d3e8:	8b 00                	mov    (%eax),%eax
  10d3ea:	89 d3                	mov    %edx,%ebx
  10d3ec:	8b 10                	mov    (%eax),%edx
	if (!eth->get_capabilities) {
  10d3ee:	8b 42 08             	mov    0x8(%edx),%eax
  10d3f1:	8b 40 0c             	mov    0xc(%eax),%eax
  10d3f4:	85 c0                	test   %eax,%eax
  10d3f6:	74 06                	je     10d3fe <need_calc_checksum.part.0+0x1a>
	return eth->get_capabilities(net_if_get_device(iface));
  10d3f8:	52                   	push   %edx
  10d3f9:	ff d0                	call   *%eax
  10d3fb:	5a                   	pop    %edx
  10d3fc:	eb 02                	jmp    10d400 <need_calc_checksum.part.0+0x1c>
		return (enum ethernet_hw_caps)0;
  10d3fe:	31 c0                	xor    %eax,%eax
#if defined(CONFIG_NET_L2_ETHERNET)
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
		return true;
	}

	return !(net_eth_get_hw_capabilities(iface) & caps);
  10d400:	85 c3                	test   %eax,%ebx
#else
	return true;
#endif
}
  10d402:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return !(net_eth_get_hw_capabilities(iface) & caps);
  10d405:	0f 94 c0             	sete   %al
}
  10d408:	c9                   	leave  
  10d409:	c3                   	ret    

0010d40a <net_if_ipv4_get_best_match.isra.0>:
static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
  10d40a:	55                   	push   %ebp
  10d40b:	89 e5                	mov    %esp,%ebp
  10d40d:	57                   	push   %edi
  10d40e:	56                   	push   %esi
  10d40f:	53                   	push   %ebx
  10d410:	89 c3                	mov    %eax,%ebx
  10d412:	83 ec 0c             	sub    $0xc,%esp
  10d415:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	if (!ipv4) {
  10d418:	85 c0                	test   %eax,%eax
  10d41a:	74 7a                	je     10d496 <net_if_ipv4_get_best_match.isra.0+0x8c>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
  10d41c:	8b 40 14             	mov    0x14(%eax),%eax
  10d41f:	25 00 ff 02 00       	and    $0x2ff00,%eax
  10d424:	3d 00 01 02 00       	cmp    $0x20100,%eax
  10d429:	75 69                	jne    10d494 <net_if_ipv4_get_best_match.isra.0+0x8a>
  10d42b:	66 83 3b 01          	cmpw   $0x1,(%ebx)
  10d42f:	75 63                	jne    10d494 <net_if_ipv4_get_best_match.isra.0+0x8a>
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
  10d431:	8d 73 04             	lea    0x4(%ebx),%esi
  10d434:	89 f0                	mov    %esi,%eax
  10d436:	e8 c2 fe ff ff       	call   10d2fd <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
  10d43b:	84 c0                	test   %al,%al
  10d43d:	75 55                	jne    10d494 <net_if_ipv4_get_best_match.isra.0+0x8a>
  10d43f:	89 d7                	mov    %edx,%edi
  10d441:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (src[j] == dst[j]) {
  10d448:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10d44b:	8a 45 f0             	mov    -0x10(%ebp),%al
  10d44e:	c1 e0 03             	shl    $0x3,%eax
  10d451:	8a 0c 17             	mov    (%edi,%edx,1),%cl
  10d454:	88 4d ef             	mov    %cl,-0x11(%ebp)
  10d457:	8a 4c 13 04          	mov    0x4(%ebx,%edx,1),%cl
  10d45b:	38 4d ef             	cmp    %cl,-0x11(%ebp)
  10d45e:	88 4d ee             	mov    %cl,-0x12(%ebp)
  10d461:	75 0e                	jne    10d471 <net_if_ipv4_get_best_match.isra.0+0x67>
			len += 8U;
  10d463:	ff 45 f0             	incl   -0x10(%ebp)
  10d466:	83 c0 08             	add    $0x8,%eax
	for (j = 0U; j < addr_len; j++) {
  10d469:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
  10d46d:	75 d9                	jne    10d448 <net_if_ipv4_get_best_match.isra.0+0x3e>
  10d46f:	eb 14                	jmp    10d485 <net_if_ipv4_get_best_match.isra.0+0x7b>
			xor = src[j] ^ dst[j];
  10d471:	8a 55 ef             	mov    -0x11(%ebp),%dl
  10d474:	8d 58 08             	lea    0x8(%eax),%ebx
  10d477:	32 55 ee             	xor    -0x12(%ebp),%dl
				if (!(xor & 0x80)) {
  10d47a:	84 d2                	test   %dl,%dl
  10d47c:	78 07                	js     10d485 <net_if_ipv4_get_best_match.isra.0+0x7b>
					len++;
  10d47e:	40                   	inc    %eax
					xor <<= 1;
  10d47f:	01 d2                	add    %edx,%edx
			for (k = 0U; k < 8; k++) {
  10d481:	38 d8                	cmp    %bl,%al
  10d483:	75 f5                	jne    10d47a <net_if_ipv4_get_best_match.isra.0+0x70>
		if (len >= *best_so_far) {
  10d485:	8b 7d e8             	mov    -0x18(%ebp),%edi
		return NULL;
  10d488:	31 db                	xor    %ebx,%ebx
		if (len >= *best_so_far) {
  10d48a:	38 07                	cmp    %al,(%edi)
  10d48c:	77 08                	ja     10d496 <net_if_ipv4_get_best_match.isra.0+0x8c>
			*best_so_far = len;
  10d48e:	88 07                	mov    %al,(%edi)
		len = get_diff_ipv4(dst, &ipv4->unicast[i].address.in_addr);
  10d490:	89 f3                	mov    %esi,%ebx
  10d492:	eb 02                	jmp    10d496 <net_if_ipv4_get_best_match.isra.0+0x8c>
		return NULL;
  10d494:	31 db                	xor    %ebx,%ebx
}
  10d496:	83 c4 0c             	add    $0xc,%esp
  10d499:	89 d8                	mov    %ebx,%eax
  10d49b:	5b                   	pop    %ebx
  10d49c:	5e                   	pop    %esi
  10d49d:	5f                   	pop    %edi
  10d49e:	5d                   	pop    %ebp
  10d49f:	c3                   	ret    

0010d4a0 <iface_router_run_timer>:
{
  10d4a0:	55                   	push   %ebp
  10d4a1:	89 e5                	mov    %esp,%ebp
  10d4a3:	56                   	push   %esi
  10d4a4:	53                   	push   %ebx
  10d4a5:	89 c3                	mov    %eax,%ebx
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
  10d4a7:	68 ac a8 12 00       	push   $0x12a8ac
  10d4ac:	e8 43 4d 01 00       	call   1221f4 <z_timeout_remaining>
			return ((uint32_t)t) * (to_hz / from_hz);
  10d4b1:	6b c0 0a             	imul   $0xa,%eax,%eax
  10d4b4:	5a                   	pop    %edx
	if (k_delayed_work_remaining_get(&router_timer)) {
  10d4b5:	85 c0                	test   %eax,%eax
  10d4b7:	74 0b                	je     10d4c4 <iface_router_run_timer+0x24>
		k_delayed_work_cancel(&router_timer);
  10d4b9:	68 a0 a8 12 00       	push   $0x12a8a0
  10d4be:	e8 9b 4a 01 00       	call   121f5e <k_delayed_work_cancel>
  10d4c3:	58                   	pop    %eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
  10d4c4:	8b 15 c0 eb 12 00    	mov    0x12ebc0,%edx
  10d4ca:	85 d2                	test   %edx,%edx
  10d4cc:	74 5d                	je     10d52b <iface_router_run_timer+0x8b>
	return node->next;
  10d4ce:	8b 32                	mov    (%edx),%esi
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10d4d0:	83 c8 ff             	or     $0xffffffff,%eax
  10d4d3:	85 d2                	test   %edx,%edx
  10d4d5:	74 25                	je     10d4fc <iface_router_run_timer+0x5c>
			(MSEC_PER_SEC * router->lifetime) - current_time;
  10d4d7:	0f b7 4a 20          	movzwl 0x20(%edx),%ecx
  10d4db:	69 c9 e8 03 00 00    	imul   $0x3e8,%ecx,%ecx
		uint32_t current_timer = router->life_start +
  10d4e1:	8b 52 1c             	mov    0x1c(%edx),%edx
  10d4e4:	29 da                	sub    %ebx,%edx
  10d4e6:	01 ca                	add    %ecx,%edx
		new_timer = MIN(current_timer, new_timer);
  10d4e8:	39 d0                	cmp    %edx,%eax
  10d4ea:	76 02                	jbe    10d4ee <iface_router_run_timer+0x4e>
  10d4ec:	89 d0                	mov    %edx,%eax
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
  10d4ee:	31 c9                	xor    %ecx,%ecx
  10d4f0:	85 f6                	test   %esi,%esi
  10d4f2:	74 02                	je     10d4f6 <iface_router_run_timer+0x56>
	return node->next;
  10d4f4:	8b 0e                	mov    (%esi),%ecx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10d4f6:	89 f2                	mov    %esi,%edx
  10d4f8:	89 ce                	mov    %ecx,%esi
  10d4fa:	eb d7                	jmp    10d4d3 <iface_router_run_timer+0x33>
	if (new_timer != UINT_MAX) {
  10d4fc:	83 f8 ff             	cmp    $0xffffffff,%eax
  10d4ff:	74 2a                	je     10d52b <iface_router_run_timer+0x8b>
			return t / (from_hz / to_hz);
  10d501:	6a 00                	push   $0x0
		k_delayed_work_submit(&router_timer, K_MSEC(new_timer));
  10d503:	31 d2                	xor    %edx,%edx
		t += off;
  10d505:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  10d508:	6a 0a                	push   $0xa
		t += off;
  10d50a:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  10d50d:	52                   	push   %edx
  10d50e:	50                   	push   %eax
  10d50f:	e8 0c 2d ff ff       	call   100220 <__udivdi3>
  10d514:	83 c4 10             	add    $0x10,%esp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
  10d517:	52                   	push   %edx
  10d518:	50                   	push   %eax
  10d519:	68 a0 a8 12 00       	push   $0x12a8a0
  10d51e:	68 00 ea 12 00       	push   $0x12ea00
  10d523:	e8 af 49 01 00       	call   121ed7 <k_delayed_work_submit_to_queue>
  10d528:	83 c4 10             	add    $0x10,%esp
}
  10d52b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10d52e:	5b                   	pop    %ebx
  10d52f:	5e                   	pop    %esi
  10d530:	5d                   	pop    %ebp
  10d531:	c3                   	ret    

0010d532 <iface_router_expired>:
{
  10d532:	55                   	push   %ebp
  10d533:	89 e5                	mov    %esp,%ebp
  10d535:	57                   	push   %edi
  10d536:	56                   	push   %esi
  10d537:	53                   	push   %ebx
  10d538:	50                   	push   %eax
	uint32_t current_time = k_uptime_get_32();
  10d539:	e8 95 fe ff ff       	call   10d3d3 <k_uptime_get_32>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
  10d53e:	8b 1d c0 eb 12 00    	mov    0x12ebc0,%ebx
  10d544:	85 db                	test   %ebx,%ebx
  10d546:	75 0c                	jne    10d554 <iface_router_expired+0x22>
}
  10d548:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10d54b:	5b                   	pop    %ebx
  10d54c:	5e                   	pop    %esi
  10d54d:	5f                   	pop    %edi
  10d54e:	5d                   	pop    %ebp
	iface_router_run_timer(current_time);
  10d54f:	e9 4c ff ff ff       	jmp    10d4a0 <iface_router_run_timer>
	return node->next;
  10d554:	8b 3b                	mov    (%ebx),%edi
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10d556:	31 f6                	xor    %esi,%esi
			    (MSEC_PER_SEC * router->lifetime) -
  10d558:	0f b7 53 20          	movzwl 0x20(%ebx),%edx
  10d55c:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
  10d562:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10d565:	8b 53 1c             	mov    0x1c(%ebx),%edx
  10d568:	29 c2                	sub    %eax,%edx
  10d56a:	89 d9                	mov    %ebx,%ecx
  10d56c:	03 55 f0             	add    -0x10(%ebp),%edx
		if ((int32_t)(router->life_start +
  10d56f:	85 d2                	test   %edx,%edx
  10d571:	7f 5b                	jg     10d5ce <iface_router_expired+0x9c>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10d573:	66 83 7b 04 01       	cmpw   $0x1,0x4(%ebx)
  10d578:	75 1c                	jne    10d596 <iface_router_expired+0x64>
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ROUTER_DEL,
  10d57a:	6a 10                	push   $0x10
						&router->address.in_addr,
  10d57c:	8d 53 08             	lea    0x8(%ebx),%edx
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ROUTER_DEL,
  10d57f:	52                   	push   %edx
  10d580:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10d583:	ff 73 18             	pushl  0x18(%ebx)
  10d586:	68 04 00 04 e0       	push   $0xe0040004
  10d58b:	e8 56 12 00 00       	call   10e7e6 <net_mgmt_event_notify_with_info>
  10d590:	83 c4 10             	add    $0x10,%esp
  10d593:	8b 45 f0             	mov    -0x10(%ebp),%eax
Z_GENLIST_REMOVE(slist, snode)
  10d596:	85 f6                	test   %esi,%esi
  10d598:	8b 13                	mov    (%ebx),%edx
  10d59a:	75 16                	jne    10d5b2 <iface_router_expired+0x80>
  10d59c:	39 1d c4 eb 12 00    	cmp    %ebx,0x12ebc4
	list->head = node;
  10d5a2:	89 15 c0 eb 12 00    	mov    %edx,0x12ebc0
Z_GENLIST_REMOVE(slist, snode)
  10d5a8:	75 18                	jne    10d5c2 <iface_router_expired+0x90>
	list->tail = node;
  10d5aa:	89 15 c4 eb 12 00    	mov    %edx,0x12ebc4
}
  10d5b0:	eb 10                	jmp    10d5c2 <iface_router_expired+0x90>
	parent->next = child;
  10d5b2:	89 16                	mov    %edx,(%esi)
Z_GENLIST_REMOVE(slist, snode)
  10d5b4:	39 1d c4 eb 12 00    	cmp    %ebx,0x12ebc4
  10d5ba:	75 06                	jne    10d5c2 <iface_router_expired+0x90>
	list->tail = node;
  10d5bc:	89 35 c4 eb 12 00    	mov    %esi,0x12ebc4
		router->is_used = false;
  10d5c2:	80 63 22 fe          	andb   $0xfe,0x22(%ebx)
	parent->next = child;
  10d5c6:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  10d5cc:	89 f1                	mov    %esi,%ecx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
  10d5ce:	85 ff                	test   %edi,%edi
  10d5d0:	0f 84 72 ff ff ff    	je     10d548 <iface_router_expired+0x16>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10d5d6:	89 fb                	mov    %edi,%ebx
  10d5d8:	89 ce                	mov    %ecx,%esi
  10d5da:	8b 3f                	mov    (%edi),%edi
  10d5dc:	e9 77 ff ff ff       	jmp    10d558 <iface_router_expired+0x26>

0010d5e1 <z_impl_net_if_get_by_index>:
{
  10d5e1:	55                   	push   %ebp
		return NULL;
  10d5e2:	31 c0                	xor    %eax,%eax
{
  10d5e4:	89 e5                	mov    %esp,%ebp
  10d5e6:	8b 55 08             	mov    0x8(%ebp),%edx
	if (index <= 0) {
  10d5e9:	85 d2                	test   %edx,%edx
  10d5eb:	7e 10                	jle    10d5fd <z_impl_net_if_get_by_index+0x1c>
	if (&_net_if_list_start[index - 1] >= _net_if_list_end) {
  10d5ed:	8d 04 d5 38 5e 14 00 	lea    0x145e38(,%edx,8),%eax
  10d5f4:	3d 48 5e 14 00       	cmp    $0x145e48,%eax
  10d5f9:	72 02                	jb     10d5fd <z_impl_net_if_get_by_index+0x1c>
		return NULL;
  10d5fb:	31 c0                	xor    %eax,%eax
}
  10d5fd:	5d                   	pop    %ebp
  10d5fe:	c3                   	ret    

0010d5ff <net_if_queue_tx>:
{
  10d5ff:	55                   	push   %ebp
  10d600:	89 e5                	mov    %esp,%ebp
  10d602:	53                   	push   %ebx
  10d603:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	uint8_t tc = net_tx_priority2tc(prio);
  10d606:	0f b6 43 44          	movzbl 0x44(%ebx),%eax
  10d60a:	50                   	push   %eax
  10d60b:	e8 67 2f 00 00       	call   110577 <net_tx_priority2tc>
  10d610:	5a                   	pop    %edx
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  10d611:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  10d617:	c7 43 04 0b da 10 00 	movl   $0x10da0b,0x4(%ebx)
  10d61e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	if (!net_tc_submit_to_tx_queue(tc, pkt)) {
  10d625:	0f b6 c0             	movzbl %al,%eax
  10d628:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
  10d62b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	if (!net_tc_submit_to_tx_queue(tc, pkt)) {
  10d62e:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10d631:	c9                   	leave  
	if (!net_tc_submit_to_tx_queue(tc, pkt)) {
  10d632:	e9 f7 2e 00 00       	jmp    11052e <net_tc_submit_to_tx_queue>

0010d637 <net_if_lookup_by_dev>:
{
  10d637:	55                   	push   %ebp
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d638:	b8 40 5e 14 00       	mov    $0x145e40,%eax
{
  10d63d:	89 e5                	mov    %esp,%ebp
  10d63f:	8b 55 08             	mov    0x8(%ebp),%edx
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d642:	3d 48 5e 14 00       	cmp    $0x145e48,%eax
  10d647:	73 0b                	jae    10d654 <net_if_lookup_by_dev+0x1d>
  10d649:	8b 08                	mov    (%eax),%ecx
		if (net_if_get_device(iface) == dev) {
  10d64b:	3b 11                	cmp    (%ecx),%edx
  10d64d:	74 07                	je     10d656 <net_if_lookup_by_dev+0x1f>
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d64f:	83 c0 08             	add    $0x8,%eax
  10d652:	eb ee                	jmp    10d642 <net_if_lookup_by_dev+0xb>
	return NULL;
  10d654:	31 c0                	xor    %eax,%eax
}
  10d656:	5d                   	pop    %ebp
  10d657:	c3                   	ret    

0010d658 <net_if_get_default>:
	return iface ? iface : _net_if_list_start;
  10d658:	b8 40 5e 14 00       	mov    $0x145e40,%eax
	if (_net_if_list_start == _net_if_list_end) {
  10d65d:	3d 48 5e 14 00       	cmp    $0x145e48,%eax
  10d662:	75 02                	jne    10d666 <net_if_get_default+0xe>
		return NULL;
  10d664:	31 c0                	xor    %eax,%eax
}
  10d666:	c3                   	ret    

0010d667 <net_if_config_ipv4_get>:
{
  10d667:	55                   	push   %ebp
  10d668:	89 e5                	mov    %esp,%ebp
  10d66a:	8b 55 08             	mov    0x8(%ebp),%edx
  10d66d:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (iface->config.ip.ipv4) {
  10d670:	8b 4a 04             	mov    0x4(%edx),%ecx
  10d673:	85 c9                	test   %ecx,%ecx
  10d675:	74 08                	je     10d67f <net_if_config_ipv4_get+0x18>
		if (ipv4) {
  10d677:	85 c0                	test   %eax,%eax
  10d679:	74 24                	je     10d69f <net_if_config_ipv4_get+0x38>
			*ipv4 = iface->config.ip.ipv4;
  10d67b:	89 08                	mov    %ecx,(%eax)
  10d67d:	eb 20                	jmp    10d69f <net_if_config_ipv4_get+0x38>
		if (ipv4_addresses[i].iface) {
  10d67f:	83 3d 9c a8 12 00 00 	cmpl   $0x0,0x12a89c
  10d686:	75 1b                	jne    10d6a3 <net_if_config_ipv4_get+0x3c>
		iface->config.ip.ipv4 = &ipv4_addresses[i].ipv4;
  10d688:	c7 42 04 60 a8 12 00 	movl   $0x12a860,0x4(%edx)
		if (ipv4) {
  10d68f:	85 c0                	test   %eax,%eax
		ipv4_addresses[i].iface = iface;
  10d691:	89 15 9c a8 12 00    	mov    %edx,0x12a89c
		if (ipv4) {
  10d697:	74 06                	je     10d69f <net_if_config_ipv4_get+0x38>
			*ipv4 = &ipv4_addresses[i].ipv4;
  10d699:	c7 00 60 a8 12 00    	movl   $0x12a860,(%eax)
  10d69f:	31 c0                	xor    %eax,%eax
  10d6a1:	eb 05                	jmp    10d6a8 <net_if_config_ipv4_get+0x41>
	return -ESRCH;
  10d6a3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  10d6a8:	5d                   	pop    %ebp
  10d6a9:	c3                   	ret    

0010d6aa <net_if_ipv4_addr_mask_cmp>:
{
  10d6aa:	55                   	push   %ebp
  10d6ab:	89 e5                	mov    %esp,%ebp
  10d6ad:	53                   	push   %ebx
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
  10d6ae:	8b 45 08             	mov    0x8(%ebp),%eax
  10d6b1:	8b 50 04             	mov    0x4(%eax),%edx
		return false;
  10d6b4:	31 c0                	xor    %eax,%eax
	if (!ipv4) {
  10d6b6:	85 d2                	test   %edx,%edx
  10d6b8:	74 23                	je     10d6dd <net_if_ipv4_addr_mask_cmp+0x33>
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
  10d6ba:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d6bd:	8b 4a 34             	mov    0x34(%edx),%ecx
  10d6c0:	8b 18                	mov    (%eax),%ebx
		if (!ipv4->unicast[i].is_used ||
  10d6c2:	8a 42 16             	mov    0x16(%edx),%al
  10d6c5:	d0 e8                	shr    %al
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
  10d6c7:	21 cb                	and    %ecx,%ebx
		if (!ipv4->unicast[i].is_used ||
  10d6c9:	24 01                	and    $0x1,%al
  10d6cb:	74 10                	je     10d6dd <net_if_ipv4_addr_mask_cmp+0x33>
		return false;
  10d6cd:	31 c0                	xor    %eax,%eax
		if (!ipv4->unicast[i].is_used ||
  10d6cf:	66 83 3a 01          	cmpw   $0x1,(%edx)
  10d6d3:	75 08                	jne    10d6dd <net_if_ipv4_addr_mask_cmp+0x33>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
  10d6d5:	23 4a 04             	and    0x4(%edx),%ecx
  10d6d8:	39 d9                	cmp    %ebx,%ecx
  10d6da:	0f 94 c0             	sete   %al
}
  10d6dd:	5b                   	pop    %ebx
  10d6de:	5d                   	pop    %ebp
  10d6df:	c3                   	ret    

0010d6e0 <ipv4_is_broadcast_address>:
{
  10d6e0:	55                   	push   %ebp
  10d6e1:	89 e5                	mov    %esp,%ebp
  10d6e3:	56                   	push   %esi
  10d6e4:	53                   	push   %ebx
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
  10d6e5:	8b 70 04             	mov    0x4(%eax),%esi
	if (!ipv4) {
  10d6e8:	85 f6                	test   %esi,%esi
  10d6ea:	74 1f                	je     10d70b <ipv4_is_broadcast_address+0x2b>
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
  10d6ec:	52                   	push   %edx
  10d6ed:	89 d3                	mov    %edx,%ebx
  10d6ef:	50                   	push   %eax
  10d6f0:	e8 b5 ff ff ff       	call   10d6aa <net_if_ipv4_addr_mask_cmp>
  10d6f5:	5a                   	pop    %edx
  10d6f6:	84 c0                	test   %al,%al
  10d6f8:	59                   	pop    %ecx
  10d6f9:	74 12                	je     10d70d <ipv4_is_broadcast_address+0x2d>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
  10d6fb:	8b 46 34             	mov    0x34(%esi),%eax
  10d6fe:	8b 13                	mov    (%ebx),%edx
  10d700:	f7 d0                	not    %eax
  10d702:	21 c2                	and    %eax,%edx
  10d704:	39 c2                	cmp    %eax,%edx
  10d706:	0f 94 c0             	sete   %al
  10d709:	eb 02                	jmp    10d70d <ipv4_is_broadcast_address+0x2d>
		return false;
  10d70b:	31 c0                	xor    %eax,%eax
}
  10d70d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10d710:	5b                   	pop    %ebx
  10d711:	5e                   	pop    %esi
  10d712:	5d                   	pop    %ebp
  10d713:	c3                   	ret    

0010d714 <net_if_ipv4_is_addr_bcast>:
{
  10d714:	55                   	push   %ebp
  10d715:	89 e5                	mov    %esp,%ebp
  10d717:	53                   	push   %ebx
  10d718:	53                   	push   %ebx
  10d719:	8b 45 08             	mov    0x8(%ebp),%eax
  10d71c:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (iface) {
  10d71f:	85 c0                	test   %eax,%eax
  10d721:	74 08                	je     10d72b <net_if_ipv4_is_addr_bcast+0x17>
}
  10d723:	59                   	pop    %ecx
  10d724:	5b                   	pop    %ebx
  10d725:	5d                   	pop    %ebp
		return ipv4_is_broadcast_address(iface, addr);
  10d726:	e9 b5 ff ff ff       	jmp    10d6e0 <ipv4_is_broadcast_address>
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d72b:	bb 40 5e 14 00       	mov    $0x145e40,%ebx
  10d730:	81 fb 48 5e 14 00    	cmp    $0x145e48,%ebx
  10d736:	73 16                	jae    10d74e <net_if_ipv4_is_addr_bcast+0x3a>
		ret = ipv4_is_broadcast_address(iface, addr);
  10d738:	89 d8                	mov    %ebx,%eax
  10d73a:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10d73d:	e8 9e ff ff ff       	call   10d6e0 <ipv4_is_broadcast_address>
		if (ret) {
  10d742:	84 c0                	test   %al,%al
  10d744:	75 0a                	jne    10d750 <net_if_ipv4_is_addr_bcast+0x3c>
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d746:	83 c3 08             	add    $0x8,%ebx
  10d749:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10d74c:	eb e2                	jmp    10d730 <net_if_ipv4_is_addr_bcast+0x1c>
	return false;
  10d74e:	31 c0                	xor    %eax,%eax
}
  10d750:	5a                   	pop    %edx
  10d751:	5b                   	pop    %ebx
  10d752:	5d                   	pop    %ebp
  10d753:	c3                   	ret    

0010d754 <net_if_ipv4_select_src_iface>:
{
  10d754:	55                   	push   %ebp
  10d755:	89 e5                	mov    %esp,%ebp
  10d757:	53                   	push   %ebx
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d758:	bb 40 5e 14 00       	mov    $0x145e40,%ebx
  10d75d:	81 fb 48 5e 14 00    	cmp    $0x145e48,%ebx
  10d763:	73 14                	jae    10d779 <net_if_ipv4_select_src_iface+0x25>
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
  10d765:	ff 75 08             	pushl  0x8(%ebp)
  10d768:	53                   	push   %ebx
  10d769:	e8 3c ff ff ff       	call   10d6aa <net_if_ipv4_addr_mask_cmp>
  10d76e:	5a                   	pop    %edx
		if (ret) {
  10d76f:	84 c0                	test   %al,%al
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
  10d771:	59                   	pop    %ecx
		if (ret) {
  10d772:	75 14                	jne    10d788 <net_if_ipv4_select_src_iface+0x34>
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d774:	83 c3 08             	add    $0x8,%ebx
  10d777:	eb e4                	jmp    10d75d <net_if_ipv4_select_src_iface+0x9>
	return iface ? iface : _net_if_list_start;
  10d779:	bb 40 5e 14 00       	mov    $0x145e40,%ebx
	if (_net_if_list_start == _net_if_list_end) {
  10d77e:	81 fb 48 5e 14 00    	cmp    $0x145e48,%ebx
  10d784:	75 02                	jne    10d788 <net_if_ipv4_select_src_iface+0x34>
		return NULL;
  10d786:	31 db                	xor    %ebx,%ebx
}
  10d788:	89 d8                	mov    %ebx,%eax
  10d78a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10d78d:	c9                   	leave  
  10d78e:	c3                   	ret    

0010d78f <net_if_ipv4_get_ll>:
{
  10d78f:	55                   	push   %ebp
	return if_ipv4_get_addr(iface, addr_state, true);
  10d790:	b9 01 00 00 00       	mov    $0x1,%ecx
{
  10d795:	89 e5                	mov    %esp,%ebp
	return if_ipv4_get_addr(iface, addr_state, true);
  10d797:	0f be 55 0c          	movsbl 0xc(%ebp),%edx
  10d79b:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10d79e:	5d                   	pop    %ebp
	return if_ipv4_get_addr(iface, addr_state, true);
  10d79f:	e9 b4 fb ff ff       	jmp    10d358 <if_ipv4_get_addr>

0010d7a4 <net_if_ipv4_get_global_addr>:
{
  10d7a4:	55                   	push   %ebp
	return if_ipv4_get_addr(iface, addr_state, false);
  10d7a5:	31 c9                	xor    %ecx,%ecx
{
  10d7a7:	89 e5                	mov    %esp,%ebp
	return if_ipv4_get_addr(iface, addr_state, false);
  10d7a9:	0f be 55 0c          	movsbl 0xc(%ebp),%edx
  10d7ad:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10d7b0:	5d                   	pop    %ebp
	return if_ipv4_get_addr(iface, addr_state, false);
  10d7b1:	e9 a2 fb ff ff       	jmp    10d358 <if_ipv4_get_addr>

0010d7b6 <net_if_ipv4_select_src_addr>:
{
  10d7b6:	55                   	push   %ebp
  10d7b7:	89 e5                	mov    %esp,%ebp
  10d7b9:	57                   	push   %edi
  10d7ba:	56                   	push   %esi
  10d7bb:	53                   	push   %ebx
  10d7bc:	56                   	push   %esi
	uint8_t best_match = 0U;
  10d7bd:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
  10d7c1:	8b 45 0c             	mov    0xc(%ebp),%eax
{
  10d7c4:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
  10d7c7:	e8 31 fb ff ff       	call   10d2fd <net_ipv4_is_ll_addr>
  10d7cc:	84 c0                	test   %al,%al
  10d7ce:	75 48                	jne    10d818 <net_if_ipv4_select_src_addr+0x62>
  10d7d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  10d7d3:	e8 15 fb ff ff       	call   10d2ed <net_ipv4_is_addr_mcast>
  10d7d8:	84 c0                	test   %al,%al
  10d7da:	75 3c                	jne    10d818 <net_if_ipv4_select_src_addr+0x62>
		if (dst_iface) {
  10d7dc:	85 f6                	test   %esi,%esi
  10d7de:	74 10                	je     10d7f0 <net_if_ipv4_select_src_addr+0x3a>
			src = net_if_ipv4_get_best_match(dst_iface, dst,
  10d7e0:	8b 46 04             	mov    0x4(%esi),%eax
  10d7e3:	8d 4d f3             	lea    -0xd(%ebp),%ecx
  10d7e6:	8b 55 0c             	mov    0xc(%ebp),%edx
  10d7e9:	e8 1c fc ff ff       	call   10d40a <net_if_ipv4_get_best_match.isra.0>
  10d7ee:	eb 36                	jmp    10d826 <net_if_ipv4_select_src_addr+0x70>
	struct in_addr *src = NULL;
  10d7f0:	31 db                	xor    %ebx,%ebx
			Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d7f2:	bf 40 5e 14 00       	mov    $0x145e40,%edi
  10d7f7:	81 ff 48 5e 14 00    	cmp    $0x145e48,%edi
  10d7fd:	73 4d                	jae    10d84c <net_if_ipv4_select_src_addr+0x96>
				addr = net_if_ipv4_get_best_match(iface, dst,
  10d7ff:	8b 47 04             	mov    0x4(%edi),%eax
  10d802:	8d 4d f3             	lea    -0xd(%ebp),%ecx
  10d805:	8b 55 0c             	mov    0xc(%ebp),%edx
  10d808:	e8 fd fb ff ff       	call   10d40a <net_if_ipv4_get_best_match.isra.0>
				if (addr) {
  10d80d:	85 c0                	test   %eax,%eax
  10d80f:	74 02                	je     10d813 <net_if_ipv4_select_src_addr+0x5d>
  10d811:	89 c3                	mov    %eax,%ebx
			Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d813:	83 c7 08             	add    $0x8,%edi
  10d816:	eb df                	jmp    10d7f7 <net_if_ipv4_select_src_addr+0x41>
		if (dst_iface) {
  10d818:	85 f6                	test   %esi,%esi
  10d81a:	74 0e                	je     10d82a <net_if_ipv4_select_src_addr+0x74>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
  10d81c:	6a 01                	push   $0x1
  10d81e:	56                   	push   %esi
  10d81f:	e8 6b ff ff ff       	call   10d78f <net_if_ipv4_get_ll>
  10d824:	59                   	pop    %ecx
  10d825:	5b                   	pop    %ebx
  10d826:	89 c3                	mov    %eax,%ebx
  10d828:	eb 22                	jmp    10d84c <net_if_ipv4_select_src_addr+0x96>
			Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d82a:	bf 40 5e 14 00       	mov    $0x145e40,%edi
  10d82f:	81 ff 48 5e 14 00    	cmp    $0x145e48,%edi
  10d835:	73 19                	jae    10d850 <net_if_ipv4_select_src_addr+0x9a>
				addr = net_if_ipv4_get_ll(iface,
  10d837:	6a 01                	push   $0x1
  10d839:	57                   	push   %edi
  10d83a:	e8 50 ff ff ff       	call   10d78f <net_if_ipv4_get_ll>
  10d83f:	5b                   	pop    %ebx
				if (addr) {
  10d840:	85 c0                	test   %eax,%eax
				addr = net_if_ipv4_get_ll(iface,
  10d842:	5a                   	pop    %edx
  10d843:	89 c3                	mov    %eax,%ebx
				if (addr) {
  10d845:	75 20                	jne    10d867 <net_if_ipv4_select_src_addr+0xb1>
			Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d847:	83 c7 08             	add    $0x8,%edi
  10d84a:	eb e3                	jmp    10d82f <net_if_ipv4_select_src_addr+0x79>
	if (!src) {
  10d84c:	85 db                	test   %ebx,%ebx
  10d84e:	75 17                	jne    10d867 <net_if_ipv4_select_src_addr+0xb1>
		src = net_if_ipv4_get_global_addr(dst_iface,
  10d850:	6a 01                	push   $0x1
  10d852:	56                   	push   %esi
  10d853:	e8 4c ff ff ff       	call   10d7a4 <net_if_ipv4_get_global_addr>
  10d858:	5a                   	pop    %edx
  10d859:	89 c3                	mov    %eax,%ebx
  10d85b:	59                   	pop    %ecx
		if (src) {
  10d85c:	85 c0                	test   %eax,%eax
  10d85e:	75 07                	jne    10d867 <net_if_ipv4_select_src_addr+0xb1>
		return net_ipv4_unspecified_address();
  10d860:	e8 ee 0c 00 00       	call   10e553 <net_ipv4_unspecified_address>
  10d865:	89 c3                	mov    %eax,%ebx
}
  10d867:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10d86a:	89 d8                	mov    %ebx,%eax
  10d86c:	5b                   	pop    %ebx
  10d86d:	5e                   	pop    %esi
  10d86e:	5f                   	pop    %edi
  10d86f:	5d                   	pop    %ebp
  10d870:	c3                   	ret    

0010d871 <net_if_ipv4_addr_lookup>:
{
  10d871:	55                   	push   %ebp
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d872:	ba 40 5e 14 00       	mov    $0x145e40,%edx
{
  10d877:	89 e5                	mov    %esp,%ebp
  10d879:	53                   	push   %ebx
  10d87a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d87d:	81 fa 48 5e 14 00    	cmp    $0x145e48,%edx
  10d883:	73 2a                	jae    10d8af <net_if_ipv4_addr_lookup+0x3e>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
  10d885:	8b 42 04             	mov    0x4(%edx),%eax
		if (!ipv4) {
  10d888:	85 c0                	test   %eax,%eax
  10d88a:	74 1e                	je     10d8aa <net_if_ipv4_addr_lookup+0x39>
			if (!ipv4->unicast[i].is_used ||
  10d88c:	f6 40 16 02          	testb  $0x2,0x16(%eax)
  10d890:	74 18                	je     10d8aa <net_if_ipv4_addr_lookup+0x39>
  10d892:	66 83 38 01          	cmpw   $0x1,(%eax)
  10d896:	75 12                	jne    10d8aa <net_if_ipv4_addr_lookup+0x39>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
  10d898:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10d89b:	8b 1b                	mov    (%ebx),%ebx
  10d89d:	39 58 04             	cmp    %ebx,0x4(%eax)
  10d8a0:	75 08                	jne    10d8aa <net_if_ipv4_addr_lookup+0x39>
				if (ret) {
  10d8a2:	85 c9                	test   %ecx,%ecx
  10d8a4:	74 0b                	je     10d8b1 <net_if_ipv4_addr_lookup+0x40>
					*ret = iface;
  10d8a6:	89 11                	mov    %edx,(%ecx)
				return &ipv4->unicast[i];
  10d8a8:	eb 07                	jmp    10d8b1 <net_if_ipv4_addr_lookup+0x40>
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d8aa:	83 c2 08             	add    $0x8,%edx
  10d8ad:	eb ce                	jmp    10d87d <net_if_ipv4_addr_lookup+0xc>
	return NULL;
  10d8af:	31 c0                	xor    %eax,%eax
}
  10d8b1:	5b                   	pop    %ebx
  10d8b2:	5d                   	pop    %ebp
  10d8b3:	c3                   	ret    

0010d8b4 <net_if_ipv4_set_netmask>:
{
  10d8b4:	55                   	push   %ebp
  10d8b5:	89 e5                	mov    %esp,%ebp
  10d8b7:	53                   	push   %ebx
	if (net_if_config_ipv4_get(iface, NULL) < 0) {
  10d8b8:	6a 00                	push   $0x0
{
  10d8ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_if_config_ipv4_get(iface, NULL) < 0) {
  10d8bd:	53                   	push   %ebx
  10d8be:	e8 a4 fd ff ff       	call   10d667 <net_if_config_ipv4_get>
  10d8c3:	5a                   	pop    %edx
  10d8c4:	85 c0                	test   %eax,%eax
  10d8c6:	59                   	pop    %ecx
  10d8c7:	78 0f                	js     10d8d8 <net_if_ipv4_set_netmask+0x24>
	if (!iface->config.ip.ipv4) {
  10d8c9:	8b 43 04             	mov    0x4(%ebx),%eax
  10d8cc:	85 c0                	test   %eax,%eax
  10d8ce:	74 08                	je     10d8d8 <net_if_ipv4_set_netmask+0x24>
	net_ipaddr_copy(&iface->config.ip.ipv4->netmask, netmask);
  10d8d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  10d8d3:	8b 12                	mov    (%edx),%edx
  10d8d5:	89 50 34             	mov    %edx,0x34(%eax)
}
  10d8d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10d8db:	c9                   	leave  
  10d8dc:	c3                   	ret    

0010d8dd <net_if_ipv4_addr_add>:
{
  10d8dd:	55                   	push   %ebp
  10d8de:	89 e5                	mov    %esp,%ebp
  10d8e0:	56                   	push   %esi
  10d8e1:	53                   	push   %ebx
  10d8e2:	83 ec 08             	sub    $0x8,%esp
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
  10d8e5:	8d 45 f4             	lea    -0xc(%ebp),%eax
{
  10d8e8:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10d8eb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
  10d8ee:	50                   	push   %eax
{
  10d8ef:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
  10d8f2:	53                   	push   %ebx
{
  10d8f3:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
  10d8f6:	e8 6c fd ff ff       	call   10d667 <net_if_config_ipv4_get>
  10d8fb:	5a                   	pop    %edx
  10d8fc:	89 c2                	mov    %eax,%edx
  10d8fe:	59                   	pop    %ecx
		return NULL;
  10d8ff:	31 c0                	xor    %eax,%eax
	if (net_if_config_ipv4_get(iface, &ipv4) < 0) {
  10d901:	85 d2                	test   %edx,%edx
  10d903:	78 78                	js     10d97d <net_if_ipv4_addr_add+0xa0>
	ifaddr = ipv4_addr_find(iface, addr);
  10d905:	8b 43 04             	mov    0x4(%ebx),%eax
		if (!ipv4->unicast[i].is_used) {
  10d908:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10d90b:	f6 40 16 02          	testb  $0x2,0x16(%eax)
  10d90f:	74 07                	je     10d918 <net_if_ipv4_addr_add+0x3b>
		if (net_ipv4_addr_cmp(addr,
  10d911:	8b 50 04             	mov    0x4(%eax),%edx
  10d914:	39 16                	cmp    %edx,(%esi)
  10d916:	74 65                	je     10d97d <net_if_ipv4_addr_add+0xa0>
		struct net_if_addr *cur = &ipv4->unicast[i];
  10d918:	8b 55 f4             	mov    -0xc(%ebp),%edx
		if (addr_type == NET_ADDR_DHCP
  10d91b:	80 f9 02             	cmp    $0x2,%cl
  10d91e:	75 06                	jne    10d926 <net_if_ipv4_addr_add+0x49>
		    && cur->addr_type == NET_ADDR_OVERRIDABLE) {
  10d920:	80 7a 14 04          	cmpb   $0x4,0x14(%edx)
  10d924:	74 08                	je     10d92e <net_if_ipv4_addr_add+0x51>
		return NULL;
  10d926:	31 c0                	xor    %eax,%eax
		if (!ipv4->unicast[i].is_used) {
  10d928:	f6 42 16 02          	testb  $0x2,0x16(%edx)
  10d92c:	75 4f                	jne    10d97d <net_if_ipv4_addr_add+0xa0>
		struct net_if_addr *cur = &ipv4->unicast[i];
  10d92e:	89 d0                	mov    %edx,%eax
	if (ifaddr) {
  10d930:	85 d2                	test   %edx,%edx
  10d932:	74 49                	je     10d97d <net_if_ipv4_addr_add+0xa0>
		ifaddr->is_used = true;
  10d934:	80 4a 16 02          	orb    $0x2,0x16(%edx)
		ifaddr->address.family = AF_INET;
  10d938:	66 c7 02 01 00       	movw   $0x1,(%edx)
						&ifaddr->address.in_addr,
  10d93d:	89 45 f0             	mov    %eax,-0x10(%ebp)
						addr->s4_addr32[0];
  10d940:	8b 16                	mov    (%esi),%edx
		ifaddr->addr_type = addr_type;
  10d942:	88 48 14             	mov    %cl,0x14(%eax)
		ifaddr->address.in_addr.s4_addr32[0] =
  10d945:	89 50 04             	mov    %edx,0x4(%eax)
		if (vlifetime) {
  10d948:	31 d2                	xor    %edx,%edx
  10d94a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10d94e:	0f 94 c2             	sete   %dl
		ifaddr->addr_state = NET_ADDR_PREFERRED;
  10d951:	c1 e2 08             	shl    $0x8,%edx
  10d954:	66 8b 48 15          	mov    0x15(%eax),%cx
  10d958:	66 81 e1 00 fe       	and    $0xfe00,%cx
  10d95d:	83 ca 01             	or     $0x1,%edx
  10d960:	09 ca                	or     %ecx,%edx
  10d962:	66 89 50 15          	mov    %dx,0x15(%eax)
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
  10d966:	6a 04                	push   $0x4
						&ifaddr->address.in_addr,
  10d968:	8d 50 04             	lea    0x4(%eax),%edx
		net_mgmt_event_notify_with_info(NET_EVENT_IPV4_ADDR_ADD, iface,
  10d96b:	52                   	push   %edx
  10d96c:	53                   	push   %ebx
  10d96d:	68 01 00 04 e0       	push   $0xe0040001
  10d972:	e8 6f 0e 00 00       	call   10e7e6 <net_mgmt_event_notify_with_info>
  10d977:	83 c4 10             	add    $0x10,%esp
		return ifaddr;
  10d97a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  10d97d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10d980:	5b                   	pop    %ebx
  10d981:	5e                   	pop    %esi
  10d982:	5d                   	pop    %ebp
  10d983:	c3                   	ret    

0010d984 <net_if_ipv4_maddr_lookup>:
{
  10d984:	55                   	push   %ebp
  10d985:	89 e5                	mov    %esp,%ebp
  10d987:	56                   	push   %esi
  10d988:	53                   	push   %ebx
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d989:	bb 40 5e 14 00       	mov    $0x145e40,%ebx
{
  10d98e:	8b 75 0c             	mov    0xc(%ebp),%esi
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d991:	81 fb 48 5e 14 00    	cmp    $0x145e48,%ebx
  10d997:	73 2e                	jae    10d9c7 <net_if_ipv4_maddr_lookup+0x43>
		if (ret && *ret && iface != *ret) {
  10d999:	85 f6                	test   %esi,%esi
  10d99b:	74 0a                	je     10d9a7 <net_if_ipv4_maddr_lookup+0x23>
  10d99d:	8b 06                	mov    (%esi),%eax
  10d99f:	85 c0                	test   %eax,%eax
  10d9a1:	74 04                	je     10d9a7 <net_if_ipv4_maddr_lookup+0x23>
  10d9a3:	39 d8                	cmp    %ebx,%eax
  10d9a5:	75 1b                	jne    10d9c2 <net_if_ipv4_maddr_lookup+0x3e>
		addr = ipv4_maddr_find(iface, true, maddr);
  10d9a7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10d9aa:	ba 01 00 00 00       	mov    $0x1,%edx
  10d9af:	89 d8                	mov    %ebx,%eax
  10d9b1:	e8 e8 f9 ff ff       	call   10d39e <ipv4_maddr_find>
		if (addr) {
  10d9b6:	85 c0                	test   %eax,%eax
  10d9b8:	74 08                	je     10d9c2 <net_if_ipv4_maddr_lookup+0x3e>
			if (ret) {
  10d9ba:	85 f6                	test   %esi,%esi
  10d9bc:	74 0b                	je     10d9c9 <net_if_ipv4_maddr_lookup+0x45>
				*ret = iface;
  10d9be:	89 1e                	mov    %ebx,(%esi)
  10d9c0:	eb 07                	jmp    10d9c9 <net_if_ipv4_maddr_lookup+0x45>
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10d9c2:	83 c3 08             	add    $0x8,%ebx
  10d9c5:	eb ca                	jmp    10d991 <net_if_ipv4_maddr_lookup+0xd>
	return NULL;
  10d9c7:	31 c0                	xor    %eax,%eax
}
  10d9c9:	5b                   	pop    %ebx
  10d9ca:	5e                   	pop    %esi
  10d9cb:	5d                   	pop    %ebp
  10d9cc:	c3                   	ret    

0010d9cd <net_if_recv_data>:
{
  10d9cd:	55                   	push   %ebp
  10d9ce:	89 e5                	mov    %esp,%ebp
	return net_if_l2(iface)->recv(iface, pkt);
  10d9d0:	8b 45 08             	mov    0x8(%ebp),%eax
  10d9d3:	e8 37 f9 ff ff       	call   10d30f <net_if_l2>
}
  10d9d8:	5d                   	pop    %ebp
	return net_if_l2(iface)->recv(iface, pkt);
  10d9d9:	8b 00                	mov    (%eax),%eax
  10d9db:	ff e0                	jmp    *%eax

0010d9dd <net_if_call_link_cb>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
  10d9dd:	a1 b8 eb 12 00       	mov    0x12ebb8,%eax
  10d9e2:	85 c0                	test   %eax,%eax
  10d9e4:	74 24                	je     10da0a <net_if_call_link_cb+0x2d>
{
  10d9e6:	55                   	push   %ebp
  10d9e7:	89 e5                	mov    %esp,%ebp
  10d9e9:	53                   	push   %ebx
  10d9ea:	8b 18                	mov    (%eax),%ebx
		link->cb(iface, lladdr, status);
  10d9ec:	ff 75 10             	pushl  0x10(%ebp)
  10d9ef:	ff 75 0c             	pushl  0xc(%ebp)
  10d9f2:	ff 75 08             	pushl  0x8(%ebp)
  10d9f5:	ff 50 04             	call   *0x4(%eax)
  10d9f8:	83 c4 0c             	add    $0xc,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
  10d9fb:	85 db                	test   %ebx,%ebx
  10d9fd:	74 06                	je     10da05 <net_if_call_link_cb+0x28>
  10d9ff:	89 d8                	mov    %ebx,%eax
  10da01:	8b 1b                	mov    (%ebx),%ebx
  10da03:	eb e7                	jmp    10d9ec <net_if_call_link_cb+0xf>
}
  10da05:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10da08:	c9                   	leave  
  10da09:	c3                   	ret    
  10da0a:	c3                   	ret    

0010da0b <process_tx_packet>:
{
  10da0b:	55                   	push   %ebp
  10da0c:	89 e5                	mov    %esp,%ebp
  10da0e:	57                   	push   %edi
  10da0f:	56                   	push   %esi
  10da10:	53                   	push   %ebx
  10da11:	83 ec 14             	sub    $0x14,%esp
	struct net_linkaddr ll_dst = {
  10da14:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
{
  10da1b:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct net_linkaddr ll_dst = {
  10da1e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	if (!sys_slist_is_empty(&link_callbacks)) {
  10da25:	83 3d b8 eb 12 00 00 	cmpl   $0x0,0x12ebb8
	iface = net_pkt_iface(pkt);
  10da2c:	8b 77 20             	mov    0x20(%edi),%esi
	if (!sys_slist_is_empty(&link_callbacks)) {
  10da2f:	74 2f                	je     10da60 <process_tx_packet+0x55>
				     net_pkt_lladdr_dst(pkt)->len) == 0) {
  10da31:	0f b6 47 34          	movzbl 0x34(%edi),%eax
		if (net_linkaddr_set(&ll_dst_storage,
  10da35:	8b 4f 30             	mov    0x30(%edi),%ecx
{
	if (!lladdr_store || !new_addr) {
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
  10da38:	3c 06                	cmp    $0x6,%al
  10da3a:	77 24                	ja     10da60 <process_tx_packet+0x55>
  10da3c:	85 c9                	test   %ecx,%ecx
  10da3e:	74 20                	je     10da60 <process_tx_packet+0x55>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
	memcpy(lladdr_store->addr, new_addr, new_len);
  10da40:	50                   	push   %eax
  10da41:	8d 5d ee             	lea    -0x12(%ebp),%ebx
  10da44:	51                   	push   %ecx
	lladdr_store->len = new_len;
  10da45:	88 45 ed             	mov    %al,-0x13(%ebp)
	memcpy(lladdr_store->addr, new_addr, new_len);
  10da48:	53                   	push   %ebx
  10da49:	e8 9e e3 ff ff       	call   10bdec <memcpy>
			ll_dst.len = ll_dst_storage.len;
  10da4e:	8a 45 ed             	mov    -0x13(%ebp),%al
  10da51:	83 c4 0c             	add    $0xc,%esp
  10da54:	88 45 e8             	mov    %al,-0x18(%ebp)
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
  10da57:	8a 47 35             	mov    0x35(%edi),%al
			ll_dst.addr = ll_dst_storage.addr;
  10da5a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
  10da5d:	88 45 e9             	mov    %al,-0x17(%ebp)
	context = net_pkt_context(pkt);
  10da60:	8b 47 1c             	mov    0x1c(%edi),%eax
  10da63:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10da66:	8b 06                	mov    (%esi),%eax
  10da68:	8b 40 0c             	mov    0xc(%eax),%eax
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
  10da6b:	a8 01                	test   $0x1,%al
  10da6d:	74 20                	je     10da8f <process_tx_packet+0x84>
		if (IS_ENABLED(CONFIG_NET_TCP) &&
  10da6f:	f6 47 3f 0e          	testb  $0xe,0x3f(%edi)
  10da73:	74 04                	je     10da79 <process_tx_packet+0x6e>
	pkt->pkt_queued = send;
  10da75:	80 67 3e fe          	andb   $0xfe,0x3e(%edi)
		status = net_if_l2(iface)->send(iface, pkt);
  10da79:	89 f0                	mov    %esi,%eax
  10da7b:	e8 8f f8 ff ff       	call   10d30f <net_if_l2>
  10da80:	57                   	push   %edi
  10da81:	56                   	push   %esi
  10da82:	ff 50 04             	call   *0x4(%eax)
  10da85:	5a                   	pop    %edx
  10da86:	59                   	pop    %ecx
  10da87:	89 c3                	mov    %eax,%ebx
	if (status < 0) {
  10da89:	85 c0                	test   %eax,%eax
  10da8b:	79 39                	jns    10dac6 <process_tx_packet+0xbb>
  10da8d:	eb 30                	jmp    10dabf <process_tx_packet+0xb4>
		NET_WARN("iface %p is down", iface);
  10da8f:	f6 05 c8 5b 14 00 06 	testb  $0x6,0x145bc8
		status = -ENETDOWN;
  10da96:	bb c2 ff ff ff       	mov    $0xffffffc2,%ebx
		NET_WARN("iface %p is down", iface);
  10da9b:	74 22                	je     10dabf <process_tx_packet+0xb4>
  10da9d:	b8 10 31 12 00       	mov    $0x123110,%eax
  10daa2:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10daa7:	c1 e8 03             	shr    $0x3,%eax
  10daaa:	c1 e0 06             	shl    $0x6,%eax
  10daad:	83 c8 02             	or     $0x2,%eax
  10dab0:	50                   	push   %eax
  10dab1:	56                   	push   %esi
  10dab2:	68 6c 5d 12 00       	push   $0x125d6c
  10dab7:	e8 ba 5a ff ff       	call   103576 <log_1>
  10dabc:	83 c4 0c             	add    $0xc,%esp
		net_pkt_unref(pkt);
  10dabf:	57                   	push   %edi
  10dac0:	e8 b7 1f 00 00       	call   10fa7c <net_pkt_unref>
  10dac5:	58                   	pop    %eax
	if (context) {
  10dac6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  10daca:	74 0a                	je     10dad6 <process_tx_packet+0xcb>
		net_context_send_cb(context, status);
  10dacc:	89 da                	mov    %ebx,%edx
  10dace:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10dad1:	e8 47 f8 ff ff       	call   10d31d <net_context_send_cb>
	if (ll_dst.addr) {
  10dad6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  10dada:	74 0e                	je     10daea <process_tx_packet+0xdf>
		net_if_call_link_cb(iface, &ll_dst, status);
  10dadc:	53                   	push   %ebx
  10dadd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  10dae0:	50                   	push   %eax
  10dae1:	56                   	push   %esi
  10dae2:	e8 f6 fe ff ff       	call   10d9dd <net_if_call_link_cb>
  10dae7:	83 c4 0c             	add    $0xc,%esp
}
  10daea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10daed:	5b                   	pop    %ebx
  10daee:	5e                   	pop    %esi
  10daef:	5f                   	pop    %edi
  10daf0:	5d                   	pop    %ebp
  10daf1:	c3                   	ret    

0010daf2 <net_if_send_data>:
{
  10daf2:	55                   	push   %ebp
  10daf3:	89 e5                	mov    %esp,%ebp
  10daf5:	57                   	push   %edi
  10daf6:	56                   	push   %esi
  10daf7:	53                   	push   %ebx
  10daf8:	51                   	push   %ecx
  10daf9:	8b 75 08             	mov    0x8(%ebp),%esi
  10dafc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10daff:	8b 06                	mov    (%esi),%eax
	struct net_context *context = net_pkt_context(pkt);
  10db01:	8b 7b 1c             	mov    0x1c(%ebx),%edi
  10db04:	8b 40 0c             	mov    0xc(%eax),%eax
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
  10db07:	a8 01                	test   $0x1,%al
  10db09:	75 2d                	jne    10db38 <net_if_send_data+0x46>
		NET_WARN("iface %p is down", iface);
  10db0b:	f6 05 c8 5b 14 00 06 	testb  $0x6,0x145bc8
  10db12:	74 2f                	je     10db43 <net_if_send_data+0x51>
  10db14:	b8 10 31 12 00       	mov    $0x123110,%eax
  10db19:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10db1e:	c1 e8 03             	shr    $0x3,%eax
  10db21:	c1 e0 06             	shl    $0x6,%eax
  10db24:	83 c8 02             	or     $0x2,%eax
  10db27:	50                   	push   %eax
  10db28:	56                   	push   %esi
  10db29:	68 6c 5d 12 00       	push   $0x125d6c
  10db2e:	e8 43 5a ff ff       	call   103576 <log_1>
  10db33:	83 c4 0c             	add    $0xc,%esp
  10db36:	eb 0b                	jmp    10db43 <net_if_send_data+0x51>
  10db38:	8b 06                	mov    (%esi),%eax
  10db3a:	8b 40 0c             	mov    0xc(%eax),%eax
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
  10db3d:	a8 10                	test   $0x10,%al
  10db3f:	75 ca                	jne    10db0b <net_if_send_data+0x19>
  10db41:	eb 12                	jmp    10db55 <net_if_send_data+0x63>
		if (context) {
  10db43:	85 ff                	test   %edi,%edi
  10db45:	74 30                	je     10db77 <net_if_send_data+0x85>
			net_context_send_cb(context, status);
  10db47:	ba c2 ff ff ff       	mov    $0xffffffc2,%edx
  10db4c:	89 f8                	mov    %edi,%eax
  10db4e:	e8 ca f7 ff ff       	call   10d31d <net_context_send_cb>
  10db53:	eb 22                	jmp    10db77 <net_if_send_data+0x85>
  10db55:	8b 06                	mov    (%esi),%eax
  10db57:	8b 40 0c             	mov    0xc(%eax),%eax
	if (!net_if_flag_is_set(iface, NET_IF_POINTOPOINT) &&
  10db5a:	a8 02                	test   $0x2,%al
  10db5c:	75 3b                	jne    10db99 <net_if_send_data+0xa7>
  10db5e:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
  10db62:	75 35                	jne    10db99 <net_if_send_data+0xa7>
	return net_if_get_link_addr(pkt->iface);
  10db64:	8b 43 20             	mov    0x20(%ebx),%eax
  10db67:	8b 00                	mov    (%eax),%eax
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
  10db69:	8b 50 10             	mov    0x10(%eax),%edx
  10db6c:	89 53 28             	mov    %edx,0x28(%ebx)
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
  10db6f:	8a 40 14             	mov    0x14(%eax),%al
  10db72:	88 43 2c             	mov    %al,0x2c(%ebx)
	if (verdict == NET_DROP) {
  10db75:	eb 22                	jmp    10db99 <net_if_send_data+0xa7>
		if (dst->addr) {
  10db77:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
		verdict = NET_DROP;
  10db7b:	b8 02 00 00 00       	mov    $0x2,%eax
		if (dst->addr) {
  10db80:	74 22                	je     10dba4 <net_if_send_data+0xb2>
			net_if_call_link_cb(iface, dst, status);
  10db82:	6a c2                	push   $0xffffffc2
	return &pkt->lladdr_dst;
  10db84:	83 c3 30             	add    $0x30,%ebx
  10db87:	53                   	push   %ebx
  10db88:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10db8b:	56                   	push   %esi
  10db8c:	e8 4c fe ff ff       	call   10d9dd <net_if_call_link_cb>
  10db91:	83 c4 0c             	add    $0xc,%esp
  10db94:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10db97:	eb 0b                	jmp    10dba4 <net_if_send_data+0xb2>
		net_if_queue_tx(iface, pkt);
  10db99:	53                   	push   %ebx
  10db9a:	56                   	push   %esi
  10db9b:	e8 5f fa ff ff       	call   10d5ff <net_if_queue_tx>
  10dba0:	58                   	pop    %eax
  10dba1:	31 c0                	xor    %eax,%eax
  10dba3:	5a                   	pop    %edx
}
  10dba4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10dba7:	5b                   	pop    %ebx
  10dba8:	5e                   	pop    %esi
  10dba9:	5f                   	pop    %edi
  10dbaa:	5d                   	pop    %ebp
  10dbab:	c3                   	ret    

0010dbac <net_if_need_calc_tx_checksum>:

bool net_if_need_calc_tx_checksum(struct net_if *iface)
{
  10dbac:	55                   	push   %ebp
  10dbad:	89 e5                	mov    %esp,%ebp
  10dbaf:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
  10dbb2:	89 c8                	mov    %ecx,%eax
  10dbb4:	e8 56 f7 ff ff       	call   10d30f <net_if_l2>
  10dbb9:	3d 64 5e 14 00       	cmp    $0x145e64,%eax
  10dbbe:	75 0d                	jne    10dbcd <net_if_need_calc_tx_checksum+0x21>
  10dbc0:	ba 01 00 00 00       	mov    $0x1,%edx
  10dbc5:	89 c8                	mov    %ecx,%eax
	return need_calc_checksum(iface, ETHERNET_HW_TX_CHKSUM_OFFLOAD);
}
  10dbc7:	5d                   	pop    %ebp
  10dbc8:	e9 17 f8 ff ff       	jmp    10d3e4 <need_calc_checksum.part.0>
  10dbcd:	b0 01                	mov    $0x1,%al
  10dbcf:	5d                   	pop    %ebp
  10dbd0:	c3                   	ret    

0010dbd1 <net_if_need_calc_rx_checksum>:

bool net_if_need_calc_rx_checksum(struct net_if *iface)
{
  10dbd1:	55                   	push   %ebp
  10dbd2:	89 e5                	mov    %esp,%ebp
  10dbd4:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (net_if_l2(iface) != &NET_L2_GET_NAME(ETHERNET)) {
  10dbd7:	89 c8                	mov    %ecx,%eax
  10dbd9:	e8 31 f7 ff ff       	call   10d30f <net_if_l2>
  10dbde:	3d 64 5e 14 00       	cmp    $0x145e64,%eax
  10dbe3:	75 0d                	jne    10dbf2 <net_if_need_calc_rx_checksum+0x21>
  10dbe5:	ba 02 00 00 00       	mov    $0x2,%edx
  10dbea:	89 c8                	mov    %ecx,%eax
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
}
  10dbec:	5d                   	pop    %ebp
  10dbed:	e9 f2 f7 ff ff       	jmp    10d3e4 <need_calc_checksum.part.0>
  10dbf2:	b0 01                	mov    $0x1,%al
  10dbf4:	5d                   	pop    %ebp
  10dbf5:	c3                   	ret    

0010dbf6 <net_if_get_by_iface>:

int net_if_get_by_iface(struct net_if *iface)
{
  10dbf6:	55                   	push   %ebp
  10dbf7:	89 e5                	mov    %esp,%ebp
  10dbf9:	8b 45 08             	mov    0x8(%ebp),%eax
	if (!(iface >= _net_if_list_start && iface < _net_if_list_end)) {
  10dbfc:	3d 40 5e 14 00       	cmp    $0x145e40,%eax
  10dc01:	72 12                	jb     10dc15 <net_if_get_by_iface+0x1f>
  10dc03:	3d 48 5e 14 00       	cmp    $0x145e48,%eax
  10dc08:	73 0b                	jae    10dc15 <net_if_get_by_iface+0x1f>
		return -1;
	}

	return (iface - _net_if_list_start) + 1;
  10dc0a:	2d 40 5e 14 00       	sub    $0x145e40,%eax
  10dc0f:	c1 f8 03             	sar    $0x3,%eax
  10dc12:	40                   	inc    %eax
  10dc13:	eb 03                	jmp    10dc18 <net_if_get_by_iface+0x22>
		return -1;
  10dc15:	83 c8 ff             	or     $0xffffffff,%eax
}
  10dc18:	5d                   	pop    %ebp
  10dc19:	c3                   	ret    

0010dc1a <net_if_foreach>:

void net_if_foreach(net_if_cb_t cb, void *user_data)
{
  10dc1a:	55                   	push   %ebp
  10dc1b:	89 e5                	mov    %esp,%ebp
  10dc1d:	53                   	push   %ebx
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dc1e:	bb 40 5e 14 00       	mov    $0x145e40,%ebx
  10dc23:	81 fb 48 5e 14 00    	cmp    $0x145e48,%ebx
  10dc29:	73 0e                	jae    10dc39 <net_if_foreach+0x1f>
		cb(iface, user_data);
  10dc2b:	ff 75 0c             	pushl  0xc(%ebp)
  10dc2e:	53                   	push   %ebx
  10dc2f:	ff 55 08             	call   *0x8(%ebp)
  10dc32:	58                   	pop    %eax
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dc33:	83 c3 08             	add    $0x8,%ebx
		cb(iface, user_data);
  10dc36:	5a                   	pop    %edx
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dc37:	eb ea                	jmp    10dc23 <net_if_foreach+0x9>
	}
}
  10dc39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10dc3c:	c9                   	leave  
  10dc3d:	c3                   	ret    

0010dc3e <net_if_up>:

int net_if_up(struct net_if *iface)
{
  10dc3e:	55                   	push   %ebp
  10dc3f:	89 e5                	mov    %esp,%ebp
  10dc41:	53                   	push   %ebx
  10dc42:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10dc45:	8b 03                	mov    (%ebx),%eax
  10dc47:	8b 50 0c             	mov    0xc(%eax),%edx
	int status;

	NET_DBG("iface %p", iface);

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
		return 0;
  10dc4a:	31 c0                	xor    %eax,%eax
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
  10dc4c:	80 e2 01             	and    $0x1,%dl
  10dc4f:	75 41                	jne    10dc92 <net_if_up+0x54>
		net_if_flag_set(iface, NET_IF_UP);
		goto exit;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
  10dc51:	89 d8                	mov    %ebx,%eax
  10dc53:	e8 b7 f6 ff ff       	call   10d30f <net_if_l2>
  10dc58:	85 c0                	test   %eax,%eax
  10dc5a:	75 24                	jne    10dc80 <net_if_up+0x42>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  10dc5c:	8b 03                	mov    (%ebx),%eax
  10dc5e:	f0 83 48 0c 01       	lock orl $0x1,0xc(%eax)
	net_if_flag_set(iface, NET_IF_UP);

	/* If the interface is only having point-to-point traffic then we do
	 * not need to run DAD etc for it.
	 */
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
  10dc63:	89 d8                	mov    %ebx,%eax
  10dc65:	e8 cd f6 ff ff       	call   10d337 <l2_flags_get>
				     const void *info, size_t length);

static inline void net_mgmt_event_notify(uint32_t mgmt_event,
					 struct net_if *iface)
{
	net_mgmt_event_notify_with_info(mgmt_event, iface, NULL, 0);
  10dc6a:	6a 00                	push   $0x0
  10dc6c:	6a 00                	push   $0x0
  10dc6e:	53                   	push   %ebx
  10dc6f:	68 02 00 01 d0       	push   $0xd0010002
  10dc74:	e8 6d 0b 00 00       	call   10e7e6 <net_mgmt_event_notify_with_info>
  10dc79:	83 c4 10             	add    $0x10,%esp
  10dc7c:	31 c0                	xor    %eax,%eax
  10dc7e:	eb 12                	jmp    10dc92 <net_if_up+0x54>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
  10dc80:	8b 40 08             	mov    0x8(%eax),%eax
  10dc83:	85 c0                	test   %eax,%eax
  10dc85:	74 d5                	je     10dc5c <net_if_up+0x1e>
	status = net_if_l2(iface)->enable(iface, true);
  10dc87:	6a 01                	push   $0x1
  10dc89:	53                   	push   %ebx
  10dc8a:	ff d0                	call   *%eax
  10dc8c:	5a                   	pop    %edx
	if (status < 0) {
  10dc8d:	85 c0                	test   %eax,%eax
	status = net_if_l2(iface)->enable(iface, true);
  10dc8f:	59                   	pop    %ecx
	if (status < 0) {
  10dc90:	79 ca                	jns    10dc5c <net_if_up+0x1e>

exit:
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
}
  10dc92:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10dc95:	c9                   	leave  
  10dc96:	c3                   	ret    

0010dc97 <net_if_down>:

	net_mgmt_event_notify(NET_EVENT_IF_DOWN, iface);
}

int net_if_down(struct net_if *iface)
{
  10dc97:	55                   	push   %ebp
  10dc98:	89 e5                	mov    %esp,%ebp
  10dc9a:	53                   	push   %ebx
  10dc9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (net_if_is_ip_offloaded(iface)) {
		goto done;
	}

	/* If the L2 does not support enable just clear the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
  10dc9e:	89 d8                	mov    %ebx,%eax
  10dca0:	e8 6a f6 ff ff       	call   10d30f <net_if_l2>
  10dca5:	85 c0                	test   %eax,%eax
  10dca7:	75 1d                	jne    10dcc6 <net_if_down+0x2f>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  10dca9:	8b 03                	mov    (%ebx),%eax
  10dcab:	f0 83 60 0c fe       	lock andl $0xfffffffe,0xc(%eax)
  10dcb0:	6a 00                	push   $0x0
  10dcb2:	6a 00                	push   $0x0
  10dcb4:	53                   	push   %ebx
  10dcb5:	68 01 00 01 d0       	push   $0xd0010001
  10dcba:	e8 27 0b 00 00       	call   10e7e6 <net_mgmt_event_notify_with_info>
  10dcbf:	83 c4 10             	add    $0x10,%esp
done:
	net_if_flag_clear(iface, NET_IF_UP);

	net_mgmt_event_notify(NET_EVENT_IF_DOWN, iface);

	return 0;
  10dcc2:	31 c0                	xor    %eax,%eax
}
  10dcc4:	eb 12                	jmp    10dcd8 <net_if_down+0x41>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
  10dcc6:	8b 40 08             	mov    0x8(%eax),%eax
  10dcc9:	85 c0                	test   %eax,%eax
  10dccb:	74 dc                	je     10dca9 <net_if_down+0x12>
	status = net_if_l2(iface)->enable(iface, false);
  10dccd:	6a 00                	push   $0x0
  10dccf:	53                   	push   %ebx
  10dcd0:	ff d0                	call   *%eax
  10dcd2:	5a                   	pop    %edx
	if (status < 0) {
  10dcd3:	85 c0                	test   %eax,%eax
	status = net_if_l2(iface)->enable(iface, false);
  10dcd5:	59                   	pop    %ecx
	if (status < 0) {
  10dcd6:	79 d1                	jns    10dca9 <net_if_down+0x12>
}
  10dcd8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10dcdb:	c9                   	leave  
  10dcdc:	c3                   	ret    

0010dcdd <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
  10dcdd:	55                   	push   %ebp
  10dcde:	89 e5                	mov    %esp,%ebp
  10dce0:	57                   	push   %edi
  10dce1:	56                   	push   %esi

	NET_DBG("");

	net_tc_tx_init();

	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dce2:	be 40 5e 14 00       	mov    $0x145e40,%esi
{
  10dce7:	53                   	push   %ebx
	net_tc_tx_init();
  10dce8:	e8 a8 28 00 00       	call   110595 <net_tc_tx_init>
  10dced:	bb 10 31 12 00       	mov    $0x123110,%ebx
  10dcf2:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  10dcf8:	c1 eb 03             	shr    $0x3,%ebx
		NET_ERR("Iface %p driver API init NULL", iface);
  10dcfb:	89 df                	mov    %ebx,%edi
  10dcfd:	c1 e7 06             	shl    $0x6,%edi
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dd00:	81 fe 48 5e 14 00    	cmp    $0x145e48,%esi
  10dd06:	73 39                	jae    10dd41 <net_if_init+0x64>
  10dd08:	8b 06                	mov    (%esi),%eax
	const struct net_if_api *api = net_if_get_device(iface)->api;
  10dd0a:	8b 00                	mov    (%eax),%eax
  10dd0c:	8b 40 08             	mov    0x8(%eax),%eax
	if (!api || !api->init) {
  10dd0f:	85 c0                	test   %eax,%eax
  10dd11:	74 06                	je     10dd19 <net_if_init+0x3c>
  10dd13:	8b 00                	mov    (%eax),%eax
  10dd15:	85 c0                	test   %eax,%eax
  10dd17:	75 1f                	jne    10dd38 <net_if_init+0x5b>
		NET_ERR("Iface %p driver API init NULL", iface);
  10dd19:	f6 05 c8 5b 14 00 07 	testb  $0x7,0x145bc8
  10dd20:	74 1a                	je     10dd3c <net_if_init+0x5f>
  10dd22:	89 f8                	mov    %edi,%eax
  10dd24:	83 c8 01             	or     $0x1,%eax
  10dd27:	50                   	push   %eax
  10dd28:	56                   	push   %esi
  10dd29:	68 7d 5d 12 00       	push   $0x125d7d
  10dd2e:	e8 43 58 ff ff       	call   103576 <log_1>
  10dd33:	83 c4 0c             	add    $0xc,%esp
  10dd36:	eb 04                	jmp    10dd3c <net_if_init+0x5f>
	api->init(iface);
  10dd38:	56                   	push   %esi
  10dd39:	ff d0                	call   *%eax
  10dd3b:	58                   	pop    %eax
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dd3c:	83 c6 08             	add    $0x8,%esi
  10dd3f:	eb bf                	jmp    10dd00 <net_if_init+0x23>
  10dd41:	b8 39 5e 14 00       	mov    $0x145e39,%eax
  10dd46:	3d 48 5e 14 00       	cmp    $0x145e48,%eax
  10dd4b:	77 0f                	ja     10dd5c <net_if_init+0x7f>
		init_iface(iface);
		if_count++;
	}

	if (if_count == 0) {
  10dd4d:	b8 4f 5e 14 00       	mov    $0x145e4f,%eax
  10dd52:	2d 40 5e 14 00       	sub    $0x145e40,%eax
  10dd57:	c1 e8 03             	shr    $0x3,%eax
  10dd5a:	75 1e                	jne    10dd7a <net_if_init+0x9d>
		NET_ERR("There is no network interface to work with!");
  10dd5c:	f6 05 c8 5b 14 00 07 	testb  $0x7,0x145bc8
  10dd63:	74 7c                	je     10dde1 <net_if_init+0x104>
  10dd65:	c1 e3 06             	shl    $0x6,%ebx
  10dd68:	83 cb 01             	or     $0x1,%ebx
  10dd6b:	53                   	push   %ebx
  10dd6c:	68 9b 5d 12 00       	push   $0x125d9b
  10dd71:	e8 d7 57 ff ff       	call   10354d <log_0>
  10dd76:	5e                   	pop    %esi
  10dd77:	5f                   	pop    %edi
  10dd78:	eb 67                	jmp    10dde1 <net_if_init+0x104>
	if (if_count > ARRAY_SIZE(ipv4_addresses)) {
  10dd7a:	83 f8 01             	cmp    $0x1,%eax
  10dd7d:	74 36                	je     10ddb5 <net_if_init+0xd8>
		NET_WARN("You have %lu IPv4 net_if addresses but %d "
  10dd7f:	f6 05 c8 5b 14 00 06 	testb  $0x6,0x145bc8
  10dd86:	74 2d                	je     10ddb5 <net_if_init+0xd8>
  10dd88:	c1 e3 06             	shl    $0x6,%ebx
  10dd8b:	83 cb 02             	or     $0x2,%ebx
  10dd8e:	53                   	push   %ebx
  10dd8f:	50                   	push   %eax
  10dd90:	6a 01                	push   $0x1
  10dd92:	68 c7 5d 12 00       	push   $0x125dc7
  10dd97:	e8 14 58 ff ff       	call   1035b0 <log_2>
  10dd9c:	83 c4 10             	add    $0x10,%esp
		NET_WARN("Consider increasing CONFIG_NET_IF_MAX_IPV4_COUNT "
  10dd9f:	f6 05 c8 5b 14 00 06 	testb  $0x6,0x145bc8
  10dda6:	74 0d                	je     10ddb5 <net_if_init+0xd8>
  10dda8:	53                   	push   %ebx
  10dda9:	68 04 5e 12 00       	push   $0x125e04
  10ddae:	e8 9a 57 ff ff       	call   10354d <log_0>
  10ddb3:	59                   	pop    %ecx
  10ddb4:	5b                   	pop    %ebx
	k_delayed_work_init(&router_timer, iface_router_expired);
  10ddb5:	68 32 d5 10 00       	push   $0x10d532
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
  10ddba:	c6 05 98 a8 12 00 40 	movb   $0x40,0x12a898
	k_delayed_work_init(&router_timer, iface_router_expired);
  10ddc1:	68 a0 a8 12 00       	push   $0x12a8a0
  10ddc6:	e8 dc 40 01 00       	call   121ea7 <k_delayed_work_init>
  10ddcb:	58                   	pop    %eax
	list->head = NULL;
  10ddcc:	c7 05 c0 eb 12 00 00 	movl   $0x0,0x12ebc0
  10ddd3:	00 00 00 
  10ddd6:	5a                   	pop    %edx
	list->tail = NULL;
  10ddd7:	c7 05 c4 eb 12 00 00 	movl   $0x0,0x12ebc4
  10ddde:	00 00 00 
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
  10dde1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10dde4:	5b                   	pop    %ebx
  10dde5:	5e                   	pop    %esi
  10dde6:	5f                   	pop    %edi
  10dde7:	5d                   	pop    %ebp
  10dde8:	c3                   	ret    

0010dde9 <net_if_post_init>:

void net_if_post_init(void)
{
  10dde9:	55                   	push   %ebp
  10ddea:	89 e5                	mov    %esp,%ebp
  10ddec:	53                   	push   %ebx
	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10dded:	bb 40 5e 14 00       	mov    $0x145e40,%ebx
  10ddf2:	81 fb 48 5e 14 00    	cmp    $0x145e48,%ebx
  10ddf8:	73 15                	jae    10de0f <net_if_post_init+0x26>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10ddfa:	8b 03                	mov    (%ebx),%eax
  10ddfc:	8b 40 0c             	mov    0xc(%eax),%eax
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
  10ddff:	a8 08                	test   $0x8,%al
  10de01:	75 07                	jne    10de0a <net_if_post_init+0x21>
			net_if_up(iface);
  10de03:	53                   	push   %ebx
  10de04:	e8 35 fe ff ff       	call   10dc3e <net_if_up>
  10de09:	58                   	pop    %eax
	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
  10de0a:	83 c3 08             	add    $0x8,%ebx
  10de0d:	eb e3                	jmp    10ddf2 <net_if_post_init+0x9>
		}
	}
}
  10de0f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10de12:	c9                   	leave  
  10de13:	c3                   	ret    

0010de14 <calc_chksum>:
}
#include <syscalls/net_addr_pton_mrsh.c>
#endif /* CONFIG_USERSPACE */

static uint16_t calc_chksum(uint16_t sum, const uint8_t *data, size_t len)
{
  10de14:	55                   	push   %ebp
  10de15:	89 e5                	mov    %esp,%ebp
  10de17:	57                   	push   %edi
  10de18:	56                   	push   %esi
	const uint8_t *end;
	uint16_t tmp;

	end = data + len - 1;

	while (data < end) {
  10de19:	89 d6                	mov    %edx,%esi
{
  10de1b:	53                   	push   %ebx
	end = data + len - 1;
  10de1c:	8d 5c 0a ff          	lea    -0x1(%edx,%ecx,1),%ebx
	while (data < end) {
  10de20:	39 de                	cmp    %ebx,%esi
  10de22:	73 27                	jae    10de4b <calc_chksum+0x37>
		tmp = (data[0] << 8) + data[1];
  10de24:	0f b6 0e             	movzbl (%esi),%ecx
  10de27:	89 cf                	mov    %ecx,%edi
  10de29:	0f b6 4e 01          	movzbl 0x1(%esi),%ecx
  10de2d:	c1 e7 08             	shl    $0x8,%edi
  10de30:	01 f9                	add    %edi,%ecx
  10de32:	31 ff                	xor    %edi,%edi
  10de34:	66 01 c8             	add    %cx,%ax
  10de37:	73 05                	jae    10de3e <calc_chksum+0x2a>
  10de39:	bf 01 00 00 00       	mov    $0x1,%edi
		sum += tmp;
		if (sum < tmp) {
			sum++;
  10de3e:	66 83 ff 01          	cmp    $0x1,%di
  10de42:	66 83 d8 ff          	sbb    $0xffff,%ax
		}

		data += 2;
  10de46:	83 c6 02             	add    $0x2,%esi
  10de49:	eb d5                	jmp    10de20 <calc_chksum+0xc>
  10de4b:	8d 72 ff             	lea    -0x1(%edx),%esi
  10de4e:	31 c9                	xor    %ecx,%ecx
  10de50:	39 f3                	cmp    %esi,%ebx
  10de52:	72 08                	jb     10de5c <calc_chksum+0x48>
  10de54:	89 d9                	mov    %ebx,%ecx
  10de56:	29 d1                	sub    %edx,%ecx
  10de58:	41                   	inc    %ecx
  10de59:	83 e1 fe             	and    $0xfffffffe,%ecx
  10de5c:	01 ca                	add    %ecx,%edx
	}

	if (data == end) {
  10de5e:	39 da                	cmp    %ebx,%edx
  10de60:	75 1a                	jne    10de7c <calc_chksum+0x68>
		tmp = data[0] << 8;
  10de62:	0f b6 13             	movzbl (%ebx),%edx
  10de65:	c1 e2 08             	shl    $0x8,%edx
  10de68:	31 c9                	xor    %ecx,%ecx
  10de6a:	66 01 d0             	add    %dx,%ax
  10de6d:	73 05                	jae    10de74 <calc_chksum+0x60>
  10de6f:	b9 01 00 00 00       	mov    $0x1,%ecx
		sum += tmp;
		if (sum < tmp) {
			sum++;
  10de74:	66 83 f9 01          	cmp    $0x1,%cx
  10de78:	66 83 d8 ff          	sbb    $0xffff,%ax
		}
	}

	return sum;
}
  10de7c:	5b                   	pop    %ebx
  10de7d:	5e                   	pop    %esi
  10de7e:	5f                   	pop    %edi
  10de7f:	5d                   	pop    %ebp
  10de80:	c3                   	ret    

0010de81 <net_byte_to_hex>:
{
  10de81:	55                   	push   %ebp
  10de82:	89 e5                	mov    %esp,%ebp
  10de84:	57                   	push   %edi
  10de85:	56                   	push   %esi
  10de86:	53                   	push   %ebx
  10de87:	51                   	push   %ecx
  10de88:	8b 45 0c             	mov    0xc(%ebp),%eax
  10de8b:	8b 75 08             	mov    0x8(%ebp),%esi
  10de8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10de91:	8b 5d 10             	mov    0x10(%ebp),%ebx
		if (i == 0 && !pad && !val) {
  10de94:	8a 55 f0             	mov    -0x10(%ebp),%dl
{
  10de97:	8b 7d 14             	mov    0x14(%ebp),%edi
		if (i == 0 && !pad && !val) {
  10de9a:	c0 ea 04             	shr    $0x4,%dl
  10de9d:	8d 4e 01             	lea    0x1(%esi),%ecx
  10dea0:	75 06                	jne    10dea8 <net_byte_to_hex+0x27>
  10dea2:	89 f8                	mov    %edi,%eax
  10dea4:	fe c8                	dec    %al
  10dea6:	75 12                	jne    10deba <net_byte_to_hex+0x39>
		if (val < 10) {
  10dea8:	80 fa 09             	cmp    $0x9,%dl
  10deab:	76 06                	jbe    10deb3 <net_byte_to_hex+0x32>
			*ptr++ = (char) (val - 10 + base);
  10dead:	8d 54 1a f6          	lea    -0xa(%edx,%ebx,1),%edx
  10deb1:	eb 03                	jmp    10deb6 <net_byte_to_hex+0x35>
			*ptr++ = (char) (val + '0');
  10deb3:	83 c2 30             	add    $0x30,%edx
  10deb6:	88 16                	mov    %dl,(%esi)
  10deb8:	eb 02                	jmp    10debc <net_byte_to_hex+0x3b>
		if (i == 0 && !pad && !val) {
  10deba:	89 f1                	mov    %esi,%ecx
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
  10debc:	8a 45 f0             	mov    -0x10(%ebp),%al
  10debf:	8d 71 01             	lea    0x1(%ecx),%esi
  10dec2:	83 e0 0f             	and    $0xf,%eax
		if (val < 10) {
  10dec5:	3c 09                	cmp    $0x9,%al
			*ptr++ = (char) (val + '0');
  10dec7:	8d 50 30             	lea    0x30(%eax),%edx
		if (val < 10) {
  10deca:	76 04                	jbe    10ded0 <net_byte_to_hex+0x4f>
			*ptr++ = (char) (val - 10 + base);
  10decc:	8d 54 18 f6          	lea    -0xa(%eax,%ebx,1),%edx
  10ded0:	88 11                	mov    %dl,(%ecx)
	*ptr = '\0';
  10ded2:	c6 41 01 00          	movb   $0x0,0x1(%ecx)
}
  10ded6:	5a                   	pop    %edx
  10ded7:	89 f0                	mov    %esi,%eax
  10ded9:	5b                   	pop    %ebx
  10deda:	5e                   	pop    %esi
  10dedb:	5f                   	pop    %edi
  10dedc:	5d                   	pop    %ebp
  10dedd:	c3                   	ret    

0010dede <net_sprint_ll_addr_buf>:
{
  10dede:	55                   	push   %ebp
  10dedf:	89 e5                	mov    %esp,%ebp
  10dee1:	57                   	push   %edi
  10dee2:	56                   	push   %esi
  10dee3:	bf 06 00 00 00       	mov    $0x6,%edi
  10dee8:	53                   	push   %ebx
  10dee9:	50                   	push   %eax
  10deea:	8a 45 0c             	mov    0xc(%ebp),%al
  10deed:	8b 75 10             	mov    0x10(%ebp),%esi
	switch (ll_len) {
  10def0:	83 e8 02             	sub    $0x2,%eax
  10def3:	3c 06                	cmp    $0x6,%al
  10def5:	77 0a                	ja     10df01 <net_sprint_ll_addr_buf+0x23>
  10def7:	0f b6 c0             	movzbl %al,%eax
  10defa:	0f b6 b8 4c 43 12 00 	movzbl 0x12434c(%eax),%edi
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
  10df01:	8a 4d 14             	mov    0x14(%ebp),%cl
  10df04:	89 f2                	mov    %esi,%edx
  10df06:	31 db                	xor    %ebx,%ebx
  10df08:	89 f8                	mov    %edi,%eax
  10df0a:	38 d8                	cmp    %bl,%al
  10df0c:	76 2b                	jbe    10df39 <net_sprint_ll_addr_buf+0x5b>
  10df0e:	84 c9                	test   %cl,%cl
  10df10:	74 27                	je     10df39 <net_sprint_ll_addr_buf+0x5b>
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
  10df12:	6a 01                	push   $0x1
  10df14:	8b 45 08             	mov    0x8(%ebp),%eax
  10df17:	6a 41                	push   $0x41
  10df19:	88 4d f3             	mov    %cl,-0xd(%ebp)
  10df1c:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  10df20:	50                   	push   %eax
  10df21:	43                   	inc    %ebx
  10df22:	52                   	push   %edx
  10df23:	e8 59 ff ff ff       	call   10de81 <net_byte_to_hex>
		blen -= 3U;
  10df28:	8a 4d f3             	mov    -0xd(%ebp),%cl
		ptr = net_byte_to_hex(ptr, (char)ll[i], 'A', true);
  10df2b:	83 c4 10             	add    $0x10,%esp
		*ptr++ = ':';
  10df2e:	8d 50 01             	lea    0x1(%eax),%edx
  10df31:	c6 00 3a             	movb   $0x3a,(%eax)
		blen -= 3U;
  10df34:	83 e9 03             	sub    $0x3,%ecx
	for (i = 0U, blen = buflen; i < len && blen > 0; i++) {
  10df37:	eb cf                	jmp    10df08 <net_sprint_ll_addr_buf+0x2a>
		return NULL;
  10df39:	31 c0                	xor    %eax,%eax
	if (!(ptr - buf)) {
  10df3b:	39 f2                	cmp    %esi,%edx
  10df3d:	74 06                	je     10df45 <net_sprint_ll_addr_buf+0x67>
	*(ptr - 1) = '\0';
  10df3f:	c6 42 ff 00          	movb   $0x0,-0x1(%edx)
	return buf;
  10df43:	89 f0                	mov    %esi,%eax
}
  10df45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10df48:	5b                   	pop    %ebx
  10df49:	5e                   	pop    %esi
  10df4a:	5f                   	pop    %edi
  10df4b:	5d                   	pop    %ebp
  10df4c:	c3                   	ret    

0010df4d <z_impl_net_addr_ntop>:
{
  10df4d:	55                   	push   %ebp
  10df4e:	89 e5                	mov    %esp,%ebp
  10df50:	57                   	push   %edi
  10df51:	56                   	push   %esi
  10df52:	53                   	push   %ebx
  10df53:	83 ec 38             	sub    $0x38,%esp
	unsigned char zeros[8] = { 0 };
  10df56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  10df5d:	8b 45 08             	mov    0x8(%ebp),%eax
	unsigned char zeros[8] = { 0 };
  10df60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
{
  10df67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (family == AF_INET6) {
  10df6a:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
  10df6f:	75 60                	jne    10dfd1 <z_impl_net_addr_ntop+0x84>
		w = (uint16_t *)addr6->s6_addr16;
  10df71:	8b 45 0c             	mov    0xc(%ebp),%eax
  10df74:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  10df77:	89 45 cc             	mov    %eax,-0x34(%ebp)
		for (i = 0U; i < 8; i++) {
  10df7a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
		w = (uint16_t *)addr6->s6_addr16;
  10df7d:	89 c8                	mov    %ecx,%eax
			for (j = i; j < 8; j++) {
  10df7f:	89 c2                	mov    %eax,%edx
  10df81:	29 ca                	sub    %ecx,%edx
				if (UNALIGNED_GET(&w[j]) != 0) {
  10df83:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10df86:	66 83 3c 57 00       	cmpw   $0x0,(%edi,%edx,2)
  10df8b:	74 0f                	je     10df9c <z_impl_net_addr_ntop+0x4f>
		for (i = 0U; i < 8; i++) {
  10df8d:	40                   	inc    %eax
  10df8e:	39 c3                	cmp    %eax,%ebx
  10df90:	75 ed                	jne    10df7f <z_impl_net_addr_ntop+0x32>
  10df92:	31 c0                	xor    %eax,%eax
	int8_t pos = -1;
  10df94:	b2 ff                	mov    $0xff,%dl
	uint8_t i, bl, bh, longest = 1U;
  10df96:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
  10df9a:	eb 10                	jmp    10dfac <z_impl_net_addr_ntop+0x5f>
				zeros[i]++;
  10df9c:	42                   	inc    %edx
  10df9d:	fe 00                	incb   (%eax)
			for (j = i; j < 8; j++) {
  10df9f:	80 fa 07             	cmp    $0x7,%dl
  10dfa2:	76 df                	jbe    10df83 <z_impl_net_addr_ntop+0x36>
  10dfa4:	eb e7                	jmp    10df8d <z_impl_net_addr_ntop+0x40>
		for (i = 0U; i < 8; i++) {
  10dfa6:	40                   	inc    %eax
  10dfa7:	83 f8 08             	cmp    $0x8,%eax
  10dfaa:	74 10                	je     10dfbc <z_impl_net_addr_ntop+0x6f>
			if (zeros[i] > longest) {
  10dfac:	8a 4c 05 ec          	mov    -0x14(%ebp,%eax,1),%cl
  10dfb0:	3a 4d eb             	cmp    -0x15(%ebp),%cl
  10dfb3:	76 f1                	jbe    10dfa6 <z_impl_net_addr_ntop+0x59>
				pos = i;
  10dfb5:	88 c2                	mov    %al,%dl
  10dfb7:	88 4d eb             	mov    %cl,-0x15(%ebp)
  10dfba:	eb ea                	jmp    10dfa6 <z_impl_net_addr_ntop+0x59>
		if (longest == 1U) {
  10dfbc:	80 7d eb 01          	cmpb   $0x1,-0x15(%ebp)
		len = 8;
  10dfc0:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
	char delim = ':';
  10dfc7:	c6 45 ea 3a          	movb   $0x3a,-0x16(%ebp)
		if (longest == 1U) {
  10dfcb:	75 28                	jne    10dff5 <z_impl_net_addr_ntop+0xa8>
			pos = -1;
  10dfcd:	b2 ff                	mov    $0xff,%dl
  10dfcf:	eb 24                	jmp    10dff5 <z_impl_net_addr_ntop+0xa8>
	} else if (family == AF_INET) {
  10dfd1:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
  10dfd6:	74 0c                	je     10dfe4 <z_impl_net_addr_ntop+0x97>
		return NULL;
  10dfd8:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
  10dfdf:	e9 b5 01 00 00       	jmp    10e199 <z_impl_net_addr_ntop+0x24c>
		len = 4;
  10dfe4:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
		delim = '.';
  10dfeb:	c6 45 ea 2e          	movb   $0x2e,-0x16(%ebp)
	int8_t pos = -1;
  10dfef:	b2 ff                	mov    $0xff,%dl
	uint8_t i, bl, bh, longest = 1U;
  10dff1:	c6 45 eb 01          	movb   $0x1,-0x15(%ebp)
		if (i == pos) {
  10dff5:	0f be c2             	movsbl %dl,%eax
	for (i = 0U; i < len; i++) {
  10dff8:	8b 4d 10             	mov    0x10(%ebp),%ecx
	bool needcolon = false;
  10dffb:	31 f6                	xor    %esi,%esi
	for (i = 0U; i < len; i++) {
  10dffd:	31 ff                	xor    %edi,%edi
		if (i == pos) {
  10dfff:	89 45 bc             	mov    %eax,-0x44(%ebp)
	for (i = 0U; i < len; i++) {
  10e002:	89 f8                	mov    %edi,%eax
  10e004:	0f b6 c0             	movzbl %al,%eax
  10e007:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  10e00a:	0f 8d 70 01 00 00    	jge    10e180 <z_impl_net_addr_ntop+0x233>
		if (len == 4) {
  10e010:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
  10e014:	0f 85 a4 00 00 00    	jne    10e0be <z_impl_net_addr_ntop+0x171>
			value = (uint32_t)addr->s4_addr[i];
  10e01a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  10e01d:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
			if (value == 0U) {
  10e021:	84 c0                	test   %al,%al
  10e023:	75 11                	jne    10e036 <z_impl_net_addr_ntop+0xe9>
				*ptr++ = delim;
  10e025:	8a 5d ea             	mov    -0x16(%ebp),%bl
				*ptr++ = '0';
  10e028:	c6 01 30             	movb   $0x30,(%ecx)
				*ptr++ = delim;
  10e02b:	8d 41 02             	lea    0x2(%ecx),%eax
  10e02e:	88 59 01             	mov    %bl,0x1(%ecx)
				continue;
  10e031:	e9 42 01 00 00       	jmp    10e178 <z_impl_net_addr_ntop+0x22b>
			l = net_value_to_udec(ptr, value, 0);
  10e036:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10e039:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10e03c:	c7 45 dc 09 00 00 00 	movl   $0x9,-0x24(%ebp)
  10e043:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  10e04a:	bb 00 ca 9a 3b       	mov    $0x3b9aca00,%ebx
		value = value % divisor;
  10e04f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10e052:	31 d2                	xor    %edx,%edx
  10e054:	f7 f3                	div    %ebx
  10e056:	89 55 c0             	mov    %edx,-0x40(%ebp)
  10e059:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  10e05c:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10e05f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10e062:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if ((precision > i) || (temp != 0)) {
  10e065:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10e068:	39 45 d0             	cmp    %eax,-0x30(%ebp)
  10e06b:	89 55 c8             	mov    %edx,-0x38(%ebp)
  10e06e:	7f 05                	jg     10e075 <z_impl_net_addr_ntop+0x128>
  10e070:	39 5d c8             	cmp    %ebx,-0x38(%ebp)
  10e073:	72 17                	jb     10e08c <z_impl_net_addr_ntop+0x13f>
			*buf++ = (char) (temp + '0');
  10e075:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10e078:	8a 45 c4             	mov    -0x3c(%ebp),%al
  10e07b:	83 c0 30             	add    $0x30,%eax
  10e07e:	88 02                	mov    %al,(%edx)
  10e080:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10e083:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10e086:	89 d0                	mov    %edx,%eax
  10e088:	40                   	inc    %eax
  10e089:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (i = 9; i >= 0; i--, divisor /= 10U) {
  10e08c:	ff 4d dc             	decl   -0x24(%ebp)
  10e08f:	89 d8                	mov    %ebx,%eax
  10e091:	31 d2                	xor    %edx,%edx
  10e093:	bb 0a 00 00 00       	mov    $0xa,%ebx
  10e098:	f7 f3                	div    %ebx
  10e09a:	89 c3                	mov    %eax,%ebx
  10e09c:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
  10e0a0:	75 ad                	jne    10e04f <z_impl_net_addr_ntop+0x102>
	*buf = 0;
  10e0a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	return buf - start;
  10e0a5:	89 c3                	mov    %eax,%ebx
  10e0a7:	29 cb                	sub    %ecx,%ebx
	*buf = 0;
  10e0a9:	c6 00 00             	movb   $0x0,(%eax)
			ptr += l;
  10e0ac:	0f b6 db             	movzbl %bl,%ebx
  10e0af:	01 d9                	add    %ebx,%ecx
			*ptr++ = delim;
  10e0b1:	8a 5d ea             	mov    -0x16(%ebp),%bl
  10e0b4:	8d 41 01             	lea    0x1(%ecx),%eax
  10e0b7:	88 19                	mov    %bl,(%ecx)
			continue;
  10e0b9:	e9 ba 00 00 00       	jmp    10e178 <z_impl_net_addr_ntop+0x22b>
		if (i == pos) {
  10e0be:	39 45 bc             	cmp    %eax,-0x44(%ebp)
  10e0c1:	75 25                	jne    10e0e8 <z_impl_net_addr_ntop+0x19b>
			if (needcolon || i == 0U) {
  10e0c3:	89 f8                	mov    %edi,%eax
  10e0c5:	84 c0                	test   %al,%al
  10e0c7:	74 06                	je     10e0cf <z_impl_net_addr_ntop+0x182>
  10e0c9:	89 f0                	mov    %esi,%eax
  10e0cb:	84 c0                	test   %al,%al
  10e0cd:	74 04                	je     10e0d3 <z_impl_net_addr_ntop+0x186>
				*ptr++ = ':';
  10e0cf:	c6 01 3a             	movb   $0x3a,(%ecx)
  10e0d2:	41                   	inc    %ecx
			i += longest - 1U;
  10e0d3:	0f b6 75 eb          	movzbl -0x15(%ebp),%esi
			*ptr++ = ':';
  10e0d7:	8d 41 01             	lea    0x1(%ecx),%eax
  10e0da:	c6 01 3a             	movb   $0x3a,(%ecx)
			i += longest - 1U;
  10e0dd:	8d 7c 37 ff          	lea    -0x1(%edi,%esi,1),%edi
			needcolon = false;
  10e0e1:	31 f6                	xor    %esi,%esi
			continue;
  10e0e3:	e9 90 00 00 00       	jmp    10e178 <z_impl_net_addr_ntop+0x22b>
		if (needcolon) {
  10e0e8:	89 f0                	mov    %esi,%eax
  10e0ea:	84 c0                	test   %al,%al
  10e0ec:	74 04                	je     10e0f2 <z_impl_net_addr_ntop+0x1a5>
			*ptr++ = ':';
  10e0ee:	c6 01 3a             	movb   $0x3a,(%ecx)
  10e0f1:	41                   	inc    %ecx
		value = (uint32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
  10e0f2:	89 f8                	mov    %edi,%eax
  10e0f4:	8b 75 cc             	mov    -0x34(%ebp),%esi
  10e0f7:	0f b6 c0             	movzbl %al,%eax
  10e0fa:	66 8b 14 46          	mov    (%esi,%eax,2),%dx
  10e0fe:	89 d6                	mov    %edx,%esi
  10e100:	66 c1 c6 08          	rol    $0x8,%si
		if (bh) {
  10e104:	66 81 e2 ff 00       	and    $0xff,%dx
		bl = value & 0xff;
  10e109:	89 f3                	mov    %esi,%ebx
		if (bh) {
  10e10b:	74 3e                	je     10e14b <z_impl_net_addr_ntop+0x1fe>
			if (bh > 0x0f) {
  10e10d:	66 83 fa 0f          	cmp    $0xf,%dx
  10e111:	76 16                	jbe    10e129 <z_impl_net_addr_ntop+0x1dc>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
  10e113:	6a 00                	push   $0x0
  10e115:	6a 61                	push   $0x61
  10e117:	0f b7 d2             	movzwl %dx,%edx
  10e11a:	52                   	push   %edx
  10e11b:	51                   	push   %ecx
  10e11c:	e8 60 fd ff ff       	call   10de81 <net_byte_to_hex>
  10e121:	83 c4 10             	add    $0x10,%esp
  10e124:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10e127:	eb 15                	jmp    10e13e <z_impl_net_addr_ntop+0x1f1>
				if (bh < 10) {
  10e129:	8d 41 01             	lea    0x1(%ecx),%eax
  10e12c:	80 fa 09             	cmp    $0x9,%dl
  10e12f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10e132:	77 05                	ja     10e139 <z_impl_net_addr_ntop+0x1ec>
					*ptr++ = (char)(bh + '0');
  10e134:	83 c2 30             	add    $0x30,%edx
  10e137:	eb 03                	jmp    10e13c <z_impl_net_addr_ntop+0x1ef>
					*ptr++ = (char) (bh - 10 + 'a');
  10e139:	83 c2 57             	add    $0x57,%edx
  10e13c:	88 11                	mov    %dl,(%ecx)
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
  10e13e:	6a 01                	push   $0x1
  10e140:	6a 61                	push   $0x61
  10e142:	0f b6 db             	movzbl %bl,%ebx
  10e145:	53                   	push   %ebx
  10e146:	ff 75 e4             	pushl  -0x1c(%ebp)
  10e149:	eb 0e                	jmp    10e159 <z_impl_net_addr_ntop+0x20c>
		} else if (bl > 0x0f) {
  10e14b:	80 fb 0f             	cmp    $0xf,%bl
  10e14e:	76 13                	jbe    10e163 <z_impl_net_addr_ntop+0x216>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
  10e150:	6a 00                	push   $0x0
  10e152:	6a 61                	push   $0x61
  10e154:	0f b6 db             	movzbl %bl,%ebx
  10e157:	53                   	push   %ebx
  10e158:	51                   	push   %ecx
  10e159:	e8 23 fd ff ff       	call   10de81 <net_byte_to_hex>
  10e15e:	83 c4 10             	add    $0x10,%esp
  10e161:	eb 10                	jmp    10e173 <z_impl_net_addr_ntop+0x226>
			if (bl < 10) {
  10e163:	8d 41 01             	lea    0x1(%ecx),%eax
				*ptr++ = (char)(bl + '0');
  10e166:	8d 56 30             	lea    0x30(%esi),%edx
			if (bl < 10) {
  10e169:	80 fb 09             	cmp    $0x9,%bl
  10e16c:	76 03                	jbe    10e171 <z_impl_net_addr_ntop+0x224>
				*ptr++ = (char) (bl - 10 + 'a');
  10e16e:	8d 56 57             	lea    0x57(%esi),%edx
  10e171:	88 11                	mov    %dl,(%ecx)
		needcolon = true;
  10e173:	be 01 00 00 00       	mov    $0x1,%esi
	for (i = 0U; i < len; i++) {
  10e178:	47                   	inc    %edi
  10e179:	89 c1                	mov    %eax,%ecx
  10e17b:	e9 82 fe ff ff       	jmp    10e002 <z_impl_net_addr_ntop+0xb5>
	if (!(ptr - dst)) {
  10e180:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  10e183:	0f 84 4f fe ff ff    	je     10dfd8 <z_impl_net_addr_ntop+0x8b>
	if (family == AF_INET) {
  10e189:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
  10e18e:	75 06                	jne    10e196 <z_impl_net_addr_ntop+0x249>
		*(ptr - 1) = '\0';
  10e190:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
  10e194:	eb 03                	jmp    10e199 <z_impl_net_addr_ntop+0x24c>
		*ptr = '\0';
  10e196:	c6 01 00             	movb   $0x0,(%ecx)
}
  10e199:	8b 45 10             	mov    0x10(%ebp),%eax
  10e19c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10e19f:	5b                   	pop    %ebx
  10e1a0:	5e                   	pop    %esi
  10e1a1:	5f                   	pop    %edi
  10e1a2:	5d                   	pop    %ebp
  10e1a3:	c3                   	ret    

0010e1a4 <net_sprint_addr>:
{
  10e1a4:	55                   	push   %ebp
	char *s = buf[++i % NBUFS];
  10e1a5:	a1 c8 eb 12 00       	mov    0x12ebc8,%eax
{
  10e1aa:	89 e5                	mov    %esp,%ebp
	char *s = buf[++i % NBUFS];
  10e1ac:	40                   	inc    %eax
{
  10e1ad:	53                   	push   %ebx
	char *s = buf[++i % NBUFS];
  10e1ae:	a3 c8 eb 12 00       	mov    %eax,0x12ebc8
{
  10e1b3:	8b 4d 08             	mov    0x8(%ebp),%ecx
	char *s = buf[++i % NBUFS];
  10e1b6:	bb 03 00 00 00       	mov    $0x3,%ebx
	if (z_syscall_trap()) {
		return (char *) arch_syscall_invoke4(*(uintptr_t *)&family, *(uintptr_t *)&src, *(uintptr_t *)&dst, *(uintptr_t *)&size, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
  10e1bb:	6a 28                	push   $0x28
  10e1bd:	99                   	cltd   
  10e1be:	f7 fb                	idiv   %ebx
  10e1c0:	6b c2 28             	imul   $0x28,%edx,%eax
  10e1c3:	05 e0 a8 12 00       	add    $0x12a8e0,%eax
  10e1c8:	50                   	push   %eax
  10e1c9:	ff 75 0c             	pushl  0xc(%ebp)
	return net_addr_ntop(af, addr, s, NET_IPV6_ADDR_LEN);
  10e1cc:	0f b7 c9             	movzwl %cx,%ecx
  10e1cf:	51                   	push   %ecx
  10e1d0:	e8 78 fd ff ff       	call   10df4d <z_impl_net_addr_ntop>
  10e1d5:	83 c4 10             	add    $0x10,%esp
}
  10e1d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10e1db:	c9                   	leave  
  10e1dc:	c3                   	ret    

0010e1dd <z_impl_net_addr_pton>:
{
  10e1dd:	55                   	push   %ebp
  10e1de:	89 e5                	mov    %esp,%ebp
  10e1e0:	57                   	push   %edi
  10e1e1:	56                   	push   %esi
  10e1e2:	53                   	push   %ebx
  10e1e3:	83 ec 08             	sub    $0x8,%esp
  10e1e6:	8b 45 08             	mov    0x8(%ebp),%eax
  10e1e9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (family == AF_INET) {
  10e1ec:	66 83 f8 01          	cmp    $0x1,%ax
  10e1f0:	75 66                	jne    10e258 <z_impl_net_addr_pton+0x7b>
		len = strlen(src);
  10e1f2:	53                   	push   %ebx
  10e1f3:	e8 24 db ff ff       	call   10bd1c <strlen>
  10e1f8:	5e                   	pop    %esi
  10e1f9:	89 c7                	mov    %eax,%edi
		for (i = 0; i < len; i++) {
  10e1fb:	31 d2                	xor    %edx,%edx
  10e1fd:	39 fa                	cmp    %edi,%edx
  10e1ff:	74 1e                	je     10e21f <z_impl_net_addr_pton+0x42>
			if (!(src[i] >= '0' && src[i] <= '9') &&
  10e201:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
  10e204:	8d 71 d0             	lea    -0x30(%ecx),%esi
  10e207:	89 f0                	mov    %esi,%eax
  10e209:	3c 09                	cmp    $0x9,%al
  10e20b:	76 0f                	jbe    10e21c <z_impl_net_addr_pton+0x3f>
  10e20d:	80 f9 2e             	cmp    $0x2e,%cl
  10e210:	74 0a                	je     10e21c <z_impl_net_addr_pton+0x3f>
				return -EINVAL;
  10e212:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10e217:	e9 b9 01 00 00       	jmp    10e3d5 <z_impl_net_addr_pton+0x1f8>
		for (i = 0; i < len; i++) {
  10e21c:	42                   	inc    %edx
  10e21d:	eb de                	jmp    10e1fd <z_impl_net_addr_pton+0x20>
		(void)memset(addr, 0, sizeof(struct in_addr));
  10e21f:	6a 04                	push   $0x4
		for (i = 0; i < sizeof(struct in_addr); i++) {
  10e221:	31 f6                	xor    %esi,%esi
		(void)memset(addr, 0, sizeof(struct in_addr));
  10e223:	6a 00                	push   $0x0
  10e225:	ff 75 10             	pushl  0x10(%ebp)
  10e228:	e8 2e dc ff ff       	call   10be5b <memset>
  10e22d:	83 c4 0c             	add    $0xc,%esp
			addr->s4_addr[i] = strtol(src, &endptr, 10);
  10e230:	6a 0a                	push   $0xa
  10e232:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10e235:	50                   	push   %eax
  10e236:	53                   	push   %ebx
  10e237:	e8 58 d7 ff ff       	call   10b994 <strtol>
  10e23c:	8b 7d 10             	mov    0x10(%ebp),%edi
  10e23f:	83 c4 0c             	add    $0xc,%esp
  10e242:	88 04 37             	mov    %al,(%edi,%esi,1)
			src = ++endptr;
  10e245:	8b 45 f0             	mov    -0x10(%ebp),%eax
		for (i = 0; i < sizeof(struct in_addr); i++) {
  10e248:	46                   	inc    %esi
			src = ++endptr;
  10e249:	8d 58 01             	lea    0x1(%eax),%ebx
		for (i = 0; i < sizeof(struct in_addr); i++) {
  10e24c:	83 fe 04             	cmp    $0x4,%esi
  10e24f:	75 df                	jne    10e230 <z_impl_net_addr_pton+0x53>
	return 0;
  10e251:	31 c0                	xor    %eax,%eax
  10e253:	e9 7d 01 00 00       	jmp    10e3d5 <z_impl_net_addr_pton+0x1f8>
	} else if (family == AF_INET6) {
  10e258:	66 83 f8 02          	cmp    $0x2,%ax
  10e25c:	75 b4                	jne    10e212 <z_impl_net_addr_pton+0x35>
		int expected_groups = strchr(src, '.') ? 6 : 8;
  10e25e:	6a 2e                	push   $0x2e
  10e260:	53                   	push   %ebx
  10e261:	e8 7c da ff ff       	call   10bce2 <strchr>
  10e266:	83 f8 01             	cmp    $0x1,%eax
  10e269:	5a                   	pop    %edx
  10e26a:	19 f6                	sbb    %esi,%esi
  10e26c:	59                   	pop    %ecx
  10e26d:	83 e6 02             	and    $0x2,%esi
  10e270:	83 c6 06             	add    $0x6,%esi
		if (*src == ':') {
  10e273:	80 3b 3a             	cmpb   $0x3a,(%ebx)
  10e276:	75 01                	jne    10e279 <z_impl_net_addr_pton+0x9c>
			src++;
  10e278:	43                   	inc    %ebx
		len = strlen(src);
  10e279:	53                   	push   %ebx
  10e27a:	e8 9d da ff ff       	call   10bd1c <strlen>
  10e27f:	5f                   	pop    %edi
  10e280:	89 c2                	mov    %eax,%edx
		for (i = 0; i < len; i++) {
  10e282:	31 ff                	xor    %edi,%edi
  10e284:	39 d7                	cmp    %edx,%edi
  10e286:	7d 31                	jge    10e2b9 <z_impl_net_addr_pton+0xdc>
			if (!(src[i] >= '0' && src[i] <= '9') &&
  10e288:	8a 0c 3b             	mov    (%ebx,%edi,1),%cl
  10e28b:	8d 41 d0             	lea    -0x30(%ecx),%eax
  10e28e:	3c 09                	cmp    $0x9,%al
  10e290:	76 24                	jbe    10e2b6 <z_impl_net_addr_pton+0xd9>
			    !(src[i] >= 'A' && src[i] <= 'F') &&
  10e292:	8d 41 bf             	lea    -0x41(%ecx),%eax
			if (!(src[i] >= '0' && src[i] <= '9') &&
  10e295:	3c 05                	cmp    $0x5,%al
  10e297:	76 1d                	jbe    10e2b6 <z_impl_net_addr_pton+0xd9>
			    !(src[i] >= 'a' && src[i] <= 'f') &&
  10e299:	8d 41 9f             	lea    -0x61(%ecx),%eax
			    !(src[i] >= 'A' && src[i] <= 'F') &&
  10e29c:	3c 05                	cmp    $0x5,%al
  10e29e:	0f 97 45 ec          	seta   -0x14(%ebp)
			    !(src[i] >= 'a' && src[i] <= 'f') &&
  10e2a2:	80 f9 2e             	cmp    $0x2e,%cl
  10e2a5:	0f 95 c0             	setne  %al
			    src[i] != '.' && src[i] != ':') {
  10e2a8:	84 45 ec             	test   %al,-0x14(%ebp)
  10e2ab:	74 09                	je     10e2b6 <z_impl_net_addr_pton+0xd9>
  10e2ad:	80 f9 3a             	cmp    $0x3a,%cl
  10e2b0:	0f 85 5c ff ff ff    	jne    10e212 <z_impl_net_addr_pton+0x35>
		for (i = 0; i < len; i++) {
  10e2b6:	47                   	inc    %edi
  10e2b7:	eb cb                	jmp    10e284 <z_impl_net_addr_pton+0xa7>
		for (i = 0; i < expected_groups; i++) {
  10e2b9:	31 d2                	xor    %edx,%edx
			if (!src || *src == '\0') {
  10e2bb:	85 db                	test   %ebx,%ebx
  10e2bd:	0f 84 4f ff ff ff    	je     10e212 <z_impl_net_addr_pton+0x35>
  10e2c3:	8a 03                	mov    (%ebx),%al
  10e2c5:	84 c0                	test   %al,%al
  10e2c7:	0f 84 45 ff ff ff    	je     10e212 <z_impl_net_addr_pton+0x35>
			if (*src != ':') {
  10e2cd:	3c 3a                	cmp    $0x3a,%al
  10e2cf:	74 54                	je     10e325 <z_impl_net_addr_pton+0x148>
				UNALIGNED_PUT(htons(strtol(src, NULL, 16)),
  10e2d1:	6a 10                	push   $0x10
  10e2d3:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10e2d6:	6a 00                	push   $0x0
  10e2d8:	53                   	push   %ebx
  10e2d9:	e8 b6 d6 ff ff       	call   10b994 <strtol>
  10e2de:	83 c4 0c             	add    $0xc,%esp
  10e2e1:	89 c7                	mov    %eax,%edi
  10e2e3:	66 c1 ef 08          	shr    $0x8,%di
  10e2e7:	6a 10                	push   $0x10
  10e2e9:	6a 00                	push   $0x0
  10e2eb:	53                   	push   %ebx
  10e2ec:	e8 a3 d6 ff ff       	call   10b994 <strtol>
  10e2f1:	c1 e0 08             	shl    $0x8,%eax
  10e2f4:	83 c4 0c             	add    $0xc,%esp
  10e2f7:	09 c7                	or     %eax,%edi
  10e2f9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10e2fc:	8b 45 10             	mov    0x10(%ebp),%eax
  10e2ff:	66 89 3c 50          	mov    %di,(%eax,%edx,2)
				src = strchr(src, ':');
  10e303:	6a 3a                	push   $0x3a
  10e305:	53                   	push   %ebx
  10e306:	e8 d7 d9 ff ff       	call   10bce2 <strchr>
  10e30b:	59                   	pop    %ecx
				if (src) {
  10e30c:	85 c0                	test   %eax,%eax
				src = strchr(src, ':');
  10e30e:	5b                   	pop    %ebx
				if (src) {
  10e30f:	8b 55 ec             	mov    -0x14(%ebp),%edx
				src = strchr(src, ':');
  10e312:	89 c3                	mov    %eax,%ebx
				if (src) {
  10e314:	74 03                	je     10e319 <z_impl_net_addr_pton+0x13c>
					src++;
  10e316:	43                   	inc    %ebx
  10e317:	eb 5c                	jmp    10e375 <z_impl_net_addr_pton+0x198>
					if (i < expected_groups - 1) {
  10e319:	8d 46 ff             	lea    -0x1(%esi),%eax
  10e31c:	39 d0                	cmp    %edx,%eax
  10e31e:	7e 55                	jle    10e375 <z_impl_net_addr_pton+0x198>
  10e320:	e9 ed fe ff ff       	jmp    10e212 <z_impl_net_addr_pton+0x35>
				UNALIGNED_PUT(0, &addr->s6_addr16[i]);
  10e325:	8b 45 10             	mov    0x10(%ebp),%eax
  10e328:	66 c7 04 50 00 00    	movw   $0x0,(%eax,%edx,2)
			for (; i < expected_groups; i++) {
  10e32e:	42                   	inc    %edx
  10e32f:	39 d6                	cmp    %edx,%esi
  10e331:	7f f2                	jg     10e325 <z_impl_net_addr_pton+0x148>
			tmp = strrchr(src, ':');
  10e333:	6a 3a                	push   $0x3a
  10e335:	53                   	push   %ebx
  10e336:	e8 c9 d9 ff ff       	call   10bd04 <strrchr>
  10e33b:	5f                   	pop    %edi
			if (src == tmp && (expected_groups == 6 || !src[1])) {
  10e33c:	39 d8                	cmp    %ebx,%eax
			tmp = strrchr(src, ':');
  10e33e:	5a                   	pop    %edx
			if (src == tmp && (expected_groups == 6 || !src[1])) {
  10e33f:	75 0e                	jne    10e34f <z_impl_net_addr_pton+0x172>
  10e341:	83 fe 06             	cmp    $0x6,%esi
  10e344:	74 06                	je     10e34c <z_impl_net_addr_pton+0x16f>
  10e346:	80 7b 01 00          	cmpb   $0x0,0x1(%ebx)
  10e34a:	75 0b                	jne    10e357 <z_impl_net_addr_pton+0x17a>
				src++;
  10e34c:	43                   	inc    %ebx
				break;
  10e34d:	eb 2f                	jmp    10e37e <z_impl_net_addr_pton+0x1a1>
			if (expected_groups == 6) {
  10e34f:	83 fe 06             	cmp    $0x6,%esi
  10e352:	75 05                	jne    10e359 <z_impl_net_addr_pton+0x17c>
				tmp--;
  10e354:	48                   	dec    %eax
  10e355:	eb 02                	jmp    10e359 <z_impl_net_addr_pton+0x17c>
  10e357:	89 d8                	mov    %ebx,%eax
			i = expected_groups - 1;
  10e359:	8d 56 ff             	lea    -0x1(%esi),%edx
				if (*tmp == ':') {
  10e35c:	80 38 3a             	cmpb   $0x3a,(%eax)
  10e35f:	75 01                	jne    10e362 <z_impl_net_addr_pton+0x185>
					i--;
  10e361:	4a                   	dec    %edx
				if (i < 0) {
  10e362:	85 d2                	test   %edx,%edx
  10e364:	0f 88 a8 fe ff ff    	js     10e212 <z_impl_net_addr_pton+0x35>
			} while (tmp-- != src);
  10e36a:	48                   	dec    %eax
  10e36b:	8d 48 01             	lea    0x1(%eax),%ecx
  10e36e:	39 cb                	cmp    %ecx,%ebx
  10e370:	75 ea                	jne    10e35c <z_impl_net_addr_pton+0x17f>
			src++;
  10e372:	8d 58 02             	lea    0x2(%eax),%ebx
		for (i = 0; i < expected_groups; i++) {
  10e375:	42                   	inc    %edx
  10e376:	39 d6                	cmp    %edx,%esi
  10e378:	0f 8f 3d ff ff ff    	jg     10e2bb <z_impl_net_addr_pton+0xde>
		if (expected_groups == 6) {
  10e37e:	83 fe 06             	cmp    $0x6,%esi
  10e381:	0f 85 ca fe ff ff    	jne    10e251 <z_impl_net_addr_pton+0x74>
			for (i = 0; i < 4; i++) {
  10e387:	31 f6                	xor    %esi,%esi
				if (!src || !*src) {
  10e389:	85 db                	test   %ebx,%ebx
  10e38b:	0f 84 81 fe ff ff    	je     10e212 <z_impl_net_addr_pton+0x35>
  10e391:	80 3b 00             	cmpb   $0x0,(%ebx)
  10e394:	0f 84 78 fe ff ff    	je     10e212 <z_impl_net_addr_pton+0x35>
				addr->s6_addr[12 + i] = strtol(src, NULL, 10);
  10e39a:	6a 0a                	push   $0xa
  10e39c:	6a 00                	push   $0x0
  10e39e:	53                   	push   %ebx
  10e39f:	e8 f0 d5 ff ff       	call   10b994 <strtol>
  10e3a4:	83 c4 0c             	add    $0xc,%esp
  10e3a7:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10e3aa:	88 44 31 0c          	mov    %al,0xc(%ecx,%esi,1)
				src = strchr(src, '.');
  10e3ae:	6a 2e                	push   $0x2e
  10e3b0:	53                   	push   %ebx
  10e3b1:	e8 2c d9 ff ff       	call   10bce2 <strchr>
  10e3b6:	5a                   	pop    %edx
  10e3b7:	89 c3                	mov    %eax,%ebx
  10e3b9:	59                   	pop    %ecx
				if (src) {
  10e3ba:	85 c0                	test   %eax,%eax
  10e3bc:	74 03                	je     10e3c1 <z_impl_net_addr_pton+0x1e4>
					src++;
  10e3be:	43                   	inc    %ebx
  10e3bf:	eb 09                	jmp    10e3ca <z_impl_net_addr_pton+0x1ed>
					if (i < 3) {
  10e3c1:	83 fe 03             	cmp    $0x3,%esi
  10e3c4:	0f 85 48 fe ff ff    	jne    10e212 <z_impl_net_addr_pton+0x35>
			for (i = 0; i < 4; i++) {
  10e3ca:	46                   	inc    %esi
  10e3cb:	83 fe 04             	cmp    $0x4,%esi
  10e3ce:	75 b9                	jne    10e389 <z_impl_net_addr_pton+0x1ac>
  10e3d0:	e9 7c fe ff ff       	jmp    10e251 <z_impl_net_addr_pton+0x74>
}
  10e3d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10e3d8:	5b                   	pop    %ebx
  10e3d9:	5e                   	pop    %esi
  10e3da:	5f                   	pop    %edi
  10e3db:	5d                   	pop    %ebp
  10e3dc:	c3                   	ret    

0010e3dd <net_calc_chksum>:

	return sum;
}

uint16_t net_calc_chksum(struct net_pkt *pkt, uint8_t proto)
{
  10e3dd:	55                   	push   %ebp
  10e3de:	89 e5                	mov    %esp,%ebp
  10e3e0:	57                   	push   %edi
  10e3e1:	56                   	push   %esi
  10e3e2:	53                   	push   %ebx
  10e3e3:	83 ec 10             	sub    $0x10,%esp
  10e3e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10e3e9:	8b 55 0c             	mov    0xc(%ebp),%edx
	return pkt->family;
  10e3ec:	8a 4b 3f             	mov    0x3f(%ebx),%cl
  10e3ef:	d0 e9                	shr    %cl
  10e3f1:	83 e1 07             	and    $0x7,%ecx
	size_t len = 0U;
	uint16_t sum = 0U;
	struct net_pkt_cursor backup;
	bool ow;

	if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10e3f4:	fe c9                	dec    %cl
  10e3f6:	0f 85 1e 01 00 00    	jne    10e51a <net_calc_chksum+0x13d>
	    net_pkt_family(pkt) == AF_INET) {
		if (proto != IPPROTO_ICMP) {
  10e3fc:	80 fa 01             	cmp    $0x1,%dl
  10e3ff:	74 2b                	je     10e42c <net_calc_chksum+0x4f>
			len = 2 * sizeof(struct in_addr);
			sum = net_pkt_get_len(pkt) -
  10e401:	8b 4b 10             	mov    0x10(%ebx),%ecx
	size_t bytes = 0;
  10e404:	31 f6                	xor    %esi,%esi
	while (buf) {
  10e406:	85 c9                	test   %ecx,%ecx
  10e408:	74 0a                	je     10e414 <net_calc_chksum+0x37>
		bytes += buf->len;
  10e40a:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
		buf = buf->frags;
  10e40e:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
  10e410:	01 c6                	add    %eax,%esi
		buf = buf->frags;
  10e412:	eb f2                	jmp    10e406 <net_calc_chksum+0x29>
				net_pkt_ip_hdr_len(pkt) -
  10e414:	0f b6 43 3c          	movzbl 0x3c(%ebx),%eax
				net_pkt_ipv4_opts_len(pkt) + proto;
  10e418:	0f b6 4b 43          	movzbl 0x43(%ebx),%ecx
  10e41c:	0f b6 d2             	movzbl %dl,%edx
			sum = net_pkt_get_len(pkt) -
  10e41f:	01 c8                	add    %ecx,%eax
			len = 2 * sizeof(struct in_addr);
  10e421:	bf 08 00 00 00       	mov    $0x8,%edi
			sum = net_pkt_get_len(pkt) -
  10e426:	29 c2                	sub    %eax,%edx
  10e428:	01 d6                	add    %edx,%esi
  10e42a:	eb 04                	jmp    10e430 <net_calc_chksum+0x53>
	uint16_t sum = 0U;
  10e42c:	31 f6                	xor    %esi,%esi
	size_t len = 0U;
  10e42e:	31 ff                	xor    %edi,%edi
	backup->buf = pkt->cursor.buf;
  10e430:	8b 43 14             	mov    0x14(%ebx),%eax
  10e433:	89 45 ec             	mov    %eax,-0x14(%ebp)
	backup->pos = pkt->cursor.pos;
  10e436:	8b 43 18             	mov    0x18(%ebx),%eax
  10e439:	89 45 e8             	mov    %eax,-0x18(%ebp)
		NET_DBG("Unknown protocol family %d", net_pkt_family(pkt));
		return 0;
	}

	net_pkt_cursor_backup(pkt, &backup);
	net_pkt_cursor_init(pkt);
  10e43c:	53                   	push   %ebx
  10e43d:	e8 a8 17 00 00       	call   10fbea <net_pkt_cursor_init>
	return pkt->overwrite;
  10e442:	8a 43 3d             	mov    0x3d(%ebx),%al
  10e445:	88 c1                	mov    %al,%cl
	pkt->overwrite = overwrite;
  10e447:	83 c8 01             	or     $0x1,%eax
  10e44a:	88 43 3d             	mov    %al,0x3d(%ebx)
	return pkt->overwrite;
  10e44d:	83 e1 01             	and    $0x1,%ecx

	ow = net_pkt_is_being_overwritten(pkt);
	net_pkt_set_overwrite(pkt, true);

	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
  10e450:	0f b6 43 3c          	movzbl 0x3c(%ebx),%eax
  10e454:	29 f8                	sub    %edi,%eax
  10e456:	88 4d f3             	mov    %cl,-0xd(%ebp)
  10e459:	89 04 24             	mov    %eax,(%esp)
  10e45c:	53                   	push   %ebx
  10e45d:	e8 a9 1b 00 00       	call   11000b <net_pkt_skip>
  10e462:	58                   	pop    %eax
  10e463:	5a                   	pop    %edx

	sum = calc_chksum(sum, pkt->cursor.pos, len);
  10e464:	89 f9                	mov    %edi,%ecx
  10e466:	8b 53 18             	mov    0x18(%ebx),%edx
  10e469:	0f b7 c6             	movzwl %si,%eax
  10e46c:	e8 a3 f9 ff ff       	call   10de14 <calc_chksum>
  10e471:	89 c6                	mov    %eax,%esi
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
  10e473:	0f b6 43 43          	movzbl 0x43(%ebx),%eax
  10e477:	01 c7                	add    %eax,%edi
  10e479:	57                   	push   %edi
  10e47a:	53                   	push   %ebx
  10e47b:	e8 8b 1b 00 00       	call   11000b <net_pkt_skip>
  10e480:	59                   	pop    %ecx
	if (!cur->buf || !cur->pos) {
  10e481:	8b 53 14             	mov    0x14(%ebx),%edx
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
  10e484:	5f                   	pop    %edi
	if (!cur->buf || !cur->pos) {
  10e485:	85 d2                	test   %edx,%edx
  10e487:	74 69                	je     10e4f2 <net_calc_chksum+0x115>
  10e489:	8b 43 18             	mov    0x18(%ebx),%eax
  10e48c:	85 c0                	test   %eax,%eax
  10e48e:	74 62                	je     10e4f2 <net_calc_chksum+0x115>
	len = cur->buf->len - (cur->pos - cur->buf->data);
  10e490:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
  10e494:	2b 42 08             	sub    0x8(%edx),%eax
  10e497:	29 c1                	sub    %eax,%ecx
	while (cur->buf) {
  10e499:	8b 7b 14             	mov    0x14(%ebx),%edi
  10e49c:	85 ff                	test   %edi,%edi
  10e49e:	74 52                	je     10e4f2 <net_calc_chksum+0x115>
		sum = calc_chksum(sum, cur->pos, len);
  10e4a0:	0f b7 c6             	movzwl %si,%eax
  10e4a3:	8b 53 18             	mov    0x18(%ebx),%edx
  10e4a6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10e4a9:	e8 66 f9 ff ff       	call   10de14 <calc_chksum>
		cur->buf = cur->buf->frags;
  10e4ae:	8b 17                	mov    (%edi),%edx
		sum = calc_chksum(sum, cur->pos, len);
  10e4b0:	89 c6                	mov    %eax,%esi
		cur->buf = cur->buf->frags;
  10e4b2:	89 53 14             	mov    %edx,0x14(%ebx)
		if (!cur->buf || !cur->buf->len) {
  10e4b5:	85 d2                	test   %edx,%edx
  10e4b7:	74 39                	je     10e4f2 <net_calc_chksum+0x115>
  10e4b9:	8b 42 0c             	mov    0xc(%edx),%eax
  10e4bc:	66 85 c0             	test   %ax,%ax
  10e4bf:	74 31                	je     10e4f2 <net_calc_chksum+0x115>
		cur->pos = cur->buf->data;
  10e4c1:	8b 52 08             	mov    0x8(%edx),%edx
		if (len % 2) {
  10e4c4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10e4c7:	80 e1 01             	and    $0x1,%cl
		cur->pos = cur->buf->data;
  10e4ca:	89 53 18             	mov    %edx,0x18(%ebx)
		if (len % 2) {
  10e4cd:	0f b7 c8             	movzwl %ax,%ecx
  10e4d0:	74 c7                	je     10e499 <net_calc_chksum+0xbc>
			sum += *cur->pos;
  10e4d2:	0f b6 02             	movzbl (%edx),%eax
  10e4d5:	31 ff                	xor    %edi,%edi
  10e4d7:	66 01 f0             	add    %si,%ax
  10e4da:	73 05                	jae    10e4e1 <net_calc_chksum+0x104>
  10e4dc:	bf 01 00 00 00       	mov    $0x1,%edi
				sum++;
  10e4e1:	66 83 ff 01          	cmp    $0x1,%di
  10e4e5:	66 83 d8 ff          	sbb    $0xffff,%ax
			cur->pos++;
  10e4e9:	42                   	inc    %edx
				sum++;
  10e4ea:	89 c6                	mov    %eax,%esi
			cur->pos++;
  10e4ec:	89 53 18             	mov    %edx,0x18(%ebx)
			len = cur->buf->len - 1;
  10e4ef:	49                   	dec    %ecx
  10e4f0:	eb a7                	jmp    10e499 <net_calc_chksum+0xbc>

	sum = pkt_calc_chksum(pkt, sum);

	sum = (sum == 0U) ? 0xffff : htons(sum);
  10e4f2:	83 c8 ff             	or     $0xffffffff,%eax
  10e4f5:	66 85 f6             	test   %si,%si
  10e4f8:	74 04                	je     10e4fe <net_calc_chksum+0x121>
  10e4fa:	89 f0                	mov    %esi,%eax
  10e4fc:	86 e0                	xchg   %ah,%al
	pkt->overwrite = overwrite;
  10e4fe:	8a 53 3d             	mov    0x3d(%ebx),%dl
	pkt->cursor.buf = backup->buf;
  10e501:	8b 75 ec             	mov    -0x14(%ebp),%esi
	pkt->overwrite = overwrite;
  10e504:	83 e2 fe             	and    $0xfffffffe,%edx
	pkt->cursor.pos = backup->pos;
  10e507:	8b 7d e8             	mov    -0x18(%ebp),%edi
	pkt->overwrite = overwrite;
  10e50a:	0a 55 f3             	or     -0xd(%ebp),%dl
	pkt->cursor.buf = backup->buf;
  10e50d:	89 73 14             	mov    %esi,0x14(%ebx)
	pkt->cursor.pos = backup->pos;
  10e510:	89 7b 18             	mov    %edi,0x18(%ebx)
	pkt->overwrite = overwrite;
  10e513:	88 53 3d             	mov    %dl,0x3d(%ebx)

	net_pkt_cursor_restore(pkt, &backup);

	net_pkt_set_overwrite(pkt, ow);

	return ~sum;
  10e516:	f7 d0                	not    %eax
  10e518:	eb 02                	jmp    10e51c <net_calc_chksum+0x13f>
  10e51a:	31 c0                	xor    %eax,%eax
}
  10e51c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10e51f:	5b                   	pop    %ebx
  10e520:	5e                   	pop    %esi
  10e521:	5f                   	pop    %edi
  10e522:	5d                   	pop    %ebp
  10e523:	c3                   	ret    

0010e524 <net_calc_chksum_ipv4>:

#if defined(CONFIG_NET_IPV4)
uint16_t net_calc_chksum_ipv4(struct net_pkt *pkt)
{
  10e524:	55                   	push   %ebp
  10e525:	89 e5                	mov    %esp,%ebp
  10e527:	8b 45 08             	mov    0x8(%ebp),%eax
	uint16_t sum;

	sum = calc_chksum(0, pkt->buffer->data,
			  net_pkt_ip_hdr_len(pkt) +
			  net_pkt_ipv4_opts_len(pkt));
  10e52a:	0f b6 50 43          	movzbl 0x43(%eax),%edx
			  net_pkt_ip_hdr_len(pkt) +
  10e52e:	0f b6 48 3c          	movzbl 0x3c(%eax),%ecx
	sum = calc_chksum(0, pkt->buffer->data,
  10e532:	8b 40 10             	mov    0x10(%eax),%eax
			  net_pkt_ip_hdr_len(pkt) +
  10e535:	01 d1                	add    %edx,%ecx
	sum = calc_chksum(0, pkt->buffer->data,
  10e537:	8b 50 08             	mov    0x8(%eax),%edx
  10e53a:	31 c0                	xor    %eax,%eax
  10e53c:	e8 d3 f8 ff ff       	call   10de14 <calc_chksum>
  10e541:	89 c2                	mov    %eax,%edx

	sum = (sum == 0U) ? 0xffff : htons(sum);
  10e543:	83 c8 ff             	or     $0xffffffff,%eax
  10e546:	66 85 d2             	test   %dx,%dx
  10e549:	74 04                	je     10e54f <net_calc_chksum_ipv4+0x2b>
  10e54b:	89 d0                	mov    %edx,%eax
  10e54d:	86 e0                	xchg   %ah,%al

	return ~sum;
  10e54f:	f7 d0                	not    %eax
}
  10e551:	5d                   	pop    %ebp
  10e552:	c3                   	ret    

0010e553 <net_ipv4_unspecified_address>:
const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
}
  10e553:	b8 58 43 12 00       	mov    $0x124358,%eax
  10e558:	c3                   	ret    

0010e559 <net_ipv4_broadcast_address>:
const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
  10e559:	b8 54 43 12 00       	mov    $0x124354,%eax
  10e55e:	c3                   	ret    

0010e55f <k_sem_take>:
{
  10e55f:	55                   	push   %ebp
  10e560:	89 e5                	mov    %esp,%ebp
  10e562:	53                   	push   %ebx
	return z_impl_k_sem_take(sem, timeout);
  10e563:	51                   	push   %ecx
  10e564:	52                   	push   %edx
  10e565:	50                   	push   %eax
  10e566:	e8 87 33 01 00       	call   1218f2 <z_impl_k_sem_take>
  10e56b:	83 c4 0c             	add    $0xc,%esp
}
  10e56e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10e571:	c9                   	leave  
  10e572:	c3                   	ret    

0010e573 <k_sem_give>:
{
  10e573:	55                   	push   %ebp
  10e574:	89 e5                	mov    %esp,%ebp
	z_impl_k_sem_give(sem);
  10e576:	50                   	push   %eax
  10e577:	e8 1d 33 01 00       	call   121899 <z_impl_k_sem_give>
  10e57c:	58                   	pop    %eax
}
  10e57d:	c9                   	leave  
  10e57e:	c3                   	ret    

0010e57f <mgmt_thread>:
	log_stack_usage(&mgmt_thread_data);
#endif
}

static void mgmt_thread(void)
{
  10e57f:	55                   	push   %ebp
  10e580:	89 e5                	mov    %esp,%ebp
  10e582:	57                   	push   %edi
  10e583:	56                   	push   %esi
  10e584:	53                   	push   %ebx
  10e585:	83 ec 08             	sub    $0x8,%esp
	struct mgmt_event_entry *mgmt_event;

	while (1) {
		k_sem_take(&network_event, K_FOREVER);
  10e588:	83 ca ff             	or     $0xffffffff,%edx
  10e58b:	b8 78 5d 14 00       	mov    $0x145d78,%eax
  10e590:	89 d1                	mov    %edx,%ecx
  10e592:	e8 c8 ff ff ff       	call   10e55f <k_sem_take>
		k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e597:	83 ca ff             	or     $0xffffffff,%edx
  10e59a:	89 d1                	mov    %edx,%ecx
  10e59c:	b8 58 5d 14 00       	mov    $0x145d58,%eax
  10e5a1:	e8 b9 ff ff ff       	call   10e55f <k_sem_take>
	if (out_event < 0 || !events[out_event].event) {
  10e5a6:	66 a1 72 ed 12 00    	mov    0x12ed72,%ax
  10e5ac:	66 85 c0             	test   %ax,%ax
  10e5af:	78 77                	js     10e628 <mgmt_thread+0xa9>
  10e5b1:	0f bf f0             	movswl %ax,%esi
  10e5b4:	83 3c f5 d8 eb 12 00 	cmpl   $0x0,0x12ebd8(,%esi,8)
  10e5bb:	00 
  10e5bc:	74 6a                	je     10e628 <mgmt_thread+0xa9>
	if (o_idx == in_event) {
  10e5be:	66 3b 05 74 ed 12 00 	cmp    0x12ed74,%ax
	out_event++;
  10e5c5:	8d 50 01             	lea    0x1(%eax),%edx
  10e5c8:	66 89 15 72 ed 12 00 	mov    %dx,0x12ed72
	if (o_idx == in_event) {
  10e5cf:	75 14                	jne    10e5e5 <mgmt_thread+0x66>
		in_event = -1;
  10e5d1:	66 c7 05 74 ed 12 00 	movw   $0xffff,0x12ed74
  10e5d8:	ff ff 
		out_event = -1;
  10e5da:	66 c7 05 72 ed 12 00 	movw   $0xffff,0x12ed72
  10e5e1:	ff ff 
  10e5e3:	eb 0f                	jmp    10e5f4 <mgmt_thread+0x75>
	} else if (out_event == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
  10e5e5:	66 83 fa 02          	cmp    $0x2,%dx
  10e5e9:	75 09                	jne    10e5f4 <mgmt_thread+0x75>
		out_event = 0;
  10e5eb:	66 c7 05 72 ed 12 00 	movw   $0x0,0x12ed72
  10e5f2:	00 00 
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
  10e5f4:	8b 1d cc eb 12 00    	mov    0x12ebcc,%ebx
  10e5fa:	85 db                	test   %ebx,%ebx
  10e5fc:	75 4a                	jne    10e648 <mgmt_thread+0xc9>

		mgmt_run_callbacks(mgmt_event);

		mgmt_clean_event(mgmt_event);

		k_sem_give(&net_mgmt_lock);
  10e5fe:	b8 58 5d 14 00       	mov    $0x145d58,%eax
	mgmt_event->event = 0U;
  10e603:	c7 04 f5 d8 eb 12 00 	movl   $0x0,0x12ebd8(,%esi,8)
  10e60a:	00 00 00 00 
	mgmt_event->iface = NULL;
  10e60e:	c7 04 f5 dc eb 12 00 	movl   $0x0,0x12ebdc(,%esi,8)
  10e615:	00 00 00 00 
		k_sem_give(&net_mgmt_lock);
  10e619:	e8 55 ff ff ff       	call   10e573 <k_sem_give>
	z_impl_k_yield();
  10e61e:	e8 90 31 01 00       	call   1217b3 <z_impl_k_yield>
  10e623:	e9 60 ff ff ff       	jmp    10e588 <mgmt_thread+0x9>
	return z_impl_k_sem_init(sem, initial_count, limit);
  10e628:	6a ff                	push   $0xffffffff
  10e62a:	6a 00                	push   $0x0
  10e62c:	68 78 5d 14 00       	push   $0x145d78
  10e631:	e8 21 32 01 00       	call   121857 <z_impl_k_sem_init>
  10e636:	83 c4 0c             	add    $0xc,%esp
			k_sem_give(&net_mgmt_lock);
  10e639:	b8 58 5d 14 00       	mov    $0x145d58,%eax
  10e63e:	e8 30 ff ff ff       	call   10e573 <k_sem_give>
			continue;
  10e643:	e9 40 ff ff ff       	jmp    10e588 <mgmt_thread+0x9>
	return node->next;
  10e648:	8b 03                	mov    (%ebx),%eax
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10e64a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10e651:	89 45 ec             	mov    %eax,-0x14(%ebp)
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
  10e654:	8b 53 08             	mov    0x8(%ebx),%edx
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
  10e657:	8b 04 f5 d8 eb 12 00 	mov    0x12ebd8(,%esi,8),%eax
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
  10e65e:	89 d1                	mov    %edx,%ecx
  10e660:	31 c1                	xor    %eax,%ecx
		if (!(NET_MGMT_GET_LAYER(mgmt_event->event) ==
  10e662:	c1 e9 1c             	shr    $0x1c,%ecx
  10e665:	83 e1 03             	and    $0x3,%ecx
  10e668:	89 cf                	mov    %ecx,%edi
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
  10e66a:	89 d1                	mov    %edx,%ecx
  10e66c:	31 c1                	xor    %eax,%ecx
		    !(NET_MGMT_GET_LAYER_CODE(mgmt_event->event) ==
  10e66e:	c1 e9 10             	shr    $0x10,%ecx
  10e671:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
		      NET_MGMT_GET_LAYER(cb->event_mask)) ||
  10e677:	09 cf                	or     %ecx,%edi
  10e679:	75 79                	jne    10e6f4 <mgmt_thread+0x175>
		      NET_MGMT_GET_LAYER_CODE(cb->event_mask)) ||
  10e67b:	66 85 c0             	test   %ax,%ax
  10e67e:	74 0e                	je     10e68e <mgmt_thread+0x10f>
		    (NET_MGMT_GET_COMMAND(mgmt_event->event) &&
  10e680:	66 85 d2             	test   %dx,%dx
  10e683:	74 09                	je     10e68e <mgmt_thread+0x10f>
		     !(NET_MGMT_GET_COMMAND(mgmt_event->event) &
  10e685:	89 c1                	mov    %eax,%ecx
  10e687:	21 d1                	and    %edx,%ecx
		     NET_MGMT_GET_COMMAND(cb->event_mask) &&
  10e689:	66 85 c9             	test   %cx,%cx
  10e68c:	74 66                	je     10e6f4 <mgmt_thread+0x175>
		if (NET_MGMT_EVENT_SYNCHRONOUS(cb->event_mask)) {
  10e68e:	8b 4b 04             	mov    0x4(%ebx),%ecx
  10e691:	8b 3c f5 dc eb 12 00 	mov    0x12ebdc(,%esi,8),%edi
  10e698:	0f ba e2 1b          	bt     $0x1b,%edx
  10e69c:	73 4b                	jae    10e6e9 <mgmt_thread+0x16a>
			if (sync_data->iface &&
  10e69e:	8b 51 20             	mov    0x20(%ecx),%edx
  10e6a1:	85 d2                	test   %edx,%edx
  10e6a3:	74 04                	je     10e6a9 <mgmt_thread+0x12a>
  10e6a5:	39 fa                	cmp    %edi,%edx
  10e6a7:	75 4b                	jne    10e6f4 <mgmt_thread+0x175>
			cb->raised_event = mgmt_event->event;
  10e6a9:	89 43 08             	mov    %eax,0x8(%ebx)
			sync_data->iface = mgmt_event->iface;
  10e6ac:	89 79 20             	mov    %edi,0x20(%ecx)
Z_GENLIST_REMOVE(slist, snode)
  10e6af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10e6b3:	8b 03                	mov    (%ebx),%eax
  10e6b5:	75 0f                	jne    10e6c6 <mgmt_thread+0x147>
  10e6b7:	3b 1d d0 eb 12 00    	cmp    0x12ebd0,%ebx
	list->head = node;
  10e6bd:	a3 cc eb 12 00       	mov    %eax,0x12ebcc
Z_GENLIST_REMOVE(slist, snode)
  10e6c2:	75 16                	jne    10e6da <mgmt_thread+0x15b>
  10e6c4:	eb 0f                	jmp    10e6d5 <mgmt_thread+0x156>
	parent->next = child;
  10e6c6:	8b 7d f0             	mov    -0x10(%ebp),%edi
  10e6c9:	89 07                	mov    %eax,(%edi)
Z_GENLIST_REMOVE(slist, snode)
  10e6cb:	3b 1d d0 eb 12 00    	cmp    0x12ebd0,%ebx
  10e6d1:	75 07                	jne    10e6da <mgmt_thread+0x15b>
	list->tail = node;
  10e6d3:	89 f8                	mov    %edi,%eax
  10e6d5:	a3 d0 eb 12 00       	mov    %eax,0x12ebd0
	parent->next = child;
  10e6da:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
			k_sem_give(cb->sync_call);
  10e6e0:	89 c8                	mov    %ecx,%eax
  10e6e2:	e8 8c fe ff ff       	call   10e573 <k_sem_give>
  10e6e7:	eb 0b                	jmp    10e6f4 <mgmt_thread+0x175>
			cb->handler(cb, mgmt_event->event, mgmt_event->iface);
  10e6e9:	57                   	push   %edi
  10e6ea:	50                   	push   %eax
  10e6eb:	53                   	push   %ebx
  10e6ec:	ff d1                	call   *%ecx
  10e6ee:	83 c4 0c             	add    $0xc,%esp
			prev = &cb->node;
  10e6f1:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
  10e6f4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10e6f8:	0f 84 00 ff ff ff    	je     10e5fe <mgmt_thread+0x7f>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10e6fe:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  10e701:	8b 03                	mov    (%ebx),%eax
  10e703:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10e706:	e9 49 ff ff ff       	jmp    10e654 <mgmt_thread+0xd5>

0010e70b <net_mgmt_add_event_callback>:

	return ret;
}

void net_mgmt_add_event_callback(struct net_mgmt_event_callback *cb)
{
  10e70b:	55                   	push   %ebp
	NET_DBG("Adding event callback %p", cb);

	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e70c:	83 ca ff             	or     $0xffffffff,%edx
{
  10e70f:	89 e5                	mov    %esp,%ebp
	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e711:	89 d1                	mov    %edx,%ecx
{
  10e713:	53                   	push   %ebx
	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e714:	b8 58 5d 14 00       	mov    $0x145d58,%eax
{
  10e719:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e71c:	e8 3e fe ff ff       	call   10e55f <k_sem_take>
Z_GENLIST_PREPEND(slist, snode)
  10e721:	a1 cc eb 12 00       	mov    0x12ebcc,%eax
	parent->next = child;
  10e726:	89 03                	mov    %eax,(%ebx)
	list->head = node;
  10e728:	89 1d cc eb 12 00    	mov    %ebx,0x12ebcc
Z_GENLIST_PREPEND(slist, snode)
  10e72e:	83 3d d0 eb 12 00 00 	cmpl   $0x0,0x12ebd0
  10e735:	75 06                	jne    10e73d <net_mgmt_add_event_callback+0x32>
	list->tail = node;
  10e737:	89 1d d0 eb 12 00    	mov    %ebx,0x12ebd0
	global_event_mask |= event_mask;
  10e73d:	8b 43 08             	mov    0x8(%ebx),%eax
	sys_slist_prepend(&event_callbacks, &cb->node);

	mgmt_add_event_mask(cb->event_mask);

	k_sem_give(&net_mgmt_lock);
}
  10e740:	5b                   	pop    %ebx
	global_event_mask |= event_mask;
  10e741:	09 05 d4 eb 12 00    	or     %eax,0x12ebd4
	k_sem_give(&net_mgmt_lock);
  10e747:	b8 58 5d 14 00       	mov    $0x145d58,%eax
}
  10e74c:	5d                   	pop    %ebp
	k_sem_give(&net_mgmt_lock);
  10e74d:	e9 21 fe ff ff       	jmp    10e573 <k_sem_give>

0010e752 <net_mgmt_del_event_callback>:

void net_mgmt_del_event_callback(struct net_mgmt_event_callback *cb)
{
  10e752:	55                   	push   %ebp
	NET_DBG("Deleting event callback %p", cb);

	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e753:	83 ca ff             	or     $0xffffffff,%edx
{
  10e756:	89 e5                	mov    %esp,%ebp
	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e758:	89 d1                	mov    %edx,%ecx
  10e75a:	b8 58 5d 14 00       	mov    $0x145d58,%eax
{
  10e75f:	53                   	push   %ebx
  10e760:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e763:	e8 f7 fd ff ff       	call   10e55f <k_sem_take>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10e768:	a1 cc eb 12 00       	mov    0x12ebcc,%eax
  10e76d:	31 d2                	xor    %edx,%edx
  10e76f:	85 c0                	test   %eax,%eax
  10e771:	74 3c                	je     10e7af <net_mgmt_del_event_callback+0x5d>
  10e773:	39 c3                	cmp    %eax,%ebx
  10e775:	75 32                	jne    10e7a9 <net_mgmt_del_event_callback+0x57>
Z_GENLIST_REMOVE(slist, snode)
  10e777:	8b 03                	mov    (%ebx),%eax
  10e779:	85 d2                	test   %edx,%edx
  10e77b:	75 14                	jne    10e791 <net_mgmt_del_event_callback+0x3f>
  10e77d:	3b 1d d0 eb 12 00    	cmp    0x12ebd0,%ebx
	list->head = node;
  10e783:	a3 cc eb 12 00       	mov    %eax,0x12ebcc
Z_GENLIST_REMOVE(slist, snode)
  10e788:	75 17                	jne    10e7a1 <net_mgmt_del_event_callback+0x4f>
	list->tail = node;
  10e78a:	a3 d0 eb 12 00       	mov    %eax,0x12ebd0
}
  10e78f:	eb 10                	jmp    10e7a1 <net_mgmt_del_event_callback+0x4f>
	parent->next = child;
  10e791:	89 02                	mov    %eax,(%edx)
Z_GENLIST_REMOVE(slist, snode)
  10e793:	3b 1d d0 eb 12 00    	cmp    0x12ebd0,%ebx
  10e799:	75 06                	jne    10e7a1 <net_mgmt_del_event_callback+0x4f>
	list->tail = node;
  10e79b:	89 15 d0 eb 12 00    	mov    %edx,0x12ebd0
	parent->next = child;
  10e7a1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
  10e7a7:	eb 06                	jmp    10e7af <net_mgmt_del_event_callback+0x5d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10e7a9:	89 c2                	mov    %eax,%edx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  10e7ab:	8b 00                	mov    (%eax),%eax
  10e7ad:	eb c0                	jmp    10e76f <net_mgmt_del_event_callback+0x1d>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
  10e7af:	8b 15 cc eb 12 00    	mov    0x12ebcc,%edx
	global_event_mask = 0U;
  10e7b5:	c7 05 d4 eb 12 00 00 	movl   $0x0,0x12ebd4
  10e7bc:	00 00 00 
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
  10e7bf:	85 d2                	test   %edx,%edx
  10e7c1:	74 17                	je     10e7da <net_mgmt_del_event_callback+0x88>
	return node->next;
  10e7c3:	8b 02                	mov    (%edx),%eax
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  10e7c5:	31 c9                	xor    %ecx,%ecx
	global_event_mask |= event_mask;
  10e7c7:	0b 4a 08             	or     0x8(%edx),%ecx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&event_callbacks, cb, tmp, node) {
  10e7ca:	85 c0                	test   %eax,%eax
  10e7cc:	74 06                	je     10e7d4 <net_mgmt_del_event_callback+0x82>
  10e7ce:	89 c2                	mov    %eax,%edx
  10e7d0:	8b 00                	mov    (%eax),%eax
  10e7d2:	eb f3                	jmp    10e7c7 <net_mgmt_del_event_callback+0x75>
  10e7d4:	89 0d d4 eb 12 00    	mov    %ecx,0x12ebd4
	sys_slist_find_and_remove(&event_callbacks, &cb->node);

	mgmt_rebuild_global_event_mask();

	k_sem_give(&net_mgmt_lock);
}
  10e7da:	5b                   	pop    %ebx
	k_sem_give(&net_mgmt_lock);
  10e7db:	b8 58 5d 14 00       	mov    $0x145d58,%eax
}
  10e7e0:	5d                   	pop    %ebp
	k_sem_give(&net_mgmt_lock);
  10e7e1:	e9 8d fd ff ff       	jmp    10e573 <k_sem_give>

0010e7e6 <net_mgmt_event_notify_with_info>:

void net_mgmt_event_notify_with_info(uint32_t mgmt_event, struct net_if *iface,
				     const void *info, size_t length)
{
  10e7e6:	55                   	push   %ebp
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
  10e7e7:	a1 d4 eb 12 00       	mov    0x12ebd4,%eax
{
  10e7ec:	89 e5                	mov    %esp,%ebp
  10e7ee:	57                   	push   %edi
  10e7ef:	56                   	push   %esi
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
  10e7f0:	89 c2                	mov    %eax,%edx
{
  10e7f2:	53                   	push   %ebx
  10e7f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
  10e7f6:	c1 ea 1c             	shr    $0x1c,%edx
	return (((NET_MGMT_GET_LAYER(mgmt_event) &
  10e7f9:	89 d9                	mov    %ebx,%ecx
  10e7fb:	c1 e9 1c             	shr    $0x1c,%ecx
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
  10e7fe:	89 df                	mov    %ebx,%edi
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
  10e800:	f7 d2                	not    %edx
  10e802:	21 ca                	and    %ecx,%edx
{
  10e804:	8b 75 0c             	mov    0xc(%ebp),%esi
		((NET_MGMT_GET_LAYER_CODE(mgmt_event) &
  10e807:	c1 ef 10             	shr    $0x10,%edi
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
  10e80a:	89 d1                	mov    %edx,%ecx
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
  10e80c:	89 c2                	mov    %eax,%edx
		  NET_MGMT_GET_LAYER(global_event_mask)) ==
  10e80e:	83 e1 03             	and    $0x3,%ecx
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
  10e811:	c1 ea 10             	shr    $0x10,%edx
  10e814:	f7 d2                	not    %edx
  10e816:	21 fa                	and    %edi,%edx
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
  10e818:	f7 d0                	not    %eax
		  NET_MGMT_GET_LAYER_CODE(global_event_mask)) ==
  10e81a:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
  10e820:	21 d8                	and    %ebx,%eax
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
  10e822:	09 ca                	or     %ecx,%edx
		  NET_MGMT_GET_COMMAND(global_event_mask)) ==
  10e824:	0f b7 c0             	movzwl %ax,%eax
		 NET_MGMT_GET_LAYER_CODE(mgmt_event)) &&
  10e827:	09 c2                	or     %eax,%edx
  10e829:	0f 85 86 00 00 00    	jne    10e8b5 <net_mgmt_event_notify_with_info+0xcf>
	k_sem_take(&net_mgmt_lock, K_FOREVER);
  10e82f:	83 ca ff             	or     $0xffffffff,%edx
  10e832:	b8 58 5d 14 00       	mov    $0x145d58,%eax
  10e837:	89 d1                	mov    %edx,%ecx
  10e839:	e8 21 fd ff ff       	call   10e55f <k_sem_take>
	i_idx = in_event + 1;
  10e83e:	66 8b 15 74 ed 12 00 	mov    0x12ed74,%dx
  10e845:	8d 42 01             	lea    0x1(%edx),%eax
	if (i_idx == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
  10e848:	66 4a                	dec    %dx
  10e84a:	75 02                	jne    10e84e <net_mgmt_event_notify_with_info+0x68>
		i_idx = 0;
  10e84c:	31 c0                	xor    %eax,%eax
	events[i_idx].event = mgmt_event;
  10e84e:	0f bf d0             	movswl %ax,%edx
  10e851:	89 1c d5 d8 eb 12 00 	mov    %ebx,0x12ebd8(,%edx,8)
	events[i_idx].iface = iface;
  10e858:	89 34 d5 dc eb 12 00 	mov    %esi,0x12ebdc(,%edx,8)
	if (i_idx == out_event) {
  10e85f:	66 8b 15 72 ed 12 00 	mov    0x12ed72,%dx
  10e866:	66 39 d0             	cmp    %dx,%ax
  10e869:	75 21                	jne    10e88c <net_mgmt_event_notify_with_info+0xa6>
		if (o_idx == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
  10e86b:	66 83 f8 01          	cmp    $0x1,%ax
		uint16_t o_idx = out_event + 1;
  10e86f:	8d 50 01             	lea    0x1(%eax),%edx
		if (o_idx == CONFIG_NET_MGMT_EVENT_QUEUE_SIZE) {
  10e872:	75 02                	jne    10e876 <net_mgmt_event_notify_with_info+0x90>
			o_idx = 0U;
  10e874:	31 d2                	xor    %edx,%edx
		if (events[o_idx].event) {
  10e876:	0f b7 ca             	movzwl %dx,%ecx
  10e879:	83 3c cd d8 eb 12 00 	cmpl   $0x0,0x12ebd8(,%ecx,8)
  10e880:	00 
  10e881:	74 14                	je     10e897 <net_mgmt_event_notify_with_info+0xb1>
			out_event = o_idx;
  10e883:	66 89 15 72 ed 12 00 	mov    %dx,0x12ed72
  10e88a:	eb 0b                	jmp    10e897 <net_mgmt_event_notify_with_info+0xb1>
	} else if (out_event < 0) {
  10e88c:	66 85 d2             	test   %dx,%dx
  10e88f:	79 06                	jns    10e897 <net_mgmt_event_notify_with_info+0xb1>
		out_event = i_idx;
  10e891:	66 a3 72 ed 12 00    	mov    %ax,0x12ed72
	in_event = i_idx;
  10e897:	66 a3 74 ed 12 00    	mov    %ax,0x12ed74
	k_sem_give(&net_mgmt_lock);
  10e89d:	b8 58 5d 14 00       	mov    $0x145d58,%eax
  10e8a2:	e8 cc fc ff ff       	call   10e573 <k_sem_give>
			NET_MGMT_GET_COMMAND(mgmt_event));

		mgmt_push_event(mgmt_event, iface, info, length);
		k_sem_give(&network_event);
	}
}
  10e8a7:	5b                   	pop    %ebx
  10e8a8:	5e                   	pop    %esi
		k_sem_give(&network_event);
  10e8a9:	b8 78 5d 14 00       	mov    $0x145d78,%eax
}
  10e8ae:	5f                   	pop    %edi
  10e8af:	5d                   	pop    %ebp
		k_sem_give(&network_event);
  10e8b0:	e9 be fc ff ff       	jmp    10e573 <k_sem_give>
}
  10e8b5:	5b                   	pop    %ebx
  10e8b6:	5e                   	pop    %esi
  10e8b7:	5f                   	pop    %edi
  10e8b8:	5d                   	pop    %ebp
  10e8b9:	c3                   	ret    

0010e8ba <net_mgmt_event_init>:
				    raised_event, NULL, info, info_length,
				    timeout);
}

void net_mgmt_event_init(void)
{
  10e8ba:	55                   	push   %ebp
	list->head = NULL;
  10e8bb:	c7 05 cc eb 12 00 00 	movl   $0x0,0x12ebcc
  10e8c2:	00 00 00 
  10e8c5:	89 e5                	mov    %esp,%ebp
	global_event_mask = 0U;

	in_event = -1;
	out_event = -1;

	(void)memset(events, 0, CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
  10e8c7:	6a 10                	push   $0x10
  10e8c9:	6a 00                	push   $0x0
	list->tail = NULL;
  10e8cb:	c7 05 d0 eb 12 00 00 	movl   $0x0,0x12ebd0
  10e8d2:	00 00 00 
  10e8d5:	68 d8 eb 12 00       	push   $0x12ebd8
	global_event_mask = 0U;
  10e8da:	c7 05 d4 eb 12 00 00 	movl   $0x0,0x12ebd4
  10e8e1:	00 00 00 
	in_event = -1;
  10e8e4:	66 c7 05 74 ed 12 00 	movw   $0xffff,0x12ed74
  10e8eb:	ff ff 
	out_event = -1;
  10e8ed:	66 c7 05 72 ed 12 00 	movw   $0xffff,0x12ed72
  10e8f4:	ff ff 
	(void)memset(events, 0, CONFIG_NET_MGMT_EVENT_QUEUE_SIZE *
  10e8f6:	e8 60 d5 ff ff       	call   10be5b <memset>
  10e8fb:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  10e8fe:	6a 00                	push   $0x0
  10e900:	6a 00                	push   $0x0
  10e902:	6a 00                	push   $0x0
  10e904:	6a f7                	push   $0xfffffff7
  10e906:	6a 00                	push   $0x0
  10e908:	6a 00                	push   $0x0
  10e90a:	6a 00                	push   $0x0
  10e90c:	68 7f e5 10 00       	push   $0x10e57f
  10e911:	68 00 03 00 00       	push   $0x300
  10e916:	68 e0 1e 14 00       	push   $0x141ee0
  10e91b:	68 60 a9 12 00       	push   $0x12a960
  10e920:	e8 b1 32 01 00       	call   121bd6 <z_impl_k_thread_create>
  10e925:	83 c4 2c             	add    $0x2c,%esp
	return z_impl_k_thread_name_set(thread_id, value);
  10e928:	68 79 5e 12 00       	push   $0x125e79
  10e92d:	68 60 a9 12 00       	push   $0x12a960
  10e932:	e8 f6 30 01 00       	call   121a2d <z_impl_k_thread_name_set>
  10e937:	58                   	pop    %eax
  10e938:	5a                   	pop    %edx
	k_thread_name_set(&mgmt_thread_data, "net_mgmt");

	NET_DBG("Net MGMT initialized: queue of %u entries, stack size of %u",
		CONFIG_NET_MGMT_EVENT_QUEUE_SIZE,
		CONFIG_NET_MGMT_EVENT_STACK_SIZE);
}
  10e939:	c9                   	leave  
  10e93a:	c3                   	ret    

0010e93b <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  10e93b:	8b 00                	mov    (%eax),%eax
  10e93d:	25 f0 00 00 00       	and    $0xf0,%eax
  10e942:	3d e0 00 00 00       	cmp    $0xe0,%eax
  10e947:	0f 94 c0             	sete   %al
}
  10e94a:	c3                   	ret    

0010e94b <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol ip_proto,
			   uint16_t local_port,
			   const struct sockaddr *local_addr)

{
  10e94b:	55                   	push   %ebp
  10e94c:	89 e5                	mov    %esp,%ebp
  10e94e:	57                   	push   %edi
  10e94f:	56                   	push   %esi
  10e950:	53                   	push   %ebx
  10e951:	31 db                	xor    %ebx,%ebx
	int i;

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
  10e953:	f6 83 b2 aa 12 00 01 	testb  $0x1,0x12aab2(%ebx)
  10e95a:	74 27                	je     10e983 <check_used_port+0x38>
			continue;
		}

		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
  10e95c:	0f b7 b3 b0 aa 12 00 	movzwl 0x12aab0(%ebx),%esi
  10e963:	39 c6                	cmp    %eax,%esi
  10e965:	75 1c                	jne    10e983 <check_used_port+0x38>
  10e967:	66 39 93 46 aa 12 00 	cmp    %dx,0x12aa46(%ebx)
  10e96e:	75 13                	jne    10e983 <check_used_port+0x38>
							     sin6_addr,
				    &((struct sockaddr_in6 *)
				      local_addr)->sin6_addr)) {
				return -EEXIST;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10e970:	66 83 39 01          	cmpw   $0x1,(%ecx)
  10e974:	75 0d                	jne    10e983 <check_used_port+0x38>
			   local_addr->sa_family == AF_INET) {
			if (net_ipv4_addr_cmp(
  10e976:	8b b3 48 aa 12 00    	mov    0x12aa48(%ebx),%esi
  10e97c:	8b 79 04             	mov    0x4(%ecx),%edi
  10e97f:	39 3e                	cmp    %edi,(%esi)
  10e981:	74 12                	je     10e995 <check_used_port+0x4a>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10e983:	81 c3 98 00 00 00    	add    $0x98,%ebx
  10e989:	81 fb 90 03 00 00    	cmp    $0x390,%ebx
  10e98f:	75 c2                	jne    10e953 <check_used_port+0x8>
				return -EEXIST;
			}
		}
	}

	return 0;
  10e991:	31 c0                	xor    %eax,%eax
  10e993:	eb 05                	jmp    10e99a <check_used_port+0x4f>
				return -EEXIST;
  10e995:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
}
  10e99a:	5b                   	pop    %ebx
  10e99b:	5e                   	pop    %esi
  10e99c:	5f                   	pop    %edi
  10e99d:	5d                   	pop    %ebp
  10e99e:	c3                   	ret    

0010e99f <find_available_port>:

static uint16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
  10e99f:	55                   	push   %ebp
  10e9a0:	89 e5                	mov    %esp,%ebp
  10e9a2:	57                   	push   %edi
  10e9a3:	56                   	push   %esi
  10e9a4:	89 c7                	mov    %eax,%edi
  10e9a6:	53                   	push   %ebx
  10e9a7:	89 d6                	mov    %edx,%esi
  10e9a9:	e8 a4 15 01 00       	call   11ff52 <z_impl_sys_rand32_get>
		local_port = sys_rand32_get() | 0x8000;
		if (local_port <= 1023U) {
			/* 0 - 1023 ports are reserved */
			continue;
		}
	} while (check_used_port(net_context_get_ip_proto(context),
  10e9ae:	89 f1                	mov    %esi,%ecx
		local_port = sys_rand32_get() | 0x8000;
  10e9b0:	89 c3                	mov    %eax,%ebx
  10e9b2:	66 81 cb 00 80       	or     $0x8000,%bx
	} while (check_used_port(net_context_get_ip_proto(context),
  10e9b7:	0f b7 87 90 00 00 00 	movzwl 0x90(%edi),%eax
  10e9be:	86 fb                	xchg   %bh,%bl
  10e9c0:	0f b7 d3             	movzwl %bx,%edx
  10e9c3:	e8 83 ff ff ff       	call   10e94b <check_used_port>
				 htons(local_port), addr) == -EEXIST);
  10e9c8:	83 f8 ef             	cmp    $0xffffffef,%eax
  10e9cb:	74 dc                	je     10e9a9 <find_available_port+0xa>

	return htons(local_port);
}
  10e9cd:	89 d8                	mov    %ebx,%eax
  10e9cf:	5b                   	pop    %ebx
  10e9d0:	5e                   	pop    %esi
  10e9d1:	5f                   	pop    %edi
  10e9d2:	5d                   	pop    %ebp
  10e9d3:	c3                   	ret    

0010e9d4 <k_mutex_unlock>:
{
  10e9d4:	55                   	push   %ebp
  10e9d5:	89 e5                	mov    %esp,%ebp
	return z_impl_k_mutex_unlock(mutex);
  10e9d7:	50                   	push   %eax
  10e9d8:	e8 f1 22 01 00       	call   120cce <z_impl_k_mutex_unlock>
  10e9dd:	5a                   	pop    %edx
}
  10e9de:	c9                   	leave  
  10e9df:	c3                   	ret    

0010e9e0 <context_write_data>:
/* If buf is not NULL, then use it. Otherwise read the data to be written
 * to net_pkt from msghdr.
 */
static int context_write_data(struct net_pkt *pkt, const void *buf,
			      int buf_len, const struct msghdr *msghdr)
{
  10e9e0:	55                   	push   %ebp
  10e9e1:	89 e5                	mov    %esp,%ebp
  10e9e3:	57                   	push   %edi
  10e9e4:	56                   	push   %esi
  10e9e5:	8b 7d 08             	mov    0x8(%ebp),%edi
  10e9e8:	53                   	push   %ebx
	int ret = 0;

	if (msghdr) {
  10e9e9:	85 ff                	test   %edi,%edi
{
  10e9eb:	89 c3                	mov    %eax,%ebx
	if (msghdr) {
  10e9ed:	74 24                	je     10ea13 <context_write_data+0x33>
		int i;

		for (i = 0; i < msghdr->msg_iovlen; i++) {
  10e9ef:	31 f6                	xor    %esi,%esi
	int ret = 0;
  10e9f1:	31 c0                	xor    %eax,%eax
		for (i = 0; i < msghdr->msg_iovlen; i++) {
  10e9f3:	39 77 0c             	cmp    %esi,0xc(%edi)
  10e9f6:	76 26                	jbe    10ea1e <context_write_data+0x3e>
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
					    msghdr->msg_iov[i].iov_len);
  10e9f8:	8b 47 08             	mov    0x8(%edi),%eax
  10e9fb:	8d 04 f0             	lea    (%eax,%esi,8),%eax
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
  10e9fe:	ff 70 04             	pushl  0x4(%eax)
  10ea01:	ff 30                	pushl  (%eax)
  10ea03:	53                   	push   %ebx
  10ea04:	e8 f6 19 00 00       	call   1103ff <net_pkt_write>
  10ea09:	83 c4 0c             	add    $0xc,%esp
			if (ret < 0) {
  10ea0c:	85 c0                	test   %eax,%eax
  10ea0e:	78 0e                	js     10ea1e <context_write_data+0x3e>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
  10ea10:	46                   	inc    %esi
  10ea11:	eb e0                	jmp    10e9f3 <context_write_data+0x13>
				break;
			}
		}
	} else {
		ret = net_pkt_write(pkt, buf, buf_len);
  10ea13:	51                   	push   %ecx
  10ea14:	52                   	push   %edx
  10ea15:	50                   	push   %eax
  10ea16:	e8 e4 19 00 00       	call   1103ff <net_pkt_write>
  10ea1b:	83 c4 0c             	add    $0xc,%esp
	}

	return ret;
}
  10ea1e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ea21:	5b                   	pop    %ebx
  10ea22:	5e                   	pop    %esi
  10ea23:	5f                   	pop    %edi
  10ea24:	5d                   	pop    %ebp
  10ea25:	c3                   	ret    

0010ea26 <k_mutex_lock.constprop.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
  10ea26:	55                   	push   %ebp
  10ea27:	89 e5                	mov    %esp,%ebp
  10ea29:	53                   	push   %ebx
	return z_impl_k_mutex_lock(mutex, timeout);
  10ea2a:	51                   	push   %ecx
  10ea2b:	52                   	push   %edx
  10ea2c:	50                   	push   %eax
  10ea2d:	e8 9e 21 01 00       	call   120bd0 <z_impl_k_mutex_lock>
  10ea32:	83 c4 0c             	add    $0xc,%esp
}
  10ea35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10ea38:	c9                   	leave  
  10ea39:	c3                   	ret    

0010ea3a <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
  10ea3a:	55                   	push   %ebp
  10ea3b:	89 e5                	mov    %esp,%ebp
  10ea3d:	57                   	push   %edi
  10ea3e:	56                   	push   %esi
  10ea3f:	53                   	push   %ebx
  10ea40:	8b 45 08             	mov    0x8(%ebp),%eax
  10ea43:	8b 75 0c             	mov    0xc(%ebp),%esi
  10ea46:	bb 20 aa 12 00       	mov    $0x12aa20,%ebx
		if (!net_context_is_used(&contexts[i])) {
  10ea4b:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
  10ea52:	74 05                	je     10ea59 <net_context_packet_received+0x1f>
		if (contexts[i].conn_handler == conn_handler) {
  10ea54:	3b 43 34             	cmp    0x34(%ebx),%eax
  10ea57:	74 2f                	je     10ea88 <net_context_packet_received+0x4e>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10ea59:	81 c3 98 00 00 00    	add    $0x98,%ebx
  10ea5f:	81 fb b0 ad 12 00    	cmp    $0x12adb0,%ebx
  10ea65:	75 e4                	jne    10ea4b <net_context_packet_received+0x11>
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
	NET_ASSERT(net_pkt_iface(pkt));

	k_mutex_lock(&context->lock, K_FOREVER);
  10ea67:	83 ca ff             	or     $0xffffffff,%edx
  10ea6a:	b8 08 00 00 00       	mov    $0x8,%eax
  10ea6f:	89 d1                	mov    %edx,%ecx
  10ea71:	e8 b0 ff ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
static inline void net_context_set_iface(struct net_context *context,
					 struct net_if *iface)
{
	NET_ASSERT(iface);

	context->iface = net_if_get_by_iface(iface);
  10ea76:	ff 76 20             	pushl  0x20(%esi)
  10ea79:	e8 78 f1 ff ff       	call   10dbf6 <net_if_get_by_iface>
  10ea7e:	58                   	pop    %eax
  10ea7f:	c6 05 94 00 00 00 00 	movb   $0x0,0x94
  10ea86:	0f 0b                	ud2    
  10ea88:	83 ca ff             	or     $0xffffffff,%edx
  10ea8b:	8d 7b 08             	lea    0x8(%ebx),%edi
  10ea8e:	89 d1                	mov    %edx,%ecx
  10ea90:	89 f8                	mov    %edi,%eax
  10ea92:	e8 8f ff ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
  10ea97:	ff 76 20             	pushl  0x20(%esi)
  10ea9a:	e8 57 f1 ff ff       	call   10dbf6 <net_if_get_by_iface>
  10ea9f:	59                   	pop    %ecx
  10eaa0:	88 83 94 00 00 00    	mov    %al,0x94(%ebx)
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
  10eaa6:	83 7b 38 00          	cmpl   $0x0,0x38(%ebx)
	pkt->context = ctx;
  10eaaa:	89 5e 1c             	mov    %ebx,0x1c(%esi)
  10eaad:	75 0e                	jne    10eabd <net_context_packet_received+0x83>
	verdict = NET_OK;

	return verdict;

unlock:
	k_mutex_unlock(&context->lock);
  10eaaf:	89 f8                	mov    %edi,%eax
  10eab1:	e8 1e ff ff ff       	call   10e9d4 <k_mutex_unlock>

	return verdict;
  10eab6:	b8 02 00 00 00       	mov    $0x2,%eax
  10eabb:	eb 26                	jmp    10eae3 <net_context_packet_received+0xa9>
	k_sem_give(&context->recv_data_wait);
  10eabd:	8d 43 48             	lea    0x48(%ebx),%eax
	z_impl_k_sem_give(sem);
  10eac0:	50                   	push   %eax
  10eac1:	e8 d3 2d 01 00       	call   121899 <z_impl_k_sem_give>
  10eac6:	5a                   	pop    %edx
	k_mutex_unlock(&context->lock);
  10eac7:	89 f8                	mov    %edi,%eax
  10eac9:	e8 06 ff ff ff       	call   10e9d4 <k_mutex_unlock>
	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
  10eace:	ff 75 18             	pushl  0x18(%ebp)
  10ead1:	6a 00                	push   $0x0
  10ead3:	ff 75 14             	pushl  0x14(%ebp)
  10ead6:	ff 75 10             	pushl  0x10(%ebp)
  10ead9:	56                   	push   %esi
  10eada:	53                   	push   %ebx
  10eadb:	ff 53 38             	call   *0x38(%ebx)
  10eade:	83 c4 18             	add    $0x18,%esp
	return verdict;
  10eae1:	31 c0                	xor    %eax,%eax
}
  10eae3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10eae6:	5b                   	pop    %ebx
  10eae7:	5e                   	pop    %esi
  10eae8:	5f                   	pop    %edi
  10eae9:	5d                   	pop    %ebp
  10eaea:	c3                   	ret    

0010eaeb <net_context_get>:
{
  10eaeb:	55                   	push   %ebp
  10eaec:	89 e5                	mov    %esp,%ebp
  10eaee:	57                   	push   %edi
  10eaef:	56                   	push   %esi
  10eaf0:	53                   	push   %ebx
  10eaf1:	83 ec 08             	sub    $0x8,%esp
  10eaf4:	8b 7d 08             	mov    0x8(%ebp),%edi
  10eaf7:	8b 45 10             	mov    0x10(%ebp),%eax
  10eafa:	89 45 f0             	mov    %eax,-0x10(%ebp)
			return -EPFNOSUPPORT;
  10eafd:	b8 d2 ff ff ff       	mov    $0xffffffd2,%eax
		if (!IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
  10eb02:	8d 57 fe             	lea    -0x2(%edi),%edx
		if (!IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == AF_CAN) {
  10eb05:	66 f7 c2 fd ff       	test   $0xfffd,%dx
  10eb0a:	0f 84 f6 01 00 00    	je     10ed06 <net_context_get+0x21b>
		if (type == SOCK_RAW) {
  10eb10:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  10eb14:	74 12                	je     10eb28 <net_context_get+0x3d>
			} else if (family == AF_PACKET || family == AF_CAN) {
  10eb16:	8d 57 fd             	lea    -0x3(%edi),%edx
				return -EPROTOTYPE;
  10eb19:	b8 d7 ff ff ff       	mov    $0xffffffd7,%eax
			} else if (family == AF_PACKET || family == AF_CAN) {
  10eb1e:	66 83 fa 01          	cmp    $0x1,%dx
  10eb22:	0f 86 de 01 00 00    	jbe    10ed06 <net_context_get+0x21b>
		    family != AF_PACKET && family != AF_CAN) {
  10eb28:	8d 57 ff             	lea    -0x1(%edi),%edx
			return -EAFNOSUPPORT;
  10eb2b:	b8 d1 ff ff ff       	mov    $0xffffffd1,%eax
		if (family != AF_INET && family != AF_INET6 &&
  10eb30:	66 83 fa 03          	cmp    $0x3,%dx
  10eb34:	0f 87 cc 01 00 00    	ja     10ed06 <net_context_get+0x21b>
		if (type != SOCK_DGRAM && type != SOCK_STREAM &&
  10eb3a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10eb3d:	8d 50 ff             	lea    -0x1(%eax),%edx
				return -EPROTOTYPE;
  10eb40:	b8 d7 ff ff ff       	mov    $0xffffffd7,%eax
		if (type != SOCK_DGRAM && type != SOCK_STREAM &&
  10eb45:	83 fa 02             	cmp    $0x2,%edx
  10eb48:	0f 87 b8 01 00 00    	ja     10ed06 <net_context_get+0x21b>
		if (type != SOCK_RAW && ip_proto != IPPROTO_UDP &&
  10eb4e:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
  10eb52:	74 18                	je     10eb6c <net_context_get+0x81>
  10eb54:	66 83 7d f0 11       	cmpw   $0x11,-0x10(%ebp)
  10eb59:	74 11                	je     10eb6c <net_context_get+0x81>
  10eb5b:	66 83 7d f0 06       	cmpw   $0x6,-0x10(%ebp)
			return -EPROTONOSUPPORT;
  10eb60:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
		if (type != SOCK_RAW && ip_proto != IPPROTO_UDP &&
  10eb65:	74 1b                	je     10eb82 <net_context_get+0x97>
  10eb67:	e9 9a 01 00 00       	jmp    10ed06 <net_context_get+0x21b>
		if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
  10eb6c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  10eb70:	75 10                	jne    10eb82 <net_context_get+0x97>
  10eb72:	66 83 7d f0 11       	cmpw   $0x11,-0x10(%ebp)
			return -EOPNOTSUPP;
  10eb77:	b8 d3 ff ff ff       	mov    $0xffffffd3,%eax
		if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
  10eb7c:	0f 84 84 01 00 00    	je     10ed06 <net_context_get+0x21b>
  10eb82:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
  10eb86:	75 10                	jne    10eb98 <net_context_get+0xad>
  10eb88:	66 83 7d f0 06       	cmpw   $0x6,-0x10(%ebp)
			return -EOPNOTSUPP;
  10eb8d:	b8 d3 ff ff ff       	mov    $0xffffffd3,%eax
		if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
  10eb92:	0f 84 6e 01 00 00    	je     10ed06 <net_context_get+0x21b>
		if (!context) {
  10eb98:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
			return -EINVAL;
  10eb9c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (!context) {
  10eba1:	0f 84 5f 01 00 00    	je     10ed06 <net_context_get+0x21b>
	return z_impl_k_sem_take(sem, timeout);
  10eba7:	6a ff                	push   $0xffffffff
  10eba9:	bb 20 aa 12 00       	mov    $0x12aa20,%ebx
  10ebae:	6a ff                	push   $0xffffffff
  10ebb0:	68 00 aa 12 00       	push   $0x12aa00
  10ebb5:	e8 38 2d 01 00       	call   1218f2 <z_impl_k_sem_take>
  10ebba:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10ebbd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		if (net_context_is_used(&contexts[i])) {
  10ebc4:	69 75 ec 98 00 00 00 	imul   $0x98,-0x14(%ebp),%esi
  10ebcb:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
  10ebd2:	74 19                	je     10ebed <net_context_get+0x102>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10ebd4:	ff 45 ec             	incl   -0x14(%ebp)
  10ebd7:	81 c3 98 00 00 00    	add    $0x98,%ebx
  10ebdd:	83 7d ec 06          	cmpl   $0x6,-0x14(%ebp)
  10ebe1:	75 e1                	jne    10ebc4 <net_context_get+0xd9>
	int i, ret = -ENOENT;
  10ebe3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  10ebe8:	e9 08 01 00 00       	jmp    10ecf5 <net_context_get+0x20a>
		memset(&contexts[i], 0, sizeof(contexts[i]));
  10ebed:	68 98 00 00 00       	push   $0x98
  10ebf2:	6a 00                	push   $0x0
  10ebf4:	53                   	push   %ebx
  10ebf5:	e8 61 d2 ff ff       	call   10be5b <memset>
  10ebfa:	83 c4 0c             	add    $0xc,%esp
		if (!net_if_is_ip_offloaded(net_if_get_default())
  10ebfd:	e8 56 ea ff ff       	call   10d658 <net_if_get_default>
			&& ip_proto == IPPROTO_TCP) {
  10ec02:	66 83 7d f0 06       	cmpw   $0x6,-0x10(%ebp)
  10ec07:	0f 84 81 00 00 00    	je     10ec8e <net_context_get+0x1a3>
		contexts[i].iface = -1;
  10ec0d:	69 45 ec 98 00 00 00 	imul   $0x98,-0x14(%ebp),%eax
  10ec14:	05 20 aa 12 00       	add    $0x12aa20,%eax
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
  10ec19:	ba 01 00 00 00       	mov    $0x1,%edx
  10ec1e:	c6 80 94 00 00 00 ff 	movb   $0xff,0x94(%eax)
		contexts[i].flags = 0U;
  10ec25:	66 c7 80 92 00 00 00 	movw   $0x0,0x92(%eax)
  10ec2c:	00 00 
  10ec2e:	87 96 24 aa 12 00    	xchg   %edx,0x12aa24(%esi)
		flag = family << 3;
  10ec34:	8d 14 fd 00 00 00 00 	lea    0x0(,%edi,8),%edx
	context->flags |= flag;
  10ec3b:	0f b6 d2             	movzbl %dl,%edx
  10ec3e:	66 09 90 92 00 00 00 	or     %dx,0x92(%eax)
		flag = type << 6;
  10ec45:	8b 55 0c             	mov    0xc(%ebp),%edx
  10ec48:	c1 e2 06             	shl    $0x6,%edx
	context->proto = proto;
  10ec4b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	context->flags |= flag;
  10ec4e:	66 09 93 92 00 00 00 	or     %dx,0x92(%ebx)
	context->proto = proto;
  10ec55:	66 89 88 90 00 00 00 	mov    %cx,0x90(%eax)
			(void)memset(&contexts[i].remote, 0,
  10ec5c:	6a 08                	push   $0x8
  10ec5e:	8d 86 4c aa 12 00    	lea    0x12aa4c(%esi),%eax
  10ec64:	6a 00                	push   $0x0
  10ec66:	50                   	push   %eax
  10ec67:	e8 ef d1 ff ff       	call   10be5b <memset>
  10ec6c:	83 c4 0c             	add    $0xc,%esp
			(void)memset(&contexts[i].local, 0,
  10ec6f:	8d 96 44 aa 12 00    	lea    0x12aa44(%esi),%edx
  10ec75:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10ec78:	6a 08                	push   $0x8
  10ec7a:	6a 00                	push   $0x0
  10ec7c:	52                   	push   %edx
  10ec7d:	e8 d9 d1 ff ff       	call   10be5b <memset>
  10ec82:	83 c4 0c             	add    $0xc,%esp
		if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
  10ec85:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10ec88:	66 4f                	dec    %di
  10ec8a:	75 16                	jne    10eca2 <net_context_get+0x1b7>
  10ec8c:	eb 4c                	jmp    10ecda <net_context_get+0x1ef>
			if (net_tcp_get(&contexts[i]) < 0) {
  10ec8e:	53                   	push   %ebx
  10ec8f:	e8 ce 40 00 00       	call   112d62 <net_tcp_get>
  10ec94:	59                   	pop    %ecx
  10ec95:	85 c0                	test   %eax,%eax
  10ec97:	0f 89 70 ff ff ff    	jns    10ec0d <net_context_get+0x122>
  10ec9d:	e9 41 ff ff ff       	jmp    10ebe3 <net_context_get+0xf8>
	return z_impl_k_sem_init(sem, initial_count, limit);
  10eca2:	6a ff                	push   $0xffffffff
		k_sem_init(&contexts[i].recv_data_wait, 1, UINT_MAX);
  10eca4:	8d 86 68 aa 12 00    	lea    0x12aa68(%esi),%eax
  10ecaa:	6a 01                	push   $0x1
  10ecac:	50                   	push   %eax
  10ecad:	e8 a5 2b 01 00       	call   121857 <z_impl_k_sem_init>
  10ecb2:	83 c4 0c             	add    $0xc,%esp
		k_mutex_init(&contexts[i].lock);
  10ecb5:	81 c6 28 aa 12 00    	add    $0x12aa28,%esi
	return z_impl_k_mutex_init(mutex);
  10ecbb:	56                   	push   %esi
  10ecbc:	e8 e5 1e 01 00       	call   120ba6 <z_impl_k_mutex_init>
		contexts[i].flags |= NET_CONTEXT_IN_USE;
  10ecc1:	69 45 ec 98 00 00 00 	imul   $0x98,-0x14(%ebp),%eax
  10ecc8:	5a                   	pop    %edx
  10ecc9:	66 83 88 b2 aa 12 00 	orw    $0x1,0x12aab2(%eax)
  10ecd0:	01 
		*context = &contexts[i];
  10ecd1:	8b 45 14             	mov    0x14(%ebp),%eax
  10ecd4:	89 18                	mov    %ebx,(%eax)
		ret = 0;
  10ecd6:	31 c0                	xor    %eax,%eax
		break;
  10ecd8:	eb 1b                	jmp    10ecf5 <net_context_get+0x20a>
			addr->sin_port = find_available_port(&contexts[i],
  10ecda:	89 d8                	mov    %ebx,%eax
  10ecdc:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10ecdf:	e8 bb fc ff ff       	call   10e99f <find_available_port>
  10ece4:	8b 55 f0             	mov    -0x10(%ebp),%edx
			if (!addr->sin_port) {
  10ece7:	66 85 c0             	test   %ax,%ax
			addr->sin_port = find_available_port(&contexts[i],
  10ecea:	66 89 42 02          	mov    %ax,0x2(%edx)
			if (!addr->sin_port) {
  10ecee:	75 b2                	jne    10eca2 <net_context_get+0x1b7>
				ret = -EADDRINUSE;
  10ecf0:	b8 d0 ff ff ff       	mov    $0xffffffd0,%eax
  10ecf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	z_impl_k_sem_give(sem);
  10ecf8:	68 00 aa 12 00       	push   $0x12aa00
  10ecfd:	e8 97 2b 01 00       	call   121899 <z_impl_k_sem_give>
  10ed02:	58                   	pop    %eax
  10ed03:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  10ed06:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ed09:	5b                   	pop    %ebx
  10ed0a:	5e                   	pop    %esi
  10ed0b:	5f                   	pop    %edi
  10ed0c:	5d                   	pop    %ebp
  10ed0d:	c3                   	ret    

0010ed0e <net_context_ref>:
{
  10ed0e:	55                   	push   %ebp
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  10ed0f:	b8 01 00 00 00       	mov    $0x1,%eax
  10ed14:	89 e5                	mov    %esp,%ebp
  10ed16:	8b 55 08             	mov    0x8(%ebp),%edx
  10ed19:	f0 0f c1 42 04       	lock xadd %eax,0x4(%edx)
	return old_rc + 1;
  10ed1e:	40                   	inc    %eax
}
  10ed1f:	5d                   	pop    %ebp
  10ed20:	c3                   	ret    

0010ed21 <net_context_unref>:
{
  10ed21:	55                   	push   %ebp
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  10ed22:	83 c8 ff             	or     $0xffffffff,%eax
  10ed25:	89 e5                	mov    %esp,%ebp
  10ed27:	56                   	push   %esi
  10ed28:	53                   	push   %ebx
  10ed29:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10ed2c:	f0 0f c1 43 04       	lock xadd %eax,0x4(%ebx)
	if (old_rc != 1) {
  10ed31:	83 f8 01             	cmp    $0x1,%eax
  10ed34:	74 03                	je     10ed39 <net_context_unref+0x18>
		return old_rc - 1;
  10ed36:	48                   	dec    %eax
  10ed37:	eb 3c                	jmp    10ed75 <net_context_unref+0x54>
	k_mutex_lock(&context->lock, K_FOREVER);
  10ed39:	83 ca ff             	or     $0xffffffff,%edx
  10ed3c:	8d 73 08             	lea    0x8(%ebx),%esi
  10ed3f:	89 d1                	mov    %edx,%ecx
  10ed41:	89 f0                	mov    %esi,%eax
  10ed43:	e8 de fc ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	net_tcp_unref(context);
  10ed48:	53                   	push   %ebx
  10ed49:	e8 fd 3f 00 00       	call   112d4b <net_tcp_unref>
	if (context->conn_handler) {
  10ed4e:	8b 43 34             	mov    0x34(%ebx),%eax
	net_tcp_unref(context);
  10ed51:	5a                   	pop    %edx
	if (context->conn_handler) {
  10ed52:	85 c0                	test   %eax,%eax
  10ed54:	74 0e                	je     10ed64 <net_context_unref+0x43>
			net_conn_unregister(context->conn_handler);
  10ed56:	50                   	push   %eax
  10ed57:	e8 fb 23 00 00       	call   111157 <net_conn_unregister>
  10ed5c:	58                   	pop    %eax
		context->conn_handler = NULL;
  10ed5d:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
	context->flags &= ~NET_CONTEXT_IN_USE;
  10ed64:	66 83 a3 92 00 00 00 	andw   $0xfff8,0x92(%ebx)
  10ed6b:	f8 
	k_mutex_unlock(&context->lock);
  10ed6c:	89 f0                	mov    %esi,%eax
  10ed6e:	e8 61 fc ff ff       	call   10e9d4 <k_mutex_unlock>
	return 0;
  10ed73:	31 c0                	xor    %eax,%eax
}
  10ed75:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10ed78:	5b                   	pop    %ebx
  10ed79:	5e                   	pop    %esi
  10ed7a:	5d                   	pop    %ebp
  10ed7b:	c3                   	ret    

0010ed7c <net_context_put>:
{
  10ed7c:	55                   	push   %ebp
  10ed7d:	89 e5                	mov    %esp,%ebp
  10ed7f:	56                   	push   %esi
  10ed80:	53                   	push   %ebx
  10ed81:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!PART_OF_ARRAY(contexts, context)) {
  10ed84:	85 db                	test   %ebx,%ebx
  10ed86:	0f 94 c2             	sete   %dl
  10ed89:	81 fb 20 aa 12 00    	cmp    $0x12aa20,%ebx
  10ed8f:	0f 92 c0             	setb   %al
  10ed92:	08 c2                	or     %al,%dl
  10ed94:	75 46                	jne    10eddc <net_context_put+0x60>
  10ed96:	81 fb b0 ad 12 00    	cmp    $0x12adb0,%ebx
  10ed9c:	73 3e                	jae    10eddc <net_context_put+0x60>
	k_mutex_lock(&context->lock, K_FOREVER);
  10ed9e:	83 ca ff             	or     $0xffffffff,%edx
  10eda1:	8d 73 08             	lea    0x8(%ebx),%esi
  10eda4:	89 d1                	mov    %edx,%ecx
  10eda6:	89 f0                	mov    %esi,%eax
  10eda8:	e8 79 fc ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	context->connect_cb = NULL;
  10edad:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
	context->recv_cb = NULL;
  10edb4:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	context->send_cb = NULL;
  10edbb:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
	net_context_unref(context);
  10edc2:	53                   	push   %ebx
  10edc3:	e8 59 ff ff ff       	call   10ed21 <net_context_unref>
	net_tcp_put(context);
  10edc8:	89 1c 24             	mov    %ebx,(%esp)
  10edcb:	e8 f1 40 00 00       	call   112ec1 <net_tcp_put>
  10edd0:	58                   	pop    %eax
	k_mutex_unlock(&context->lock);
  10edd1:	89 f0                	mov    %esi,%eax
  10edd3:	e8 fc fb ff ff       	call   10e9d4 <k_mutex_unlock>
	return ret;
  10edd8:	31 c0                	xor    %eax,%eax
  10edda:	eb 05                	jmp    10ede1 <net_context_put+0x65>
		return -EINVAL;
  10eddc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  10ede1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10ede4:	5b                   	pop    %ebx
  10ede5:	5e                   	pop    %esi
  10ede6:	5d                   	pop    %ebp
  10ede7:	c3                   	ret    

0010ede8 <net_context_bind>:
{
  10ede8:	55                   	push   %ebp
  10ede9:	89 e5                	mov    %esp,%ebp
  10edeb:	57                   	push   %edi
  10edec:	56                   	push   %esi
		return -EISCONN;
  10eded:	be c8 ff ff ff       	mov    $0xffffffc8,%esi
{
  10edf2:	53                   	push   %ebx
  10edf3:	83 ec 08             	sub    $0x8,%esp
  10edf6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (context->conn_handler) {
  10edf9:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
  10edfd:	0f 85 70 01 00 00    	jne    10ef73 <net_context_bind+0x18b>
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
  10ee03:	8b 45 0c             	mov    0xc(%ebp),%eax
	return -EINVAL;
  10ee06:	be ea ff ff ff       	mov    $0xffffffea,%esi
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
  10ee0b:	66 83 38 01          	cmpw   $0x1,(%eax)
  10ee0f:	0f 85 5e 01 00 00    	jne    10ef73 <net_context_bind+0x18b>
		if (addrlen < sizeof(struct sockaddr_in)) {
  10ee15:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
		struct net_if *iface = NULL;
  10ee19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		if (addrlen < sizeof(struct sockaddr_in)) {
  10ee20:	0f 86 4d 01 00 00    	jbe    10ef73 <net_context_bind+0x18b>
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
  10ee26:	8d 78 04             	lea    0x4(%eax),%edi
  10ee29:	89 f8                	mov    %edi,%eax
  10ee2b:	e8 0b fb ff ff       	call   10e93b <net_ipv4_is_addr_mcast>
  10ee30:	84 c0                	test   %al,%al
  10ee32:	74 1d                	je     10ee51 <net_context_bind+0x69>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
  10ee34:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10ee37:	50                   	push   %eax
  10ee38:	57                   	push   %edi
  10ee39:	e8 46 eb ff ff       	call   10d984 <net_if_ipv4_maddr_lookup>
  10ee3e:	5a                   	pop    %edx
			if (!maddr) {
  10ee3f:	85 c0                	test   %eax,%eax
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
  10ee41:	59                   	pop    %ecx
			ptr = &maddr->address.in_addr;
  10ee42:	8d 70 04             	lea    0x4(%eax),%esi
			if (!maddr) {
  10ee45:	75 3c                	jne    10ee83 <net_context_bind+0x9b>
				return -ENOENT;
  10ee47:	be fe ff ff ff       	mov    $0xfffffffe,%esi
  10ee4c:	e9 22 01 00 00       	jmp    10ef73 <net_context_bind+0x18b>
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
  10ee51:	8b 45 0c             	mov    0xc(%ebp),%eax
  10ee54:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  10ee58:	75 16                	jne    10ee70 <net_context_bind+0x88>
				&net_sin(&context->remote)->sin_addr);
  10ee5a:	8d 43 30             	lea    0x30(%ebx),%eax
			iface = net_if_ipv4_select_src_iface(
  10ee5d:	50                   	push   %eax
  10ee5e:	e8 f1 e8 ff ff       	call   10d754 <net_if_ipv4_select_src_iface>
  10ee63:	5e                   	pop    %esi
  10ee64:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
  10ee67:	e8 e7 f6 ff ff       	call   10e553 <net_ipv4_unspecified_address>
  10ee6c:	89 c6                	mov    %eax,%esi
  10ee6e:	eb 13                	jmp    10ee83 <net_context_bind+0x9b>
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
  10ee70:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10ee73:	50                   	push   %eax
  10ee74:	57                   	push   %edi
  10ee75:	e8 f7 e9 ff ff       	call   10d871 <net_if_ipv4_addr_lookup>
  10ee7a:	5a                   	pop    %edx
			if (!ifaddr) {
  10ee7b:	85 c0                	test   %eax,%eax
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
  10ee7d:	59                   	pop    %ecx
			if (!ifaddr) {
  10ee7e:	74 c7                	je     10ee47 <net_context_bind+0x5f>
			ptr = &ifaddr->address.in_addr;
  10ee80:	8d 70 04             	lea    0x4(%eax),%esi
		if (!iface) {
  10ee83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10ee87:	75 4d                	jne    10eed6 <net_context_bind+0xee>
			NET_ERR("Cannot bind to %s",
  10ee89:	f6 05 bc 5b 14 00 07 	testb  $0x7,0x145bbc
			return -EADDRNOTAVAIL;
  10ee90:	be cf ff ff ff       	mov    $0xffffffcf,%esi
			NET_ERR("Cannot bind to %s",
  10ee95:	0f 84 d8 00 00 00    	je     10ef73 <net_context_bind+0x18b>
  10ee9b:	57                   	push   %edi
  10ee9c:	bb f8 30 12 00       	mov    $0x1230f8,%ebx
  10eea1:	6a 01                	push   $0x1
  10eea3:	e8 fc f2 ff ff       	call   10e1a4 <net_sprint_addr>
  10eea8:	59                   	pop    %ecx
  10eea9:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  10eeaf:	c1 eb 03             	shr    $0x3,%ebx
  10eeb2:	5f                   	pop    %edi
  10eeb3:	c1 e3 06             	shl    $0x6,%ebx
  10eeb6:	50                   	push   %eax
  10eeb7:	e8 9b 43 ff ff       	call   103257 <log_strdup>
  10eebc:	83 cb 01             	or     $0x1,%ebx
  10eebf:	66 89 1c 24          	mov    %bx,(%esp)
  10eec3:	50                   	push   %eax
  10eec4:	68 82 5e 12 00       	push   $0x125e82
  10eec9:	e8 a8 46 ff ff       	call   103576 <log_1>
  10eece:	83 c4 0c             	add    $0xc,%esp
  10eed1:	e9 9d 00 00 00       	jmp    10ef73 <net_context_bind+0x18b>
		k_mutex_lock(&context->lock, K_FOREVER);
  10eed6:	83 ca ff             	or     $0xffffffff,%edx
  10eed9:	8d 43 08             	lea    0x8(%ebx),%eax
  10eedc:	89 d1                	mov    %edx,%ecx
  10eede:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10eee1:	e8 40 fb ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	context->iface = net_if_get_by_iface(iface);
  10eee6:	ff 75 f0             	pushl  -0x10(%ebp)
  10eee9:	e8 08 ed ff ff       	call   10dbf6 <net_if_get_by_iface>
  10eeee:	5a                   	pop    %edx
  10eeef:	88 83 94 00 00 00    	mov    %al,0x94(%ebx)
		if (addr4->sin_port) {
  10eef5:	8b 45 0c             	mov    0xc(%ebp),%eax
		net_sin_ptr(&context->local)->sin_family = AF_INET;
  10eef8:	66 c7 43 24 01 00    	movw   $0x1,0x24(%ebx)
		net_sin_ptr(&context->local)->sin_addr = ptr;
  10eefe:	89 73 28             	mov    %esi,0x28(%ebx)
		if (addr4->sin_port) {
  10ef01:	66 8b 78 02          	mov    0x2(%eax),%di
  10ef05:	66 85 ff             	test   %di,%di
  10ef08:	74 54                	je     10ef5e <net_context_bind+0x176>
			ret = check_used_port(AF_INET, addr4->sin_port,
  10ef0a:	89 c1                	mov    %eax,%ecx
  10ef0c:	b8 01 00 00 00       	mov    $0x1,%eax
  10ef11:	0f b7 d7             	movzwl %di,%edx
  10ef14:	e8 32 fa ff ff       	call   10e94b <check_used_port>
  10ef19:	89 c6                	mov    %eax,%esi
			if (!ret) {
  10ef1b:	85 c0                	test   %eax,%eax
  10ef1d:	75 06                	jne    10ef25 <net_context_bind+0x13d>
				net_sin_ptr(&context->local)->sin_port =
  10ef1f:	66 89 7b 26          	mov    %di,0x26(%ebx)
  10ef23:	eb 46                	jmp    10ef6b <net_context_bind+0x183>
				NET_ERR("Port %d is in use!",
  10ef25:	f6 05 bc 5b 14 00 07 	testb  $0x7,0x145bbc
  10ef2c:	74 3d                	je     10ef6b <net_context_bind+0x183>
  10ef2e:	c1 e2 08             	shl    $0x8,%edx
  10ef31:	b8 f8 30 12 00       	mov    $0x1230f8,%eax
  10ef36:	66 c1 ef 08          	shr    $0x8,%di
  10ef3a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10ef3f:	c1 e8 03             	shr    $0x3,%eax
  10ef42:	09 d7                	or     %edx,%edi
  10ef44:	c1 e0 06             	shl    $0x6,%eax
  10ef47:	83 c8 01             	or     $0x1,%eax
  10ef4a:	50                   	push   %eax
  10ef4b:	0f b7 ff             	movzwl %di,%edi
  10ef4e:	57                   	push   %edi
  10ef4f:	68 94 5e 12 00       	push   $0x125e94
  10ef54:	e8 1d 46 ff ff       	call   103576 <log_1>
  10ef59:	83 c4 0c             	add    $0xc,%esp
  10ef5c:	eb 0d                	jmp    10ef6b <net_context_bind+0x183>
			addr4->sin_port =
  10ef5e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10ef61:	66 8b 43 26          	mov    0x26(%ebx),%ax
		ret = 0;
  10ef65:	31 f6                	xor    %esi,%esi
			addr4->sin_port =
  10ef67:	66 89 41 02          	mov    %ax,0x2(%ecx)
		k_mutex_unlock(&context->lock);
  10ef6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10ef6e:	e8 61 fa ff ff       	call   10e9d4 <k_mutex_unlock>
}
  10ef73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ef76:	89 f0                	mov    %esi,%eax
  10ef78:	5b                   	pop    %ebx
  10ef79:	5e                   	pop    %esi
  10ef7a:	5f                   	pop    %edi
  10ef7b:	5d                   	pop    %ebp
  10ef7c:	c3                   	ret    

0010ef7d <bind_default>:
{
  10ef7d:	55                   	push   %ebp
  10ef7e:	89 e5                	mov    %esp,%ebp
  10ef80:	56                   	push   %esi
  10ef81:	53                   	push   %ebx
  10ef82:	89 c3                	mov    %eax,%ebx
  10ef84:	83 ec 08             	sub    $0x8,%esp
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  10ef87:	0f b7 80 92 00 00 00 	movzwl 0x92(%eax),%eax
  10ef8e:	c1 e8 03             	shr    $0x3,%eax
  10ef91:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
  10ef94:	66 48                	dec    %ax
	return -EINVAL;
  10ef96:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
  10ef9b:	75 31                	jne    10efce <bind_default+0x51>
			return 0;
  10ef9d:	31 c0                	xor    %eax,%eax
		if (net_sin_ptr(&context->local)->sin_addr) {
  10ef9f:	83 7b 28 00          	cmpl   $0x0,0x28(%ebx)
  10efa3:	75 29                	jne    10efce <bind_default+0x51>
			find_available_port(context,
  10efa5:	8d 75 f0             	lea    -0x10(%ebp),%esi
  10efa8:	89 d8                	mov    %ebx,%eax
  10efaa:	89 f2                	mov    %esi,%edx
		addr4.sin_family = AF_INET;
  10efac:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
		addr4.sin_addr.s_addr = INADDR_ANY;
  10efb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			find_available_port(context,
  10efb9:	e8 e1 f9 ff ff       	call   10e99f <find_available_port>
		return net_context_bind(context, (struct sockaddr *)&addr4,
  10efbe:	6a 08                	push   $0x8
		addr4.sin_port =
  10efc0:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
		return net_context_bind(context, (struct sockaddr *)&addr4,
  10efc4:	56                   	push   %esi
  10efc5:	53                   	push   %ebx
  10efc6:	e8 1d fe ff ff       	call   10ede8 <net_context_bind>
  10efcb:	83 c4 0c             	add    $0xc,%esp
}
  10efce:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10efd1:	5b                   	pop    %ebx
  10efd2:	5e                   	pop    %esi
  10efd3:	5d                   	pop    %ebp
  10efd4:	c3                   	ret    

0010efd5 <net_context_listen>:
{
  10efd5:	55                   	push   %ebp
		return -EBADF;
  10efd6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
{
  10efdb:	89 e5                	mov    %esp,%ebp
  10efdd:	56                   	push   %esi
  10efde:	53                   	push   %ebx
  10efdf:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!net_context_is_used(context)) {
  10efe2:	f6 86 92 00 00 00 01 	testb  $0x1,0x92(%esi)
  10efe9:	74 2f                	je     10f01a <net_context_listen+0x45>
	k_mutex_lock(&context->lock, K_FOREVER);
  10efeb:	83 ca ff             	or     $0xffffffff,%edx
  10efee:	8d 5e 08             	lea    0x8(%esi),%ebx
  10eff1:	89 d1                	mov    %edx,%ecx
  10eff3:	89 d8                	mov    %ebx,%eax
  10eff5:	e8 2c fa ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	if (net_tcp_listen(context) >= 0) {
  10effa:	56                   	push   %esi
  10effb:	e8 77 3f 00 00       	call   112f77 <net_tcp_listen>
  10f000:	5a                   	pop    %edx
  10f001:	85 c0                	test   %eax,%eax
		k_mutex_unlock(&context->lock);
  10f003:	89 d8                	mov    %ebx,%eax
	if (net_tcp_listen(context) >= 0) {
  10f005:	78 09                	js     10f010 <net_context_listen+0x3b>
		k_mutex_unlock(&context->lock);
  10f007:	e8 c8 f9 ff ff       	call   10e9d4 <k_mutex_unlock>
		return 0;
  10f00c:	31 c0                	xor    %eax,%eax
  10f00e:	eb 0a                	jmp    10f01a <net_context_listen+0x45>
	k_mutex_unlock(&context->lock);
  10f010:	e8 bf f9 ff ff       	call   10e9d4 <k_mutex_unlock>
	return -EOPNOTSUPP;
  10f015:	b8 d3 ff ff ff       	mov    $0xffffffd3,%eax
}
  10f01a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10f01d:	5b                   	pop    %ebx
  10f01e:	5e                   	pop    %esi
  10f01f:	5d                   	pop    %ebp
  10f020:	c3                   	ret    

0010f021 <net_context_create_ipv4_new>:
{
  10f021:	55                   	push   %ebp
  10f022:	89 e5                	mov    %esp,%ebp
  10f024:	57                   	push   %edi
  10f025:	56                   	push   %esi
  10f026:	8b 55 10             	mov    0x10(%ebp),%edx
  10f029:	53                   	push   %ebx
  10f02a:	8b 7d 08             	mov    0x8(%ebp),%edi
  10f02d:	8b 75 0c             	mov    0xc(%ebp),%esi
  10f030:	8b 5d 14             	mov    0x14(%ebp),%ebx
	if (!src) {
  10f033:	85 d2                	test   %edx,%edx
  10f035:	75 03                	jne    10f03a <net_context_create_ipv4_new+0x19>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
  10f037:	8b 57 28             	mov    0x28(%edi),%edx
	if (net_ipv4_is_addr_unspecified(src)
  10f03a:	83 3a 00             	cmpl   $0x0,(%edx)
  10f03d:	74 0b                	je     10f04a <net_context_create_ipv4_new+0x29>
	    || net_ipv4_is_addr_mcast(src)) {
  10f03f:	89 d0                	mov    %edx,%eax
  10f041:	e8 f5 f8 ff ff       	call   10e93b <net_ipv4_is_addr_mcast>
  10f046:	84 c0                	test   %al,%al
  10f048:	74 12                	je     10f05c <net_context_create_ipv4_new+0x3b>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
  10f04a:	53                   	push   %ebx
  10f04b:	ff 76 20             	pushl  0x20(%esi)
  10f04e:	e8 63 e7 ff ff       	call   10d7b6 <net_if_ipv4_select_src_addr>
  10f053:	5a                   	pop    %edx
  10f054:	89 c2                	mov    %eax,%edx
		if (net_ipv4_is_addr_unspecified(src)) {
  10f056:	83 38 00             	cmpl   $0x0,(%eax)
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
  10f059:	59                   	pop    %ecx
		if (net_ipv4_is_addr_unspecified(src)) {
  10f05a:	74 1e                	je     10f07a <net_context_create_ipv4_new+0x59>
	pkt->ipv4_ttl = ttl;
  10f05c:	8a 87 95 00 00 00    	mov    0x95(%edi),%al
  10f062:	88 46 42             	mov    %al,0x42(%esi)
	return net_ipv4_create(pkt, src, dst);
  10f065:	89 5d 10             	mov    %ebx,0x10(%ebp)
  10f068:	89 75 08             	mov    %esi,0x8(%ebp)
  10f06b:	89 55 0c             	mov    %edx,0xc(%ebp)
}
  10f06e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f071:	5b                   	pop    %ebx
  10f072:	5e                   	pop    %esi
  10f073:	5f                   	pop    %edi
  10f074:	5d                   	pop    %ebp
	return net_ipv4_create(pkt, src, dst);
  10f075:	e9 05 1b 00 00       	jmp    110b7f <net_ipv4_create>
}
  10f07a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f07d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10f082:	5b                   	pop    %ebx
  10f083:	5e                   	pop    %esi
  10f084:	5f                   	pop    %edi
  10f085:	5d                   	pop    %ebp
  10f086:	c3                   	ret    

0010f087 <context_sendto.constprop.0>:
static int context_sendto(struct net_context *context,
  10f087:	55                   	push   %ebp
  10f088:	89 e5                	mov    %esp,%ebp
  10f08a:	57                   	push   %edi
  10f08b:	56                   	push   %esi
  10f08c:	53                   	push   %ebx
  10f08d:	89 c3                	mov    %eax,%ebx
  10f08f:	83 ec 0c             	sub    $0xc,%esp
  10f092:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if (!net_context_is_used(context)) {
  10f095:	66 8b 93 92 00 00 00 	mov    0x92(%ebx),%dx
static int context_sendto(struct net_context *context,
  10f09c:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!net_context_is_used(context)) {
  10f09f:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
static int context_sendto(struct net_context *context,
  10f0a3:	8b 45 18             	mov    0x18(%ebp),%eax
	if (!net_context_is_used(context)) {
  10f0a6:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
  10f0aa:	0f 84 0d 02 00 00    	je     10f2bd <context_sendto.constprop.0+0x236>
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
  10f0b0:	89 f2                	mov    %esi,%edx
  10f0b2:	89 cf                	mov    %ecx,%edi
  10f0b4:	0b 55 08             	or     0x8(%ebp),%edx
  10f0b7:	75 09                	jne    10f0c2 <context_sendto.constprop.0+0x3b>
  10f0b9:	84 c0                	test   %al,%al
  10f0bb:	74 05                	je     10f0c2 <context_sendto.constprop.0+0x3b>
	const struct msghdr *msghdr = NULL;
  10f0bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10f0c0:	eb 02                	jmp    10f0c4 <context_sendto.constprop.0+0x3d>
  10f0c2:	31 d2                	xor    %edx,%edx
	if (!msghdr && !dst_addr) {
  10f0c4:	89 d1                	mov    %edx,%ecx
		return -EDESTADDRREQ;
  10f0c6:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
	if (!msghdr && !dst_addr) {
  10f0cb:	0b 4d 08             	or     0x8(%ebp),%ecx
  10f0ce:	0f 84 ee 01 00 00    	je     10f2c2 <context_sendto.constprop.0+0x23b>
  10f0d4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		return -EINVAL;
  10f0d7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10f0dc:	66 c1 e9 03          	shr    $0x3,%cx
  10f0e0:	83 e1 07             	and    $0x7,%ecx
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10f0e3:	66 49                	dec    %cx
  10f0e5:	0f 85 d7 01 00 00    	jne    10f2c2 <context_sendto.constprop.0+0x23b>
		if (msghdr) {
  10f0eb:	85 d2                	test   %edx,%edx
  10f0ed:	74 14                	je     10f103 <context_sendto.constprop.0+0x7c>
			addr4 = msghdr->msg_name;
  10f0ef:	8b 02                	mov    (%edx),%eax
			addrlen = msghdr->msg_namelen;
  10f0f1:	8b 72 04             	mov    0x4(%edx),%esi
			addr4 = msghdr->msg_name;
  10f0f4:	89 45 08             	mov    %eax,0x8(%ebp)
			if (!addr4) {
  10f0f7:	85 c0                	test   %eax,%eax
  10f0f9:	75 08                	jne    10f103 <context_sendto.constprop.0+0x7c>
				addr4 = net_sin(&context->remote);
  10f0fb:	8d 43 2c             	lea    0x2c(%ebx),%eax
  10f0fe:	89 45 08             	mov    %eax,0x8(%ebp)
		if (addrlen < sizeof(struct sockaddr_in)) {
  10f101:	eb 0e                	jmp    10f111 <context_sendto.constprop.0+0x8a>
		return -EINVAL;
  10f103:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (addrlen < sizeof(struct sockaddr_in)) {
  10f108:	83 fe 07             	cmp    $0x7,%esi
  10f10b:	0f 86 b1 01 00 00    	jbe    10f2c2 <context_sendto.constprop.0+0x23b>
		if (!addr4->sin_addr.s_addr) {
  10f111:	8b 4d 08             	mov    0x8(%ebp),%ecx
		return -EDESTADDRREQ;
  10f114:	b8 d8 ff ff ff       	mov    $0xffffffd8,%eax
		if (!addr4->sin_addr.s_addr) {
  10f119:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
  10f11d:	0f 84 9f 01 00 00    	je     10f2c2 <context_sendto.constprop.0+0x23b>
	if (msghdr && len == 0) {
  10f123:	85 d2                	test   %edx,%edx
  10f125:	74 17                	je     10f13e <context_sendto.constprop.0+0xb7>
  10f127:	85 ff                	test   %edi,%edi
  10f129:	75 13                	jne    10f13e <context_sendto.constprop.0+0xb7>
  10f12b:	8b 4a 0c             	mov    0xc(%edx),%ecx
		for (i = 0; i < msghdr->msg_iovlen; i++) {
  10f12e:	31 c0                	xor    %eax,%eax
  10f130:	39 c8                	cmp    %ecx,%eax
  10f132:	74 0a                	je     10f13e <context_sendto.constprop.0+0xb7>
			len += msghdr->msg_iov[i].iov_len;
  10f134:	8b 72 08             	mov    0x8(%edx),%esi
  10f137:	03 7c c6 04          	add    0x4(%esi,%eax,8),%edi
		for (i = 0; i < msghdr->msg_iovlen; i++) {
  10f13b:	40                   	inc    %eax
  10f13c:	eb f2                	jmp    10f130 <context_sendto.constprop.0+0xa9>
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
  10f13e:	0f b7 b3 90 00 00 00 	movzwl 0x90(%ebx),%esi
	return net_if_get_by_index(context->iface);
  10f145:	0f be 83 94 00 00 00 	movsbl 0x94(%ebx),%eax
  10f14c:	89 55 ec             	mov    %edx,-0x14(%ebp)
	if (z_syscall_trap()) {
		return (struct net_if *) arch_syscall_invoke1(*(uintptr_t *)&index, K_SYSCALL_NET_IF_GET_BY_INDEX);
	}
#endif
	compiler_barrier();
	return z_impl_net_if_get_by_index(index);
  10f14f:	50                   	push   %eax
  10f150:	e8 8c e4 ff ff       	call   10d5e1 <z_impl_net_if_get_by_index>
  10f155:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10f15c:	6a 64                	push   $0x64
  10f15e:	56                   	push   %esi
  10f15f:	6a 01                	push   $0x1
  10f161:	57                   	push   %edi
  10f162:	50                   	push   %eax
  10f163:	e8 6e 0e 00 00       	call   10ffd6 <net_pkt_alloc_with_buffer>
  10f168:	89 c6                	mov    %eax,%esi
  10f16a:	83 c4 18             	add    $0x18,%esp
		return -ENOBUFS;
  10f16d:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (pkt) {
  10f172:	85 f6                	test   %esi,%esi
  10f174:	0f 84 48 01 00 00    	je     10f2c2 <context_sendto.constprop.0+0x23b>
	tmp_len = net_pkt_available_payload_buffer(
  10f17a:	0f b7 83 90 00 00 00 	movzwl 0x90(%ebx),%eax
	pkt->context = ctx;
  10f181:	89 5e 1c             	mov    %ebx,0x1c(%esi)
  10f184:	50                   	push   %eax
  10f185:	56                   	push   %esi
  10f186:	e8 ca 09 00 00       	call   10fb55 <net_pkt_available_payload_buffer>
  10f18b:	59                   	pop    %ecx
  10f18c:	39 c7                	cmp    %eax,%edi
  10f18e:	5a                   	pop    %edx
	if (tmp_len < len) {
  10f18f:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10f192:	76 02                	jbe    10f196 <context_sendto.constprop.0+0x10f>
  10f194:	89 c7                	mov    %eax,%edi
	context->send_cb = cb;
  10f196:	8b 45 10             	mov    0x10(%ebp),%eax
	    net_context_get_ip_proto(context) == IPPROTO_UDP) {
  10f199:	66 8b 8b 90 00 00 00 	mov    0x90(%ebx),%cx
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
  10f1a0:	66 83 f9 11          	cmp    $0x11,%cx
	context->send_cb = cb;
  10f1a4:	89 43 3c             	mov    %eax,0x3c(%ebx)
	context->user_data = user_data;
  10f1a7:	8b 45 14             	mov    0x14(%ebp),%eax
  10f1aa:	89 03                	mov    %eax,(%ebx)
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
  10f1ac:	0f 85 b3 00 00 00    	jne    10f265 <context_sendto.constprop.0+0x1de>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  10f1b2:	0f b7 8b 92 00 00 00 	movzwl 0x92(%ebx),%ecx
  10f1b9:	c1 e9 03             	shr    $0x3,%ecx
	int ret = -EINVAL;
  10f1bc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  10f1c1:	83 e1 07             	and    $0x7,%ecx
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10f1c4:	66 49                	dec    %cx
  10f1c6:	0f 85 e2 00 00 00    	jne    10f2ae <context_sendto.constprop.0+0x227>
		dst_port = addr4->sin_port;
  10f1cc:	8b 45 08             	mov    0x8(%ebp),%eax
  10f1cf:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10f1d2:	66 8b 40 02          	mov    0x2(%eax),%ax
  10f1d6:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
						  NULL, &addr4->sin_addr);
  10f1da:	8b 45 08             	mov    0x8(%ebp),%eax
  10f1dd:	83 c0 04             	add    $0x4,%eax
		ret = net_context_create_ipv4_new(context, pkt,
  10f1e0:	50                   	push   %eax
  10f1e1:	6a 00                	push   $0x0
  10f1e3:	56                   	push   %esi
  10f1e4:	53                   	push   %ebx
  10f1e5:	e8 37 fe ff ff       	call   10f021 <net_context_create_ipv4_new>
  10f1ea:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
  10f1ed:	85 c0                	test   %eax,%eax
  10f1ef:	0f 88 b9 00 00 00    	js     10f2ae <context_sendto.constprop.0+0x227>
	ret = bind_default(context);
  10f1f5:	89 d8                	mov    %ebx,%eax
  10f1f7:	e8 81 fd ff ff       	call   10ef7d <bind_default>
	if (ret) {
  10f1fc:	85 c0                	test   %eax,%eax
  10f1fe:	75 56                	jne    10f256 <context_sendto.constprop.0+0x1cf>
	ret = net_udp_create(pkt,
  10f200:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  10f204:	50                   	push   %eax
  10f205:	0f b7 43 26          	movzwl 0x26(%ebx),%eax
  10f209:	50                   	push   %eax
  10f20a:	56                   	push   %esi
  10f20b:	e8 6b 42 00 00       	call   11347b <net_udp_create>
  10f210:	83 c4 0c             	add    $0xc,%esp
	if (ret) {
  10f213:	85 c0                	test   %eax,%eax
  10f215:	75 3f                	jne    10f256 <context_sendto.constprop.0+0x1cf>
	ret = context_write_data(pkt, buf, len, msg);
  10f217:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10f21a:	89 f9                	mov    %edi,%ecx
  10f21c:	52                   	push   %edx
  10f21d:	89 f0                	mov    %esi,%eax
  10f21f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10f222:	e8 b9 f7 ff ff       	call   10e9e0 <context_write_data>
  10f227:	5a                   	pop    %edx
	if (ret) {
  10f228:	85 c0                	test   %eax,%eax
  10f22a:	75 2a                	jne    10f256 <context_sendto.constprop.0+0x1cf>
	net_pkt_cursor_init(pkt);
  10f22c:	56                   	push   %esi
  10f22d:	e8 b8 09 00 00       	call   10fbea <net_pkt_cursor_init>
  10f232:	58                   	pop    %eax
  10f233:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
  10f23a:	c1 e8 03             	shr    $0x3,%eax
  10f23d:	83 e0 07             	and    $0x7,%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10f240:	66 48                	dec    %ax
  10f242:	75 18                	jne    10f25c <context_sendto.constprop.0+0x1d5>
		net_ipv4_finalize(pkt, net_context_get_ip_proto(context));
  10f244:	0f b6 83 90 00 00 00 	movzbl 0x90(%ebx),%eax
  10f24b:	50                   	push   %eax
  10f24c:	56                   	push   %esi
  10f24d:	e8 b4 19 00 00       	call   110c06 <net_ipv4_finalize>
  10f252:	5b                   	pop    %ebx
  10f253:	58                   	pop    %eax
  10f254:	eb 06                	jmp    10f25c <context_sendto.constprop.0+0x1d5>
		if (ret < 0) {
  10f256:	85 c0                	test   %eax,%eax
  10f258:	79 d2                	jns    10f22c <context_sendto.constprop.0+0x1a5>
  10f25a:	eb 52                	jmp    10f2ae <context_sendto.constprop.0+0x227>
		ret = net_send_data(pkt);
  10f25c:	56                   	push   %esi
  10f25d:	e8 e0 de ff ff       	call   10d142 <net_send_data>
  10f262:	59                   	pop    %ecx
  10f263:	eb 41                	jmp    10f2a6 <context_sendto.constprop.0+0x21f>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
  10f265:	66 83 f9 06          	cmp    $0x6,%cx
		ret = -EPROTONOSUPPORT;
  10f269:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
  10f26e:	75 3e                	jne    10f2ae <context_sendto.constprop.0+0x227>
		ret = context_write_data(pkt, buf, len, msghdr);
  10f270:	52                   	push   %edx
  10f271:	89 f9                	mov    %edi,%ecx
  10f273:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10f276:	89 f0                	mov    %esi,%eax
  10f278:	e8 63 f7 ff ff       	call   10e9e0 <context_write_data>
  10f27d:	5a                   	pop    %edx
		if (ret < 0) {
  10f27e:	85 c0                	test   %eax,%eax
  10f280:	78 2c                	js     10f2ae <context_sendto.constprop.0+0x227>
		net_pkt_cursor_init(pkt);
  10f282:	56                   	push   %esi
  10f283:	e8 62 09 00 00       	call   10fbea <net_pkt_cursor_init>
		ret = net_tcp_queue_data(context, pkt);
  10f288:	89 34 24             	mov    %esi,(%esp)
  10f28b:	53                   	push   %ebx
  10f28c:	e8 fe 3c 00 00       	call   112f8f <net_tcp_queue_data>
  10f291:	5a                   	pop    %edx
  10f292:	59                   	pop    %ecx
		if (ret < 0) {
  10f293:	85 c0                	test   %eax,%eax
  10f295:	78 17                	js     10f2ae <context_sendto.constprop.0+0x227>
		ret = net_tcp_send_data(context, cb, user_data);
  10f297:	ff 75 14             	pushl  0x14(%ebp)
  10f29a:	ff 75 10             	pushl  0x10(%ebp)
  10f29d:	53                   	push   %ebx
  10f29e:	e8 19 3e 00 00       	call   1130bc <net_tcp_send_data>
  10f2a3:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  10f2a6:	85 c0                	test   %eax,%eax
  10f2a8:	78 04                	js     10f2ae <context_sendto.constprop.0+0x227>
	return len;
  10f2aa:	89 f8                	mov    %edi,%eax
  10f2ac:	eb 14                	jmp    10f2c2 <context_sendto.constprop.0+0x23b>
	net_pkt_unref(pkt);
  10f2ae:	56                   	push   %esi
  10f2af:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10f2b2:	e8 c5 07 00 00       	call   10fa7c <net_pkt_unref>
  10f2b7:	58                   	pop    %eax
	return ret;
  10f2b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10f2bb:	eb 05                	jmp    10f2c2 <context_sendto.constprop.0+0x23b>
		return -EBADF;
  10f2bd:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  10f2c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f2c5:	5b                   	pop    %ebx
  10f2c6:	5e                   	pop    %esi
  10f2c7:	5f                   	pop    %edi
  10f2c8:	5d                   	pop    %ebp
  10f2c9:	c3                   	ret    

0010f2ca <net_context_connect>:
{
  10f2ca:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
  10f2cb:	83 ca ff             	or     $0xffffffff,%edx
{
  10f2ce:	89 e5                	mov    %esp,%ebp
  10f2d0:	57                   	push   %edi
  10f2d1:	56                   	push   %esi
	k_mutex_lock(&context->lock, K_FOREVER);
  10f2d2:	89 d1                	mov    %edx,%ecx
{
  10f2d4:	53                   	push   %ebx
		ret = -EBADF;
  10f2d5:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
{
  10f2da:	83 ec 0c             	sub    $0xc,%esp
  10f2dd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f2e0:	8d 43 08             	lea    0x8(%ebx),%eax
  10f2e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10f2e6:	e8 3b f7 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	if (!net_context_is_used(context)) {
  10f2eb:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
  10f2f2:	a8 01                	test   $0x1,%al
  10f2f4:	0f 84 ff 00 00 00    	je     10f3f9 <net_context_connect+0x12f>
  10f2fa:	89 c2                	mov    %eax,%edx
	if (addr->sa_family != net_context_get_family(context)) {
  10f2fc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10f2ff:	66 c1 ea 03          	shr    $0x3,%dx
		ret = -EINVAL;
  10f303:	be ea ff ff ff       	mov    $0xffffffea,%esi
  10f308:	83 e2 07             	and    $0x7,%edx
	if (addr->sa_family != net_context_get_family(context)) {
  10f30b:	66 39 11             	cmp    %dx,(%ecx)
  10f30e:	0f 85 e5 00 00 00    	jne    10f3f9 <net_context_connect+0x12f>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
  10f314:	83 f0 06             	xor    $0x6,%eax
		ret = -EOPNOTSUPP;
  10f317:	be d3 ff ff ff       	mov    $0xffffffd3,%esi
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
  10f31c:	a8 06                	test   $0x6,%al
  10f31e:	0f 84 d5 00 00 00    	je     10f3f9 <net_context_connect+0x12f>
		if (addrlen < sizeof(struct sockaddr_in)) {
  10f324:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
  10f328:	0f 86 c6 00 00 00    	jbe    10f3f4 <net_context_connect+0x12a>
  10f32e:	66 4a                	dec    %dx
  10f330:	0f 85 be 00 00 00    	jne    10f3f4 <net_context_connect+0x12a>
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
  10f336:	89 c8                	mov    %ecx,%eax
  10f338:	6a 04                	push   $0x4
  10f33a:	83 c0 04             	add    $0x4,%eax
  10f33d:	50                   	push   %eax
  10f33e:	8d 43 30             	lea    0x30(%ebx),%eax
  10f341:	50                   	push   %eax
  10f342:	e8 a5 ca ff ff       	call   10bdec <memcpy>
		addr4->sin_port = net_sin(addr)->sin_port;
  10f347:	8b 45 0c             	mov    0xc(%ebp),%eax
		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
  10f34a:	83 c4 0c             	add    $0xc,%esp
		if (addr4->sin_addr.s_addr) {
  10f34d:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
		addr4->sin_port = net_sin(addr)->sin_port;
  10f351:	0f b7 78 02          	movzwl 0x2(%eax),%edi
		addr4->sin_family = AF_INET;
  10f355:	66 c7 43 2c 01 00    	movw   $0x1,0x2c(%ebx)
		addr4->sin_port = net_sin(addr)->sin_port;
  10f35b:	66 89 7b 2e          	mov    %di,0x2e(%ebx)
		if (addr4->sin_addr.s_addr) {
  10f35f:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
  10f366:	74 05                	je     10f36d <net_context_connect+0xa3>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
  10f368:	80 cc 01             	or     $0x1,%ah
  10f36b:	eb 03                	jmp    10f370 <net_context_connect+0xa6>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
  10f36d:	80 e4 fe             	and    $0xfe,%ah
  10f370:	66 89 83 92 00 00 00 	mov    %ax,0x92(%ebx)
		ret = bind_default(context);
  10f377:	89 d8                	mov    %ebx,%eax
  10f379:	e8 ff fb ff ff       	call   10ef7d <bind_default>
  10f37e:	89 c6                	mov    %eax,%esi
		if (ret) {
  10f380:	85 c0                	test   %eax,%eax
  10f382:	75 75                	jne    10f3f9 <net_context_connect+0x12f>
		net_sin(&local_addr)->sin_port = lport =
  10f384:	0f b7 4b 26          	movzwl 0x26(%ebx),%ecx
		if (net_sin_ptr(&context->local)->sin_addr) {
  10f388:	8b 53 28             	mov    0x28(%ebx),%edx
		net_sin_ptr(&context->local)->sin_family = AF_INET;
  10f38b:	66 c7 43 24 01 00    	movw   $0x1,0x24(%ebx)
		net_sin(&local_addr)->sin_family = AF_INET;
  10f391:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
		net_sin(&local_addr)->sin_port = lport =
  10f397:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
		if (net_sin_ptr(&context->local)->sin_addr) {
  10f39b:	85 d2                	test   %edx,%edx
  10f39d:	74 08                	je     10f3a7 <net_context_connect+0xdd>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  10f39f:	8b 02                	mov    (%edx),%eax
			laddr = &local_addr;
  10f3a1:	8d 55 ec             	lea    -0x14(%ebp),%edx
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  10f3a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
  10f3a7:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
  10f3ae:	c1 e8 06             	shr    $0x6,%eax
  10f3b1:	83 e0 03             	and    $0x3,%eax
	if (IS_ENABLED(CONFIG_NET_UDP) &&
  10f3b4:	83 f8 02             	cmp    $0x2,%eax
  10f3b7:	75 14                	jne    10f3cd <net_context_connect+0x103>
		if (cb) {
  10f3b9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  10f3bd:	74 3a                	je     10f3f9 <net_context_connect+0x12f>
			cb(context, 0, user_data);
  10f3bf:	ff 75 20             	pushl  0x20(%ebp)
  10f3c2:	6a 00                	push   $0x0
  10f3c4:	53                   	push   %ebx
  10f3c5:	ff 55 14             	call   *0x14(%ebp)
  10f3c8:	83 c4 0c             	add    $0xc,%esp
  10f3cb:	eb 2c                	jmp    10f3f9 <net_context_connect+0x12f>
		ret = -ENOTSUP;
  10f3cd:	be dd ff ff ff       	mov    $0xffffffdd,%esi
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
  10f3d2:	48                   	dec    %eax
  10f3d3:	75 24                	jne    10f3f9 <net_context_connect+0x12f>
		ret = net_tcp_connect(context, addr, laddr, rport, lport,
  10f3d5:	ff 75 20             	pushl  0x20(%ebp)
  10f3d8:	ff 75 14             	pushl  0x14(%ebp)
  10f3db:	ff 75 1c             	pushl  0x1c(%ebp)
  10f3de:	ff 75 18             	pushl  0x18(%ebp)
  10f3e1:	51                   	push   %ecx
  10f3e2:	57                   	push   %edi
  10f3e3:	52                   	push   %edx
  10f3e4:	ff 75 0c             	pushl  0xc(%ebp)
  10f3e7:	53                   	push   %ebx
  10f3e8:	e8 ea 3c 00 00       	call   1130d7 <net_tcp_connect>
  10f3ed:	83 c4 24             	add    $0x24,%esp
  10f3f0:	89 c6                	mov    %eax,%esi
  10f3f2:	eb 05                	jmp    10f3f9 <net_context_connect+0x12f>
		ret = -EINVAL;
  10f3f4:	be ea ff ff ff       	mov    $0xffffffea,%esi
	k_mutex_unlock(&context->lock);
  10f3f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10f3fc:	e8 d3 f5 ff ff       	call   10e9d4 <k_mutex_unlock>
}
  10f401:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f404:	5b                   	pop    %ebx
  10f405:	89 f0                	mov    %esi,%eax
  10f407:	5e                   	pop    %esi
  10f408:	5f                   	pop    %edi
  10f409:	5d                   	pop    %ebp
  10f40a:	c3                   	ret    

0010f40b <net_context_accept>:
{
  10f40b:	55                   	push   %ebp
  10f40c:	89 e5                	mov    %esp,%ebp
  10f40e:	57                   	push   %edi
  10f40f:	56                   	push   %esi
  10f410:	8b 7d 08             	mov    0x8(%ebp),%edi
  10f413:	53                   	push   %ebx
  10f414:	bb f7 ff ff ff       	mov    $0xfffffff7,%ebx
	if (!net_context_is_used(context)) {
  10f419:	f6 87 92 00 00 00 01 	testb  $0x1,0x92(%edi)
  10f420:	74 52                	je     10f474 <net_context_accept+0x69>
	k_mutex_lock(&context->lock, K_FOREVER);
  10f422:	83 ca ff             	or     $0xffffffff,%edx
  10f425:	8d 77 08             	lea    0x8(%edi),%esi
  10f428:	89 d1                	mov    %edx,%ecx
  10f42a:	89 f0                	mov    %esi,%eax
  10f42c:	e8 f5 f5 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
  10f431:	66 8b 87 92 00 00 00 	mov    0x92(%edi),%ax
  10f438:	89 c2                	mov    %eax,%edx
  10f43a:	83 f2 06             	xor    $0x6,%edx
  10f43d:	80 e2 06             	and    $0x6,%dl
  10f440:	74 0e                	je     10f450 <net_context_accept+0x45>
  10f442:	c1 e8 06             	shr    $0x6,%eax
		ret = -EINVAL;
  10f445:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
  10f44a:	83 e0 03             	and    $0x3,%eax
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
  10f44d:	48                   	dec    %eax
  10f44e:	75 1d                	jne    10f46d <net_context_accept+0x62>
	int ret = 0;
  10f450:	31 db                	xor    %ebx,%ebx
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
  10f452:	66 83 bf 90 00 00 00 	cmpw   $0x6,0x90(%edi)
  10f459:	06 
  10f45a:	75 11                	jne    10f46d <net_context_accept+0x62>
		ret = net_tcp_accept(context, cb, user_data);
  10f45c:	ff 75 18             	pushl  0x18(%ebp)
  10f45f:	ff 75 0c             	pushl  0xc(%ebp)
  10f462:	57                   	push   %edi
  10f463:	e8 4d 3e 00 00       	call   1132b5 <net_tcp_accept>
  10f468:	83 c4 0c             	add    $0xc,%esp
  10f46b:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&context->lock);
  10f46d:	89 f0                	mov    %esi,%eax
  10f46f:	e8 60 f5 ff ff       	call   10e9d4 <k_mutex_unlock>
}
  10f474:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f477:	89 d8                	mov    %ebx,%eax
  10f479:	5b                   	pop    %ebx
  10f47a:	5e                   	pop    %esi
  10f47b:	5f                   	pop    %edi
  10f47c:	5d                   	pop    %ebp
  10f47d:	c3                   	ret    

0010f47e <net_context_send>:
{
  10f47e:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
  10f47f:	83 ca ff             	or     $0xffffffff,%edx
{
  10f482:	89 e5                	mov    %esp,%ebp
  10f484:	57                   	push   %edi
  10f485:	56                   	push   %esi
	k_mutex_lock(&context->lock, K_FOREVER);
  10f486:	89 d1                	mov    %edx,%ecx
{
  10f488:	8b 7d 08             	mov    0x8(%ebp),%edi
  10f48b:	53                   	push   %ebx
		ret = -EDESTADDRREQ;
  10f48c:	bb d8 ff ff ff       	mov    $0xffffffd8,%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f491:	8d 77 08             	lea    0x8(%edi),%esi
  10f494:	89 f0                	mov    %esi,%eax
  10f496:	e8 8b f5 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
  10f49b:	0f b7 87 92 00 00 00 	movzwl 0x92(%edi),%eax
  10f4a2:	f6 c4 01             	test   $0x1,%ah
  10f4a5:	74 37                	je     10f4de <net_context_send+0x60>
  10f4a7:	66 83 7f 2e 00       	cmpw   $0x0,0x2e(%edi)
  10f4ac:	74 30                	je     10f4de <net_context_send+0x60>
	ret = context_sendto(context, buf, len, &context->remote,
  10f4ae:	6a 00                	push   $0x0
  10f4b0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10f4b3:	ff 75 20             	pushl  0x20(%ebp)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  10f4b6:	c1 e8 03             	shr    $0x3,%eax
  10f4b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f4bc:	ff 75 14             	pushl  0x14(%ebp)
  10f4bf:	83 e0 07             	and    $0x7,%eax
		addrlen = 0;
  10f4c2:	66 48                	dec    %ax
  10f4c4:	0f 94 c0             	sete   %al
  10f4c7:	0f b6 c0             	movzbl %al,%eax
  10f4ca:	c1 e0 03             	shl    $0x3,%eax
	ret = context_sendto(context, buf, len, &context->remote,
  10f4cd:	50                   	push   %eax
  10f4ce:	8d 47 2c             	lea    0x2c(%edi),%eax
  10f4d1:	50                   	push   %eax
  10f4d2:	89 f8                	mov    %edi,%eax
  10f4d4:	e8 ae fb ff ff       	call   10f087 <context_sendto.constprop.0>
  10f4d9:	83 c4 14             	add    $0x14,%esp
  10f4dc:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&context->lock);
  10f4de:	89 f0                	mov    %esi,%eax
  10f4e0:	e8 ef f4 ff ff       	call   10e9d4 <k_mutex_unlock>
}
  10f4e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f4e8:	89 d8                	mov    %ebx,%eax
  10f4ea:	5b                   	pop    %ebx
  10f4eb:	5e                   	pop    %esi
  10f4ec:	5f                   	pop    %edi
  10f4ed:	5d                   	pop    %ebp
  10f4ee:	c3                   	ret    

0010f4ef <net_context_sendmsg>:
{
  10f4ef:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
  10f4f0:	83 ca ff             	or     $0xffffffff,%edx
{
  10f4f3:	89 e5                	mov    %esp,%ebp
  10f4f5:	56                   	push   %esi
  10f4f6:	53                   	push   %ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f4f7:	89 d1                	mov    %edx,%ecx
{
  10f4f9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f4fc:	8d 73 08             	lea    0x8(%ebx),%esi
  10f4ff:	89 f0                	mov    %esi,%eax
  10f501:	e8 20 f5 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	ret = context_sendto(context, msghdr, 0, NULL, 0,
  10f506:	6a 01                	push   $0x1
  10f508:	ff 75 20             	pushl  0x20(%ebp)
  10f50b:	ff 75 14             	pushl  0x14(%ebp)
  10f50e:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f511:	31 c9                	xor    %ecx,%ecx
  10f513:	6a 00                	push   $0x0
  10f515:	89 d8                	mov    %ebx,%eax
  10f517:	6a 00                	push   $0x0
  10f519:	e8 69 fb ff ff       	call   10f087 <context_sendto.constprop.0>
  10f51e:	83 c4 14             	add    $0x14,%esp
  10f521:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&context->lock);
  10f523:	89 f0                	mov    %esi,%eax
  10f525:	e8 aa f4 ff ff       	call   10e9d4 <k_mutex_unlock>
}
  10f52a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10f52d:	89 d8                	mov    %ebx,%eax
  10f52f:	5b                   	pop    %ebx
  10f530:	5e                   	pop    %esi
  10f531:	5d                   	pop    %ebp
  10f532:	c3                   	ret    

0010f533 <net_context_sendto>:
{
  10f533:	55                   	push   %ebp
	k_mutex_lock(&context->lock, K_FOREVER);
  10f534:	83 ca ff             	or     $0xffffffff,%edx
{
  10f537:	89 e5                	mov    %esp,%ebp
  10f539:	56                   	push   %esi
  10f53a:	53                   	push   %ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f53b:	89 d1                	mov    %edx,%ecx
{
  10f53d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f540:	8d 73 08             	lea    0x8(%ebx),%esi
  10f543:	89 f0                	mov    %esi,%eax
  10f545:	e8 dc f4 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
  10f54a:	6a 01                	push   $0x1
  10f54c:	ff 75 28             	pushl  0x28(%ebp)
  10f54f:	ff 75 1c             	pushl  0x1c(%ebp)
  10f552:	ff 75 18             	pushl  0x18(%ebp)
  10f555:	ff 75 14             	pushl  0x14(%ebp)
  10f558:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10f55b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10f55e:	89 d8                	mov    %ebx,%eax
  10f560:	e8 22 fb ff ff       	call   10f087 <context_sendto.constprop.0>
  10f565:	83 c4 14             	add    $0x14,%esp
  10f568:	89 c3                	mov    %eax,%ebx
	k_mutex_unlock(&context->lock);
  10f56a:	89 f0                	mov    %esi,%eax
  10f56c:	e8 63 f4 ff ff       	call   10e9d4 <k_mutex_unlock>
}
  10f571:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10f574:	89 d8                	mov    %ebx,%eax
  10f576:	5b                   	pop    %ebx
  10f577:	5e                   	pop    %esi
  10f578:	5d                   	pop    %ebp
  10f579:	c3                   	ret    

0010f57a <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     k_timeout_t timeout,
		     void *user_data)
{
  10f57a:	55                   	push   %ebp
  10f57b:	89 e5                	mov    %esp,%ebp
  10f57d:	57                   	push   %edi
  10f57e:	56                   	push   %esi
  10f57f:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  10f584:	53                   	push   %ebx
  10f585:	83 ec 18             	sub    $0x18,%esp
  10f588:	8b 45 10             	mov    0x10(%ebp),%eax
  10f58b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10f58e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10f591:	8b 45 14             	mov    0x14(%ebp),%eax
	int ret;
	NET_ASSERT(context);

	if (!net_context_is_used(context)) {
  10f594:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
{
  10f59b:	8b 75 0c             	mov    0xc(%ebp),%esi
  10f59e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (!net_context_is_used(context)) {
  10f5a1:	0f 84 3a 01 00 00    	je     10f6e1 <net_context_recv+0x167>
		return -EBADF;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
  10f5a7:	83 ca ff             	or     $0xffffffff,%edx
  10f5aa:	8d 43 08             	lea    0x8(%ebx),%eax
  10f5ad:	89 d1                	mov    %edx,%ecx
  10f5af:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10f5b2:	e8 6f f4 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
			context, cb, timeout, user_data);
		goto unlock;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
	    net_context_get_ip_proto(context) == IPPROTO_UDP) {
  10f5b7:	66 8b 83 90 00 00 00 	mov    0x90(%ebx),%ax
	if (IS_ENABLED(CONFIG_NET_UDP) &&
  10f5be:	66 83 f8 11          	cmp    $0x11,%ax
  10f5c2:	0f 85 bb 00 00 00    	jne    10f683 <net_context_recv+0x109>
	struct sockaddr local_addr = {
  10f5c8:	31 c0                	xor    %eax,%eax
  10f5ca:	8d 7d ec             	lea    -0x14(%ebp),%edi
  10f5cd:	b9 02 00 00 00       	mov    $0x2,%ecx
  10f5d2:	f3 ab                	rep stos %eax,%es:(%edi)
  10f5d4:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
  10f5db:	c1 e8 03             	shr    $0x3,%eax
  10f5de:	83 e0 07             	and    $0x7,%eax
  10f5e1:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	if (context->conn_handler) {
  10f5e5:	8b 43 34             	mov    0x34(%ebx),%eax
  10f5e8:	85 c0                	test   %eax,%eax
  10f5ea:	74 0e                	je     10f5fa <net_context_recv+0x80>
		net_conn_unregister(context->conn_handler);
  10f5ec:	50                   	push   %eax
  10f5ed:	e8 65 1b 00 00       	call   111157 <net_conn_unregister>
  10f5f2:	58                   	pop    %eax
		context->conn_handler = NULL;
  10f5f3:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
	ret = bind_default(context);
  10f5fa:	89 d8                	mov    %ebx,%eax
  10f5fc:	e8 7c f9 ff ff       	call   10ef7d <bind_default>
  10f601:	89 c7                	mov    %eax,%edi
	if (ret) {
  10f603:	85 c0                	test   %eax,%eax
  10f605:	0f 85 92 00 00 00    	jne    10f69d <net_context_recv+0x123>
		   net_context_get_family(context) == AF_INET) {
  10f60b:	66 8b 83 92 00 00 00 	mov    0x92(%ebx),%ax
  10f612:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  10f616:	66 c1 e8 03          	shr    $0x3,%ax
  10f61a:	83 e0 07             	and    $0x7,%eax
  10f61d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  10f621:	66 48                	dec    %ax
  10f623:	75 15                	jne    10f63a <net_context_recv+0xc0>
		if (net_sin_ptr(&context->local)->sin_addr) {
  10f625:	8b 53 28             	mov    0x28(%ebx),%edx
  10f628:	85 d2                	test   %edx,%edx
  10f62a:	74 08                	je     10f634 <net_context_recv+0xba>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  10f62c:	8b 02                	mov    (%edx),%eax
			laddr = &local_addr;
  10f62e:	8d 55 ec             	lea    -0x14(%ebp),%edx
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  10f631:	89 45 f0             	mov    %eax,-0x10(%ebp)
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
  10f634:	66 8b 43 26          	mov    0x26(%ebx),%ax
  10f638:	eb 04                	jmp    10f63e <net_context_recv+0xc4>
	uint16_t lport = 0U;
  10f63a:	31 c0                	xor    %eax,%eax
	struct sockaddr *laddr = NULL;
  10f63c:	31 d2                	xor    %edx,%edx
				ntohs(net_sin(&context->remote)->sin_port),
  10f63e:	66 8b 4b 2e          	mov    0x2e(%ebx),%cx
	ret = net_conn_register(net_context_get_ip_proto(context),
  10f642:	86 e0                	xchg   %ah,%al
				ntohs(net_sin(&context->remote)->sin_port),
  10f644:	86 e9                	xchg   %ch,%cl
	context->recv_cb = cb;
  10f646:	89 73 38             	mov    %esi,0x38(%ebx)
	ret = net_conn_register(net_context_get_ip_proto(context),
  10f649:	8d 7b 34             	lea    0x34(%ebx),%edi
  10f64c:	31 f6                	xor    %esi,%esi
  10f64e:	0f b7 c0             	movzwl %ax,%eax
  10f651:	66 f7 45 e6 00 01    	testw  $0x100,-0x1a(%ebp)
  10f657:	0f b7 c9             	movzwl %cx,%ecx
  10f65a:	74 03                	je     10f65f <net_context_recv+0xe5>
  10f65c:	8d 73 2c             	lea    0x2c(%ebx),%esi
  10f65f:	57                   	push   %edi
  10f660:	ff 75 18             	pushl  0x18(%ebp)
  10f663:	68 3a ea 10 00       	push   $0x10ea3a
  10f668:	50                   	push   %eax
  10f669:	51                   	push   %ecx
  10f66a:	52                   	push   %edx
  10f66b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  10f66f:	56                   	push   %esi
  10f670:	50                   	push   %eax
  10f671:	0f b7 83 90 00 00 00 	movzwl 0x90(%ebx),%eax
  10f678:	50                   	push   %eax
  10f679:	e8 31 18 00 00       	call   110eaf <net_conn_register>
  10f67e:	83 c4 24             	add    $0x24,%esp
  10f681:	eb 18                	jmp    10f69b <net_context_recv+0x121>
		ret = recv_udp(context, cb, timeout, user_data);
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
  10f683:	66 83 f8 06          	cmp    $0x6,%ax
				 * correct net_context listener.
				 */
				ret = 0;
			}
		} else {
			ret = -EPROTOTYPE;
  10f687:	bf d7 ff ff ff       	mov    $0xffffffd7,%edi
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
  10f68c:	75 4b                	jne    10f6d9 <net_context_recv+0x15f>
		ret = net_tcp_recv(context, cb, user_data);
  10f68e:	ff 75 18             	pushl  0x18(%ebp)
  10f691:	56                   	push   %esi
  10f692:	53                   	push   %ebx
  10f693:	e8 0f 3d 00 00       	call   1133a7 <net_tcp_recv>
  10f698:	83 c4 0c             	add    $0xc,%esp
  10f69b:	89 c7                	mov    %eax,%edi
		}
	}

	if (ret < 0) {
  10f69d:	85 ff                	test   %edi,%edi
  10f69f:	78 38                	js     10f6d9 <net_context_recv+0x15f>
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  10f6a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10f6a4:	0b 45 e0             	or     -0x20(%ebp),%eax
  10f6a7:	74 30                	je     10f6d9 <net_context_recv+0x15f>
	sem->count = 0U;
  10f6a9:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
		 * net_context_packet_received() callback will release the
		 * semaphore when data has been received.
		 */
		k_sem_reset(&context->recv_data_wait);

		k_mutex_unlock(&context->lock);
  10f6b0:	8d 43 08             	lea    0x8(%ebx),%eax
  10f6b3:	e8 1c f3 ff ff       	call   10e9d4 <k_mutex_unlock>

		ret = k_sem_take(&context->recv_data_wait, timeout);
  10f6b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10f6bb:	8b 55 dc             	mov    -0x24(%ebp),%edx
	return z_impl_k_sem_take(sem, timeout);
  10f6be:	52                   	push   %edx
  10f6bf:	83 c3 48             	add    $0x48,%ebx
  10f6c2:	50                   	push   %eax
  10f6c3:	53                   	push   %ebx
  10f6c4:	e8 29 22 01 00       	call   1218f2 <z_impl_k_sem_take>

		k_mutex_lock(&context->lock, K_FOREVER);
  10f6c9:	83 ca ff             	or     $0xffffffff,%edx
  10f6cc:	83 c4 0c             	add    $0xc,%esp
  10f6cf:	89 d1                	mov    %edx,%ecx
  10f6d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10f6d4:	e8 4d f3 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>
		}
	}
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

unlock:
	k_mutex_unlock(&context->lock);
  10f6d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10f6dc:	e8 f3 f2 ff ff       	call   10e9d4 <k_mutex_unlock>

	return ret;
}
  10f6e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f6e4:	89 f8                	mov    %edi,%eax
  10f6e6:	5b                   	pop    %ebx
  10f6e7:	5e                   	pop    %esi
  10f6e8:	5f                   	pop    %edi
  10f6e9:	5d                   	pop    %ebp
  10f6ea:	c3                   	ret    

0010f6eb <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				int32_t delta)
{
  10f6eb:	55                   	push   %ebp
	if (IS_ENABLED(CONFIG_NET_OFFLOAD) &&
		net_if_is_ip_offloaded(net_context_get_iface(context))) {
		return 0;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
  10f6ec:	83 ca ff             	or     $0xffffffff,%edx
{
  10f6ef:	89 e5                	mov    %esp,%ebp
  10f6f1:	56                   	push   %esi
  10f6f2:	53                   	push   %ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f6f3:	89 d1                	mov    %edx,%ecx
{
  10f6f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&context->lock, K_FOREVER);
  10f6f8:	8d 73 08             	lea    0x8(%ebx),%esi
  10f6fb:	89 f0                	mov    %esi,%eax
  10f6fd:	e8 24 f3 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>

	ret = net_tcp_update_recv_wnd(context, delta);
  10f702:	ff 75 0c             	pushl  0xc(%ebp)
  10f705:	53                   	push   %ebx
  10f706:	e8 7e 38 00 00       	call   112f89 <net_tcp_update_recv_wnd>
  10f70b:	5a                   	pop    %edx
  10f70c:	89 c3                	mov    %eax,%ebx

	k_mutex_unlock(&context->lock);
  10f70e:	89 f0                	mov    %esi,%eax
	ret = net_tcp_update_recv_wnd(context, delta);
  10f710:	59                   	pop    %ecx
	k_mutex_unlock(&context->lock);
  10f711:	e8 be f2 ff ff       	call   10e9d4 <k_mutex_unlock>

	return ret;
}
  10f716:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10f719:	89 d8                	mov    %ebx,%eax
  10f71b:	5b                   	pop    %ebx
  10f71c:	5e                   	pop    %esi
  10f71d:	5d                   	pop    %ebp
  10f71e:	c3                   	ret    

0010f71f <net_context_foreach>:

	return ret;
}

void net_context_foreach(net_context_cb_t cb, void *user_data)
{
  10f71f:	55                   	push   %ebp
  10f720:	89 e5                	mov    %esp,%ebp
  10f722:	57                   	push   %edi
  10f723:	56                   	push   %esi
  10f724:	53                   	push   %ebx
  10f725:	8b 75 08             	mov    0x8(%ebp),%esi
  10f728:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10f72b:	6a ff                	push   $0xffffffff
  10f72d:	bb 20 aa 12 00       	mov    $0x12aa20,%ebx
  10f732:	6a ff                	push   $0xffffffff
  10f734:	68 00 aa 12 00       	push   $0x12aa00
  10f739:	e8 b4 21 01 00       	call   1218f2 <z_impl_k_sem_take>
  10f73e:	83 c4 0c             	add    $0xc,%esp
	int i;

	k_sem_take(&contexts_lock, K_FOREVER);

	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
  10f741:	f6 83 92 00 00 00 01 	testb  $0x1,0x92(%ebx)
  10f748:	74 1b                	je     10f765 <net_context_foreach+0x46>
			continue;
		}

		k_mutex_lock(&contexts[i].lock, K_FOREVER);
  10f74a:	83 ca ff             	or     $0xffffffff,%edx
  10f74d:	8d 43 08             	lea    0x8(%ebx),%eax
  10f750:	89 d1                	mov    %edx,%ecx
  10f752:	e8 cf f2 ff ff       	call   10ea26 <k_mutex_lock.constprop.0>

		cb(&contexts[i], user_data);
  10f757:	57                   	push   %edi
  10f758:	53                   	push   %ebx
  10f759:	ff d6                	call   *%esi
  10f75b:	58                   	pop    %eax

		k_mutex_unlock(&contexts[i].lock);
  10f75c:	8d 43 08             	lea    0x8(%ebx),%eax
		cb(&contexts[i], user_data);
  10f75f:	5a                   	pop    %edx
		k_mutex_unlock(&contexts[i].lock);
  10f760:	e8 6f f2 ff ff       	call   10e9d4 <k_mutex_unlock>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
  10f765:	81 c3 98 00 00 00    	add    $0x98,%ebx
  10f76b:	81 fb b0 ad 12 00    	cmp    $0x12adb0,%ebx
  10f771:	75 ce                	jne    10f741 <net_context_foreach+0x22>
	z_impl_k_sem_give(sem);
  10f773:	c7 45 08 00 aa 12 00 	movl   $0x12aa00,0x8(%ebp)
	}

	k_sem_give(&contexts_lock);
}
  10f77a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f77d:	5b                   	pop    %ebx
  10f77e:	5e                   	pop    %esi
  10f77f:	5f                   	pop    %edi
  10f780:	5d                   	pop    %ebp
  10f781:	e9 13 21 01 00       	jmp    121899 <z_impl_k_sem_give>

0010f786 <net_context_init>:

	return NULL;
}

void net_context_init(void)
{
  10f786:	55                   	push   %ebp
  10f787:	89 e5                	mov    %esp,%ebp
	return z_impl_k_sem_init(sem, initial_count, limit);
  10f789:	6a ff                	push   $0xffffffff
  10f78b:	6a 01                	push   $0x1
  10f78d:	68 00 aa 12 00       	push   $0x12aa00
  10f792:	e8 c0 20 01 00       	call   121857 <z_impl_k_sem_init>
  10f797:	83 c4 0c             	add    $0xc,%esp
	k_sem_init(&contexts_lock, 1, UINT_MAX);
}
  10f79a:	c9                   	leave  
  10f79b:	c3                   	ret    

0010f79c <net_buf_frags_len>:
	size_t bytes = 0;
  10f79c:	31 d2                	xor    %edx,%edx
	while (buf) {
  10f79e:	85 c0                	test   %eax,%eax
  10f7a0:	74 0a                	je     10f7ac <net_buf_frags_len+0x10>
		bytes += buf->len;
  10f7a2:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
  10f7a6:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  10f7a8:	01 ca                	add    %ecx,%edx
		buf = buf->frags;
  10f7aa:	eb f2                	jmp    10f79e <net_buf_frags_len+0x2>
	}

	return bytes;
}
  10f7ac:	89 d0                	mov    %edx,%eax
  10f7ae:	c3                   	ret    

0010f7af <pkt_cursor_jump>:

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
  10f7af:	8b 48 14             	mov    0x14(%eax),%ecx
  10f7b2:	8b 09                	mov    (%ecx),%ecx
  10f7b4:	89 48 14             	mov    %ecx,0x14(%eax)
	while (cursor->buf) {
  10f7b7:	8b 48 14             	mov    0x14(%eax),%ecx
  10f7ba:	85 c9                	test   %ecx,%ecx
  10f7bc:	75 08                	jne    10f7c6 <pkt_cursor_jump+0x17>
	}

	if (cursor->buf) {
		cursor->pos = cursor->buf->data;
	} else {
		cursor->pos = NULL;
  10f7be:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  10f7c5:	c3                   	ret    
{
  10f7c6:	55                   	push   %ebp
  10f7c7:	89 e5                	mov    %esp,%ebp
  10f7c9:	53                   	push   %ebx
		size_t len = write ? cursor->buf->size : cursor->buf->len;
  10f7ca:	84 d2                	test   %dl,%dl
  10f7cc:	74 06                	je     10f7d4 <pkt_cursor_jump+0x25>
  10f7ce:	0f b7 59 0e          	movzwl 0xe(%ecx),%ebx
  10f7d2:	eb 04                	jmp    10f7d8 <pkt_cursor_jump+0x29>
  10f7d4:	0f b7 59 0c          	movzwl 0xc(%ecx),%ebx
		if (!len) {
  10f7d8:	85 db                	test   %ebx,%ebx
  10f7da:	75 15                	jne    10f7f1 <pkt_cursor_jump+0x42>
			cursor->buf = cursor->buf->frags;
  10f7dc:	8b 09                	mov    (%ecx),%ecx
  10f7de:	89 48 14             	mov    %ecx,0x14(%eax)
	while (cursor->buf) {
  10f7e1:	8b 48 14             	mov    0x14(%eax),%ecx
  10f7e4:	85 c9                	test   %ecx,%ecx
  10f7e6:	75 e2                	jne    10f7ca <pkt_cursor_jump+0x1b>
		cursor->pos = NULL;
  10f7e8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  10f7ef:	eb 06                	jmp    10f7f7 <pkt_cursor_jump+0x48>
		cursor->pos = cursor->buf->data;
  10f7f1:	8b 51 08             	mov    0x8(%ecx),%edx
  10f7f4:	89 50 18             	mov    %edx,0x18(%eax)
	}
}
  10f7f7:	5b                   	pop    %ebx
  10f7f8:	5d                   	pop    %ebp
  10f7f9:	c3                   	ret    

0010f7fa <pkt_cursor_advance>:
static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
  10f7fa:	8b 48 14             	mov    0x14(%eax),%ecx
  10f7fd:	85 c9                	test   %ecx,%ecx
  10f7ff:	74 2c                	je     10f82d <pkt_cursor_advance+0x33>
{
  10f801:	55                   	push   %ebp
		return;
	}

	len = write ? cursor->buf->size : cursor->buf->len;
  10f802:	84 d2                	test   %dl,%dl
{
  10f804:	89 e5                	mov    %esp,%ebp
  10f806:	56                   	push   %esi
  10f807:	53                   	push   %ebx
	len = write ? cursor->buf->size : cursor->buf->len;
  10f808:	74 06                	je     10f810 <pkt_cursor_advance+0x16>
  10f80a:	0f b7 59 0e          	movzwl 0xe(%ecx),%ebx
  10f80e:	eb 04                	jmp    10f814 <pkt_cursor_advance+0x1a>
  10f810:	0f b7 59 0c          	movzwl 0xc(%ecx),%ebx
	if ((cursor->pos - cursor->buf->data) == len) {
  10f814:	8b 70 18             	mov    0x18(%eax),%esi
  10f817:	2b 71 08             	sub    0x8(%ecx),%esi
  10f81a:	39 de                	cmp    %ebx,%esi
  10f81c:	75 0b                	jne    10f829 <pkt_cursor_advance+0x2f>
		pkt_cursor_jump(pkt, write);
	}
}
  10f81e:	5b                   	pop    %ebx
  10f81f:	5e                   	pop    %esi
		pkt_cursor_jump(pkt, write);
  10f820:	0f b6 d2             	movzbl %dl,%edx
}
  10f823:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
  10f824:	e9 86 ff ff ff       	jmp    10f7af <pkt_cursor_jump>
}
  10f829:	5b                   	pop    %ebx
  10f82a:	5e                   	pop    %esi
  10f82b:	5d                   	pop    %ebp
  10f82c:	c3                   	ret    
  10f82d:	c3                   	ret    

0010f82e <pkt_cursor_update>:

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
  10f82e:	55                   	push   %ebp
  10f82f:	89 e5                	mov    %esp,%ebp
  10f831:	57                   	push   %edi
  10f832:	56                   	push   %esi
  10f833:	89 ce                	mov    %ecx,%esi
  10f835:	53                   	push   %ebx
  10f836:	83 ec 08             	sub    $0x8,%esp
  10f839:	89 55 ec             	mov    %edx,-0x14(%ebp)
	return pkt->overwrite;
  10f83c:	8a 48 3d             	mov    0x3d(%eax),%cl
  10f83f:	8b 58 14             	mov    0x14(%eax),%ebx
  10f842:	83 e1 01             	and    $0x1,%ecx
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (net_pkt_is_being_overwritten(pkt)) {
  10f845:	88 ca                	mov    %cl,%dl
  10f847:	88 4d f3             	mov    %cl,-0xd(%ebp)
  10f84a:	83 f2 01             	xor    $0x1,%edx
		write = false;
	}

	len = write ? cursor->buf->size : cursor->buf->len;
  10f84d:	89 f1                	mov    %esi,%ecx
  10f84f:	20 ca                	and    %cl,%dl
  10f851:	88 55 f2             	mov    %dl,-0xe(%ebp)
  10f854:	74 06                	je     10f85c <pkt_cursor_update+0x2e>
  10f856:	0f b7 73 0e          	movzwl 0xe(%ebx),%esi
  10f85a:	eb 04                	jmp    10f860 <pkt_cursor_update+0x32>
  10f85c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
	if (length + (cursor->pos - cursor->buf->data) == len &&
  10f860:	8b 50 18             	mov    0x18(%eax),%edx
  10f863:	89 d7                	mov    %edx,%edi
  10f865:	2b 7b 08             	sub    0x8(%ebx),%edi
  10f868:	03 7d ec             	add    -0x14(%ebp),%edi
  10f86b:	39 f7                	cmp    %esi,%edi
  10f86d:	75 1d                	jne    10f88c <pkt_cursor_update+0x5e>
  10f86f:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
  10f873:	74 08                	je     10f87d <pkt_cursor_update+0x4f>
	    !(net_pkt_is_being_overwritten(pkt) && len < cursor->buf->size)) {
  10f875:	0f b7 4b 0e          	movzwl 0xe(%ebx),%ecx
  10f879:	39 f1                	cmp    %esi,%ecx
  10f87b:	77 0f                	ja     10f88c <pkt_cursor_update+0x5e>
		pkt_cursor_jump(pkt, write);
  10f87d:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
	} else {
		cursor->pos += length;
	}
}
  10f881:	59                   	pop    %ecx
  10f882:	5b                   	pop    %ebx
  10f883:	5b                   	pop    %ebx
  10f884:	5e                   	pop    %esi
  10f885:	5f                   	pop    %edi
  10f886:	5d                   	pop    %ebp
		pkt_cursor_jump(pkt, write);
  10f887:	e9 23 ff ff ff       	jmp    10f7af <pkt_cursor_jump>
		cursor->pos += length;
  10f88c:	03 55 ec             	add    -0x14(%ebp),%edx
  10f88f:	89 50 18             	mov    %edx,0x18(%eax)
}
  10f892:	58                   	pop    %eax
  10f893:	5a                   	pop    %edx
  10f894:	5b                   	pop    %ebx
  10f895:	5e                   	pop    %esi
  10f896:	5f                   	pop    %edi
  10f897:	5d                   	pop    %ebp
  10f898:	c3                   	ret    

0010f899 <net_pkt_cursor_operate>:

/* Internal function that does all operation (skip/read/write/memset) */
static int net_pkt_cursor_operate(struct net_pkt *pkt,
				  void *data, size_t length,
				  bool copy, bool write)
{
  10f899:	55                   	push   %ebp
  10f89a:	89 e5                	mov    %esp,%ebp
  10f89c:	57                   	push   %edi
  10f89d:	56                   	push   %esi
  10f89e:	89 c6                	mov    %eax,%esi
  10f8a0:	53                   	push   %ebx
  10f8a1:	89 d7                	mov    %edx,%edi
  10f8a3:	83 ec 08             	sub    $0x8,%esp
  10f8a6:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10f8a9:	8a 45 08             	mov    0x8(%ebp),%al
  10f8ac:	88 45 ee             	mov    %al,-0x12(%ebp)
  10f8af:	8a 45 0c             	mov    0xc(%ebp),%al
  10f8b2:	88 45 ef             	mov    %al,-0x11(%ebp)
	/* We use such variable to avoid lengthy lines */
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (c_op->buf && length) {
  10f8b5:	83 7e 14 00          	cmpl   $0x0,0x14(%esi)
  10f8b9:	0f 84 c5 00 00 00    	je     10f984 <net_pkt_cursor_operate+0xeb>
  10f8bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10f8c3:	0f 84 c5 00 00 00    	je     10f98e <net_pkt_cursor_operate+0xf5>
  10f8c9:	8a 56 3d             	mov    0x3d(%esi),%dl
		size_t d_len, len;

		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
  10f8cc:	89 f0                	mov    %esi,%eax
  10f8ce:	83 e2 01             	and    $0x1,%edx
				   false : write);
  10f8d1:	83 f2 01             	xor    $0x1,%edx
  10f8d4:	22 55 ef             	and    -0x11(%ebp),%dl
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
  10f8d7:	0f b6 d2             	movzbl %dl,%edx
  10f8da:	e8 1b ff ff ff       	call   10f7fa <pkt_cursor_advance>
		if (c_op->buf == NULL) {
  10f8df:	8b 4e 14             	mov    0x14(%esi),%ecx
  10f8e2:	85 c9                	test   %ecx,%ecx
  10f8e4:	75 0a                	jne    10f8f0 <net_pkt_cursor_operate+0x57>
		length -= len;
	}

	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
  10f8e6:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
  10f8eb:	e9 a0 00 00 00       	jmp    10f990 <net_pkt_cursor_operate+0xf7>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
  10f8f0:	8b 46 18             	mov    0x18(%esi),%eax
  10f8f3:	89 c2                	mov    %eax,%edx
  10f8f5:	2b 51 08             	sub    0x8(%ecx),%edx
  10f8f8:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  10f8fc:	74 0c                	je     10f90a <net_pkt_cursor_operate+0x71>
  10f8fe:	f6 46 3d 01          	testb  $0x1,0x3d(%esi)
  10f902:	75 06                	jne    10f90a <net_pkt_cursor_operate+0x71>
			d_len = c_op->buf->size - (c_op->pos - c_op->buf->data);
  10f904:	0f b7 59 0e          	movzwl 0xe(%ecx),%ebx
  10f908:	eb 04                	jmp    10f90e <net_pkt_cursor_operate+0x75>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
  10f90a:	0f b7 59 0c          	movzwl 0xc(%ecx),%ebx
  10f90e:	29 d3                	sub    %edx,%ebx
		if (!d_len) {
  10f910:	85 db                	test   %ebx,%ebx
  10f912:	74 d2                	je     10f8e6 <net_pkt_cursor_operate+0x4d>
		if (length < d_len) {
  10f914:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  10f917:	76 03                	jbe    10f91c <net_pkt_cursor_operate+0x83>
  10f919:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		if (copy) {
  10f91c:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
  10f920:	74 16                	je     10f938 <net_pkt_cursor_operate+0x9f>
			memcpy(write ? c_op->pos : data,
  10f922:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  10f926:	89 fa                	mov    %edi,%edx
  10f928:	74 04                	je     10f92e <net_pkt_cursor_operate+0x95>
  10f92a:	89 c2                	mov    %eax,%edx
  10f92c:	89 f8                	mov    %edi,%eax
  10f92e:	53                   	push   %ebx
  10f92f:	50                   	push   %eax
  10f930:	52                   	push   %edx
  10f931:	e8 b6 c4 ff ff       	call   10bdec <memcpy>
  10f936:	eb 0d                	jmp    10f945 <net_pkt_cursor_operate+0xac>
		} else if (data) {
  10f938:	85 ff                	test   %edi,%edi
  10f93a:	74 0c                	je     10f948 <net_pkt_cursor_operate+0xaf>
			memset(c_op->pos, *(int *)data, len);
  10f93c:	53                   	push   %ebx
  10f93d:	ff 37                	pushl  (%edi)
  10f93f:	50                   	push   %eax
  10f940:	e8 16 c5 ff ff       	call   10be5b <memset>
  10f945:	83 c4 0c             	add    $0xc,%esp
		if (write && !net_pkt_is_being_overwritten(pkt)) {
  10f948:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
  10f94c:	74 15                	je     10f963 <net_pkt_cursor_operate+0xca>
  10f94e:	f6 46 3d 01          	testb  $0x1,0x3d(%esi)
  10f952:	75 0f                	jne    10f963 <net_pkt_cursor_operate+0xca>
			net_buf_add(c_op->buf, len);
  10f954:	8b 46 14             	mov    0x14(%esi),%eax
  10f957:	53                   	push   %ebx
  10f958:	83 c0 08             	add    $0x8,%eax
  10f95b:	50                   	push   %eax
  10f95c:	e8 b6 c8 ff ff       	call   10c217 <net_buf_simple_add>
  10f961:	58                   	pop    %eax
  10f962:	5a                   	pop    %edx
		pkt_cursor_update(pkt, len, write);
  10f963:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  10f967:	89 da                	mov    %ebx,%edx
  10f969:	89 f0                	mov    %esi,%eax
  10f96b:	e8 be fe ff ff       	call   10f82e <pkt_cursor_update>
		if (copy && data) {
  10f970:	85 ff                	test   %edi,%edi
  10f972:	74 08                	je     10f97c <net_pkt_cursor_operate+0xe3>
  10f974:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
  10f978:	74 02                	je     10f97c <net_pkt_cursor_operate+0xe3>
			data = (uint8_t *) data + len;
  10f97a:	01 df                	add    %ebx,%edi
		length -= len;
  10f97c:	29 5d f0             	sub    %ebx,-0x10(%ebp)
  10f97f:	e9 31 ff ff ff       	jmp    10f8b5 <net_pkt_cursor_operate+0x1c>
	if (length) {
  10f984:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10f988:	0f 85 58 ff ff ff    	jne    10f8e6 <net_pkt_cursor_operate+0x4d>
	}

	return 0;
  10f98e:	31 c0                	xor    %eax,%eax
}
  10f990:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10f993:	5b                   	pop    %ebx
  10f994:	5e                   	pop    %esi
  10f995:	5f                   	pop    %edi
  10f996:	5d                   	pop    %ebp
  10f997:	c3                   	ret    

0010f998 <pkt_estimate_headers_length.part.0>:
		hdr_len += NET_IPV4H_LEN;
  10f998:	66 48                	dec    %ax
  10f99a:	0f 95 c0             	setne  %al
  10f99d:	0f b6 c0             	movzbl %al,%eax
  10f9a0:	48                   	dec    %eax
  10f9a1:	83 e0 14             	and    $0x14,%eax
	if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
  10f9a4:	83 fa 06             	cmp    $0x6,%edx
  10f9a7:	75 04                	jne    10f9ad <pkt_estimate_headers_length.part.0+0x15>
		hdr_len += NET_TCPH_LEN + NET_TCP_MAX_OPT_SIZE;
  10f9a9:	83 c0 1c             	add    $0x1c,%eax
  10f9ac:	c3                   	ret    
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
  10f9ad:	83 fa 11             	cmp    $0x11,%edx
  10f9b0:	75 04                	jne    10f9b6 <pkt_estimate_headers_length.part.0+0x1e>
		hdr_len += NET_UDPH_LEN;
  10f9b2:	83 c0 08             	add    $0x8,%eax
  10f9b5:	c3                   	ret    
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
  10f9b6:	83 fa 01             	cmp    $0x1,%edx
  10f9b9:	74 05                	je     10f9c0 <pkt_estimate_headers_length.part.0+0x28>
  10f9bb:	83 fa 3a             	cmp    $0x3a,%edx
  10f9be:	75 03                	jne    10f9c3 <pkt_estimate_headers_length.part.0+0x2b>
		hdr_len += NET_ICMPH_LEN;
  10f9c0:	83 c0 04             	add    $0x4,%eax
}
  10f9c3:	c3                   	ret    

0010f9c4 <net_pkt_get_reserve_data>:
{
  10f9c4:	55                   	push   %ebp
  10f9c5:	89 e5                	mov    %esp,%ebp
  10f9c7:	53                   	push   %ebx
  10f9c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (k_is_in_isr()) {
  10f9cb:	e8 cd 1f 01 00       	call   12199d <k_is_in_isr>
  10f9d0:	84 c0                	test   %al,%al
  10f9d2:	74 06                	je     10f9da <net_pkt_get_reserve_data+0x16>
		frag = net_buf_alloc(pool, K_NO_WAIT);
  10f9d4:	6a 00                	push   $0x0
  10f9d6:	6a 00                	push   $0x0
  10f9d8:	eb 06                	jmp    10f9e0 <net_pkt_get_reserve_data+0x1c>
		frag = net_buf_alloc(pool, timeout);
  10f9da:	ff 75 10             	pushl  0x10(%ebp)
  10f9dd:	ff 75 0c             	pushl  0xc(%ebp)
  10f9e0:	53                   	push   %ebx
  10f9e1:	e8 f6 c6 ff ff       	call   10c0dc <net_buf_alloc_fixed>
  10f9e6:	83 c4 0c             	add    $0xc,%esp
}
  10f9e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10f9ec:	c9                   	leave  
  10f9ed:	c3                   	ret    

0010f9ee <net_pkt_get_reserve_rx_data>:
{
  10f9ee:	55                   	push   %ebp
  10f9ef:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve_data(&rx_bufs, timeout);
  10f9f1:	ff 75 0c             	pushl  0xc(%ebp)
  10f9f4:	ff 75 08             	pushl  0x8(%ebp)
  10f9f7:	68 d8 5d 14 00       	push   $0x145dd8
  10f9fc:	e8 c3 ff ff ff       	call   10f9c4 <net_pkt_get_reserve_data>
  10fa01:	83 c4 0c             	add    $0xc,%esp
}
  10fa04:	c9                   	leave  
  10fa05:	c3                   	ret    

0010fa06 <net_pkt_get_reserve_tx_data>:
{
  10fa06:	55                   	push   %ebp
  10fa07:	89 e5                	mov    %esp,%ebp
	return net_pkt_get_reserve_data(&tx_bufs, timeout);
  10fa09:	ff 75 0c             	pushl  0xc(%ebp)
  10fa0c:	ff 75 08             	pushl  0x8(%ebp)
  10fa0f:	68 0c 5e 14 00       	push   $0x145e0c
  10fa14:	e8 ab ff ff ff       	call   10f9c4 <net_pkt_get_reserve_data>
  10fa19:	83 c4 0c             	add    $0xc,%esp
}
  10fa1c:	c9                   	leave  
  10fa1d:	c3                   	ret    

0010fa1e <net_pkt_get_frag>:
{
  10fa1e:	55                   	push   %ebp
  10fa1f:	89 e5                	mov    %esp,%ebp
	if (pkt->slab == &rx_pkts) {
  10fa21:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
  10fa24:	8b 45 0c             	mov    0xc(%ebp),%eax
  10fa27:	8b 55 10             	mov    0x10(%ebp),%edx
	if (pkt->slab == &rx_pkts) {
  10fa2a:	81 79 0c 60 5c 14 00 	cmpl   $0x145c60,0xc(%ecx)
		return net_pkt_get_reserve_rx_data(timeout);
  10fa31:	89 45 08             	mov    %eax,0x8(%ebp)
  10fa34:	89 55 0c             	mov    %edx,0xc(%ebp)
	if (pkt->slab == &rx_pkts) {
  10fa37:	75 06                	jne    10fa3f <net_pkt_get_frag+0x21>
}
  10fa39:	5d                   	pop    %ebp
		return net_pkt_get_reserve_rx_data(timeout);
  10fa3a:	e9 af ff ff ff       	jmp    10f9ee <net_pkt_get_reserve_rx_data>
}
  10fa3f:	5d                   	pop    %ebp
	return net_pkt_get_reserve_tx_data(timeout);
  10fa40:	e9 c1 ff ff ff       	jmp    10fa06 <net_pkt_get_reserve_tx_data>

0010fa45 <net_pkt_ref>:
{
  10fa45:	55                   	push   %ebp
  10fa46:	89 e5                	mov    %esp,%ebp
  10fa48:	53                   	push   %ebx
  10fa49:	8b 55 08             	mov    0x8(%ebp),%edx
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
  10fa4c:	8d 4a 24             	lea    0x24(%edx),%ecx
  10fa4f:	85 d2                	test   %edx,%edx
  10fa51:	74 11                	je     10fa64 <net_pkt_ref+0x1f>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10fa53:	8b 01                	mov    (%ecx),%eax
		if (!ref) {
  10fa55:	85 c0                	test   %eax,%eax
  10fa57:	74 0b                	je     10fa64 <net_pkt_ref+0x1f>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
  10fa59:	8d 58 01             	lea    0x1(%eax),%ebx
	return __atomic_compare_exchange_n(target, &old_value, new_value,
  10fa5c:	f0 0f b1 19          	lock cmpxchg %ebx,(%ecx)
  10fa60:	74 04                	je     10fa66 <net_pkt_ref+0x21>
  10fa62:	eb eb                	jmp    10fa4f <net_pkt_ref+0xa>
			return NULL;
  10fa64:	31 d2                	xor    %edx,%edx
}
  10fa66:	5b                   	pop    %ebx
  10fa67:	89 d0                	mov    %edx,%eax
  10fa69:	5d                   	pop    %ebp
  10fa6a:	c3                   	ret    

0010fa6b <net_pkt_frag_unref>:
{
  10fa6b:	55                   	push   %ebp
  10fa6c:	89 e5                	mov    %esp,%ebp
	if (!frag) {
  10fa6e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10fa72:	74 06                	je     10fa7a <net_pkt_frag_unref+0xf>
}
  10fa74:	5d                   	pop    %ebp
	net_buf_unref(frag);
  10fa75:	e9 81 c6 ff ff       	jmp    10c0fb <net_buf_unref>
}
  10fa7a:	5d                   	pop    %ebp
  10fa7b:	c3                   	ret    

0010fa7c <net_pkt_unref>:
{
  10fa7c:	55                   	push   %ebp
  10fa7d:	89 e5                	mov    %esp,%ebp
  10fa7f:	53                   	push   %ebx
	if (!pkt) {
  10fa80:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10fa84:	74 3e                	je     10fac4 <net_pkt_unref+0x48>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  10fa86:	8b 45 08             	mov    0x8(%ebp),%eax
  10fa89:	8b 50 24             	mov    0x24(%eax),%edx
		if (!ref) {
  10fa8c:	85 d2                	test   %edx,%edx
  10fa8e:	74 34                	je     10fac4 <net_pkt_unref+0x48>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
  10fa90:	8b 4d 08             	mov    0x8(%ebp),%ecx
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
  10fa93:	8d 5a ff             	lea    -0x1(%edx),%ebx
  10fa96:	89 d0                	mov    %edx,%eax
  10fa98:	f0 0f b1 59 24       	lock cmpxchg %ebx,0x24(%ecx)
  10fa9d:	75 e7                	jne    10fa86 <net_pkt_unref+0xa>
	if (ref > 1) {
  10fa9f:	4a                   	dec    %edx
  10faa0:	7f 22                	jg     10fac4 <net_pkt_unref+0x48>
	if (pkt->frags) {
  10faa2:	8b 45 08             	mov    0x8(%ebp),%eax
  10faa5:	8b 40 10             	mov    0x10(%eax),%eax
  10faa8:	85 c0                	test   %eax,%eax
  10faaa:	74 07                	je     10fab3 <net_pkt_unref+0x37>
		net_pkt_frag_unref(pkt->frags);
  10faac:	50                   	push   %eax
  10faad:	e8 b9 ff ff ff       	call   10fa6b <net_pkt_frag_unref>
  10fab2:	59                   	pop    %ecx
	k_mem_slab_free(pkt->slab, (void **)&pkt);
  10fab3:	8d 45 08             	lea    0x8(%ebp),%eax
  10fab6:	50                   	push   %eax
  10fab7:	8b 45 08             	mov    0x8(%ebp),%eax
  10faba:	ff 70 0c             	pushl  0xc(%eax)
  10fabd:	e8 b8 0e 01 00       	call   12097a <k_mem_slab_free>
  10fac2:	58                   	pop    %eax
  10fac3:	5a                   	pop    %edx
}
  10fac4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10fac7:	c9                   	leave  
  10fac8:	c3                   	ret    

0010fac9 <net_pkt_frag_insert>:
{
  10fac9:	55                   	push   %ebp
  10faca:	89 e5                	mov    %esp,%ebp
  10facc:	56                   	push   %esi
  10facd:	53                   	push   %ebx
  10face:	8b 75 0c             	mov    0xc(%ebp),%esi
  10fad1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_buf_frag_last(frag)->frags = pkt->frags;
  10fad4:	56                   	push   %esi
  10fad5:	e8 98 c6 ff ff       	call   10c172 <net_buf_frag_last>
  10fada:	5a                   	pop    %edx
  10fadb:	8b 53 10             	mov    0x10(%ebx),%edx
  10fade:	89 10                	mov    %edx,(%eax)
	pkt->frags = frag;
  10fae0:	89 73 10             	mov    %esi,0x10(%ebx)
}
  10fae3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10fae6:	5b                   	pop    %ebx
  10fae7:	5e                   	pop    %esi
  10fae8:	5d                   	pop    %ebp
  10fae9:	c3                   	ret    

0010faea <net_pkt_get_info>:
{
  10faea:	55                   	push   %ebp
  10faeb:	89 e5                	mov    %esp,%ebp
  10faed:	53                   	push   %ebx
  10faee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10faf1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10faf4:	8b 55 10             	mov    0x10(%ebp),%edx
  10faf7:	8b 45 14             	mov    0x14(%ebp),%eax
	if (rx) {
  10fafa:	85 db                	test   %ebx,%ebx
  10fafc:	74 06                	je     10fb04 <net_pkt_get_info+0x1a>
		*rx = &rx_pkts;
  10fafe:	c7 03 60 5c 14 00    	movl   $0x145c60,(%ebx)
	if (tx) {
  10fb04:	85 c9                	test   %ecx,%ecx
  10fb06:	74 06                	je     10fb0e <net_pkt_get_info+0x24>
		*tx = &tx_pkts;
  10fb08:	c7 01 a8 5c 14 00    	movl   $0x145ca8,(%ecx)
	if (rx_data) {
  10fb0e:	85 d2                	test   %edx,%edx
  10fb10:	74 06                	je     10fb18 <net_pkt_get_info+0x2e>
		*rx_data = &rx_bufs;
  10fb12:	c7 02 d8 5d 14 00    	movl   $0x145dd8,(%edx)
	if (tx_data) {
  10fb18:	85 c0                	test   %eax,%eax
  10fb1a:	74 06                	je     10fb22 <net_pkt_get_info+0x38>
		*tx_data = &tx_bufs;
  10fb1c:	c7 00 0c 5e 14 00    	movl   $0x145e0c,(%eax)
}
  10fb22:	5b                   	pop    %ebx
  10fb23:	5d                   	pop    %ebp
  10fb24:	c3                   	ret    

0010fb25 <net_pkt_available_buffer>:
{
  10fb25:	55                   	push   %ebp
  10fb26:	31 c0                	xor    %eax,%eax
  10fb28:	89 e5                	mov    %esp,%ebp
  10fb2a:	53                   	push   %ebx
  10fb2b:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!pkt) {
  10fb2e:	85 d2                	test   %edx,%edx
  10fb30:	74 20                	je     10fb52 <net_pkt_available_buffer+0x2d>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
  10fb32:	8b 52 10             	mov    0x10(%edx),%edx
	size_t size = 0;
  10fb35:	31 db                	xor    %ebx,%ebx
	struct net_buf *buf = pkt->buffer;
  10fb37:	89 d0                	mov    %edx,%eax
	while (buf) {
  10fb39:	85 c0                	test   %eax,%eax
  10fb3b:	74 0a                	je     10fb47 <net_pkt_available_buffer+0x22>
		size += buf->size;
  10fb3d:	0f b7 48 0e          	movzwl 0xe(%eax),%ecx
		buf = buf->frags;
  10fb41:	8b 00                	mov    (%eax),%eax
		size += buf->size;
  10fb43:	01 cb                	add    %ecx,%ebx
		buf = buf->frags;
  10fb45:	eb f2                	jmp    10fb39 <net_pkt_available_buffer+0x14>
	return net_buf_frags_len(pkt->frags);
  10fb47:	89 d0                	mov    %edx,%eax
  10fb49:	e8 4e fc ff ff       	call   10f79c <net_buf_frags_len>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
  10fb4e:	29 c3                	sub    %eax,%ebx
  10fb50:	89 d8                	mov    %ebx,%eax
}
  10fb52:	5b                   	pop    %ebx
  10fb53:	5d                   	pop    %ebp
  10fb54:	c3                   	ret    

0010fb55 <net_pkt_available_payload_buffer>:
{
  10fb55:	55                   	push   %ebp
  10fb56:	31 c0                	xor    %eax,%eax
  10fb58:	89 e5                	mov    %esp,%ebp
  10fb5a:	57                   	push   %edi
  10fb5b:	56                   	push   %esi
  10fb5c:	8b 75 08             	mov    0x8(%ebp),%esi
  10fb5f:	53                   	push   %ebx
	if (!pkt) {
  10fb60:	85 f6                	test   %esi,%esi
  10fb62:	74 36                	je     10fb9a <net_pkt_available_payload_buffer+0x45>
	return pkt->family;
  10fb64:	8a 46 3f             	mov    0x3f(%esi),%al
		return  0;
  10fb67:	bb 00 00 00 00       	mov    $0x0,%ebx
  10fb6c:	d0 e8                	shr    %al
	if (family == AF_UNSPEC) {
  10fb6e:	24 07                	and    $0x7,%al
  10fb70:	74 0d                	je     10fb7f <net_pkt_available_payload_buffer+0x2a>
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
  10fb72:	0f b6 c0             	movzbl %al,%eax
  10fb75:	8b 55 0c             	mov    0xc(%ebp),%edx
  10fb78:	e8 1b fe ff ff       	call   10f998 <pkt_estimate_headers_length.part.0>
  10fb7d:	89 c3                	mov    %eax,%ebx
	return net_buf_frags_len(pkt->frags);
  10fb7f:	8b 46 10             	mov    0x10(%esi),%eax
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
  10fb82:	31 ff                	xor    %edi,%edi
  10fb84:	e8 13 fc ff ff       	call   10f79c <net_buf_frags_len>
  10fb89:	39 d8                	cmp    %ebx,%eax
  10fb8b:	73 04                	jae    10fb91 <net_pkt_available_payload_buffer+0x3c>
  10fb8d:	89 df                	mov    %ebx,%edi
  10fb8f:	29 c7                	sub    %eax,%edi
	len = net_pkt_available_buffer(pkt) - hdr_len;
  10fb91:	56                   	push   %esi
  10fb92:	e8 8e ff ff ff       	call   10fb25 <net_pkt_available_buffer>
  10fb97:	5a                   	pop    %edx
  10fb98:	29 f8                	sub    %edi,%eax
}
  10fb9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10fb9d:	5b                   	pop    %ebx
  10fb9e:	5e                   	pop    %esi
  10fb9f:	5f                   	pop    %edi
  10fba0:	5d                   	pop    %ebp
  10fba1:	c3                   	ret    

0010fba2 <net_pkt_trim_buffer>:
{
  10fba2:	55                   	push   %ebp
  10fba3:	89 e5                	mov    %esp,%ebp
  10fba5:	57                   	push   %edi
  10fba6:	56                   	push   %esi
  10fba7:	8b 75 08             	mov    0x8(%ebp),%esi
  10fbaa:	53                   	push   %ebx
	buf = pkt->buffer;
  10fbab:	8b 46 10             	mov    0x10(%esi),%eax
	prev = buf;
  10fbae:	89 c3                	mov    %eax,%ebx
	while (buf) {
  10fbb0:	85 c0                	test   %eax,%eax
  10fbb2:	74 2e                	je     10fbe2 <net_pkt_trim_buffer+0x40>
		if (!buf->len) {
  10fbb4:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
		struct net_buf *next = buf->frags;
  10fbb9:	8b 38                	mov    (%eax),%edi
		if (!buf->len) {
  10fbbb:	75 1f                	jne    10fbdc <net_pkt_trim_buffer+0x3a>
			if (buf == pkt->buffer) {
  10fbbd:	39 46 10             	cmp    %eax,0x10(%esi)
  10fbc0:	75 05                	jne    10fbc7 <net_pkt_trim_buffer+0x25>
				pkt->buffer = next;
  10fbc2:	89 7e 10             	mov    %edi,0x10(%esi)
  10fbc5:	eb 06                	jmp    10fbcd <net_pkt_trim_buffer+0x2b>
			} else if (buf == prev->frags) {
  10fbc7:	39 03                	cmp    %eax,(%ebx)
  10fbc9:	75 02                	jne    10fbcd <net_pkt_trim_buffer+0x2b>
				prev->frags = next;
  10fbcb:	89 3b                	mov    %edi,(%ebx)
			buf->frags = NULL;
  10fbcd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			net_buf_unref(buf);
  10fbd3:	50                   	push   %eax
  10fbd4:	e8 22 c5 ff ff       	call   10c0fb <net_buf_unref>
  10fbd9:	58                   	pop    %eax
  10fbda:	89 d8                	mov    %ebx,%eax
  10fbdc:	89 c3                	mov    %eax,%ebx
  10fbde:	89 f8                	mov    %edi,%eax
  10fbe0:	eb ce                	jmp    10fbb0 <net_pkt_trim_buffer+0xe>
}
  10fbe2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10fbe5:	5b                   	pop    %ebx
  10fbe6:	5e                   	pop    %esi
  10fbe7:	5f                   	pop    %edi
  10fbe8:	5d                   	pop    %ebp
  10fbe9:	c3                   	ret    

0010fbea <net_pkt_cursor_init>:
{
  10fbea:	55                   	push   %ebp
  10fbeb:	89 e5                	mov    %esp,%ebp
  10fbed:	8b 55 08             	mov    0x8(%ebp),%edx
	pkt->cursor.buf = pkt->buffer;
  10fbf0:	8b 42 10             	mov    0x10(%edx),%eax
  10fbf3:	89 42 14             	mov    %eax,0x14(%edx)
	if (pkt->cursor.buf) {
  10fbf6:	85 c0                	test   %eax,%eax
  10fbf8:	74 03                	je     10fbfd <net_pkt_cursor_init+0x13>
		pkt->cursor.pos = pkt->cursor.buf->data;
  10fbfa:	8b 40 08             	mov    0x8(%eax),%eax
  10fbfd:	89 42 18             	mov    %eax,0x18(%edx)
}
  10fc00:	5d                   	pop    %ebp
  10fc01:	c3                   	ret    

0010fc02 <pkt_alloc>:
{
  10fc02:	55                   	push   %ebp
  10fc03:	89 e5                	mov    %esp,%ebp
  10fc05:	57                   	push   %edi
  10fc06:	56                   	push   %esi
  10fc07:	89 cf                	mov    %ecx,%edi
  10fc09:	53                   	push   %ebx
  10fc0a:	89 d6                	mov    %edx,%esi
  10fc0c:	53                   	push   %ebx
  10fc0d:	89 c3                	mov    %eax,%ebx
	if (k_is_in_isr()) {
  10fc0f:	e8 89 1d 01 00       	call   12199d <k_is_in_isr>
  10fc14:	84 c0                	test   %al,%al
  10fc16:	74 04                	je     10fc1c <pkt_alloc+0x1a>
		timeout = K_NO_WAIT;
  10fc18:	31 f6                	xor    %esi,%esi
  10fc1a:	31 ff                	xor    %edi,%edi
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
  10fc1c:	57                   	push   %edi
  10fc1d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  10fc20:	56                   	push   %esi
  10fc21:	50                   	push   %eax
  10fc22:	53                   	push   %ebx
  10fc23:	e8 e4 0c 01 00       	call   12090c <k_mem_slab_alloc>
  10fc28:	89 c2                	mov    %eax,%edx
  10fc2a:	83 c4 10             	add    $0x10,%esp
		return NULL;
  10fc2d:	31 c0                	xor    %eax,%eax
	if (ret) {
  10fc2f:	85 d2                	test   %edx,%edx
  10fc31:	75 40                	jne    10fc73 <pkt_alloc+0x71>
	memset(pkt, 0, sizeof(struct net_pkt));
  10fc33:	6a 48                	push   $0x48
  10fc35:	6a 00                	push   $0x0
  10fc37:	ff 75 f0             	pushl  -0x10(%ebp)
  10fc3a:	e8 1c c2 ff ff       	call   10be5b <memset>
	pkt->atomic_ref = ATOMIC_INIT(1);
  10fc3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memset(pkt, 0, sizeof(struct net_pkt));
  10fc42:	83 c4 0c             	add    $0xc,%esp
	pkt->atomic_ref = ATOMIC_INIT(1);
  10fc45:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
	pkt->slab = slab;
  10fc4c:	89 58 0c             	mov    %ebx,0xc(%eax)
	if (&tx_pkts == slab) {
  10fc4f:	81 fb a8 5c 14 00    	cmp    $0x145ca8,%ebx
  10fc55:	75 06                	jne    10fc5d <pkt_alloc+0x5b>
	pkt->priority = priority;
  10fc57:	c6 40 44 01          	movb   $0x1,0x44(%eax)
}
  10fc5b:	eb 0c                	jmp    10fc69 <pkt_alloc+0x67>
	} else if (&rx_pkts == slab) {
  10fc5d:	81 fb 60 5c 14 00    	cmp    $0x145c60,%ebx
  10fc63:	75 04                	jne    10fc69 <pkt_alloc+0x67>
	pkt->priority = priority;
  10fc65:	c6 40 44 00          	movb   $0x0,0x44(%eax)
	net_pkt_cursor_init(pkt);
  10fc69:	50                   	push   %eax
  10fc6a:	e8 7b ff ff ff       	call   10fbea <net_pkt_cursor_init>
  10fc6f:	58                   	pop    %eax
	return pkt;
  10fc70:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  10fc73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10fc76:	5b                   	pop    %ebx
  10fc77:	5e                   	pop    %esi
  10fc78:	5f                   	pop    %edi
  10fc79:	5d                   	pop    %ebp
  10fc7a:	c3                   	ret    

0010fc7b <net_pkt_alloc>:
{
  10fc7b:	55                   	push   %ebp
	return pkt_alloc(&tx_pkts, timeout);
  10fc7c:	b8 a8 5c 14 00       	mov    $0x145ca8,%eax
{
  10fc81:	89 e5                	mov    %esp,%ebp
	return pkt_alloc(&tx_pkts, timeout);
  10fc83:	8b 55 08             	mov    0x8(%ebp),%edx
  10fc86:	8b 4d 0c             	mov    0xc(%ebp),%ecx
}
  10fc89:	5d                   	pop    %ebp
	return pkt_alloc(&tx_pkts, timeout);
  10fc8a:	e9 73 ff ff ff       	jmp    10fc02 <pkt_alloc>

0010fc8f <pkt_alloc_on_iface>:
{
  10fc8f:	55                   	push   %ebp
  10fc90:	89 e5                	mov    %esp,%ebp
  10fc92:	53                   	push   %ebx
  10fc93:	89 d3                	mov    %edx,%ebx
	pkt = pkt_alloc(slab, timeout);
  10fc95:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10fc98:	8b 55 08             	mov    0x8(%ebp),%edx
  10fc9b:	e8 62 ff ff ff       	call   10fc02 <pkt_alloc>
	if (pkt) {
  10fca0:	85 c0                	test   %eax,%eax
  10fca2:	74 17                	je     10fcbb <pkt_alloc_on_iface+0x2c>
	pkt->iface = iface;
  10fca4:	89 58 20             	mov    %ebx,0x20(%eax)
	if (iface) {
  10fca7:	85 db                	test   %ebx,%ebx
  10fca9:	74 10                	je     10fcbb <pkt_alloc_on_iface+0x2c>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
  10fcab:	8b 13                	mov    (%ebx),%edx
  10fcad:	8a 52 15             	mov    0x15(%edx),%dl
  10fcb0:	88 50 2d             	mov    %dl,0x2d(%eax)
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
  10fcb3:	8b 13                	mov    (%ebx),%edx
  10fcb5:	8a 52 15             	mov    0x15(%edx),%dl
  10fcb8:	88 50 35             	mov    %dl,0x35(%eax)
}
  10fcbb:	5b                   	pop    %ebx
  10fcbc:	5d                   	pop    %ebp
  10fcbd:	c3                   	ret    

0010fcbe <net_pkt_rx_alloc_on_iface>:
{
  10fcbe:	55                   	push   %ebp
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
  10fcbf:	b8 60 5c 14 00       	mov    $0x145c60,%eax
{
  10fcc4:	89 e5                	mov    %esp,%ebp
  10fcc6:	53                   	push   %ebx
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
  10fcc7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  10fcca:	8b 4d 0c             	mov    0xc(%ebp),%ecx
{
  10fccd:	8b 55 08             	mov    0x8(%ebp),%edx
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
  10fcd0:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
  10fcd3:	5b                   	pop    %ebx
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
  10fcd4:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
  10fcd7:	5d                   	pop    %ebp
	return pkt_alloc_on_iface(&rx_pkts, iface, timeout);
  10fcd8:	e9 b2 ff ff ff       	jmp    10fc8f <pkt_alloc_on_iface>

0010fcdd <net_pkt_append_buffer>:
{
  10fcdd:	55                   	push   %ebp
  10fcde:	89 e5                	mov    %esp,%ebp
  10fce0:	53                   	push   %ebx
  10fce1:	8b 55 08             	mov    0x8(%ebp),%edx
  10fce4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (!pkt->buffer) {
  10fce7:	8b 42 10             	mov    0x10(%edx),%eax
  10fcea:	85 c0                	test   %eax,%eax
  10fcec:	75 0c                	jne    10fcfa <net_pkt_append_buffer+0x1d>
		pkt->buffer = buffer;
  10fcee:	89 5a 10             	mov    %ebx,0x10(%edx)
}
  10fcf1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10fcf4:	c9                   	leave  
		net_pkt_cursor_init(pkt);
  10fcf5:	e9 f0 fe ff ff       	jmp    10fbea <net_pkt_cursor_init>
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
  10fcfa:	50                   	push   %eax
  10fcfb:	e8 72 c4 ff ff       	call   10c172 <net_buf_frag_last>
  10fd00:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
  10fd03:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
  10fd06:	5a                   	pop    %edx
  10fd07:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10fd0a:	c9                   	leave  
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
  10fd0b:	e9 74 c4 ff ff       	jmp    10c184 <net_buf_frag_insert>

0010fd10 <net_pkt_alloc_buffer>:
{
  10fd10:	55                   	push   %ebp
  10fd11:	89 e5                	mov    %esp,%ebp
  10fd13:	57                   	push   %edi
  10fd14:	56                   	push   %esi
  10fd15:	53                   	push   %ebx
  10fd16:	83 ec 1c             	sub    $0x1c,%esp
  10fd19:	8b 7d 18             	mov    0x18(%ebp),%edi
  10fd1c:	8b 75 14             	mov    0x14(%ebp),%esi
	uint64_t end = z_timeout_end_calc(timeout);
  10fd1f:	57                   	push   %edi
  10fd20:	56                   	push   %esi
  10fd21:	e8 66 26 01 00       	call   12238c <z_timeout_end_calc>
  10fd26:	5b                   	pop    %ebx
  10fd27:	89 45 d8             	mov    %eax,-0x28(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
  10fd2a:	8b 45 0c             	mov    0xc(%ebp),%eax
	uint64_t end = z_timeout_end_calc(timeout);
  10fd2d:	59                   	pop    %ecx
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
  10fd2e:	0b 45 10             	or     0x10(%ebp),%eax
	uint64_t end = z_timeout_end_calc(timeout);
  10fd31:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
  10fd34:	75 0f                	jne    10fd45 <net_pkt_alloc_buffer+0x35>
  10fd36:	8b 45 08             	mov    0x8(%ebp),%eax
		return 0;
  10fd39:	31 db                	xor    %ebx,%ebx
	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
  10fd3b:	f6 40 3f 0e          	testb  $0xe,0x3f(%eax)
  10fd3f:	0f 84 e4 01 00 00    	je     10ff29 <net_pkt_alloc_buffer+0x219>
	if (k_is_in_isr()) {
  10fd45:	e8 53 1c 01 00       	call   12199d <k_is_in_isr>
  10fd4a:	84 c0                	test   %al,%al
  10fd4c:	74 04                	je     10fd52 <net_pkt_alloc_buffer+0x42>
		timeout = K_NO_WAIT;
  10fd4e:	31 f6                	xor    %esi,%esi
  10fd50:	31 ff                	xor    %edi,%edi
	alloc_len = pkt_get_size(pkt) - net_pkt_get_len(pkt);
  10fd52:	8b 45 08             	mov    0x8(%ebp),%eax
	size_t size = 0;
  10fd55:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	alloc_len = pkt_get_size(pkt) - net_pkt_get_len(pkt);
  10fd5c:	8b 40 10             	mov    0x10(%eax),%eax
	struct net_buf *buf = pkt->buffer;
  10fd5f:	89 c3                	mov    %eax,%ebx
	while (buf) {
  10fd61:	85 db                	test   %ebx,%ebx
  10fd63:	74 0b                	je     10fd70 <net_pkt_alloc_buffer+0x60>
		size += buf->size;
  10fd65:	0f b7 53 0e          	movzwl 0xe(%ebx),%edx
		buf = buf->frags;
  10fd69:	8b 1b                	mov    (%ebx),%ebx
		size += buf->size;
  10fd6b:	01 55 ec             	add    %edx,-0x14(%ebp)
  10fd6e:	eb f1                	jmp    10fd61 <net_pkt_alloc_buffer+0x51>
	return net_buf_frags_len(pkt->frags);
  10fd70:	e8 27 fa ff ff       	call   10f79c <net_buf_frags_len>
	size_t hdr_len = 0;
  10fd75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10fd7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (!alloc_len) {
  10fd7f:	8b 45 08             	mov    0x8(%ebp),%eax
  10fd82:	8a 40 3f             	mov    0x3f(%eax),%al
  10fd85:	88 c1                	mov    %al,%cl
  10fd87:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10fd8a:	d0 e9                	shr    %cl
  10fd8c:	83 e1 07             	and    $0x7,%ecx
  10fd8f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  10fd92:	75 15                	jne    10fda9 <net_pkt_alloc_buffer+0x99>
	size_t hdr_len = 0;
  10fd94:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	if (family == AF_UNSPEC) {
  10fd97:	84 c9                	test   %cl,%cl
  10fd99:	74 0e                	je     10fda9 <net_pkt_alloc_buffer+0x99>
		hdr_len = pkt_estimate_headers_length(pkt,
  10fd9b:	0f b6 c1             	movzbl %cl,%eax
  10fd9e:	8b 55 10             	mov    0x10(%ebp),%edx
  10fda1:	e8 f2 fb ff ff       	call   10f998 <pkt_estimate_headers_length.part.0>
  10fda6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
  10fda9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10fdac:	03 45 0c             	add    0xc(%ebp),%eax
  10fdaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (net_pkt_iface(pkt)) {
  10fdb2:	8b 45 08             	mov    0x8(%ebp),%eax
  10fdb5:	8b 40 20             	mov    0x20(%eax),%eax
  10fdb8:	85 c0                	test   %eax,%eax
  10fdba:	74 0f                	je     10fdcb <net_pkt_alloc_buffer+0xbb>
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
  10fdbc:	8b 00                	mov    (%eax),%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
  10fdbe:	fe c9                	dec    %cl
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
  10fdc0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10fdc3:	0f b7 40 18          	movzwl 0x18(%eax),%eax
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
  10fdc7:	75 1b                	jne    10fde4 <net_pkt_alloc_buffer+0xd4>
  10fdc9:	eb 09                	jmp    10fdd4 <net_pkt_alloc_buffer+0xc4>
			max_len = size;
  10fdcb:	8b 55 f0             	mov    -0x10(%ebp),%edx
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
  10fdce:	fe c9                	dec    %cl
  10fdd0:	75 24                	jne    10fdf6 <net_pkt_alloc_buffer+0xe6>
		max_len = 0;
  10fdd2:	31 c0                	xor    %eax,%eax
		max_len = MAX(max_len, NET_IPV4_MTU);
  10fdd4:	89 c2                	mov    %eax,%edx
  10fdd6:	3d 40 02 00 00       	cmp    $0x240,%eax
  10fddb:	73 19                	jae    10fdf6 <net_pkt_alloc_buffer+0xe6>
  10fddd:	ba 40 02 00 00       	mov    $0x240,%edx
  10fde2:	eb 12                	jmp    10fdf6 <net_pkt_alloc_buffer+0xe6>
		if (net_if_l2(net_pkt_iface(pkt)) ==
  10fde4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
			max_len = size;
  10fde7:	8b 55 f0             	mov    -0x10(%ebp),%edx
		if (net_if_l2(net_pkt_iface(pkt)) ==
  10fdea:	81 79 04 64 5e 14 00 	cmpl   $0x145e64,0x4(%ecx)
  10fdf1:	75 03                	jne    10fdf6 <net_pkt_alloc_buffer+0xe6>
			max_len += sizeof(struct net_eth_hdr);
  10fdf3:	8d 50 0e             	lea    0xe(%eax),%edx
	max_len -= existing;
  10fdf6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10fdf9:	2b 45 ec             	sub    -0x14(%ebp),%eax
	return MIN(size, max_len);
  10fdfc:	01 d0                	add    %edx,%eax
  10fdfe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10fe01:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10fe04:	76 06                	jbe    10fe0c <net_pkt_alloc_buffer+0xfc>
  10fe06:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10fe09:	89 45 ec             	mov    %eax,-0x14(%ebp)
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
  10fe0c:	8b 45 08             	mov    0x8(%ebp),%eax
  10fe0f:	c7 45 e8 0c 5e 14 00 	movl   $0x145e0c,-0x18(%ebp)
  10fe16:	81 78 0c a8 5c 14 00 	cmpl   $0x145ca8,0xc(%eax)
  10fe1d:	74 07                	je     10fe26 <net_pkt_alloc_buffer+0x116>
  10fe1f:	c7 45 e8 d8 5d 14 00 	movl   $0x145dd8,-0x18(%ebp)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  10fe26:	89 f8                	mov    %edi,%eax
  10fe28:	09 f0                	or     %esi,%eax
  10fe2a:	74 21                	je     10fe4d <net_pkt_alloc_buffer+0x13d>
  10fe2c:	83 ff ff             	cmp    $0xffffffff,%edi
  10fe2f:	75 05                	jne    10fe36 <net_pkt_alloc_buffer+0x126>
  10fe31:	83 fe ff             	cmp    $0xffffffff,%esi
  10fe34:	74 17                	je     10fe4d <net_pkt_alloc_buffer+0x13d>
		int64_t remaining = end - z_tick_get();
  10fe36:	e8 1e 25 01 00       	call   122359 <z_tick_get>
  10fe3b:	8b 75 d8             	mov    -0x28(%ebp),%esi
  10fe3e:	29 c6                	sub    %eax,%esi
  10fe40:	8b 7d dc             	mov    -0x24(%ebp),%edi
  10fe43:	19 d7                	sbb    %edx,%edi
  10fe45:	85 ff                	test   %edi,%edi
  10fe47:	79 04                	jns    10fe4d <net_pkt_alloc_buffer+0x13d>
  10fe49:	31 f6                	xor    %esi,%esi
  10fe4b:	31 ff                	xor    %edi,%edi
	uint64_t end = z_timeout_end_calc(timeout);
  10fe4d:	57                   	push   %edi
  10fe4e:	56                   	push   %esi
  10fe4f:	e8 38 25 01 00       	call   12238c <z_timeout_end_calc>
  10fe54:	59                   	pop    %ecx
  10fe55:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (size) {
  10fe58:	8b 45 ec             	mov    -0x14(%ebp),%eax
	uint64_t end = z_timeout_end_calc(timeout);
  10fe5b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  10fe5e:	59                   	pop    %ecx
	struct net_buf *current = NULL;
  10fe5f:	31 d2                	xor    %edx,%edx
	while (size) {
  10fe61:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10fe64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10fe68:	74 7a                	je     10fee4 <net_pkt_alloc_buffer+0x1d4>
		new = net_buf_alloc_fixed(pool, timeout);
  10fe6a:	57                   	push   %edi
  10fe6b:	89 55 d8             	mov    %edx,-0x28(%ebp)
  10fe6e:	56                   	push   %esi
  10fe6f:	ff 75 e8             	pushl  -0x18(%ebp)
  10fe72:	e8 65 c2 ff ff       	call   10c0dc <net_buf_alloc_fixed>
  10fe77:	83 c4 0c             	add    $0xc,%esp
  10fe7a:	89 c1                	mov    %eax,%ecx
		if (!new) {
  10fe7c:	85 c0                	test   %eax,%eax
  10fe7e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10fe81:	75 0d                	jne    10fe90 <net_pkt_alloc_buffer+0x180>
	if (first) {
  10fe83:	85 db                	test   %ebx,%ebx
  10fe85:	74 61                	je     10fee8 <net_pkt_alloc_buffer+0x1d8>
		net_buf_unref(first);
  10fe87:	53                   	push   %ebx
  10fe88:	e8 6e c2 ff ff       	call   10c0fb <net_buf_unref>
  10fe8d:	59                   	pop    %ecx
	if (!buf) {
  10fe8e:	eb 58                	jmp    10fee8 <net_pkt_alloc_buffer+0x1d8>
		if (!first && !current) {
  10fe90:	89 d8                	mov    %ebx,%eax
  10fe92:	09 d0                	or     %edx,%eax
  10fe94:	74 04                	je     10fe9a <net_pkt_alloc_buffer+0x18a>
			current->frags = new;
  10fe96:	89 0a                	mov    %ecx,(%edx)
  10fe98:	eb 02                	jmp    10fe9c <net_pkt_alloc_buffer+0x18c>
  10fe9a:	89 cb                	mov    %ecx,%ebx
		if (current->size > size) {
  10fe9c:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
  10fea0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10fea3:	76 07                	jbe    10feac <net_pkt_alloc_buffer+0x19c>
			current->size = size;
  10fea5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10fea8:	66 89 41 0e          	mov    %ax,0xe(%ecx)
		size -= current->size;
  10feac:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
  10feb0:	29 45 f0             	sub    %eax,-0x10(%ebp)
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  10feb3:	89 f8                	mov    %edi,%eax
  10feb5:	09 f0                	or     %esi,%eax
  10feb7:	74 27                	je     10fee0 <net_pkt_alloc_buffer+0x1d0>
  10feb9:	83 ff ff             	cmp    $0xffffffff,%edi
  10febc:	75 05                	jne    10fec3 <net_pkt_alloc_buffer+0x1b3>
  10febe:	83 fe ff             	cmp    $0xffffffff,%esi
  10fec1:	74 1d                	je     10fee0 <net_pkt_alloc_buffer+0x1d0>
  10fec3:	89 4d d8             	mov    %ecx,-0x28(%ebp)
			int64_t remaining = end - z_tick_get();
  10fec6:	e8 8e 24 01 00       	call   122359 <z_tick_get>
  10fecb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  10fece:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  10fed1:	29 c6                	sub    %eax,%esi
			if (remaining <= 0) {
  10fed3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
			int64_t remaining = end - z_tick_get();
  10fed6:	19 d7                	sbb    %edx,%edi
			if (remaining <= 0) {
  10fed8:	31 c0                	xor    %eax,%eax
  10feda:	39 f0                	cmp    %esi,%eax
  10fedc:	19 f8                	sbb    %edi,%eax
  10fede:	7d 04                	jge    10fee4 <net_pkt_alloc_buffer+0x1d4>
  10fee0:	89 ca                	mov    %ecx,%edx
  10fee2:	eb 80                	jmp    10fe64 <net_pkt_alloc_buffer+0x154>
	if (!buf) {
  10fee4:	85 db                	test   %ebx,%ebx
  10fee6:	75 34                	jne    10ff1c <net_pkt_alloc_buffer+0x20c>
		NET_ERR("Data buffer (%zd) allocation failed.", alloc_len);
  10fee8:	f6 05 fc 5b 14 00 07 	testb  $0x7,0x145bfc
		return -ENOMEM;
  10feef:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
		NET_ERR("Data buffer (%zd) allocation failed.", alloc_len);
  10fef4:	74 33                	je     10ff29 <net_pkt_alloc_buffer+0x219>
  10fef6:	b8 78 31 12 00       	mov    $0x123178,%eax
  10fefb:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  10ff00:	c1 e8 03             	shr    $0x3,%eax
  10ff03:	c1 e0 06             	shl    $0x6,%eax
  10ff06:	83 c8 01             	or     $0x1,%eax
  10ff09:	50                   	push   %eax
  10ff0a:	ff 75 ec             	pushl  -0x14(%ebp)
  10ff0d:	68 ce 5e 12 00       	push   $0x125ece
  10ff12:	e8 5f 36 ff ff       	call   103576 <log_1>
  10ff17:	83 c4 0c             	add    $0xc,%esp
  10ff1a:	eb 0d                	jmp    10ff29 <net_pkt_alloc_buffer+0x219>
	net_pkt_append_buffer(pkt, buf);
  10ff1c:	53                   	push   %ebx
	return 0;
  10ff1d:	31 db                	xor    %ebx,%ebx
	net_pkt_append_buffer(pkt, buf);
  10ff1f:	ff 75 08             	pushl  0x8(%ebp)
  10ff22:	e8 b6 fd ff ff       	call   10fcdd <net_pkt_append_buffer>
  10ff27:	58                   	pop    %eax
  10ff28:	5a                   	pop    %edx
}
  10ff29:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ff2c:	89 d8                	mov    %ebx,%eax
  10ff2e:	5b                   	pop    %ebx
  10ff2f:	5e                   	pop    %esi
  10ff30:	5f                   	pop    %edi
  10ff31:	5d                   	pop    %ebp
  10ff32:	c3                   	ret    

0010ff33 <pkt_alloc_with_buffer>:
{
  10ff33:	55                   	push   %ebp
  10ff34:	89 e5                	mov    %esp,%ebp
  10ff36:	57                   	push   %edi
  10ff37:	56                   	push   %esi
  10ff38:	53                   	push   %ebx
  10ff39:	89 d3                	mov    %edx,%ebx
  10ff3b:	83 ec 14             	sub    $0x14,%esp
  10ff3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10ff41:	8b 7d 14             	mov    0x14(%ebp),%edi
  10ff44:	8b 75 10             	mov    0x10(%ebp),%esi
	uint64_t end = z_timeout_end_calc(timeout);
  10ff47:	57                   	push   %edi
{
  10ff48:	8b 45 08             	mov    0x8(%ebp),%eax
	uint64_t end = z_timeout_end_calc(timeout);
  10ff4b:	56                   	push   %esi
{
  10ff4c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  10ff4f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint64_t end = z_timeout_end_calc(timeout);
  10ff52:	e8 35 24 01 00       	call   12238c <z_timeout_end_calc>
  10ff57:	59                   	pop    %ecx
  10ff58:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10ff5b:	59                   	pop    %ecx
  10ff5c:	89 55 f0             	mov    %edx,-0x10(%ebp)
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
  10ff5f:	57                   	push   %edi
  10ff60:	89 da                	mov    %ebx,%edx
  10ff62:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10ff65:	56                   	push   %esi
  10ff66:	e8 24 fd ff ff       	call   10fc8f <pkt_alloc_on_iface>
  10ff6b:	5b                   	pop    %ebx
  10ff6c:	5a                   	pop    %edx
  10ff6d:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
  10ff6f:	85 c0                	test   %eax,%eax
  10ff71:	74 59                	je     10ffcc <pkt_alloc_with_buffer+0x99>
	pkt->family = family;
  10ff73:	8a 45 e0             	mov    -0x20(%ebp),%al
  10ff76:	83 e0 07             	and    $0x7,%eax
  10ff79:	8d 14 00             	lea    (%eax,%eax,1),%edx
  10ff7c:	8a 43 3f             	mov    0x3f(%ebx),%al
  10ff7f:	83 e0 f1             	and    $0xfffffff1,%eax
  10ff82:	09 d0                	or     %edx,%eax
  10ff84:	88 43 3f             	mov    %al,0x3f(%ebx)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  10ff87:	89 f8                	mov    %edi,%eax
  10ff89:	09 f0                	or     %esi,%eax
  10ff8b:	74 21                	je     10ffae <pkt_alloc_with_buffer+0x7b>
  10ff8d:	83 ff ff             	cmp    $0xffffffff,%edi
  10ff90:	75 05                	jne    10ff97 <pkt_alloc_with_buffer+0x64>
  10ff92:	83 fe ff             	cmp    $0xffffffff,%esi
  10ff95:	74 17                	je     10ffae <pkt_alloc_with_buffer+0x7b>
		int64_t remaining = end - z_tick_get();
  10ff97:	e8 bd 23 01 00       	call   122359 <z_tick_get>
  10ff9c:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10ff9f:	29 c6                	sub    %eax,%esi
  10ffa1:	8b 7d f0             	mov    -0x10(%ebp),%edi
  10ffa4:	19 d7                	sbb    %edx,%edi
  10ffa6:	85 ff                	test   %edi,%edi
  10ffa8:	79 04                	jns    10ffae <pkt_alloc_with_buffer+0x7b>
  10ffaa:	31 f6                	xor    %esi,%esi
  10ffac:	31 ff                	xor    %edi,%edi
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
  10ffae:	57                   	push   %edi
  10ffaf:	56                   	push   %esi
  10ffb0:	ff 75 0c             	pushl  0xc(%ebp)
  10ffb3:	ff 75 e4             	pushl  -0x1c(%ebp)
  10ffb6:	53                   	push   %ebx
  10ffb7:	e8 54 fd ff ff       	call   10fd10 <net_pkt_alloc_buffer>
  10ffbc:	83 c4 14             	add    $0x14,%esp
	if (ret) {
  10ffbf:	85 c0                	test   %eax,%eax
  10ffc1:	74 09                	je     10ffcc <pkt_alloc_with_buffer+0x99>
		net_pkt_unref(pkt);
  10ffc3:	53                   	push   %ebx
		return NULL;
  10ffc4:	31 db                	xor    %ebx,%ebx
		net_pkt_unref(pkt);
  10ffc6:	e8 b1 fa ff ff       	call   10fa7c <net_pkt_unref>
  10ffcb:	58                   	pop    %eax
}
  10ffcc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10ffcf:	89 d8                	mov    %ebx,%eax
  10ffd1:	5b                   	pop    %ebx
  10ffd2:	5e                   	pop    %esi
  10ffd3:	5f                   	pop    %edi
  10ffd4:	5d                   	pop    %ebp
  10ffd5:	c3                   	ret    

0010ffd6 <net_pkt_alloc_with_buffer>:
{
  10ffd6:	55                   	push   %ebp
  10ffd7:	89 e5                	mov    %esp,%ebp
  10ffd9:	57                   	push   %edi
  10ffda:	56                   	push   %esi
  10ffdb:	53                   	push   %ebx
  10ffdc:	8b 5d 14             	mov    0x14(%ebp),%ebx
  10ffdf:	8b 45 10             	mov    0x10(%ebp),%eax
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  10ffe2:	8b 75 18             	mov    0x18(%ebp),%esi
{
  10ffe5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  10ffe8:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
  10ffeb:	5b                   	pop    %ebx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  10ffec:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  10ffef:	89 75 10             	mov    %esi,0x10(%ebp)
}
  10fff2:	5e                   	pop    %esi
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  10fff3:	0f b7 c0             	movzwl %ax,%eax
{
  10fff6:	8b 55 08             	mov    0x8(%ebp),%edx
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  10fff9:	89 7d 14             	mov    %edi,0x14(%ebp)
  10fffc:	89 45 08             	mov    %eax,0x8(%ebp)
}
  10ffff:	5f                   	pop    %edi
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  110000:	b8 a8 5c 14 00       	mov    $0x145ca8,%eax
}
  110005:	5d                   	pop    %ebp
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
  110006:	e9 28 ff ff ff       	jmp    10ff33 <pkt_alloc_with_buffer>

0011000b <net_pkt_skip>:

int net_pkt_skip(struct net_pkt *pkt, size_t skip)
{
  11000b:	55                   	push   %ebp
	NET_DBG("pkt %p skip %zu", pkt, skip);

	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
  11000c:	31 d2                	xor    %edx,%edx
{
  11000e:	89 e5                	mov    %esp,%ebp
  110010:	8b 45 08             	mov    0x8(%ebp),%eax
  110013:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
  110016:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  11001d:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
}
  110024:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
  110025:	e9 6f f8 ff ff       	jmp    10f899 <net_pkt_cursor_operate>

0011002a <net_pkt_memset>:

int net_pkt_memset(struct net_pkt *pkt, int byte, size_t amount)
{
  11002a:	55                   	push   %ebp
  11002b:	89 e5                	mov    %esp,%ebp
	NET_DBG("pkt %p byte %d amount %zu", pkt, byte, amount);

	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
  11002d:	6a 01                	push   $0x1
  11002f:	6a 00                	push   $0x0
  110031:	8b 4d 10             	mov    0x10(%ebp),%ecx
  110034:	8d 55 0c             	lea    0xc(%ebp),%edx
  110037:	8b 45 08             	mov    0x8(%ebp),%eax
  11003a:	e8 5a f8 ff ff       	call   10f899 <net_pkt_cursor_operate>
  11003f:	5a                   	pop    %edx
  110040:	59                   	pop    %ecx
}
  110041:	c9                   	leave  
  110042:	c3                   	ret    

00110043 <net_pkt_read>:

int net_pkt_read(struct net_pkt *pkt, void *data, size_t length)
{
  110043:	55                   	push   %ebp
  110044:	89 e5                	mov    %esp,%ebp
  110046:	8b 45 08             	mov    0x8(%ebp),%eax
  110049:	8b 55 0c             	mov    0xc(%ebp),%edx
	NET_DBG("pkt %p data %p length %zu", pkt, data, length);

	return net_pkt_cursor_operate(pkt, data, length, true, false);
  11004c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11004f:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  110056:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
  11005d:	5d                   	pop    %ebp
	return net_pkt_cursor_operate(pkt, data, length, true, false);
  11005e:	e9 36 f8 ff ff       	jmp    10f899 <net_pkt_cursor_operate>

00110063 <net_pkt_read_be32>:

	return ret;
}

int net_pkt_read_be32(struct net_pkt *pkt, uint32_t *data)
{
  110063:	55                   	push   %ebp
  110064:	89 e5                	mov    %esp,%ebp
  110066:	50                   	push   %eax
	uint8_t d32[4];
	int ret;

	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
  110067:	6a 04                	push   $0x4
  110069:	8d 45 fc             	lea    -0x4(%ebp),%eax
  11006c:	50                   	push   %eax
  11006d:	ff 75 08             	pushl  0x8(%ebp)
  110070:	e8 ce ff ff ff       	call   110043 <net_pkt_read>
  110075:	8b 55 fc             	mov    -0x4(%ebp),%edx

	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
  110078:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	ret = net_pkt_read(pkt, d32, sizeof(uint32_t));
  11007b:	83 c4 0c             	add    $0xc,%esp
	*data = d32[0] << 24 | d32[1] << 16 | d32[2] << 8 | d32[3];
  11007e:	0f ca                	bswap  %edx
  110080:	89 11                	mov    %edx,(%ecx)

	return ret;
}
  110082:	c9                   	leave  
  110083:	c3                   	ret    

00110084 <net_pkt_copy>:
}

int net_pkt_copy(struct net_pkt *pkt_dst,
		 struct net_pkt *pkt_src,
		 size_t length)
{
  110084:	55                   	push   %ebp
  110085:	89 e5                	mov    %esp,%ebp
  110087:	57                   	push   %edi
  110088:	56                   	push   %esi
  110089:	53                   	push   %ebx
  11008a:	83 ec 0c             	sub    $0xc,%esp
  11008d:	8b 75 08             	mov    0x8(%ebp),%esi
  110090:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_pkt_cursor *c_dst = &pkt_dst->cursor;
	struct net_pkt_cursor *c_src = &pkt_src->cursor;

	while (c_dst->buf && c_src->buf && length) {
  110093:	83 7e 14 00          	cmpl   $0x0,0x14(%esi)
  110097:	0f 84 c4 00 00 00    	je     110161 <net_pkt_copy+0xdd>
  11009d:	83 7f 14 00          	cmpl   $0x0,0x14(%edi)
  1100a1:	0f 84 ba 00 00 00    	je     110161 <net_pkt_copy+0xdd>
  1100a7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1100ab:	0f 84 ac 00 00 00    	je     11015d <net_pkt_copy+0xd9>
		size_t s_len, d_len, len;

		pkt_cursor_advance(pkt_dst, true);
  1100b1:	ba 01 00 00 00       	mov    $0x1,%edx
  1100b6:	89 f0                	mov    %esi,%eax
  1100b8:	e8 3d f7 ff ff       	call   10f7fa <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
  1100bd:	31 d2                	xor    %edx,%edx
  1100bf:	89 f8                	mov    %edi,%eax
  1100c1:	e8 34 f7 ff ff       	call   10f7fa <pkt_cursor_advance>

		if (!c_dst->buf || !c_src->buf) {
  1100c6:	8b 5e 14             	mov    0x14(%esi),%ebx
  1100c9:	85 db                	test   %ebx,%ebx
  1100cb:	0f 84 98 00 00 00    	je     110169 <net_pkt_copy+0xe5>
  1100d1:	8b 47 14             	mov    0x14(%edi),%eax
  1100d4:	85 c0                	test   %eax,%eax
  1100d6:	0f 84 8d 00 00 00    	je     110169 <net_pkt_copy+0xe5>
			break;
		}

		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
  1100dc:	8b 56 18             	mov    0x18(%esi),%edx
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
  1100df:	8b 4f 18             	mov    0x18(%edi),%ecx
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
  1100e2:	89 55 f0             	mov    %edx,-0x10(%ebp)
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
  1100e5:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  1100e9:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1100ec:	89 ca                	mov    %ecx,%edx
  1100ee:	2b 50 08             	sub    0x8(%eax),%edx
  1100f1:	89 55 e8             	mov    %edx,-0x18(%ebp)
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
  1100f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1100f7:	2b 53 08             	sub    0x8(%ebx),%edx
  1100fa:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  1100fe:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  110101:	29 d0                	sub    %edx,%eax
  110103:	2b 5d e8             	sub    -0x18(%ebp),%ebx
  110106:	39 c3                	cmp    %eax,%ebx
  110108:	76 02                	jbe    11010c <net_pkt_copy+0x88>
  11010a:	89 c3                	mov    %eax,%ebx
		if (length < s_len && length < d_len) {
  11010c:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  11010f:	77 06                	ja     110117 <net_pkt_copy+0x93>
			} else {
				len = s_len;
			}
		}

		if (!len) {
  110111:	85 db                	test   %ebx,%ebx
  110113:	75 05                	jne    11011a <net_pkt_copy+0x96>
  110115:	eb 52                	jmp    110169 <net_pkt_copy+0xe5>
  110117:	8b 5d 10             	mov    0x10(%ebp),%ebx
			break;
		}

		memcpy(c_dst->pos, c_src->pos, len);
  11011a:	53                   	push   %ebx
  11011b:	51                   	push   %ecx
  11011c:	ff 75 f0             	pushl  -0x10(%ebp)
  11011f:	e8 c8 bc ff ff       	call   10bdec <memcpy>
  110124:	83 c4 0c             	add    $0xc,%esp

		if (!net_pkt_is_being_overwritten(pkt_dst)) {
  110127:	f6 46 3d 01          	testb  $0x1,0x3d(%esi)
  11012b:	75 0f                	jne    11013c <net_pkt_copy+0xb8>
			net_buf_add(c_dst->buf, len);
  11012d:	8b 46 14             	mov    0x14(%esi),%eax
  110130:	53                   	push   %ebx
  110131:	83 c0 08             	add    $0x8,%eax
  110134:	50                   	push   %eax
  110135:	e8 dd c0 ff ff       	call   10c217 <net_buf_simple_add>
  11013a:	58                   	pop    %eax
  11013b:	5a                   	pop    %edx
		}

		pkt_cursor_update(pkt_dst, len, true);
  11013c:	b9 01 00 00 00       	mov    $0x1,%ecx
  110141:	89 da                	mov    %ebx,%edx
  110143:	89 f0                	mov    %esi,%eax
  110145:	e8 e4 f6 ff ff       	call   10f82e <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
  11014a:	31 c9                	xor    %ecx,%ecx
  11014c:	89 da                	mov    %ebx,%edx
  11014e:	89 f8                	mov    %edi,%eax
  110150:	e8 d9 f6 ff ff       	call   10f82e <pkt_cursor_update>

		length -= len;
  110155:	29 5d 10             	sub    %ebx,0x10(%ebp)
  110158:	e9 36 ff ff ff       	jmp    110093 <net_pkt_copy+0xf>
	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
	}

	return 0;
  11015d:	31 c0                	xor    %eax,%eax
  11015f:	eb 0d                	jmp    11016e <net_pkt_copy+0xea>
  110161:	31 c0                	xor    %eax,%eax
	if (length) {
  110163:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  110167:	74 05                	je     11016e <net_pkt_copy+0xea>
		return -ENOBUFS;
  110169:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
}
  11016e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110171:	5b                   	pop    %ebx
  110172:	5e                   	pop    %esi
  110173:	5f                   	pop    %edi
  110174:	5d                   	pop    %ebp
  110175:	c3                   	ret    

00110176 <net_pkt_remaining_data>:

	return clone_pkt;
}

size_t net_pkt_remaining_data(struct net_pkt *pkt)
{
  110176:	55                   	push   %ebp
	struct net_buf *buf;
	size_t data_length;

	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
  110177:	31 c0                	xor    %eax,%eax
{
  110179:	89 e5                	mov    %esp,%ebp
  11017b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
  11017e:	85 c9                	test   %ecx,%ecx
  110180:	74 25                	je     1101a7 <net_pkt_remaining_data+0x31>
  110182:	8b 51 14             	mov    0x14(%ecx),%edx
  110185:	85 d2                	test   %edx,%edx
  110187:	74 1e                	je     1101a7 <net_pkt_remaining_data+0x31>
  110189:	8b 49 18             	mov    0x18(%ecx),%ecx
  11018c:	85 c9                	test   %ecx,%ecx
  11018e:	74 17                	je     1101a7 <net_pkt_remaining_data+0x31>
	}

	buf = pkt->cursor.buf;
	data_length = buf->len - (pkt->cursor.pos - buf->data);
  110190:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  110194:	2b 4a 08             	sub    0x8(%edx),%ecx
  110197:	29 c8                	sub    %ecx,%eax

	buf = buf->frags;
	while (buf) {
		data_length += buf->len;
		buf = buf->frags;
  110199:	8b 12                	mov    (%edx),%edx
	while (buf) {
  11019b:	85 d2                	test   %edx,%edx
  11019d:	74 08                	je     1101a7 <net_pkt_remaining_data+0x31>
		data_length += buf->len;
  11019f:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
  1101a3:	01 c8                	add    %ecx,%eax
  1101a5:	eb f2                	jmp    110199 <net_pkt_remaining_data+0x23>
	}

	return data_length;
}
  1101a7:	5d                   	pop    %ebp
  1101a8:	c3                   	ret    

001101a9 <net_pkt_update_length>:

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
  1101a9:	55                   	push   %ebp
  1101aa:	89 e5                	mov    %esp,%ebp
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
  1101ac:	8b 55 08             	mov    0x8(%ebp),%edx
{
  1101af:	8b 45 0c             	mov    0xc(%ebp),%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
  1101b2:	8b 52 10             	mov    0x10(%edx),%edx
  1101b5:	85 d2                	test   %edx,%edx
  1101b7:	74 16                	je     1101cf <net_pkt_update_length+0x26>
		if (buf->len < length) {
  1101b9:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
  1101bd:	39 c1                	cmp    %eax,%ecx
  1101bf:	73 04                	jae    1101c5 <net_pkt_update_length+0x1c>
			length -= buf->len;
  1101c1:	29 c8                	sub    %ecx,%eax
  1101c3:	eb 06                	jmp    1101cb <net_pkt_update_length+0x22>
		} else {
			buf->len = length;
  1101c5:	66 89 42 0c          	mov    %ax,0xc(%edx)
			length = 0;
  1101c9:	31 c0                	xor    %eax,%eax
	for (buf = pkt->buffer; buf; buf = buf->frags) {
  1101cb:	8b 12                	mov    (%edx),%edx
  1101cd:	eb e6                	jmp    1101b5 <net_pkt_update_length+0xc>
		}
	}

	return !length ? 0 : -EINVAL;
  1101cf:	83 f8 01             	cmp    $0x1,%eax
}
  1101d2:	5d                   	pop    %ebp
	return !length ? 0 : -EINVAL;
  1101d3:	19 c0                	sbb    %eax,%eax
  1101d5:	f7 d0                	not    %eax
  1101d7:	83 e0 ea             	and    $0xffffffea,%eax
}
  1101da:	c3                   	ret    

001101db <net_pkt_pull>:

int net_pkt_pull(struct net_pkt *pkt, size_t length)
{
  1101db:	55                   	push   %ebp
  1101dc:	89 e5                	mov    %esp,%ebp
  1101de:	57                   	push   %edi
  1101df:	56                   	push   %esi
  1101e0:	53                   	push   %ebx
  1101e1:	53                   	push   %ebx
  1101e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1101e5:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (length) {
  1101e8:	85 f6                	test   %esi,%esi
  1101ea:	74 6f                	je     11025b <net_pkt_pull+0x80>
		size_t left, rem;

		pkt_cursor_advance(pkt, false);
  1101ec:	31 d2                	xor    %edx,%edx
  1101ee:	89 d8                	mov    %ebx,%eax
  1101f0:	e8 05 f6 ff ff       	call   10f7fa <pkt_cursor_advance>

		if (!c_op->buf) {
  1101f5:	8b 43 14             	mov    0x14(%ebx),%eax
  1101f8:	85 c0                	test   %eax,%eax
  1101fa:	74 5f                	je     11025b <net_pkt_pull+0x80>
			break;
		}

		left = c_op->buf->len - (c_op->pos - c_op->buf->data);
  1101fc:	8b 4b 18             	mov    0x18(%ebx),%ecx
  1101ff:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  110203:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  110206:	2b 48 08             	sub    0x8(%eax),%ecx
  110209:	89 fa                	mov    %edi,%edx
		if (!left) {
  11020b:	29 cf                	sub    %ecx,%edi
  11020d:	89 f9                	mov    %edi,%ecx
  11020f:	74 4a                	je     11025b <net_pkt_pull+0x80>
			break;
		}

		rem = left;
		if (rem > length) {
  110211:	39 f7                	cmp    %esi,%edi
  110213:	76 02                	jbe    110217 <net_pkt_pull+0x3c>
  110215:	89 f7                	mov    %esi,%edi
			rem = length;
		}

		c_op->buf->len -= rem;
  110217:	29 fa                	sub    %edi,%edx
  110219:	66 89 50 0c          	mov    %dx,0xc(%eax)
		left -= rem;
		if (left) {
  11021d:	89 c8                	mov    %ecx,%eax
  11021f:	29 f8                	sub    %edi,%eax
  110221:	74 14                	je     110237 <net_pkt_pull+0x5c>
			memmove(c_op->pos, c_op->pos+rem, left);
  110223:	50                   	push   %eax
  110224:	8b 45 f0             	mov    -0x10(%ebp),%eax
  110227:	01 f8                	add    %edi,%eax
  110229:	50                   	push   %eax
  11022a:	ff 75 f0             	pushl  -0x10(%ebp)
  11022d:	e8 7f bb ff ff       	call   10bdb1 <memmove>
  110232:	83 c4 0c             	add    $0xc,%esp
  110235:	eb 20                	jmp    110257 <net_pkt_pull+0x7c>
		} else {
			struct net_buf *buf = pkt->buffer;
  110237:	8b 43 10             	mov    0x10(%ebx),%eax

			if (buf) {
  11023a:	85 c0                	test   %eax,%eax
  11023c:	74 12                	je     110250 <net_pkt_pull+0x75>
				pkt->buffer = buf->frags;
  11023e:	8b 10                	mov    (%eax),%edx
  110240:	89 53 10             	mov    %edx,0x10(%ebx)
				buf->frags = NULL;
  110243:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				net_buf_unref(buf);
  110249:	50                   	push   %eax
  11024a:	e8 ac be ff ff       	call   10c0fb <net_buf_unref>
  11024f:	59                   	pop    %ecx
			}

			net_pkt_cursor_init(pkt);
  110250:	53                   	push   %ebx
  110251:	e8 94 f9 ff ff       	call   10fbea <net_pkt_cursor_init>
  110256:	5a                   	pop    %edx
		}

		length -= rem;
  110257:	29 fe                	sub    %edi,%esi
  110259:	eb 8d                	jmp    1101e8 <net_pkt_pull+0xd>
	}

	net_pkt_cursor_init(pkt);
  11025b:	53                   	push   %ebx
  11025c:	e8 89 f9 ff ff       	call   10fbea <net_pkt_cursor_init>

	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
  110261:	83 fe 01             	cmp    $0x1,%esi
	net_pkt_cursor_init(pkt);
  110264:	58                   	pop    %eax
		return -ENOBUFS;
  110265:	19 c0                	sbb    %eax,%eax
	}

	return 0;
}
  110267:	8d 65 f4             	lea    -0xc(%ebp),%esp
		return -ENOBUFS;
  11026a:	f7 d0                	not    %eax
}
  11026c:	5b                   	pop    %ebx
		return -ENOBUFS;
  11026d:	83 e0 c9             	and    $0xffffffc9,%eax
}
  110270:	5e                   	pop    %esi
  110271:	5f                   	pop    %edi
  110272:	5d                   	pop    %ebp
  110273:	c3                   	ret    

00110274 <net_pkt_get_current_offset>:

uint16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
  110274:	55                   	push   %ebp
	struct net_buf *buf = pkt->buffer;
	uint16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
		return 0;
  110275:	31 c0                	xor    %eax,%eax
{
  110277:	89 e5                	mov    %esp,%ebp
  110279:	53                   	push   %ebx
  11027a:	8b 55 08             	mov    0x8(%ebp),%edx
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
  11027d:	8b 5a 14             	mov    0x14(%edx),%ebx
  110280:	85 db                	test   %ebx,%ebx
  110282:	74 1d                	je     1102a1 <net_pkt_get_current_offset+0x2d>
  110284:	8b 4a 18             	mov    0x18(%edx),%ecx
  110287:	85 c9                	test   %ecx,%ecx
  110289:	74 16                	je     1102a1 <net_pkt_get_current_offset+0x2d>
	struct net_buf *buf = pkt->buffer;
  11028b:	8b 42 10             	mov    0x10(%edx),%eax
	}

	offset = 0U;
  11028e:	31 d2                	xor    %edx,%edx

	while (buf != pkt->cursor.buf) {
  110290:	39 c3                	cmp    %eax,%ebx
  110292:	74 07                	je     11029b <net_pkt_get_current_offset+0x27>
		offset += buf->len;
  110294:	03 50 0c             	add    0xc(%eax),%edx
		buf = buf->frags;
  110297:	8b 00                	mov    (%eax),%eax
  110299:	eb f5                	jmp    110290 <net_pkt_get_current_offset+0x1c>
	}

	offset += pkt->cursor.pos - buf->data;
  11029b:	2b 4b 08             	sub    0x8(%ebx),%ecx
  11029e:	8d 04 0a             	lea    (%edx,%ecx,1),%eax

	return offset;
}
  1102a1:	5b                   	pop    %ebx
  1102a2:	5d                   	pop    %ebp
  1102a3:	c3                   	ret    

001102a4 <net_pkt_clone>:
{
  1102a4:	55                   	push   %ebp
  1102a5:	89 e5                	mov    %esp,%ebp
  1102a7:	57                   	push   %edi
  1102a8:	56                   	push   %esi
  1102a9:	53                   	push   %ebx
  1102aa:	83 ec 08             	sub    $0x8,%esp
  1102ad:	8b 75 08             	mov    0x8(%ebp),%esi
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
  1102b0:	56                   	push   %esi
  1102b1:	e8 be ff ff ff       	call   110274 <net_pkt_get_current_offset>
  1102b6:	0f b7 c0             	movzwl %ax,%eax
  1102b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return net_buf_frags_len(pkt->frags);
  1102bc:	8b 46 10             	mov    0x10(%esi),%eax
  1102bf:	5a                   	pop    %edx
  1102c0:	e8 d7 f4 ff ff       	call   10f79c <net_buf_frags_len>
	clone_pkt = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
  1102c5:	ff 75 10             	pushl  0x10(%ebp)
  1102c8:	ff 75 0c             	pushl  0xc(%ebp)
  1102cb:	6a 00                	push   $0x0
  1102cd:	6a 00                	push   $0x0
  1102cf:	50                   	push   %eax
  1102d0:	ff 76 20             	pushl  0x20(%esi)
  1102d3:	e8 fe fc ff ff       	call   10ffd6 <net_pkt_alloc_with_buffer>
  1102d8:	83 c4 18             	add    $0x18,%esp
  1102db:	89 c3                	mov    %eax,%ebx
	if (!clone_pkt) {
  1102dd:	85 c0                	test   %eax,%eax
  1102df:	0f 84 c8 00 00 00    	je     1103ad <net_pkt_clone+0x109>
	backup->pos = pkt->cursor.pos;
  1102e5:	8b 46 18             	mov    0x18(%esi),%eax
	backup->buf = pkt->cursor.buf;
  1102e8:	8b 7e 14             	mov    0x14(%esi),%edi
	net_pkt_cursor_init(pkt);
  1102eb:	56                   	push   %esi
	backup->pos = pkt->cursor.pos;
  1102ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1102ef:	e8 f6 f8 ff ff       	call   10fbea <net_pkt_cursor_init>
  1102f4:	58                   	pop    %eax
	return net_buf_frags_len(pkt->frags);
  1102f5:	8b 46 10             	mov    0x10(%esi),%eax
  1102f8:	e8 9f f4 ff ff       	call   10f79c <net_buf_frags_len>
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
  1102fd:	50                   	push   %eax
  1102fe:	56                   	push   %esi
  1102ff:	53                   	push   %ebx
  110300:	e8 7f fd ff ff       	call   110084 <net_pkt_copy>
  110305:	83 c4 0c             	add    $0xc,%esp
  110308:	85 c0                	test   %eax,%eax
  11030a:	74 17                	je     110323 <net_pkt_clone+0x7f>
		net_pkt_unref(clone_pkt);
  11030c:	53                   	push   %ebx
  11030d:	e8 6a f7 ff ff       	call   10fa7c <net_pkt_unref>
	pkt->cursor.pos = backup->pos;
  110312:	8b 45 f0             	mov    -0x10(%ebp),%eax
  110315:	5b                   	pop    %ebx
	pkt->cursor.buf = backup->buf;
  110316:	89 7e 14             	mov    %edi,0x14(%esi)
	pkt->cursor.pos = backup->pos;
  110319:	89 46 18             	mov    %eax,0x18(%esi)
		return NULL;
  11031c:	31 db                	xor    %ebx,%ebx
  11031e:	e9 8a 00 00 00       	jmp    1103ad <net_pkt_clone+0x109>
	if (clone_pkt->buffer) {
  110323:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  110327:	74 24                	je     11034d <net_pkt_clone+0xa9>
		memcpy(&clone_pkt->lladdr_src, &pkt->lladdr_src,
  110329:	6a 08                	push   $0x8
  11032b:	8d 46 28             	lea    0x28(%esi),%eax
  11032e:	50                   	push   %eax
  11032f:	8d 43 28             	lea    0x28(%ebx),%eax
  110332:	50                   	push   %eax
  110333:	e8 b4 ba ff ff       	call   10bdec <memcpy>
  110338:	83 c4 0c             	add    $0xc,%esp
		memcpy(&clone_pkt->lladdr_dst, &pkt->lladdr_dst,
  11033b:	8d 46 30             	lea    0x30(%esi),%eax
  11033e:	6a 08                	push   $0x8
  110340:	50                   	push   %eax
  110341:	8d 43 30             	lea    0x30(%ebx),%eax
  110344:	50                   	push   %eax
  110345:	e8 a2 ba ff ff       	call   10bdec <memcpy>
  11034a:	83 c4 0c             	add    $0xc,%esp
	pkt->family = family;
  11034d:	8a 56 3f             	mov    0x3f(%esi),%dl
  110350:	8a 43 3f             	mov    0x3f(%ebx),%al
  110353:	83 e2 0e             	and    $0xe,%edx
  110356:	83 e0 f1             	and    $0xfffffff1,%eax
  110359:	09 d0                	or     %edx,%eax
  11035b:	88 43 3f             	mov    %al,0x3f(%ebx)
	net_pkt_set_context(clone_pkt, net_pkt_context(pkt));
  11035e:	8b 46 1c             	mov    0x1c(%esi),%eax
	pkt->context = ctx;
  110361:	89 43 1c             	mov    %eax,0x1c(%ebx)
	net_pkt_set_ip_hdr_len(clone_pkt, net_pkt_ip_hdr_len(pkt));
  110364:	8a 46 3c             	mov    0x3c(%esi),%al
	pkt->ip_hdr_len = len;
  110367:	88 43 3c             	mov    %al,0x3c(%ebx)
	net_pkt_set_priority(clone_pkt, net_pkt_priority(pkt));
  11036a:	8a 46 44             	mov    0x44(%esi),%al
	pkt->priority = priority;
  11036d:	88 43 44             	mov    %al,0x44(%ebx)
	return pkt->family;
  110370:	8a 46 3f             	mov    0x3f(%esi),%al
  110373:	d0 e8                	shr    %al
  110375:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
  110378:	fe c8                	dec    %al
  11037a:	75 0c                	jne    110388 <net_pkt_clone+0xe4>
		net_pkt_set_ipv4_ttl(clone_pkt, net_pkt_ipv4_ttl(pkt));
  11037c:	8a 46 42             	mov    0x42(%esi),%al
	pkt->ipv4_ttl = ttl;
  11037f:	88 43 42             	mov    %al,0x42(%ebx)
					  net_pkt_ipv4_opts_len(pkt));
  110382:	8a 46 43             	mov    0x43(%esi),%al
	pkt->ipv4_opts_len = opts_len;
  110385:	88 43 43             	mov    %al,0x43(%ebx)
	net_pkt_cursor_init(clone_pkt);
  110388:	53                   	push   %ebx
  110389:	e8 5c f8 ff ff       	call   10fbea <net_pkt_cursor_init>
	if (cursor_offset) {
  11038e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
	net_pkt_cursor_init(clone_pkt);
  110392:	59                   	pop    %ecx
	if (cursor_offset) {
  110393:	74 0f                	je     1103a4 <net_pkt_clone+0x100>
	pkt->overwrite = overwrite;
  110395:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
		net_pkt_skip(clone_pkt, cursor_offset);
  110399:	ff 75 ec             	pushl  -0x14(%ebp)
  11039c:	53                   	push   %ebx
  11039d:	e8 69 fc ff ff       	call   11000b <net_pkt_skip>
  1103a2:	58                   	pop    %eax
  1103a3:	5a                   	pop    %edx
	pkt->cursor.pos = backup->pos;
  1103a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
	pkt->cursor.buf = backup->buf;
  1103a7:	89 7e 14             	mov    %edi,0x14(%esi)
	pkt->cursor.pos = backup->pos;
  1103aa:	89 46 18             	mov    %eax,0x18(%esi)
}
  1103ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1103b0:	89 d8                	mov    %ebx,%eax
  1103b2:	5b                   	pop    %ebx
  1103b3:	5e                   	pop    %esi
  1103b4:	5f                   	pop    %edi
  1103b5:	5d                   	pop    %ebp
  1103b6:	c3                   	ret    

001103b7 <net_pkt_is_contiguous>:

bool net_pkt_is_contiguous(struct net_pkt *pkt, size_t size)
{
  1103b7:	55                   	push   %ebp
  1103b8:	89 e5                	mov    %esp,%ebp
  1103ba:	53                   	push   %ebx
		if (len >= size) {
			return true;
		}
	}

	return false;
  1103bb:	31 db                	xor    %ebx,%ebx
{
  1103bd:	8b 45 08             	mov    0x8(%ebp),%eax
	return pkt->overwrite;
  1103c0:	8a 50 3d             	mov    0x3d(%eax),%dl
  1103c3:	83 e2 01             	and    $0x1,%edx
	pkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));
  1103c6:	83 f2 01             	xor    $0x1,%edx
  1103c9:	0f b6 d2             	movzbl %dl,%edx
  1103cc:	e8 29 f4 ff ff       	call   10f7fa <pkt_cursor_advance>
	if (pkt->cursor.buf && pkt->cursor.pos) {
  1103d1:	8b 48 14             	mov    0x14(%eax),%ecx
  1103d4:	85 c9                	test   %ecx,%ecx
  1103d6:	74 22                	je     1103fa <net_pkt_is_contiguous+0x43>
  1103d8:	8b 50 18             	mov    0x18(%eax),%edx
  1103db:	85 d2                	test   %edx,%edx
  1103dd:	74 1b                	je     1103fa <net_pkt_is_contiguous+0x43>
			pkt->cursor.buf->len : pkt->cursor.buf->size;
  1103df:	f6 40 3d 01          	testb  $0x1,0x3d(%eax)
  1103e3:	74 06                	je     1103eb <net_pkt_is_contiguous+0x34>
  1103e5:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  1103e9:	eb 04                	jmp    1103ef <net_pkt_is_contiguous+0x38>
  1103eb:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
  1103ef:	2b 51 08             	sub    0x8(%ecx),%edx
  1103f2:	29 d0                	sub    %edx,%eax
		if (len >= size) {
  1103f4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1103f7:	0f 93 c3             	setae  %bl
}
  1103fa:	88 d8                	mov    %bl,%al
  1103fc:	5b                   	pop    %ebx
  1103fd:	5d                   	pop    %ebp
  1103fe:	c3                   	ret    

001103ff <net_pkt_write>:
{
  1103ff:	55                   	push   %ebp
  110400:	89 e5                	mov    %esp,%ebp
  110402:	53                   	push   %ebx
  110403:	83 ec 08             	sub    $0x8,%esp
  110406:	8b 5d 08             	mov    0x8(%ebp),%ebx
  110409:	8b 55 0c             	mov    0xc(%ebp),%edx
  11040c:	8b 4d 10             	mov    0x10(%ebp),%ecx
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
  11040f:	3b 53 18             	cmp    0x18(%ebx),%edx
  110412:	75 28                	jne    11043c <net_pkt_write+0x3d>
  110414:	51                   	push   %ecx
  110415:	89 55 f4             	mov    %edx,-0xc(%ebp)
  110418:	53                   	push   %ebx
  110419:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  11041c:	e8 96 ff ff ff       	call   1103b7 <net_pkt_is_contiguous>
  110421:	5a                   	pop    %edx
  110422:	59                   	pop    %ecx
  110423:	84 c0                	test   %al,%al
  110425:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  110428:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11042b:	74 0f                	je     11043c <net_pkt_write+0x3d>
		return net_pkt_skip(pkt, length);
  11042d:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  110430:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		return net_pkt_skip(pkt, length);
  110433:	89 4d 0c             	mov    %ecx,0xc(%ebp)
}
  110436:	c9                   	leave  
		return net_pkt_skip(pkt, length);
  110437:	e9 cf fb ff ff       	jmp    11000b <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
  11043c:	89 d8                	mov    %ebx,%eax
}
  11043e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
  110441:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
  110448:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
}
  11044f:	c9                   	leave  
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
  110450:	e9 44 f4 ff ff       	jmp    10f899 <net_pkt_cursor_operate>

00110455 <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
  110455:	55                   	push   %ebp
  110456:	89 e5                	mov    %esp,%ebp
  110458:	57                   	push   %edi
  110459:	56                   	push   %esi
  11045a:	53                   	push   %ebx
  11045b:	83 ec 08             	sub    $0x8,%esp
  11045e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  110461:	8b 5d 08             	mov    0x8(%ebp),%ebx
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
  110464:	ff 77 04             	pushl  0x4(%edi)
  110467:	53                   	push   %ebx
  110468:	e8 4a ff ff ff       	call   1103b7 <net_pkt_is_contiguous>
  11046d:	5e                   	pop    %esi
  11046e:	84 c0                	test   %al,%al
  110470:	5a                   	pop    %edx
  110471:	74 07                	je     11047a <net_pkt_get_data+0x25>
			access->data = pkt->cursor.pos;
  110473:	8b 43 18             	mov    0x18(%ebx),%eax
  110476:	89 07                	mov    %eax,(%edi)
  110478:	eb 62                	jmp    1104dc <net_pkt_get_data+0x87>
		} else if (net_pkt_is_being_overwritten(pkt)) {
  11047a:	f6 43 3d 01          	testb  $0x1,0x3d(%ebx)
  11047e:	74 5c                	je     1104dc <net_pkt_get_data+0x87>
  110480:	8b 37                	mov    (%edi),%esi
			struct net_pkt_cursor backup;

			if (!access->data) {
  110482:	85 f6                	test   %esi,%esi
  110484:	75 2b                	jne    1104b1 <net_pkt_get_data+0x5c>
				NET_ERR("Uncontiguous data"
  110486:	f6 05 fc 5b 14 00 07 	testb  $0x7,0x145bfc
  11048d:	74 4f                	je     1104de <net_pkt_get_data+0x89>
  11048f:	b8 78 31 12 00       	mov    $0x123178,%eax
  110494:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  110499:	c1 e8 03             	shr    $0x3,%eax
  11049c:	c1 e0 06             	shl    $0x6,%eax
  11049f:	83 c8 01             	or     $0x1,%eax
  1104a2:	50                   	push   %eax
  1104a3:	68 f3 5e 12 00       	push   $0x125ef3
  1104a8:	e8 a0 30 ff ff       	call   10354d <log_0>
  1104ad:	58                   	pop    %eax
  1104ae:	5a                   	pop    %edx
  1104af:	eb 2d                	jmp    1104de <net_pkt_get_data+0x89>
	backup->buf = pkt->cursor.buf;
  1104b1:	8b 4b 14             	mov    0x14(%ebx),%ecx
	backup->pos = pkt->cursor.pos;
  1104b4:	8b 53 18             	mov    0x18(%ebx),%edx
				return NULL;
			}

			net_pkt_cursor_backup(pkt, &backup);

			if (net_pkt_read(pkt, access->data, access->size)) {
  1104b7:	ff 77 04             	pushl  0x4(%edi)
	backup->buf = pkt->cursor.buf;
  1104ba:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	backup->pos = pkt->cursor.pos;
  1104bd:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1104c0:	56                   	push   %esi
				net_pkt_cursor_restore(pkt, &backup);
				return NULL;
  1104c1:	31 f6                	xor    %esi,%esi
			if (net_pkt_read(pkt, access->data, access->size)) {
  1104c3:	53                   	push   %ebx
  1104c4:	e8 7a fb ff ff       	call   110043 <net_pkt_read>
  1104c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1104cc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1104cf:	83 c4 0c             	add    $0xc,%esp
	pkt->cursor.buf = backup->buf;
  1104d2:	89 4b 14             	mov    %ecx,0x14(%ebx)
  1104d5:	85 c0                	test   %eax,%eax
	pkt->cursor.pos = backup->pos;
  1104d7:	89 53 18             	mov    %edx,0x18(%ebx)
  1104da:	75 02                	jne    1104de <net_pkt_get_data+0x89>
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
  1104dc:	8b 37                	mov    (%edi),%esi
	}

	return NULL;
}
  1104de:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1104e1:	89 f0                	mov    %esi,%eax
  1104e3:	5b                   	pop    %ebx
  1104e4:	5e                   	pop    %esi
  1104e5:	5f                   	pop    %edi
  1104e6:	5d                   	pop    %ebp
  1104e7:	c3                   	ret    

001104e8 <net_pkt_set_data>:

int net_pkt_set_data(struct net_pkt *pkt,
		     struct net_pkt_data_access *access)
{
  1104e8:	55                   	push   %ebp
  1104e9:	89 e5                	mov    %esp,%ebp
  1104eb:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
  1104ee:	ff 70 04             	pushl  0x4(%eax)
  1104f1:	ff 30                	pushl  (%eax)
  1104f3:	ff 75 08             	pushl  0x8(%ebp)
  1104f6:	e8 04 ff ff ff       	call   1103ff <net_pkt_write>
  1104fb:	83 c4 0c             	add    $0xc,%esp
}
  1104fe:	c9                   	leave  
  1104ff:	c3                   	ret    

00110500 <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
  110500:	c3                   	ret    

00110501 <k_work_submit_to_queue>:
{
  110501:	55                   	push   %ebp
  110502:	89 c1                	mov    %eax,%ecx
  110504:	89 e5                	mov    %esp,%ebp
  110506:	56                   	push   %esi
  110507:	53                   	push   %ebx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  110508:	8b 42 08             	mov    0x8(%edx),%eax
  11050b:	89 c6                	mov    %eax,%esi
  11050d:	89 c3                	mov    %eax,%ebx
  11050f:	83 ce 01             	or     $0x1,%esi
  110512:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
  110517:	75 f2                	jne    11050b <k_work_submit_to_queue+0xa>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
  110519:	80 e3 01             	and    $0x1,%bl
  11051c:	75 09                	jne    110527 <k_work_submit_to_queue+0x26>
		k_queue_append(&work_q->queue, work);
  11051e:	52                   	push   %edx
  11051f:	51                   	push   %ecx
  110520:	e8 f4 09 01 00       	call   120f19 <k_queue_append>
  110525:	58                   	pop    %eax
  110526:	5a                   	pop    %edx
}
  110527:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11052a:	5b                   	pop    %ebx
  11052b:	5e                   	pop    %esi
  11052c:	5d                   	pop    %ebp
  11052d:	c3                   	ret    

0011052e <net_tc_submit_to_tx_queue>:

static struct net_traffic_class tx_classes[NET_TC_TX_COUNT];
static struct net_traffic_class rx_classes[NET_TC_RX_COUNT];

bool net_tc_submit_to_tx_queue(uint8_t tc, struct net_pkt *pkt)
{
  11052e:	55                   	push   %ebp
  11052f:	89 e5                	mov    %esp,%ebp
  110531:	53                   	push   %ebx
  110532:	8b 55 0c             	mov    0xc(%ebp),%edx
  110535:	8b 4d 08             	mov    0x8(%ebp),%ecx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  110538:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (k_work_pending(net_pkt_work(pkt))) {
  11053b:	80 e3 01             	and    $0x1,%bl
  11053e:	75 17                	jne    110557 <net_tc_submit_to_tx_queue+0x29>
		return false;
	}

	net_pkt_set_tx_stats_tick(pkt, k_cycle_get_32());

	k_work_submit_to_queue(&tx_classes[tc].work_q, net_pkt_work(pkt));
  110540:	0f b6 c1             	movzbl %cl,%eax
  110543:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
  110549:	05 80 ae 12 00       	add    $0x12ae80,%eax
  11054e:	e8 ae ff ff ff       	call   110501 <k_work_submit_to_queue>

	return true;
  110553:	b0 01                	mov    $0x1,%al
  110555:	eb 02                	jmp    110559 <net_tc_submit_to_tx_queue+0x2b>
  110557:	31 c0                	xor    %eax,%eax
}
  110559:	5b                   	pop    %ebx
  11055a:	5d                   	pop    %ebp
  11055b:	c3                   	ret    

0011055c <net_tc_submit_to_rx_queue>:

void net_tc_submit_to_rx_queue(uint8_t tc, struct net_pkt *pkt)
{
  11055c:	55                   	push   %ebp
  11055d:	89 e5                	mov    %esp,%ebp
	net_pkt_set_rx_stats_tick(pkt, k_cycle_get_32());

	k_work_submit_to_queue(&rx_classes[tc].work_q, net_pkt_work(pkt));
  11055f:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  110563:	69 c0 bc 00 00 00    	imul   $0xbc,%eax,%eax
  110569:	8b 55 0c             	mov    0xc(%ebp),%edx
  11056c:	05 c0 ad 12 00       	add    $0x12adc0,%eax
}
  110571:	5d                   	pop    %ebp
	k_work_submit_to_queue(&rx_classes[tc].work_q, net_pkt_work(pkt));
  110572:	e9 8a ff ff ff       	jmp    110501 <k_work_submit_to_queue>

00110577 <net_tx_priority2tc>:

int net_tx_priority2tc(enum net_priority prio)
{
  110577:	55                   	push   %ebp
	if (prio > NET_PRIORITY_NC) {
		/* Use default value suggested in 802.1Q */
		prio = NET_PRIORITY_BE;
  110578:	31 c0                	xor    %eax,%eax
{
  11057a:	89 e5                	mov    %esp,%ebp
  11057c:	8b 55 08             	mov    0x8(%ebp),%edx
	if (prio > NET_PRIORITY_NC) {
  11057f:	80 fa 07             	cmp    $0x7,%dl
  110582:	77 03                	ja     110587 <net_tx_priority2tc+0x10>
  110584:	0f b6 c2             	movzbl %dl,%eax
	}

	return tx_prio2tc_map[prio];
  110587:	0f b6 80 7c 43 12 00 	movzbl 0x12437c(%eax),%eax
}
  11058e:	5d                   	pop    %ebp
  11058f:	c3                   	ret    

00110590 <net_rx_priority2tc>:
  110590:	e9 e2 ff ff ff       	jmp    110577 <net_tx_priority2tc>

00110595 <net_tc_tx_init>:
/* Create workqueue for each traffic class we are using. All the network
 * traffic goes through these classes. There needs to be at least one traffic
 * class in the system.
 */
void net_tc_tx_init(void)
{
  110595:	55                   	push   %ebp
  110596:	89 e5                	mov    %esp,%ebp
  110598:	53                   	push   %ebx
  110599:	83 ec 08             	sub    $0x8,%esp
			       K_PRIO_COOP(thread_priority));

		if (IS_ENABLED(CONFIG_THREAD_NAME)) {
			char name[MAX_NAME_LEN];

			snprintk(name, sizeof(name), "tx_q[%d]", i);
  11059c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
		k_work_q_start(&tx_classes[i].work_q,
  11059f:	6a f7                	push   $0xfffffff7
  1105a1:	68 b0 04 00 00       	push   $0x4b0
  1105a6:	68 9c 2f 14 00       	push   $0x142f9c
  1105ab:	68 80 ae 12 00       	push   $0x12ae80
  1105b0:	e8 91 18 01 00       	call   121e46 <k_work_q_start>
  1105b5:	83 c4 10             	add    $0x10,%esp
			snprintk(name, sizeof(name), "tx_q[%d]", i);
  1105b8:	6a 00                	push   $0x0
  1105ba:	68 1a 5f 12 00       	push   $0x125f1a
  1105bf:	6a 08                	push   $0x8
  1105c1:	53                   	push   %ebx
  1105c2:	e8 38 0d ff ff       	call   1012ff <snprintk>
  1105c7:	83 c4 10             	add    $0x10,%esp
	return z_impl_k_thread_name_set(thread_id, value);
  1105ca:	53                   	push   %ebx
  1105cb:	68 a4 ae 12 00       	push   $0x12aea4
  1105d0:	e8 58 14 01 00       	call   121a2d <z_impl_k_thread_name_set>
  1105d5:	5a                   	pop    %edx
			k_thread_name_set(&tx_classes[i].work_q.thread, name);
		}
	}
}
  1105d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1105d9:	59                   	pop    %ecx
  1105da:	c9                   	leave  
  1105db:	c3                   	ret    

001105dc <net_tc_rx_init>:

void net_tc_rx_init(void)
{
  1105dc:	55                   	push   %ebp
  1105dd:	89 e5                	mov    %esp,%ebp
  1105df:	53                   	push   %ebx
  1105e0:	83 ec 08             	sub    $0x8,%esp
			       K_PRIO_COOP(thread_priority));

		if (IS_ENABLED(CONFIG_THREAD_NAME)) {
			char name[MAX_NAME_LEN];

			snprintk(name, sizeof(name), "rx_q[%d]", i);
  1105e3:	8d 5d f4             	lea    -0xc(%ebp),%ebx
		k_work_q_start(&rx_classes[i].work_q,
  1105e6:	6a f7                	push   $0xfffffff7
  1105e8:	68 dc 05 00 00       	push   $0x5dc
  1105ed:	68 c0 29 14 00       	push   $0x1429c0
  1105f2:	68 c0 ad 12 00       	push   $0x12adc0
  1105f7:	e8 4a 18 01 00       	call   121e46 <k_work_q_start>
  1105fc:	83 c4 10             	add    $0x10,%esp
			snprintk(name, sizeof(name), "rx_q[%d]", i);
  1105ff:	6a 00                	push   $0x0
  110601:	68 23 5f 12 00       	push   $0x125f23
  110606:	6a 08                	push   $0x8
  110608:	53                   	push   %ebx
  110609:	e8 f1 0c ff ff       	call   1012ff <snprintk>
  11060e:	83 c4 10             	add    $0x10,%esp
  110611:	53                   	push   %ebx
  110612:	68 e4 ad 12 00       	push   $0x12ade4
  110617:	e8 11 14 01 00       	call   121a2d <z_impl_k_thread_name_set>
  11061c:	5a                   	pop    %edx
			k_thread_name_set(&rx_classes[i].work_q.thread, name);
		}
	}
}
  11061d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  110620:	59                   	pop    %ecx
  110621:	c9                   	leave  
  110622:	c3                   	ret    

00110623 <icmpv4_create>:
	struct net_pkt *reply;
	const struct in_addr *src;
};

static int icmpv4_create(struct net_pkt *pkt, uint8_t icmp_type, uint8_t icmp_code)
{
  110623:	55                   	push   %ebp
  110624:	89 e5                	mov    %esp,%ebp
  110626:	57                   	push   %edi
  110627:	56                   	push   %esi
  110628:	89 d7                	mov    %edx,%edi
  11062a:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
  11062b:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
  11062e:	83 ec 0c             	sub    $0xc,%esp
  110631:	89 c3                	mov    %eax,%ebx
  110633:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  110636:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
  11063d:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  11063e:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
  110645:	50                   	push   %eax
  110646:	e8 0a fe ff ff       	call   110455 <net_pkt_get_data>
  11064b:	5a                   	pop    %edx
	if (!icmp_hdr) {
  11064c:	85 c0                	test   %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
  11064e:	59                   	pop    %ecx
	if (!icmp_hdr) {
  11064f:	74 1b                	je     11066c <icmpv4_create+0x49>
		return -ENOBUFS;
	}

	icmp_hdr->type   = icmp_type;
  110651:	89 f9                	mov    %edi,%ecx
	icmp_hdr->code   = icmp_code;
  110653:	8b 55 e8             	mov    -0x18(%ebp),%edx
	icmp_hdr->type   = icmp_type;
  110656:	88 08                	mov    %cl,(%eax)
	icmp_hdr->code   = icmp_code;
  110658:	88 50 01             	mov    %dl,0x1(%eax)
	icmp_hdr->chksum = 0U;
  11065b:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)

	return net_pkt_set_data(pkt, &icmpv4_access);
  110661:	56                   	push   %esi
  110662:	53                   	push   %ebx
  110663:	e8 80 fe ff ff       	call   1104e8 <net_pkt_set_data>
  110668:	5a                   	pop    %edx
  110669:	59                   	pop    %ecx
  11066a:	eb 05                	jmp    110671 <icmpv4_create+0x4e>
		return -ENOBUFS;
  11066c:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
}
  110671:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110674:	5b                   	pop    %ebx
  110675:	5e                   	pop    %esi
  110676:	5f                   	pop    %edi
  110677:	5d                   	pop    %ebp
  110678:	c3                   	ret    

00110679 <icmpv4_handle_echo_request>:
#endif

static enum net_verdict icmpv4_handle_echo_request(struct net_pkt *pkt,
					   struct net_ipv4_hdr *ip_hdr,
					   struct net_icmp_hdr *icmp_hdr)
{
  110679:	55                   	push   %ebp
		net_pkt_unref(reply);
	}

	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
  11067a:	b8 02 00 00 00       	mov    $0x2,%eax
{
  11067f:	89 e5                	mov    %esp,%ebp
  110681:	57                   	push   %edi
  110682:	56                   	push   %esi
  110683:	53                   	push   %ebx
  110684:	51                   	push   %ecx
  110685:	8b 7d 0c             	mov    0xc(%ebp),%edi
  110688:	8b 75 08             	mov    0x8(%ebp),%esi
	if (net_ipv4_is_addr_unspecified(&ip_hdr->src)) {
  11068b:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  11068f:	0f 84 da 00 00 00    	je     11076f <icmpv4_handle_echo_request+0xf6>
	payload_len = net_pkt_get_len(pkt) -
  110695:	8b 56 10             	mov    0x10(%esi),%edx
	size_t bytes = 0;
  110698:	31 c0                	xor    %eax,%eax
	while (buf) {
  11069a:	85 d2                	test   %edx,%edx
  11069c:	74 0a                	je     1106a8 <icmpv4_handle_echo_request+0x2f>
		bytes += buf->len;
  11069e:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
  1106a2:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
  1106a4:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
  1106a6:	eb f2                	jmp    11069a <icmpv4_handle_echo_request+0x21>
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
  1106a8:	0f b6 5e 43          	movzbl 0x43(%esi),%ebx
		      net_pkt_ip_hdr_len(pkt) -
  1106ac:	0f b6 4e 3c          	movzbl 0x3c(%esi),%ecx
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
  1106b0:	01 d9                	add    %ebx,%ecx
  1106b2:	89 da                	mov    %ebx,%edx
  1106b4:	29 c8                	sub    %ecx,%eax
  1106b6:	83 e8 04             	sub    $0x4,%eax
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
  1106b9:	66 83 f8 03          	cmp    $0x3,%ax
  1106bd:	0f 8e a7 00 00 00    	jle    11076a <icmpv4_handle_echo_request+0xf1>
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
  1106c3:	6a 00                	push   $0x0
  1106c5:	6a 64                	push   $0x64
  1106c7:	6a 01                	push   $0x1
					  net_pkt_ipv4_opts_len(pkt) +
  1106c9:	98                   	cwtl   
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
  1106ca:	6a 01                	push   $0x1
					  net_pkt_ipv4_opts_len(pkt) +
  1106cc:	01 c2                	add    %eax,%edx
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
  1106ce:	52                   	push   %edx
					  net_pkt_ipv4_opts_len(pkt) +
  1106cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
  1106d2:	ff 76 20             	pushl  0x20(%esi)
  1106d5:	e8 fc f8 ff ff       	call   10ffd6 <net_pkt_alloc_with_buffer>
  1106da:	83 c4 18             	add    $0x18,%esp
  1106dd:	89 c3                	mov    %eax,%ebx
	if (!reply) {
  1106df:	85 c0                	test   %eax,%eax
  1106e1:	0f 84 83 00 00 00    	je     11076a <icmpv4_handle_echo_request+0xf1>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  1106e7:	8b 57 10             	mov    0x10(%edi),%edx
	if (net_ipv4_is_addr_mcast(&ip_hdr->dst)) {
  1106ea:	8d 47 10             	lea    0x10(%edi),%eax
  1106ed:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  1106f3:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
  1106f9:	75 0b                	jne    110706 <icmpv4_handle_echo_request+0x8d>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
  1106fb:	50                   	push   %eax
  1106fc:	ff 76 20             	pushl  0x20(%esi)
  1106ff:	e8 b2 d0 ff ff       	call   10d7b6 <net_if_ipv4_select_src_addr>
  110704:	59                   	pop    %ecx
  110705:	5a                   	pop    %edx
	if (net_ipv4_create(reply, src, &ip_hdr->src)) {
  110706:	83 c7 0c             	add    $0xc,%edi
  110709:	57                   	push   %edi
  11070a:	50                   	push   %eax
  11070b:	53                   	push   %ebx
  11070c:	e8 6e 04 00 00       	call   110b7f <net_ipv4_create>
  110711:	83 c4 0c             	add    $0xc,%esp
  110714:	85 c0                	test   %eax,%eax
  110716:	75 4b                	jne    110763 <icmpv4_handle_echo_request+0xea>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
  110718:	31 c9                	xor    %ecx,%ecx
  11071a:	31 d2                	xor    %edx,%edx
  11071c:	89 d8                	mov    %ebx,%eax
  11071e:	e8 00 ff ff ff       	call   110623 <icmpv4_create>
  110723:	85 c0                	test   %eax,%eax
  110725:	75 3c                	jne    110763 <icmpv4_handle_echo_request+0xea>
	    net_pkt_copy(reply, pkt, payload_len)) {
  110727:	ff 75 f0             	pushl  -0x10(%ebp)
  11072a:	56                   	push   %esi
  11072b:	53                   	push   %ebx
  11072c:	e8 53 f9 ff ff       	call   110084 <net_pkt_copy>
  110731:	83 c4 0c             	add    $0xc,%esp
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
  110734:	85 c0                	test   %eax,%eax
  110736:	75 2b                	jne    110763 <icmpv4_handle_echo_request+0xea>
	net_pkt_cursor_init(reply);
  110738:	53                   	push   %ebx
  110739:	e8 ac f4 ff ff       	call   10fbea <net_pkt_cursor_init>
	net_ipv4_finalize(reply, IPPROTO_ICMP);
  11073e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  110745:	53                   	push   %ebx
  110746:	e8 bb 04 00 00       	call   110c06 <net_ipv4_finalize>
  11074b:	59                   	pop    %ecx
  11074c:	5f                   	pop    %edi
	if (net_send_data(reply) < 0) {
  11074d:	53                   	push   %ebx
  11074e:	e8 ef c9 ff ff       	call   10d142 <net_send_data>
  110753:	5a                   	pop    %edx
  110754:	85 c0                	test   %eax,%eax
  110756:	78 0b                	js     110763 <icmpv4_handle_echo_request+0xea>
	net_pkt_unref(pkt);
  110758:	56                   	push   %esi
  110759:	e8 1e f3 ff ff       	call   10fa7c <net_pkt_unref>
  11075e:	5a                   	pop    %edx
	return NET_OK;
  11075f:	31 c0                	xor    %eax,%eax
  110761:	eb 0c                	jmp    11076f <icmpv4_handle_echo_request+0xf6>
		net_pkt_unref(reply);
  110763:	53                   	push   %ebx
  110764:	e8 13 f3 ff ff       	call   10fa7c <net_pkt_unref>
  110769:	58                   	pop    %eax
	return NET_DROP;
  11076a:	b8 02 00 00 00       	mov    $0x2,%eax
}
  11076f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110772:	5b                   	pop    %ebx
  110773:	5e                   	pop    %esi
  110774:	5f                   	pop    %edi
  110775:	5d                   	pop    %ebp
  110776:	c3                   	ret    

00110777 <net_icmpv4_finalize>:
{
  110777:	55                   	push   %ebp
  110778:	89 e5                	mov    %esp,%ebp
  11077a:	57                   	push   %edi
  11077b:	56                   	push   %esi
  11077c:	53                   	push   %ebx
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
  11077d:	8d 75 ec             	lea    -0x14(%ebp),%esi
{
  110780:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  110783:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  11078a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  11078d:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
  110794:	56                   	push   %esi
  110795:	53                   	push   %ebx
  110796:	e8 ba fc ff ff       	call   110455 <net_pkt_get_data>
  11079b:	5a                   	pop    %edx
  11079c:	89 c7                	mov    %eax,%edi
  11079e:	59                   	pop    %ecx
  11079f:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!icmp_hdr) {
  1107a4:	85 ff                	test   %edi,%edi
  1107a6:	74 17                	je     1107bf <net_icmpv4_finalize+0x48>
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline uint16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
  1107a8:	6a 01                	push   $0x1
  1107aa:	53                   	push   %ebx
  1107ab:	e8 2d dc ff ff       	call   10e3dd <net_calc_chksum>
  1107b0:	5a                   	pop    %edx
  1107b1:	59                   	pop    %ecx
	icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
  1107b2:	66 89 47 02          	mov    %ax,0x2(%edi)
	return net_pkt_set_data(pkt, &icmpv4_access);
  1107b6:	56                   	push   %esi
  1107b7:	53                   	push   %ebx
  1107b8:	e8 2b fd ff ff       	call   1104e8 <net_pkt_set_data>
  1107bd:	5b                   	pop    %ebx
  1107be:	5e                   	pop    %esi
}
  1107bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1107c2:	5b                   	pop    %ebx
  1107c3:	5e                   	pop    %esi
  1107c4:	5f                   	pop    %edi
  1107c5:	5d                   	pop    %ebp
  1107c6:	c3                   	ret    

001107c7 <net_icmpv4_send_echo_request>:
				 struct in_addr *dst,
				 uint16_t identifier,
				 uint16_t sequence,
				 const void *data,
				 size_t data_size)
{
  1107c7:	55                   	push   %ebp
  1107c8:	89 e5                	mov    %esp,%ebp
  1107ca:	57                   	push   %edi
  1107cb:	56                   	push   %esi
  1107cc:	53                   	push   %ebx
  1107cd:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  1107d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  1107d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1107da:	8b 7d 14             	mov    0x14(%ebp),%edi
  1107dd:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1107e0:	89 7d e4             	mov    %edi,-0x1c(%ebp)

	if (IS_ENABLED(CONFIG_NET_OFFLOAD) && net_if_is_ip_offloaded(iface)) {
		return -ENOTSUP;
	}

	if (!iface->config.ip.ipv4) {
  1107e3:	8b 70 04             	mov    0x4(%eax),%esi
{
  1107e6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  1107e9:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
		return -ENETUNREACH;
  1107f0:	bf cd ff ff ff       	mov    $0xffffffcd,%edi
	if (!iface->config.ip.ipv4) {
  1107f5:	85 f6                	test   %esi,%esi
  1107f7:	0f 84 bb 00 00 00    	je     1108b8 <net_icmpv4_send_echo_request+0xf1>
	}

	/* Take the first address of the network interface */
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;

	pkt = net_pkt_alloc_with_buffer(iface,
  1107fd:	6a 00                	push   $0x0
  1107ff:	8b 55 1c             	mov    0x1c(%ebp),%edx
  110802:	6a 64                	push   $0x64
  110804:	83 c2 04             	add    $0x4,%edx
  110807:	6a 01                	push   $0x1
	src = &iface->config.ip.ipv4->unicast[0].address.in_addr;
  110809:	83 c6 04             	add    $0x4,%esi
	pkt = net_pkt_alloc_with_buffer(iface,
  11080c:	6a 01                	push   $0x1
					sizeof(struct net_icmpv4_echo_req)
					+ data_size,
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		return -ENOMEM;
  11080e:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	pkt = net_pkt_alloc_with_buffer(iface,
  110813:	52                   	push   %edx
  110814:	50                   	push   %eax
  110815:	e8 bc f7 ff ff       	call   10ffd6 <net_pkt_alloc_with_buffer>
  11081a:	83 c4 18             	add    $0x18,%esp
  11081d:	89 c3                	mov    %eax,%ebx
	if (!pkt) {
  11081f:	85 c0                	test   %eax,%eax
  110821:	0f 84 91 00 00 00    	je     1108b8 <net_icmpv4_send_echo_request+0xf1>
	}

	if (net_ipv4_create(pkt, src, dst) ||
  110827:	ff 75 0c             	pushl  0xc(%ebp)
  11082a:	56                   	push   %esi
  11082b:	50                   	push   %eax
  11082c:	e8 4e 03 00 00       	call   110b7f <net_ipv4_create>
  110831:	83 c4 0c             	add    $0xc,%esp
  110834:	85 c0                	test   %eax,%eax
  110836:	74 07                	je     11083f <net_icmpv4_send_echo_request+0x78>
	int ret = -ENOBUFS;
  110838:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
  11083d:	eb 72                	jmp    1108b1 <net_icmpv4_send_echo_request+0xea>
	    icmpv4_create(pkt, NET_ICMPV4_ECHO_REQUEST, 0)) {
  11083f:	31 c9                	xor    %ecx,%ecx
  110841:	ba 08 00 00 00       	mov    $0x8,%edx
  110846:	89 d8                	mov    %ebx,%eax
  110848:	e8 d6 fd ff ff       	call   110623 <icmpv4_create>
  11084d:	89 c7                	mov    %eax,%edi
	if (net_ipv4_create(pkt, src, dst) ||
  11084f:	85 c0                	test   %eax,%eax
  110851:	75 e5                	jne    110838 <net_icmpv4_send_echo_request+0x71>
		goto drop;
	}

	echo_req = (struct net_icmpv4_echo_req *)net_pkt_get_data(
  110853:	8d 75 ec             	lea    -0x14(%ebp),%esi
  110856:	56                   	push   %esi
  110857:	53                   	push   %ebx
  110858:	e8 f8 fb ff ff       	call   110455 <net_pkt_get_data>
  11085d:	59                   	pop    %ecx
							pkt, &icmpv4_access);
	if (!echo_req) {
  11085e:	85 c0                	test   %eax,%eax
	echo_req = (struct net_icmpv4_echo_req *)net_pkt_get_data(
  110860:	5a                   	pop    %edx
	if (!echo_req) {
  110861:	74 d5                	je     110838 <net_icmpv4_send_echo_request+0x71>
		goto drop;
	}

	echo_req->identifier = htons(identifier);
  110863:	8b 55 e8             	mov    -0x18(%ebp),%edx
	echo_req->sequence   = htons(sequence);
  110866:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	echo_req->identifier = htons(identifier);
  110869:	86 f2                	xchg   %dh,%dl
	echo_req->sequence   = htons(sequence);
  11086b:	86 e9                	xchg   %ch,%cl
	echo_req->identifier = htons(identifier);
  11086d:	66 89 10             	mov    %dx,(%eax)
	echo_req->sequence   = htons(sequence);
  110870:	66 89 48 02          	mov    %cx,0x2(%eax)

	net_pkt_set_data(pkt, &icmpv4_access);
  110874:	56                   	push   %esi
  110875:	53                   	push   %ebx
  110876:	e8 6d fc ff ff       	call   1104e8 <net_pkt_set_data>
  11087b:	5a                   	pop    %edx
  11087c:	59                   	pop    %ecx
	net_pkt_write(pkt, data, data_size);
  11087d:	ff 75 1c             	pushl  0x1c(%ebp)
  110880:	ff 75 18             	pushl  0x18(%ebp)
  110883:	53                   	push   %ebx
  110884:	e8 76 fb ff ff       	call   1103ff <net_pkt_write>
  110889:	83 c4 0c             	add    $0xc,%esp

	net_pkt_cursor_init(pkt);
  11088c:	53                   	push   %ebx
  11088d:	e8 58 f3 ff ff       	call   10fbea <net_pkt_cursor_init>

	net_ipv4_finalize(pkt, IPPROTO_ICMP);
  110892:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  110899:	53                   	push   %ebx
  11089a:	e8 67 03 00 00       	call   110c06 <net_ipv4_finalize>
  11089f:	5e                   	pop    %esi
  1108a0:	58                   	pop    %eax
	NET_DBG("Sending ICMPv4 Echo Request type %d from %s to %s",
		NET_ICMPV4_ECHO_REQUEST,
		log_strdup(net_sprint_ipv4_addr(src)),
		log_strdup(net_sprint_ipv4_addr(dst)));

	if (net_send_data(pkt) >= 0) {
  1108a1:	53                   	push   %ebx
  1108a2:	e8 9b c8 ff ff       	call   10d142 <net_send_data>
  1108a7:	5a                   	pop    %edx
  1108a8:	85 c0                	test   %eax,%eax
  1108aa:	79 0c                	jns    1108b8 <net_icmpv4_send_echo_request+0xf1>
		return 0;
	}

	net_stats_update_icmp_drop(iface);

	ret = -EIO;
  1108ac:	bf fb ff ff ff       	mov    $0xfffffffb,%edi

drop:
	net_pkt_unref(pkt);
  1108b1:	53                   	push   %ebx
  1108b2:	e8 c5 f1 ff ff       	call   10fa7c <net_pkt_unref>
  1108b7:	58                   	pop    %eax

	return ret;
}
  1108b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1108bb:	89 f8                	mov    %edi,%eax
  1108bd:	5b                   	pop    %ebx
  1108be:	5e                   	pop    %esi
  1108bf:	5f                   	pop    %edi
  1108c0:	5d                   	pop    %ebp
  1108c1:	c3                   	ret    

001108c2 <net_icmpv4_send_error>:

int net_icmpv4_send_error(struct net_pkt *orig, uint8_t type, uint8_t code)
{
  1108c2:	55                   	push   %ebp
  1108c3:	89 e5                	mov    %esp,%ebp
  1108c5:	57                   	push   %edi
  1108c6:	56                   	push   %esi
  1108c7:	53                   	push   %ebx
  1108c8:	83 ec 1c             	sub    $0x1c,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  1108cb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
{
  1108d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1108d5:	8b 75 08             	mov    0x8(%ebp),%esi
  1108d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1108db:	8b 45 10             	mov    0x10(%ebp),%eax
	int err = -EIO;
	struct net_ipv4_hdr *ip_hdr;
	struct net_pkt *pkt;
	size_t copy_len;

	net_pkt_cursor_init(orig);
  1108de:	56                   	push   %esi
{
  1108df:	89 45 dc             	mov    %eax,-0x24(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  1108e2:	c7 45 e8 14 00 00 00 	movl   $0x14,-0x18(%ebp)
	net_pkt_cursor_init(orig);
  1108e9:	e8 fc f2 ff ff       	call   10fbea <net_pkt_cursor_init>

	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
  1108ee:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  1108f1:	89 04 24             	mov    %eax,(%esp)
  1108f4:	56                   	push   %esi
  1108f5:	e8 5b fb ff ff       	call   110455 <net_pkt_get_data>
  1108fa:	59                   	pop    %ecx
  1108fb:	5b                   	pop    %ebx
	int err = -EIO;
  1108fc:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
	if (!ip_hdr) {
  110901:	85 c0                	test   %eax,%eax
  110903:	0f 84 0a 01 00 00    	je     110a13 <net_icmpv4_send_error+0x151>
		goto drop_no_pkt;
	}

	if (ip_hdr->proto == IPPROTO_ICMP) {
  110909:	80 78 09 01          	cmpb   $0x1,0x9(%eax)
  11090d:	89 c2                	mov    %eax,%edx
  11090f:	75 34                	jne    110945 <net_icmpv4_send_error+0x83>
  110911:	89 45 d8             	mov    %eax,-0x28(%ebp)
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
						      struct net_icmp_hdr);
		struct net_icmp_hdr *icmp_hdr;

		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
  110914:	8d 45 ec             	lea    -0x14(%ebp),%eax
  110917:	50                   	push   %eax
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  110918:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
  11091f:	56                   	push   %esi
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
  110920:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
  110927:	e8 29 fb ff ff       	call   110455 <net_pkt_get_data>
  11092c:	5f                   	pop    %edi
  11092d:	5a                   	pop    %edx
							orig, &icmpv4_access);
		if (!icmp_hdr || icmp_hdr->code < 8) {
  11092e:	85 c0                	test   %eax,%eax
  110930:	74 09                	je     11093b <net_icmpv4_send_error+0x79>
  110932:	80 78 01 07          	cmpb   $0x7,0x1(%eax)
  110936:	8b 55 d8             	mov    -0x28(%ebp),%edx
  110939:	77 0a                	ja     110945 <net_icmpv4_send_error+0x83>
			/* We must not send ICMP errors back */
			err = -EINVAL;
  11093b:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
  110940:	e9 ce 00 00 00       	jmp    110a13 <net_icmpv4_send_error+0x151>
			goto drop_no_pkt;
		}
	}

	if (ip_hdr->proto == IPPROTO_UDP) {
  110945:	8a 42 09             	mov    0x9(%edx),%al
		copy_len = sizeof(struct net_ipv4_hdr) +
  110948:	bf 1c 00 00 00       	mov    $0x1c,%edi
	if (ip_hdr->proto == IPPROTO_UDP) {
  11094d:	3c 11                	cmp    $0x11,%al
  11094f:	74 0e                	je     11095f <net_icmpv4_send_error+0x9d>
			sizeof(struct net_udp_hdr);
	} else if (ip_hdr->proto == IPPROTO_TCP) {
		copy_len = sizeof(struct net_ipv4_hdr) +
			sizeof(struct net_tcp_hdr);
	} else {
		copy_len = 0;
  110951:	3c 06                	cmp    $0x6,%al
  110953:	0f 95 c0             	setne  %al
  110956:	0f b6 c0             	movzbl %al,%eax
  110959:	89 c7                	mov    %eax,%edi
  11095b:	4f                   	dec    %edi
  11095c:	83 e7 28             	and    $0x28,%edi
	}

	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
  11095f:	6a 00                	push   $0x0
  110961:	8d 47 04             	lea    0x4(%edi),%eax
  110964:	6a 64                	push   $0x64
  110966:	89 55 d8             	mov    %edx,-0x28(%ebp)
  110969:	6a 01                	push   $0x1
  11096b:	6a 01                	push   $0x1
  11096d:	50                   	push   %eax
  11096e:	ff 76 20             	pushl  0x20(%esi)
  110971:	e8 60 f6 ff ff       	call   10ffd6 <net_pkt_alloc_with_buffer>
  110976:	83 c4 18             	add    $0x18,%esp
  110979:	89 c3                	mov    %eax,%ebx
					copy_len + NET_ICMPV4_UNUSED_LEN,
					AF_INET, IPPROTO_ICMP,
					PKT_WAIT_TIME);
	if (!pkt) {
		err =  -ENOMEM;
  11097b:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
	if (!pkt) {
  110980:	85 c0                	test   %eax,%eax
  110982:	0f 84 8b 00 00 00    	je     110a13 <net_icmpv4_send_error+0x151>
		goto drop_no_pkt;
	}

	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
  110988:	8b 55 d8             	mov    -0x28(%ebp),%edx
  11098b:	8d 42 0c             	lea    0xc(%edx),%eax
  11098e:	83 c2 10             	add    $0x10,%edx
  110991:	50                   	push   %eax
  110992:	52                   	push   %edx
  110993:	53                   	push   %ebx
  110994:	e8 e6 01 00 00       	call   110b7f <net_ipv4_create>
  110999:	83 c4 0c             	add    $0xc,%esp
  11099c:	85 c0                	test   %eax,%eax
  11099e:	74 0e                	je     1109ae <net_icmpv4_send_error+0xec>
		net_stats_update_icmp_sent(net_pkt_iface(orig));
		return 0;
	}

drop:
	net_pkt_unref(pkt);
  1109a0:	53                   	push   %ebx
  1109a1:	e8 d6 f0 ff ff       	call   10fa7c <net_pkt_unref>
  1109a6:	5b                   	pop    %ebx
	int err = -EIO;
  1109a7:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
  1109ac:	eb 65                	jmp    110a13 <net_icmpv4_send_error+0x151>
	    icmpv4_create(pkt, type, code) ||
  1109ae:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
  1109b2:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  1109b6:	89 d8                	mov    %ebx,%eax
  1109b8:	e8 66 fc ff ff       	call   110623 <icmpv4_create>
	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
  1109bd:	85 c0                	test   %eax,%eax
  1109bf:	75 df                	jne    1109a0 <net_icmpv4_send_error+0xde>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
  1109c1:	6a 04                	push   $0x4
  1109c3:	6a 00                	push   $0x0
  1109c5:	53                   	push   %ebx
  1109c6:	e8 5f f6 ff ff       	call   11002a <net_pkt_memset>
  1109cb:	83 c4 0c             	add    $0xc,%esp
	    icmpv4_create(pkt, type, code) ||
  1109ce:	85 c0                	test   %eax,%eax
  1109d0:	75 ce                	jne    1109a0 <net_icmpv4_send_error+0xde>
	    net_pkt_copy(pkt, orig, copy_len)) {
  1109d2:	57                   	push   %edi
  1109d3:	56                   	push   %esi
  1109d4:	53                   	push   %ebx
  1109d5:	e8 aa f6 ff ff       	call   110084 <net_pkt_copy>
  1109da:	83 c4 0c             	add    $0xc,%esp
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
  1109dd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1109e0:	85 c0                	test   %eax,%eax
  1109e2:	75 bc                	jne    1109a0 <net_icmpv4_send_error+0xde>
	net_pkt_cursor_init(pkt);
  1109e4:	53                   	push   %ebx
  1109e5:	e8 00 f2 ff ff       	call   10fbea <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
  1109ea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1109f1:	53                   	push   %ebx
  1109f2:	e8 0f 02 00 00       	call   110c06 <net_ipv4_finalize>
  1109f7:	58                   	pop    %eax
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
  1109f8:	8b 46 28             	mov    0x28(%esi),%eax
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
  1109fb:	5a                   	pop    %edx
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
  1109fc:	89 43 30             	mov    %eax,0x30(%ebx)
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
  1109ff:	8a 46 2c             	mov    0x2c(%esi),%al
  110a02:	88 43 34             	mov    %al,0x34(%ebx)
	if (net_send_data(pkt) >= 0) {
  110a05:	53                   	push   %ebx
  110a06:	e8 37 c7 ff ff       	call   10d142 <net_send_data>
  110a0b:	59                   	pop    %ecx
  110a0c:	85 c0                	test   %eax,%eax
  110a0e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  110a11:	78 8d                	js     1109a0 <net_icmpv4_send_error+0xde>
drop_no_pkt:
	net_stats_update_icmp_drop(net_pkt_iface(orig));

	return err;

}
  110a13:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110a16:	89 c8                	mov    %ecx,%eax
  110a18:	5b                   	pop    %ebx
  110a19:	5e                   	pop    %esi
  110a1a:	5f                   	pop    %edi
  110a1b:	5d                   	pop    %ebp
  110a1c:	c3                   	ret    

00110a1d <net_icmpv4_register_handler>:

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
  110a1d:	55                   	push   %ebp
Z_GENLIST_PREPEND(slist, snode)
  110a1e:	8b 15 e8 eb 12 00    	mov    0x12ebe8,%edx
  110a24:	89 e5                	mov    %esp,%ebp
  110a26:	8b 45 08             	mov    0x8(%ebp),%eax
	parent->next = child;
  110a29:	89 10                	mov    %edx,(%eax)
	list->head = node;
  110a2b:	a3 e8 eb 12 00       	mov    %eax,0x12ebe8
Z_GENLIST_PREPEND(slist, snode)
  110a30:	83 3d ec eb 12 00 00 	cmpl   $0x0,0x12ebec
  110a37:	75 05                	jne    110a3e <net_icmpv4_register_handler+0x21>
	list->tail = node;
  110a39:	a3 ec eb 12 00       	mov    %eax,0x12ebec
	sys_slist_prepend(&handlers, &handler->node);
}
  110a3e:	5d                   	pop    %ebp
  110a3f:	c3                   	ret    

00110a40 <net_icmpv4_unregister_handler>:

void net_icmpv4_unregister_handler(struct net_icmpv4_handler *handler)
{
  110a40:	55                   	push   %ebp
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  110a41:	a1 e8 eb 12 00       	mov    0x12ebe8,%eax
  110a46:	89 e5                	mov    %esp,%ebp
  110a48:	31 c9                	xor    %ecx,%ecx
  110a4a:	8b 55 08             	mov    0x8(%ebp),%edx
  110a4d:	85 c0                	test   %eax,%eax
  110a4f:	74 3c                	je     110a8d <net_icmpv4_unregister_handler+0x4d>
  110a51:	39 c2                	cmp    %eax,%edx
  110a53:	75 32                	jne    110a87 <net_icmpv4_unregister_handler+0x47>
Z_GENLIST_REMOVE(slist, snode)
  110a55:	8b 02                	mov    (%edx),%eax
  110a57:	85 c9                	test   %ecx,%ecx
  110a59:	75 14                	jne    110a6f <net_icmpv4_unregister_handler+0x2f>
  110a5b:	3b 15 ec eb 12 00    	cmp    0x12ebec,%edx
	list->head = node;
  110a61:	a3 e8 eb 12 00       	mov    %eax,0x12ebe8
Z_GENLIST_REMOVE(slist, snode)
  110a66:	75 17                	jne    110a7f <net_icmpv4_unregister_handler+0x3f>
	list->tail = node;
  110a68:	a3 ec eb 12 00       	mov    %eax,0x12ebec
}
  110a6d:	eb 10                	jmp    110a7f <net_icmpv4_unregister_handler+0x3f>
	parent->next = child;
  110a6f:	89 01                	mov    %eax,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
  110a71:	3b 15 ec eb 12 00    	cmp    0x12ebec,%edx
  110a77:	75 06                	jne    110a7f <net_icmpv4_unregister_handler+0x3f>
	list->tail = node;
  110a79:	89 0d ec eb 12 00    	mov    %ecx,0x12ebec
	parent->next = child;
  110a7f:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_REMOVE(slist, snode)
  110a85:	eb 06                	jmp    110a8d <net_icmpv4_unregister_handler+0x4d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  110a87:	89 c1                	mov    %eax,%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  110a89:	8b 00                	mov    (%eax),%eax
  110a8b:	eb c0                	jmp    110a4d <net_icmpv4_unregister_handler+0xd>
	sys_slist_find_and_remove(&handlers, &handler->node);
}
  110a8d:	5d                   	pop    %ebp
  110a8e:	c3                   	ret    

00110a8f <net_icmpv4_input>:

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
  110a8f:	55                   	push   %ebp
  110a90:	89 e5                	mov    %esp,%ebp
  110a92:	57                   	push   %edi
  110a93:	56                   	push   %esi
  110a94:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
  110a95:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  110a98:	83 ec 0c             	sub    $0xc,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
  110a9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  110aa2:	8b 75 08             	mov    0x8(%ebp),%esi
  110aa5:	8b 7d 0c             	mov    0xc(%ebp),%edi
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
  110aa8:	50                   	push   %eax
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
  110aa9:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
  110ab0:	56                   	push   %esi
  110ab1:	e8 9f f9 ff ff       	call   110455 <net_pkt_get_data>
  110ab6:	59                   	pop    %ecx
	if (!icmp_hdr) {
  110ab7:	85 c0                	test   %eax,%eax
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
  110ab9:	5b                   	pop    %ebx
	if (!icmp_hdr) {
  110aba:	75 07                	jne    110ac3 <net_icmpv4_input+0x34>
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
  110abc:	b8 02 00 00 00       	mov    $0x2,%eax
  110ac1:	eb 6c                	jmp    110b2f <net_icmpv4_input+0xa0>
  110ac3:	6a 01                	push   $0x1
  110ac5:	89 c3                	mov    %eax,%ebx
  110ac7:	56                   	push   %esi
  110ac8:	e8 10 d9 ff ff       	call   10e3dd <net_calc_chksum>
	}

	if (net_calc_chksum_icmpv4(pkt) != 0U) {
  110acd:	66 85 c0             	test   %ax,%ax
  110ad0:	59                   	pop    %ecx
  110ad1:	5a                   	pop    %edx
  110ad2:	75 e8                	jne    110abc <net_icmpv4_input+0x2d>
		NET_DBG("DROP: Invalid checksum");
		goto drop;
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &ip_hdr->dst) &&
  110ad4:	8b 56 20             	mov    0x20(%esi),%edx
  110ad7:	89 55 e8             	mov    %edx,-0x18(%ebp)
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  110ada:	e8 7a da ff ff       	call   10e559 <net_ipv4_broadcast_address>
  110adf:	8b 00                	mov    (%eax),%eax
  110ae1:	39 47 10             	cmp    %eax,0x10(%edi)
  110ae4:	74 d6                	je     110abc <net_icmpv4_input+0x2d>
  110ae6:	8d 47 10             	lea    0x10(%edi),%eax
	return net_if_ipv4_is_addr_bcast(iface, addr);
  110ae9:	8b 55 e8             	mov    -0x18(%ebp),%edx
  110aec:	50                   	push   %eax
  110aed:	52                   	push   %edx
  110aee:	e8 21 cc ff ff       	call   10d714 <net_if_ipv4_is_addr_bcast>
  110af3:	59                   	pop    %ecx
  110af4:	84 c0                	test   %al,%al
  110af6:	5a                   	pop    %edx
  110af7:	75 c3                	jne    110abc <net_icmpv4_input+0x2d>
	return net_pkt_skip(pkt, access->size);
  110af9:	ff 75 f0             	pushl  -0x10(%ebp)
  110afc:	56                   	push   %esi
  110afd:	e8 09 f5 ff ff       	call   11000b <net_pkt_skip>
  110b02:	58                   	pop    %eax
  110b03:	a1 e8 eb 12 00       	mov    0x12ebe8,%eax
  110b08:	5a                   	pop    %edx
	NET_DBG("ICMPv4 packet received type %d code %d",
		icmp_hdr->type, icmp_hdr->code);

	net_stats_update_icmp_recv(net_pkt_iface(pkt));

	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
  110b09:	85 c0                	test   %eax,%eax
  110b0b:	74 af                	je     110abc <net_icmpv4_input+0x2d>
		if (cb->type == icmp_hdr->type &&
  110b0d:	8a 0b                	mov    (%ebx),%cl
  110b0f:	38 48 08             	cmp    %cl,0x8(%eax)
  110b12:	75 17                	jne    110b2b <net_icmpv4_input+0x9c>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
  110b14:	8a 50 09             	mov    0x9(%eax),%dl
  110b17:	38 53 01             	cmp    %dl,0x1(%ebx)
  110b1a:	74 04                	je     110b20 <net_icmpv4_input+0x91>
  110b1c:	84 d2                	test   %dl,%dl
  110b1e:	75 0b                	jne    110b2b <net_icmpv4_input+0x9c>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
  110b20:	53                   	push   %ebx
  110b21:	57                   	push   %edi
  110b22:	56                   	push   %esi
  110b23:	ff 50 04             	call   *0x4(%eax)
  110b26:	83 c4 0c             	add    $0xc,%esp
  110b29:	eb 04                	jmp    110b2f <net_icmpv4_input+0xa0>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  110b2b:	8b 00                	mov    (%eax),%eax
	return node->next;
  110b2d:	eb da                	jmp    110b09 <net_icmpv4_input+0x7a>

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
  110b2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110b32:	5b                   	pop    %ebx
  110b33:	5e                   	pop    %esi
  110b34:	5f                   	pop    %edi
  110b35:	5d                   	pop    %ebp
  110b36:	c3                   	ret    

00110b37 <net_icmpv4_init>:
	.code = 0,
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
  110b37:	55                   	push   %ebp
  110b38:	89 e5                	mov    %esp,%ebp
	net_icmpv4_register_handler(&echo_request_handler);
  110b3a:	68 04 5b 14 00       	push   $0x145b04
  110b3f:	e8 d9 fe ff ff       	call   110a1d <net_icmpv4_register_handler>
  110b44:	58                   	pop    %eax
}
  110b45:	c9                   	leave  
  110b46:	c3                   	ret    

00110b47 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  110b47:	8b 00                	mov    (%eax),%eax
  110b49:	25 f0 00 00 00       	and    $0xf0,%eax
  110b4e:	3d e0 00 00 00       	cmp    $0xe0,%eax
  110b53:	0f 94 c0             	sete   %al
}
  110b56:	c3                   	ret    

00110b57 <net_ipv4_is_addr_bcast>:
{
  110b57:	55                   	push   %ebp
  110b58:	89 e5                	mov    %esp,%ebp
  110b5a:	56                   	push   %esi
  110b5b:	53                   	push   %ebx
  110b5c:	89 c6                	mov    %eax,%esi
  110b5e:	89 d3                	mov    %edx,%ebx
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  110b60:	e8 f4 d9 ff ff       	call   10e559 <net_ipv4_broadcast_address>
  110b65:	8b 00                	mov    (%eax),%eax
  110b67:	39 03                	cmp    %eax,(%ebx)
  110b69:	74 0b                	je     110b76 <net_ipv4_is_addr_bcast+0x1f>
	return net_if_ipv4_is_addr_bcast(iface, addr);
  110b6b:	53                   	push   %ebx
  110b6c:	56                   	push   %esi
  110b6d:	e8 a2 cb ff ff       	call   10d714 <net_if_ipv4_is_addr_bcast>
  110b72:	5a                   	pop    %edx
  110b73:	59                   	pop    %ecx
  110b74:	eb 02                	jmp    110b78 <net_ipv4_is_addr_bcast+0x21>
		return true;
  110b76:	b0 01                	mov    $0x1,%al
}
  110b78:	8d 65 f8             	lea    -0x8(%ebp),%esp
  110b7b:	5b                   	pop    %ebx
  110b7c:	5e                   	pop    %esi
  110b7d:	5d                   	pop    %ebp
  110b7e:	c3                   	ret    

00110b7f <net_ipv4_create>:
#define NET_BUF_TIMEOUT K_MSEC(50)

int net_ipv4_create(struct net_pkt *pkt,
		    const struct in_addr *src,
		    const struct in_addr *dst)
{
  110b7f:	55                   	push   %ebp
  110b80:	89 e5                	mov    %esp,%ebp
  110b82:	56                   	push   %esi
  110b83:	53                   	push   %ebx
  110b84:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110b87:	8d 75 f0             	lea    -0x10(%ebp),%esi
{
  110b8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  110b8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110b94:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  110b95:	c7 45 f4 14 00 00 00 	movl   $0x14,-0xc(%ebp)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110b9c:	53                   	push   %ebx
  110b9d:	e8 b3 f8 ff ff       	call   110455 <net_pkt_get_data>
  110ba2:	5a                   	pop    %edx
	if (!ipv4_hdr) {
  110ba3:	85 c0                	test   %eax,%eax
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110ba5:	59                   	pop    %ecx
	if (!ipv4_hdr) {
  110ba6:	ba c9 ff ff ff       	mov    $0xffffffc9,%edx
  110bab:	74 50                	je     110bfd <net_ipv4_create+0x7e>
		return -ENOBUFS;
	}

	ipv4_hdr->vhl       = 0x45;
  110bad:	c7 00 45 00 00 00    	movl   $0x45,(%eax)
	ipv4_hdr->tos       = 0x00;
	ipv4_hdr->len       = 0U;
	ipv4_hdr->id[0]     = 0U;
  110bb3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	ipv4_hdr->id[1]     = 0U;
	ipv4_hdr->offset[0] = 0U;
	ipv4_hdr->offset[1] = 0U;

	ipv4_hdr->ttl       = net_pkt_ipv4_ttl(pkt);
  110bba:	8a 53 42             	mov    0x42(%ebx),%dl
  110bbd:	88 50 08             	mov    %dl,0x8(%eax)
	if (ipv4_hdr->ttl == 0U) {
  110bc0:	84 d2                	test   %dl,%dl
  110bc2:	75 10                	jne    110bd4 <net_ipv4_create+0x55>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
  110bc4:	8b 4b 20             	mov    0x20(%ebx),%ecx
  110bc7:	8b 49 04             	mov    0x4(%ecx),%ecx
 * @return Time-to-live
 */
static inline uint8_t net_if_ipv4_get_ttl(struct net_if *iface)
{
#if defined(CONFIG_NET_NATIVE_IPV4)
	if (!iface->config.ip.ipv4) {
  110bca:	85 c9                	test   %ecx,%ecx
  110bcc:	74 03                	je     110bd1 <net_ipv4_create+0x52>
		return 0;
	}

	return iface->config.ip.ipv4->ttl;
  110bce:	8a 51 38             	mov    0x38(%ecx),%dl
  110bd1:	88 50 08             	mov    %dl,0x8(%eax)
	}

	ipv4_hdr->proto     = 0U;
	ipv4_hdr->chksum    = 0U;

	net_ipaddr_copy(&ipv4_hdr->dst, dst);
  110bd4:	8b 55 10             	mov    0x10(%ebp),%edx
	ipv4_hdr->proto     = 0U;
  110bd7:	c6 40 09 00          	movb   $0x0,0x9(%eax)
	ipv4_hdr->chksum    = 0U;
  110bdb:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
	net_ipaddr_copy(&ipv4_hdr->dst, dst);
  110be1:	8b 12                	mov    (%edx),%edx
  110be3:	89 50 10             	mov    %edx,0x10(%eax)
	net_ipaddr_copy(&ipv4_hdr->src, src);
  110be6:	8b 55 0c             	mov    0xc(%ebp),%edx
  110be9:	8b 12                	mov    (%edx),%edx
  110beb:	89 50 0c             	mov    %edx,0xc(%eax)
	pkt->ip_hdr_len = len;
  110bee:	c6 43 3c 14          	movb   $0x14,0x3c(%ebx)

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	return net_pkt_set_data(pkt, &ipv4_access);
  110bf2:	56                   	push   %esi
  110bf3:	53                   	push   %ebx
  110bf4:	e8 ef f8 ff ff       	call   1104e8 <net_pkt_set_data>
  110bf9:	5a                   	pop    %edx
  110bfa:	89 c2                	mov    %eax,%edx
  110bfc:	59                   	pop    %ecx
}
  110bfd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  110c00:	89 d0                	mov    %edx,%eax
  110c02:	5b                   	pop    %ebx
  110c03:	5e                   	pop    %esi
  110c04:	5d                   	pop    %ebp
  110c05:	c3                   	ret    

00110c06 <net_ipv4_finalize>:

int net_ipv4_finalize(struct net_pkt *pkt, uint8_t next_header_proto)
{
  110c06:	55                   	push   %ebp
  110c07:	89 e5                	mov    %esp,%ebp
  110c09:	57                   	push   %edi
  110c0a:	56                   	push   %esi
  110c0b:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	struct net_ipv4_hdr *ipv4_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110c0c:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  110c0f:	83 ec 08             	sub    $0x8,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  110c12:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  110c19:	8b 75 08             	mov    0x8(%ebp),%esi
  110c1c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  110c1f:	c7 45 f0 14 00 00 00 	movl   $0x14,-0x10(%ebp)
	pkt->overwrite = overwrite;
  110c26:	80 4e 3d 01          	orb    $0x1,0x3d(%esi)
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110c2a:	50                   	push   %eax
  110c2b:	56                   	push   %esi
  110c2c:	e8 24 f8 ff ff       	call   110455 <net_pkt_get_data>
  110c31:	5f                   	pop    %edi
  110c32:	89 c7                	mov    %eax,%edi
  110c34:	5a                   	pop    %edx
	if (!ipv4_hdr) {
		return -ENOBUFS;
  110c35:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
	if (!ipv4_hdr) {
  110c3a:	85 ff                	test   %edi,%edi
  110c3c:	74 69                	je     110ca7 <net_ipv4_finalize+0xa1>
					((net_pkt_ip_hdr_len(pkt) +
					  net_pkt_ipv4_opts_len(pkt)) / 4U));
		}
	}

	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
  110c3e:	8b 46 10             	mov    0x10(%esi),%eax
	size_t bytes = 0;
  110c41:	31 d2                	xor    %edx,%edx
	while (buf) {
  110c43:	85 c0                	test   %eax,%eax
  110c45:	74 0a                	je     110c51 <net_ipv4_finalize+0x4b>
		bytes += buf->len;
  110c47:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
  110c4b:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  110c4d:	01 ca                	add    %ecx,%edx
		buf = buf->frags;
  110c4f:	eb f2                	jmp    110c43 <net_ipv4_finalize+0x3d>
  110c51:	89 d0                	mov    %edx,%eax
	ipv4_hdr->proto = next_header_proto;
  110c53:	88 5f 09             	mov    %bl,0x9(%edi)
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
  110c56:	86 e0                	xchg   %ah,%al
  110c58:	66 89 47 02          	mov    %ax,0x2(%edi)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
  110c5c:	ff 76 20             	pushl  0x20(%esi)
  110c5f:	e8 48 cf ff ff       	call   10dbac <net_if_need_calc_tx_checksum>
  110c64:	59                   	pop    %ecx
  110c65:	84 c0                	test   %al,%al
  110c67:	74 0b                	je     110c74 <net_ipv4_finalize+0x6e>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
  110c69:	56                   	push   %esi
  110c6a:	e8 b5 d8 ff ff       	call   10e524 <net_calc_chksum_ipv4>
  110c6f:	5a                   	pop    %edx
  110c70:	66 89 47 0a          	mov    %ax,0xa(%edi)
	}

	net_pkt_set_data(pkt, &ipv4_access);
  110c74:	8d 45 ec             	lea    -0x14(%ebp),%eax
  110c77:	50                   	push   %eax
  110c78:	56                   	push   %esi
  110c79:	e8 6a f8 ff ff       	call   1104e8 <net_pkt_set_data>
  110c7e:	59                   	pop    %ecx

	if (IS_ENABLED(CONFIG_NET_UDP) &&
  110c7f:	80 fb 11             	cmp    $0x11,%bl
	net_pkt_set_data(pkt, &ipv4_access);
  110c82:	5f                   	pop    %edi
	if (IS_ENABLED(CONFIG_NET_UDP) &&
  110c83:	75 08                	jne    110c8d <net_ipv4_finalize+0x87>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
  110c85:	56                   	push   %esi
  110c86:	e8 48 28 00 00       	call   1134d3 <net_udp_finalize>
  110c8b:	eb 19                	jmp    110ca6 <net_ipv4_finalize+0xa0>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
  110c8d:	80 fb 06             	cmp    $0x6,%bl
  110c90:	75 08                	jne    110c9a <net_ipv4_finalize+0x94>
		   next_header_proto == IPPROTO_TCP) {
		return net_tcp_finalize(pkt);
  110c92:	56                   	push   %esi
  110c93:	e8 2c 27 00 00       	call   1133c4 <net_tcp_finalize>
  110c98:	eb 0c                	jmp    110ca6 <net_ipv4_finalize+0xa0>
	} else if (next_header_proto == IPPROTO_ICMP) {
		return net_icmpv4_finalize(pkt);
	}

	return 0;
  110c9a:	31 c0                	xor    %eax,%eax
	} else if (next_header_proto == IPPROTO_ICMP) {
  110c9c:	fe cb                	dec    %bl
  110c9e:	75 07                	jne    110ca7 <net_ipv4_finalize+0xa1>
		return net_icmpv4_finalize(pkt);
  110ca0:	56                   	push   %esi
  110ca1:	e8 d1 fa ff ff       	call   110777 <net_icmpv4_finalize>
  110ca6:	5a                   	pop    %edx
}
  110ca7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110caa:	5b                   	pop    %ebx
  110cab:	5e                   	pop    %esi
  110cac:	5f                   	pop    %edi
  110cad:	5d                   	pop    %ebp
  110cae:	c3                   	ret    

00110caf <net_ipv4_input>:
	return 0;
}
#endif

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
  110caf:	55                   	push   %ebp
  110cb0:	89 e5                	mov    %esp,%ebp
  110cb2:	57                   	push   %edi
  110cb3:	56                   	push   %esi
	size_t bytes = 0;
  110cb4:	31 ff                	xor    %edi,%edi
  110cb6:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  110cb7:	8d 45 d8             	lea    -0x28(%ebp),%eax
{
  110cba:	83 ec 40             	sub    $0x40,%esp
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  110cbd:	89 45 c8             	mov    %eax,-0x38(%ebp)
{
  110cc0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
  110cc3:	8d 45 e0             	lea    -0x20(%ebp),%eax
  110cc6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
  110cc9:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  110cd0:	c7 45 c4 14 00 00 00 	movl   $0x14,-0x3c(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  110cd7:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
  110cde:	c7 45 d4 14 00 00 00 	movl   $0x14,-0x2c(%ebp)
	int real_len = net_pkt_get_len(pkt);
  110ce5:	8b 43 10             	mov    0x10(%ebx),%eax
	while (buf) {
  110ce8:	85 c0                	test   %eax,%eax
  110cea:	74 0a                	je     110cf6 <net_ipv4_input+0x47>
		bytes += buf->len;
  110cec:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
		buf = buf->frags;
  110cf0:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  110cf2:	01 d7                	add    %edx,%edi
		buf = buf->frags;
  110cf4:	eb f2                	jmp    110ce8 <net_ipv4_input+0x39>
	uint8_t opts_len;
	int pkt_len;

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
  110cf6:	8d 45 c0             	lea    -0x40(%ebp),%eax
  110cf9:	50                   	push   %eax
  110cfa:	53                   	push   %ebx
  110cfb:	e8 55 f7 ff ff       	call   110455 <net_pkt_get_data>
  110d00:	5a                   	pop    %edx
  110d01:	89 c6                	mov    %eax,%esi
  110d03:	59                   	pop    %ecx
	if (!hdr) {
  110d04:	85 c0                	test   %eax,%eax
  110d06:	0f 84 1b 01 00 00    	je     110e27 <net_ipv4_input+0x178>
		NET_DBG("DROP: no buffer");
		goto drop;
	}

	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
  110d0c:	8a 00                	mov    (%eax),%al
  110d0e:	83 e0 0f             	and    $0xf,%eax
  110d11:	c1 e0 02             	shl    $0x2,%eax
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
  110d14:	3c 13                	cmp    $0x13,%al
  110d16:	0f 86 0b 01 00 00    	jbe    110e27 <net_ipv4_input+0x178>
		goto drop;
	}

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
  110d1c:	83 e8 14             	sub    $0x14,%eax
	pkt->ip_hdr_len = len;
  110d1f:	c6 43 3c 14          	movb   $0x14,0x3c(%ebx)
  110d23:	88 45 b7             	mov    %al,-0x49(%ebp)
	pkt->ipv4_opts_len = opts_len;
  110d26:	88 43 43             	mov    %al,0x43(%ebx)
		return -EINVAL;
	}

	net_pkt_set_ipv4_opts_len(pkt, opts_len);

	pkt_len = ntohs(hdr->len);
  110d29:	66 8b 46 02          	mov    0x2(%esi),%ax
  110d2d:	86 e0                	xchg   %ah,%al
  110d2f:	0f b7 c0             	movzwl %ax,%eax
	if (real_len < pkt_len) {
  110d32:	39 f8                	cmp    %edi,%eax
  110d34:	0f 8f ed 00 00 00    	jg     110e27 <net_ipv4_input+0x178>
		NET_DBG("DROP: pkt len per hdr %d != pkt real len %d",
			pkt_len, real_len);
		goto drop;
	} else if (real_len > pkt_len) {
  110d3a:	7d 09                	jge    110d45 <net_ipv4_input+0x96>
		net_pkt_update_length(pkt, pkt_len);
  110d3c:	50                   	push   %eax
  110d3d:	53                   	push   %ebx
  110d3e:	e8 66 f4 ff ff       	call   1101a9 <net_pkt_update_length>
  110d43:	5f                   	pop    %edi
  110d44:	58                   	pop    %eax
	}

	if (net_ipv4_is_addr_mcast(&hdr->src)) {
  110d45:	8d 56 0c             	lea    0xc(%esi),%edx
  110d48:	89 d0                	mov    %edx,%eax
  110d4a:	e8 f8 fd ff ff       	call   110b47 <net_ipv4_is_addr_mcast>
  110d4f:	84 c0                	test   %al,%al
  110d51:	0f 85 d0 00 00 00    	jne    110e27 <net_ipv4_input+0x178>
		NET_DBG("DROP: src addr is %s", "mcast");
		goto drop;
	}

	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->src)) {
  110d57:	8b 43 20             	mov    0x20(%ebx),%eax
  110d5a:	e8 f8 fd ff ff       	call   110b57 <net_ipv4_is_addr_bcast>
  110d5f:	84 c0                	test   %al,%al
  110d61:	0f 85 c0 00 00 00    	jne    110e27 <net_ipv4_input+0x178>
		NET_DBG("DROP: src addr is %s", "bcast");
		goto drop;
	}

	if (net_ipv4_is_addr_unspecified(&hdr->src)) {
  110d67:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  110d6b:	0f 84 b6 00 00 00    	je     110e27 <net_ipv4_input+0x178>
		NET_DBG("DROP: src addr is %s", "unspecified");
		goto drop;
	}

	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
  110d71:	ff 73 20             	pushl  0x20(%ebx)
  110d74:	e8 58 ce ff ff       	call   10dbd1 <net_if_need_calc_rx_checksum>
  110d79:	59                   	pop    %ecx
  110d7a:	84 c0                	test   %al,%al
  110d7c:	75 1f                	jne    110d9d <net_ipv4_input+0xee>
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
  110d7e:	6a 00                	push   $0x0
	    net_calc_chksum_ipv4(pkt) != 0U) {
		NET_DBG("DROP: invalid chksum");
		goto drop;
	}

	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
  110d80:	8d 7e 10             	lea    0x10(%esi),%edi
  110d83:	57                   	push   %edi
  110d84:	e8 e8 ca ff ff       	call   10d871 <net_if_ipv4_addr_lookup>
  110d89:	59                   	pop    %ecx
  110d8a:	85 c0                	test   %eax,%eax
  110d8c:	5a                   	pop    %edx
  110d8d:	0f 95 c0             	setne  %al
	if (!ret) {
  110d90:	75 19                	jne    110dab <net_ipv4_input+0xfc>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
  110d92:	89 fa                	mov    %edi,%edx
  110d94:	31 c0                	xor    %eax,%eax
  110d96:	e8 bc fd ff ff       	call   110b57 <net_ipv4_is_addr_bcast>
  110d9b:	eb 0e                	jmp    110dab <net_ipv4_input+0xfc>
	    net_calc_chksum_ipv4(pkt) != 0U) {
  110d9d:	53                   	push   %ebx
  110d9e:	e8 81 d7 ff ff       	call   10e524 <net_calc_chksum_ipv4>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
  110da3:	66 85 c0             	test   %ax,%ax
	    net_calc_chksum_ipv4(pkt) != 0U) {
  110da6:	5a                   	pop    %edx
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
  110da7:	74 d5                	je     110d7e <net_ipv4_input+0xcf>
  110da9:	eb 7c                	jmp    110e27 <net_ipv4_input+0x178>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
  110dab:	84 c0                	test   %al,%al
  110dad:	74 08                	je     110db7 <net_ipv4_input+0x108>
	     !(hdr->proto == IPPROTO_UDP &&
	       (net_ipv4_addr_cmp(&hdr->dst, net_ipv4_broadcast_address()) ||
		/* RFC 1122 ch. 3.3.6 The 0.0.0.0 is non-standard bcast addr */
		(IS_ENABLED(CONFIG_NET_IPV4_ACCEPT_ZERO_BROADCAST) &&
		 net_ipv4_addr_cmp(&hdr->dst,
				   net_ipv4_unspecified_address()))))) ||
  110daf:	80 7e 09 06          	cmpb   $0x6,0x9(%esi)
  110db3:	75 2f                	jne    110de4 <net_ipv4_input+0x135>
  110db5:	eb 1f                	jmp    110dd6 <net_ipv4_input+0x127>
	     !net_ipv4_is_addr_mcast(&hdr->dst) &&
  110db7:	89 f8                	mov    %edi,%eax
  110db9:	e8 89 fd ff ff       	call   110b47 <net_ipv4_is_addr_mcast>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
  110dbe:	84 c0                	test   %al,%al
  110dc0:	75 ed                	jne    110daf <net_ipv4_input+0x100>
	     !net_ipv4_is_addr_mcast(&hdr->dst) &&
  110dc2:	80 7e 09 11          	cmpb   $0x11,0x9(%esi)
  110dc6:	75 5f                	jne    110e27 <net_ipv4_input+0x178>
	       (net_ipv4_addr_cmp(&hdr->dst, net_ipv4_broadcast_address()) ||
  110dc8:	e8 8c d7 ff ff       	call   10e559 <net_ipv4_broadcast_address>
	     !(hdr->proto == IPPROTO_UDP &&
  110dcd:	8b 4e 10             	mov    0x10(%esi),%ecx
  110dd0:	39 08                	cmp    %ecx,(%eax)
  110dd2:	74 db                	je     110daf <net_ipv4_input+0x100>
  110dd4:	eb 51                	jmp    110e27 <net_ipv4_input+0x178>
	    (hdr->proto == IPPROTO_TCP &&
	     net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->dst))) {
  110dd6:	8b 43 20             	mov    0x20(%ebx),%eax
  110dd9:	89 fa                	mov    %edi,%edx
  110ddb:	e8 77 fd ff ff       	call   110b57 <net_ipv4_is_addr_bcast>
	    (hdr->proto == IPPROTO_TCP &&
  110de0:	84 c0                	test   %al,%al
  110de2:	75 43                	jne    110e27 <net_ipv4_input+0x178>
	return net_pkt_skip(pkt, access->size);
  110de4:	ff 75 c4             	pushl  -0x3c(%ebp)
  110de7:	53                   	push   %ebx
  110de8:	e8 1e f2 ff ff       	call   11000b <net_pkt_skip>
  110ded:	59                   	pop    %ecx
		goto drop;
	}

	net_pkt_acknowledge_data(pkt, &ipv4_access);

	if (opts_len) {
  110dee:	80 7d b7 00          	cmpb   $0x0,-0x49(%ebp)
  110df2:	5f                   	pop    %edi
  110df3:	74 11                	je     110e06 <net_ipv4_input+0x157>
		/* Only few options are handled in EchoRequest, rest skipped */
		if (net_pkt_skip(pkt, opts_len)) {
  110df5:	0f b6 45 b7          	movzbl -0x49(%ebp),%eax
  110df9:	50                   	push   %eax
  110dfa:	53                   	push   %ebx
  110dfb:	e8 0b f2 ff ff       	call   11000b <net_pkt_skip>
  110e00:	5f                   	pop    %edi
  110e01:	85 c0                	test   %eax,%eax
  110e03:	5a                   	pop    %edx
  110e04:	75 21                	jne    110e27 <net_ipv4_input+0x178>
	pkt->ipv4_ttl = ttl;
  110e06:	8a 46 08             	mov    0x8(%esi),%al
  110e09:	88 43 42             	mov    %al,0x42(%ebx)
	pkt->family = family;
  110e0c:	8a 43 3f             	mov    0x3f(%ebx),%al
  110e0f:	83 e0 f1             	and    $0xfffffff1,%eax
  110e12:	83 c8 02             	or     $0x2,%eax
  110e15:	88 43 3f             	mov    %al,0x3f(%ebx)

	NET_DBG("IPv4 packet received from %s to %s",
		log_strdup(net_sprint_ipv4_addr(&hdr->src)),
		log_strdup(net_sprint_ipv4_addr(&hdr->dst)));

	switch (hdr->proto) {
  110e18:	8a 46 09             	mov    0x9(%esi),%al
  110e1b:	3c 06                	cmp    $0x6,%al
  110e1d:	74 1a                	je     110e39 <net_ipv4_input+0x18a>
  110e1f:	3c 11                	cmp    $0x11,%al
  110e21:	74 44                	je     110e67 <net_ipv4_input+0x1b8>
  110e23:	fe c8                	dec    %al
  110e25:	74 07                	je     110e2e <net_ipv4_input+0x17f>
  110e27:	b8 02 00 00 00       	mov    $0x2,%eax
  110e2c:	eb 45                	jmp    110e73 <net_ipv4_input+0x1c4>
	case IPPROTO_ICMP:
		verdict = net_icmpv4_input(pkt, hdr);
  110e2e:	56                   	push   %esi
  110e2f:	53                   	push   %ebx
  110e30:	e8 5a fc ff ff       	call   110a8f <net_icmpv4_input>
  110e35:	5b                   	pop    %ebx
  110e36:	5e                   	pop    %esi
		if (verdict == NET_DROP) {
  110e37:	eb 3a                	jmp    110e73 <net_ipv4_input+0x1c4>
			goto drop;
		}
		return verdict;
	case IPPROTO_TCP:
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
  110e39:	8d 45 d0             	lea    -0x30(%ebp),%eax
  110e3c:	50                   	push   %eax
  110e3d:	53                   	push   %ebx
  110e3e:	e8 e3 25 00 00       	call   113426 <net_tcp_input>
  110e43:	5a                   	pop    %edx
  110e44:	89 45 b8             	mov    %eax,-0x48(%ebp)
  110e47:	59                   	pop    %ecx
		if (proto_hdr.tcp) {
  110e48:	85 c0                	test   %eax,%eax
  110e4a:	74 db                	je     110e27 <net_ipv4_input+0x178>
		goto drop;
	}

	ip.ipv4 = hdr;

	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
  110e4c:	8d 45 b8             	lea    -0x48(%ebp),%eax
	ip.ipv4 = hdr;
  110e4f:	89 75 bc             	mov    %esi,-0x44(%ebp)
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
  110e52:	50                   	push   %eax
  110e53:	0f b6 46 09          	movzbl 0x9(%esi),%eax
  110e57:	50                   	push   %eax
  110e58:	8d 45 bc             	lea    -0x44(%ebp),%eax
  110e5b:	50                   	push   %eax
  110e5c:	53                   	push   %ebx
  110e5d:	e8 70 03 00 00       	call   1111d2 <net_conn_input>
  110e62:	83 c4 10             	add    $0x10,%esp
	if (verdict != NET_DROP) {
  110e65:	eb 0c                	jmp    110e73 <net_ipv4_input+0x1c4>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
  110e67:	8d 45 c8             	lea    -0x38(%ebp),%eax
  110e6a:	50                   	push   %eax
  110e6b:	53                   	push   %ebx
  110e6c:	e8 eb 26 00 00       	call   11355c <net_udp_input>
  110e71:	eb d0                	jmp    110e43 <net_ipv4_input+0x194>
		return verdict;
	}
drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
}
  110e73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  110e76:	5b                   	pop    %ebx
  110e77:	5e                   	pop    %esi
  110e78:	5f                   	pop    %edi
  110e79:	5d                   	pop    %ebp
  110e7a:	c3                   	ret    

00110e7b <conn_set_unused>:

	sys_slist_prepend(&conn_used, &conn->node);
}

static void conn_set_unused(struct net_conn *conn)
{
  110e7b:	55                   	push   %ebp
  110e7c:	89 e5                	mov    %esp,%ebp
  110e7e:	53                   	push   %ebx
	(void)memset(conn, 0, sizeof(*conn));
  110e7f:	6a 20                	push   $0x20
{
  110e81:	89 c3                	mov    %eax,%ebx
	(void)memset(conn, 0, sizeof(*conn));
  110e83:	6a 00                	push   $0x0
  110e85:	50                   	push   %eax
  110e86:	e8 d0 af ff ff       	call   10be5b <memset>
Z_GENLIST_PREPEND(slist, snode)
  110e8b:	a1 f8 eb 12 00       	mov    0x12ebf8,%eax
  110e90:	83 c4 0c             	add    $0xc,%esp
	parent->next = child;
  110e93:	89 03                	mov    %eax,(%ebx)
	list->head = node;
  110e95:	89 1d f8 eb 12 00    	mov    %ebx,0x12ebf8
Z_GENLIST_PREPEND(slist, snode)
  110e9b:	83 3d fc eb 12 00 00 	cmpl   $0x0,0x12ebfc
  110ea2:	75 06                	jne    110eaa <conn_set_unused+0x2f>
	list->tail = node;
  110ea4:	89 1d fc eb 12 00    	mov    %ebx,0x12ebfc

	sys_slist_prepend(&conn_unused, &conn->node);
}
  110eaa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  110ead:	c9                   	leave  
  110eae:	c3                   	ret    

00110eaf <net_conn_register>:
		      uint16_t remote_port,
		      uint16_t local_port,
		      net_conn_cb_t cb,
		      void *user_data,
		      struct net_conn_handle **handle)
{
  110eaf:	55                   	push   %ebp
  110eb0:	89 e5                	mov    %esp,%ebp
  110eb2:	57                   	push   %edi
  110eb3:	56                   	push   %esi
  110eb4:	53                   	push   %ebx
  110eb5:	83 ec 1c             	sub    $0x1c,%esp
  110eb8:	8b 45 08             	mov    0x8(%ebp),%eax
  110ebb:	8b 5d 10             	mov    0x10(%ebp),%ebx
  110ebe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  110ec1:	8b 45 0c             	mov    0xc(%ebp),%eax
  110ec4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  110ec7:	8b 45 18             	mov    0x18(%ebp),%eax
  110eca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  110ecd:	8b 45 1c             	mov    0x1c(%ebp),%eax
  110ed0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  110ed3:	8a 45 e0             	mov    -0x20(%ebp),%al
  110ed6:	88 45 db             	mov    %al,-0x25(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
  110ed9:	a1 f0 eb 12 00       	mov    0x12ebf0,%eax
{
  110ede:	8b 75 14             	mov    0x14(%ebp),%esi
  110ee1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
  110ee4:	85 c0                	test   %eax,%eax
  110ee6:	0f 84 9c 00 00 00    	je     110f88 <net_conn_register+0xd9>
	return node->next;
  110eec:	8b 08                	mov    (%eax),%ecx
  110eee:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  110ef1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  110ef4:	86 e9                	xchg   %ch,%cl
  110ef6:	66 89 4d de          	mov    %cx,-0x22(%ebp)
  110efa:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  110efd:	86 e9                	xchg   %ch,%cl
  110eff:	66 89 4d dc          	mov    %cx,-0x24(%ebp)
		if (conn->proto != proto) {
  110f03:	66 3b 78 1c          	cmp    0x1c(%eax),%di
  110f07:	75 6c                	jne    110f75 <net_conn_register+0xc6>
		if (conn->family != family) {
  110f09:	8a 4d db             	mov    -0x25(%ebp),%cl
  110f0c:	3a 48 1e             	cmp    0x1e(%eax),%cl
  110f0f:	75 64                	jne    110f75 <net_conn_register+0xc6>
		if (remote_addr) {
  110f11:	8a 50 1f             	mov    0x1f(%eax),%dl
  110f14:	88 d1                	mov    %dl,%cl
  110f16:	83 e1 02             	and    $0x2,%ecx
  110f19:	85 db                	test   %ebx,%ebx
  110f1b:	74 19                	je     110f36 <net_conn_register+0x87>
			if (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {
  110f1d:	84 c9                	test   %cl,%cl
  110f1f:	74 54                	je     110f75 <net_conn_register+0xc6>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  110f21:	66 83 3b 01          	cmpw   $0x1,(%ebx)
  110f25:	75 4e                	jne    110f75 <net_conn_register+0xc6>
				   remote_addr->sa_family == AF_INET &&
  110f27:	66 83 78 04 01       	cmpw   $0x1,0x4(%eax)
  110f2c:	75 47                	jne    110f75 <net_conn_register+0xc6>
				if (!net_ipv4_addr_cmp(
  110f2e:	8b 48 08             	mov    0x8(%eax),%ecx
  110f31:	39 4b 04             	cmp    %ecx,0x4(%ebx)
  110f34:	eb 02                	jmp    110f38 <net_conn_register+0x89>
		} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
  110f36:	84 c9                	test   %cl,%cl
  110f38:	75 3b                	jne    110f75 <net_conn_register+0xc6>
		if (local_addr) {
  110f3a:	83 e2 04             	and    $0x4,%edx
  110f3d:	85 f6                	test   %esi,%esi
  110f3f:	74 19                	je     110f5a <net_conn_register+0xab>
			if (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {
  110f41:	84 d2                	test   %dl,%dl
  110f43:	74 30                	je     110f75 <net_conn_register+0xc6>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  110f45:	66 83 3e 01          	cmpw   $0x1,(%esi)
  110f49:	75 2a                	jne    110f75 <net_conn_register+0xc6>
				   local_addr->sa_family == AF_INET &&
  110f4b:	66 83 78 0c 01       	cmpw   $0x1,0xc(%eax)
  110f50:	75 23                	jne    110f75 <net_conn_register+0xc6>
				if (!net_ipv4_addr_cmp(
  110f52:	8b 48 10             	mov    0x10(%eax),%ecx
  110f55:	39 4e 04             	cmp    %ecx,0x4(%esi)
  110f58:	eb 02                	jmp    110f5c <net_conn_register+0xad>
		} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
  110f5a:	84 d2                	test   %dl,%dl
  110f5c:	75 17                	jne    110f75 <net_conn_register+0xc6>
		if (net_sin(&conn->remote_addr)->sin_port !=
  110f5e:	66 8b 4d de          	mov    -0x22(%ebp),%cx
  110f62:	66 3b 48 06          	cmp    0x6(%eax),%cx
  110f66:	75 0d                	jne    110f75 <net_conn_register+0xc6>
		if (net_sin(&conn->local_addr)->sin_port !=
  110f68:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  110f6b:	66 3b 48 0e          	cmp    0xe(%eax),%cx
  110f6f:	0f 84 a9 01 00 00    	je     11111e <net_conn_register+0x26f>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn_used, conn, tmp, node) {
  110f75:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  110f79:	74 0d                	je     110f88 <net_conn_register+0xd9>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  110f7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  110f7e:	8b 10                	mov    (%eax),%edx
  110f80:	89 55 f0             	mov    %edx,-0x10(%ebp)
  110f83:	e9 7b ff ff ff       	jmp    110f03 <net_conn_register+0x54>
	node = sys_slist_peek_head(&conn_unused);
  110f88:	8b 3d f8 eb 12 00    	mov    0x12ebf8,%edi
		return -EALREADY;
	}

	conn = conn_get_unused();
	if (!conn) {
		return -ENOENT;
  110f8e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!node) {
  110f93:	85 ff                	test   %edi,%edi
  110f95:	0f 84 b4 01 00 00    	je     11114f <net_conn_register+0x2a0>
Z_GENLIST_REMOVE(slist, snode)
  110f9b:	8b 07                	mov    (%edi),%eax
  110f9d:	3b 3d fc eb 12 00    	cmp    0x12ebfc,%edi
	list->head = node;
  110fa3:	a3 f8 eb 12 00       	mov    %eax,0x12ebf8
Z_GENLIST_REMOVE(slist, snode)
  110fa8:	75 05                	jne    110faf <net_conn_register+0x100>
	list->tail = node;
  110faa:	a3 fc eb 12 00       	mov    %eax,0x12ebfc
	parent->next = child;
  110faf:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	}

	if (remote_addr) {
  110fb5:	85 db                	test   %ebx,%ebx
  110fb7:	74 4d                	je     111006 <net_conn_register+0x157>
			if (!net_ipv6_is_addr_unspecified(
				    &net_sin6(remote_addr)->
				    sin6_addr)) {
				flags |= NET_CONN_REMOTE_ADDR_SPEC;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  110fb9:	66 83 3b 01          	cmpw   $0x1,(%ebx)
  110fbd:	75 1f                	jne    110fde <net_conn_register+0x12f>
			   remote_addr->sa_family == AF_INET) {
			memcpy(&conn->remote_addr, remote_addr,
  110fbf:	6a 08                	push   $0x8
  110fc1:	8d 47 04             	lea    0x4(%edi),%eax
  110fc4:	53                   	push   %ebx
  110fc5:	50                   	push   %eax
  110fc6:	e8 21 ae ff ff       	call   10bdec <memcpy>
  110fcb:	83 c4 0c             	add    $0xc,%esp
			       sizeof(struct sockaddr_in));

			if (net_sin(remote_addr)->sin_addr.s_addr) {
				flags |= NET_CONN_REMOTE_ADDR_SPEC;
  110fce:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
  110fd2:	19 d2                	sbb    %edx,%edx
  110fd4:	f7 d2                	not    %edx
  110fd6:	83 e2 20             	and    $0x20,%edx
		} else {
			NET_ERR("Remote address family not set");
			goto error;
		}

		flags |= NET_CONN_REMOTE_ADDR_SET;
  110fd9:	83 ca 02             	or     $0x2,%edx
  110fdc:	eb 2a                	jmp    111008 <net_conn_register+0x159>
			NET_ERR("Remote address family not set");
  110fde:	f6 05 b4 5b 14 00 07 	testb  $0x7,0x145bb4
  110fe5:	0f 84 25 01 00 00    	je     111110 <net_conn_register+0x261>
  110feb:	b8 e8 30 12 00       	mov    $0x1230e8,%eax
  110ff0:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  110ff5:	c1 e8 03             	shr    $0x3,%eax
  110ff8:	c1 e0 06             	shl    $0x6,%eax
  110ffb:	83 c8 01             	or     $0x1,%eax
  110ffe:	50                   	push   %eax
  110fff:	68 76 5f 12 00       	push   $0x125f76
  111004:	eb 56                	jmp    11105c <net_conn_register+0x1ad>
	uint8_t flags = 0U;
  111006:	31 d2                	xor    %edx,%edx
	}

	if (local_addr) {
  111008:	85 f6                	test   %esi,%esi
  11100a:	0f 84 8f 00 00 00    	je     11109f <net_conn_register+0x1f0>
			if (!net_ipv6_is_addr_unspecified(
				    &net_sin6(local_addr)->
				    sin6_addr)) {
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  111010:	66 83 3e 01          	cmpw   $0x1,(%esi)
  111014:	88 55 f0             	mov    %dl,-0x10(%ebp)
  111017:	75 1d                	jne    111036 <net_conn_register+0x187>
			   local_addr->sa_family == AF_INET) {
			memcpy(&conn->local_addr, local_addr,
  111019:	6a 08                	push   $0x8
  11101b:	8d 47 0c             	lea    0xc(%edi),%eax
  11101e:	56                   	push   %esi
  11101f:	50                   	push   %eax
  111020:	e8 c7 ad ff ff       	call   10bdec <memcpy>
  111025:	83 c4 0c             	add    $0xc,%esp
			       sizeof(struct sockaddr_in));

			if (net_sin(local_addr)->sin_addr.s_addr) {
  111028:	8a 55 f0             	mov    -0x10(%ebp),%dl
  11102b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  11102f:	74 37                	je     111068 <net_conn_register+0x1b9>
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
  111031:	83 ca 40             	or     $0x40,%edx
  111034:	eb 32                	jmp    111068 <net_conn_register+0x1b9>
		} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&
			   local_addr->sa_family == AF_PACKET) {
			memcpy(&conn->local_addr, local_addr,
			       sizeof(struct sockaddr_ll));
		} else {
			NET_ERR("Local address family not set");
  111036:	f6 05 b4 5b 14 00 07 	testb  $0x7,0x145bb4
  11103d:	0f 84 cd 00 00 00    	je     111110 <net_conn_register+0x261>
  111043:	b8 e8 30 12 00       	mov    $0x1230e8,%eax
  111048:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11104d:	c1 e8 03             	shr    $0x3,%eax
  111050:	c1 e0 06             	shl    $0x6,%eax
  111053:	83 c8 01             	or     $0x1,%eax
  111056:	50                   	push   %eax
  111057:	68 94 5f 12 00       	push   $0x125f94
  11105c:	e8 ec 24 ff ff       	call   10354d <log_0>
  111061:	58                   	pop    %eax
  111062:	5a                   	pop    %edx
  111063:	e9 a8 00 00 00       	jmp    111110 <net_conn_register+0x261>
			goto error;
		}

		flags |= NET_CONN_LOCAL_ADDR_SET;
  111068:	83 ca 04             	or     $0x4,%edx
	}

	if (remote_addr && local_addr) {
  11106b:	85 db                	test   %ebx,%ebx
  11106d:	74 30                	je     11109f <net_conn_register+0x1f0>
		if (remote_addr->sa_family != local_addr->sa_family) {
  11106f:	66 8b 06             	mov    (%esi),%ax
  111072:	66 39 03             	cmp    %ax,(%ebx)
  111075:	74 28                	je     11109f <net_conn_register+0x1f0>
			NET_ERR("Address families different");
  111077:	f6 05 b4 5b 14 00 07 	testb  $0x7,0x145bb4
  11107e:	0f 84 8c 00 00 00    	je     111110 <net_conn_register+0x261>
  111084:	b8 e8 30 12 00       	mov    $0x1230e8,%eax
  111089:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11108e:	c1 e8 03             	shr    $0x3,%eax
  111091:	c1 e0 06             	shl    $0x6,%eax
  111094:	83 c8 01             	or     $0x1,%eax
  111097:	50                   	push   %eax
  111098:	68 b1 5f 12 00       	push   $0x125fb1
  11109d:	eb bd                	jmp    11105c <net_conn_register+0x1ad>
			goto error;
		}
	}

	if (remote_port) {
  11109f:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%ebp)
  1110a4:	74 0c                	je     1110b2 <net_conn_register+0x203>
		flags |= NET_CONN_REMOTE_PORT_SPEC;
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
  1110a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
		flags |= NET_CONN_REMOTE_PORT_SPEC;
  1110a9:	83 ca 08             	or     $0x8,%edx
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
  1110ac:	86 e0                	xchg   %ah,%al
  1110ae:	66 89 47 06          	mov    %ax,0x6(%edi)
	}

	if (local_port) {
  1110b2:	66 83 7d e8 00       	cmpw   $0x0,-0x18(%ebp)
  1110b7:	74 0c                	je     1110c5 <net_conn_register+0x216>
		flags |= NET_CONN_LOCAL_PORT_SPEC;
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
  1110b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
		flags |= NET_CONN_LOCAL_PORT_SPEC;
  1110bc:	83 ca 10             	or     $0x10,%edx
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
  1110bf:	86 e0                	xchg   %ah,%al
  1110c1:	66 89 47 0e          	mov    %ax,0xe(%edi)
	}

	conn->cb = cb;
  1110c5:	8b 45 20             	mov    0x20(%ebp),%eax
	conn->user_data = user_data;
	conn->flags = flags;
  1110c8:	88 57 1f             	mov    %dl,0x1f(%edi)
	conn->cb = cb;
  1110cb:	89 47 14             	mov    %eax,0x14(%edi)
	conn->user_data = user_data;
  1110ce:	8b 45 24             	mov    0x24(%ebp),%eax
  1110d1:	89 47 18             	mov    %eax,0x18(%edi)
	conn->proto = proto;
  1110d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1110d7:	66 89 47 1c          	mov    %ax,0x1c(%edi)
	conn->family = family;
  1110db:	8a 45 e0             	mov    -0x20(%ebp),%al

	if (handle) {
  1110de:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
	conn->family = family;
  1110e2:	88 47 1e             	mov    %al,0x1e(%edi)
	if (handle) {
  1110e5:	74 05                	je     1110ec <net_conn_register+0x23d>
		*handle = (struct net_conn_handle *)conn;
  1110e7:	8b 45 28             	mov    0x28(%ebp),%eax
  1110ea:	89 38                	mov    %edi,(%eax)
Z_GENLIST_PREPEND(slist, snode)
  1110ec:	a1 f0 eb 12 00       	mov    0x12ebf0,%eax
	parent->next = child;
  1110f1:	89 07                	mov    %eax,(%edi)

	conn_set_used(conn);

	conn_register_debug(conn, remote_port, local_port);

	return 0;
  1110f3:	31 c0                	xor    %eax,%eax
	conn->flags |= NET_CONN_IN_USE;
  1110f5:	80 4f 1f 01          	orb    $0x1,0x1f(%edi)
	list->head = node;
  1110f9:	89 3d f0 eb 12 00    	mov    %edi,0x12ebf0
Z_GENLIST_PREPEND(slist, snode)
  1110ff:	83 3d f4 eb 12 00 00 	cmpl   $0x0,0x12ebf4
  111106:	75 47                	jne    11114f <net_conn_register+0x2a0>
	list->tail = node;
  111108:	89 3d f4 eb 12 00    	mov    %edi,0x12ebf4
}
  11110e:	eb 3f                	jmp    11114f <net_conn_register+0x2a0>
error:
	conn_set_unused(conn);
  111110:	89 f8                	mov    %edi,%eax
  111112:	e8 64 fd ff ff       	call   110e7b <conn_set_unused>
	return -EINVAL;
  111117:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  11111c:	eb 31                	jmp    11114f <net_conn_register+0x2a0>
		NET_ERR("Identical connection handler %p already found.", conn);
  11111e:	f6 05 b4 5b 14 00 07 	testb  $0x7,0x145bb4
  111125:	74 23                	je     11114a <net_conn_register+0x29b>
  111127:	ba e8 30 12 00       	mov    $0x1230e8,%edx
  11112c:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  111132:	c1 ea 03             	shr    $0x3,%edx
  111135:	c1 e2 06             	shl    $0x6,%edx
  111138:	83 ca 01             	or     $0x1,%edx
  11113b:	52                   	push   %edx
  11113c:	50                   	push   %eax
  11113d:	68 47 5f 12 00       	push   $0x125f47
  111142:	e8 2f 24 ff ff       	call   103576 <log_1>
  111147:	83 c4 0c             	add    $0xc,%esp
		return -EALREADY;
  11114a:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
}
  11114f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111152:	5b                   	pop    %ebx
  111153:	5e                   	pop    %esi
  111154:	5f                   	pop    %edi
  111155:	5d                   	pop    %ebp
  111156:	c3                   	ret    

00111157 <net_conn_unregister>:

int net_conn_unregister(struct net_conn_handle *handle)
{
  111157:	55                   	push   %ebp
  111158:	89 e5                	mov    %esp,%ebp
  11115a:	8b 45 08             	mov    0x8(%ebp),%eax
	struct net_conn *conn = (struct net_conn *)handle;

	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
  11115d:	3d c0 af 12 00       	cmp    $0x12afc0,%eax
  111162:	77 65                	ja     1111c9 <net_conn_unregister+0x72>
  111164:	3d 40 af 12 00       	cmp    $0x12af40,%eax
  111169:	72 5e                	jb     1111c9 <net_conn_unregister+0x72>
		return -EINVAL;
	}

	if (!(conn->flags & NET_CONN_IN_USE)) {
  11116b:	f6 40 1f 01          	testb  $0x1,0x1f(%eax)
		return -ENOENT;
  11116f:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
	if (!(conn->flags & NET_CONN_IN_USE)) {
  111174:	74 58                	je     1111ce <net_conn_unregister+0x77>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  111176:	8b 15 f0 eb 12 00    	mov    0x12ebf0,%edx
  11117c:	31 c9                	xor    %ecx,%ecx
  11117e:	85 d2                	test   %edx,%edx
  111180:	74 3e                	je     1111c0 <net_conn_unregister+0x69>
  111182:	39 d0                	cmp    %edx,%eax
  111184:	75 34                	jne    1111ba <net_conn_unregister+0x63>
Z_GENLIST_REMOVE(slist, snode)
  111186:	8b 10                	mov    (%eax),%edx
  111188:	85 c9                	test   %ecx,%ecx
  11118a:	75 16                	jne    1111a2 <net_conn_unregister+0x4b>
  11118c:	3b 05 f4 eb 12 00    	cmp    0x12ebf4,%eax
	list->head = node;
  111192:	89 15 f0 eb 12 00    	mov    %edx,0x12ebf0
Z_GENLIST_REMOVE(slist, snode)
  111198:	75 18                	jne    1111b2 <net_conn_unregister+0x5b>
	list->tail = node;
  11119a:	89 15 f4 eb 12 00    	mov    %edx,0x12ebf4
}
  1111a0:	eb 10                	jmp    1111b2 <net_conn_unregister+0x5b>
	parent->next = child;
  1111a2:	89 11                	mov    %edx,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
  1111a4:	3b 05 f4 eb 12 00    	cmp    0x12ebf4,%eax
  1111aa:	75 06                	jne    1111b2 <net_conn_unregister+0x5b>
	list->tail = node;
  1111ac:	89 0d f4 eb 12 00    	mov    %ecx,0x12ebf4
	parent->next = child;
  1111b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
Z_GENLIST_REMOVE(slist, snode)
  1111b8:	eb 06                	jmp    1111c0 <net_conn_unregister+0x69>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1111ba:	89 d1                	mov    %edx,%ecx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  1111bc:	8b 12                	mov    (%edx),%edx
  1111be:	eb be                	jmp    11117e <net_conn_unregister+0x27>

	NET_DBG("Connection handler %p removed", conn);

	sys_slist_find_and_remove(&conn_used, &conn->node);

	conn_set_unused(conn);
  1111c0:	e8 b6 fc ff ff       	call   110e7b <conn_set_unused>

	return 0;
  1111c5:	31 d2                	xor    %edx,%edx
  1111c7:	eb 05                	jmp    1111ce <net_conn_unregister+0x77>
		return -EINVAL;
  1111c9:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  1111ce:	89 d0                	mov    %edx,%eax
  1111d0:	5d                   	pop    %ebp
  1111d1:	c3                   	ret    

001111d2 <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				uint8_t proto,
				union net_proto_header *proto_hdr)
{
  1111d2:	55                   	push   %ebp
  1111d3:	89 e5                	mov    %esp,%ebp
  1111d5:	57                   	push   %edi
  1111d6:	56                   	push   %esi
  1111d7:	53                   	push   %ebx
  1111d8:	83 ec 10             	sub    $0x10,%esp
  1111db:	8b 45 10             	mov    0x10(%ebp),%eax
  1111de:	8b 75 08             	mov    0x8(%ebp),%esi
  1111e1:	88 45 ea             	mov    %al,-0x16(%ebp)
	int16_t best_rank = -1;
	struct net_conn *conn;
	uint16_t src_port;
	uint16_t dst_port;

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
  1111e4:	3c 11                	cmp    $0x11,%al
  1111e6:	75 0e                	jne    1111f6 <net_conn_input+0x24>
		src_port = proto_hdr->udp->src_port;
  1111e8:	8b 45 14             	mov    0x14(%ebp),%eax
  1111eb:	8b 00                	mov    (%eax),%eax
  1111ed:	66 8b 08             	mov    (%eax),%cx
  1111f0:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
		dst_port = proto_hdr->udp->dst_port;
  1111f4:	eb 1c                	jmp    111212 <net_conn_input+0x40>
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
  1111f6:	3c 06                	cmp    $0x6,%al
  1111f8:	0f 85 54 02 00 00    	jne    111452 <net_conn_input+0x280>
		if (proto_hdr->tcp == NULL) {
  1111fe:	8b 45 14             	mov    0x14(%ebp),%eax
  111201:	8b 00                	mov    (%eax),%eax
  111203:	85 c0                	test   %eax,%eax
  111205:	0f 84 47 02 00 00    	je     111452 <net_conn_input+0x280>
			return NET_DROP;
		}

		src_port = proto_hdr->tcp->src_port;
  11120b:	66 8b 38             	mov    (%eax),%di
  11120e:	66 89 7d ec          	mov    %di,-0x14(%ebp)
		dst_port = proto_hdr->tcp->dst_port;
  111212:	66 8b 40 02          	mov    0x2(%eax),%ax
  111216:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	return pkt->family;
  11121a:	8a 46 3f             	mov    0x3f(%esi),%al
  11121d:	d0 e8                	shr    %al
  11121f:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
  111222:	fe c8                	dec    %al
  111224:	74 09                	je     11122f <net_conn_input+0x5d>
	bool is_bcast_pkt = false;
  111226:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
  11122a:	e9 87 00 00 00       	jmp    1112b6 <net_conn_input+0xe4>
	struct net_if *pkt_iface = net_pkt_iface(pkt);
  11122f:	8b 46 20             	mov    0x20(%esi),%eax
  111232:	89 45 f0             	mov    %eax,-0x10(%ebp)
				      &ip_hdr->ipv4->dst) ||
  111235:	8b 45 0c             	mov    0xc(%ebp),%eax
  111238:	8b 38                	mov    (%eax),%edi
		if (net_ipv4_addr_cmp(&ip_hdr->ipv4->src,
  11123a:	8b 47 10             	mov    0x10(%edi),%eax
  11123d:	39 47 0c             	cmp    %eax,0xc(%edi)
  111240:	0f 84 13 02 00 00    	je     111459 <net_conn_input+0x287>
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
  111246:	6a 00                	push   $0x0
		    net_ipv4_is_my_addr(&ip_hdr->ipv4->src)) {
  111248:	8d 5f 0c             	lea    0xc(%edi),%ebx
  11124b:	53                   	push   %ebx
  11124c:	e8 20 c6 ff ff       	call   10d871 <net_if_ipv4_addr_lookup>
  111251:	59                   	pop    %ecx
  111252:	85 c0                	test   %eax,%eax
  111254:	5a                   	pop    %edx
  111255:	0f 95 c0             	setne  %al
	if (!ret) {
  111258:	75 25                	jne    11127f <net_conn_input+0xad>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
  11125a:	e8 fa d2 ff ff       	call   10e559 <net_ipv4_broadcast_address>
  11125f:	8b 00                	mov    (%eax),%eax
  111261:	39 47 0c             	cmp    %eax,0xc(%edi)
  111264:	75 0f                	jne    111275 <net_conn_input+0xa3>
	} else {
		NET_DBG("No suitable protocol handler configured");
		return NET_DROP;
	}

	if (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {
  111266:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  111269:	66 39 4d ee          	cmp    %cx,-0x12(%ebp)
  11126d:	0f 84 df 01 00 00    	je     111452 <net_conn_input+0x280>
  111273:	eb 0e                	jmp    111283 <net_conn_input+0xb1>
	return net_if_ipv4_is_addr_bcast(iface, addr);
  111275:	53                   	push   %ebx
  111276:	6a 00                	push   $0x0
  111278:	e8 97 c4 ff ff       	call   10d714 <net_if_ipv4_is_addr_bcast>
  11127d:	5f                   	pop    %edi
  11127e:	5a                   	pop    %edx
				      &ip_hdr->ipv4->dst) ||
  11127f:	84 c0                	test   %al,%al
  111281:	75 e3                	jne    111266 <net_conn_input+0x94>
  111283:	8a 46 3f             	mov    0x3f(%esi),%al
  111286:	d0 e8                	shr    %al
  111288:	83 e0 07             	and    $0x7,%eax
		ntohs(src_port), ntohs(dst_port), net_pkt_family(pkt));

	/* If we receive a packet with multicast destination address, we might
	 * need to deliver the packet to multiple recipients.
	 */
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
  11128b:	fe c8                	dec    %al
  11128d:	75 97                	jne    111226 <net_conn_input+0x54>
		if (net_ipv4_is_addr_mcast(&ip_hdr->ipv4->dst)) {
  11128f:	8b 45 0c             	mov    0xc(%ebp),%eax
  111292:	8b 00                	mov    (%eax),%eax
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xF0000000) == 0xE0000000;
  111294:	8b 50 10             	mov    0x10(%eax),%edx
  111297:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  11129d:	81 fa e0 00 00 00    	cmp    $0xe0,%edx
  1112a3:	74 17                	je     1112bc <net_conn_input+0xea>
  1112a5:	83 c0 10             	add    $0x10,%eax
			is_mcast_pkt = true;
		} else if (net_if_ipv4_is_addr_bcast(pkt_iface,
  1112a8:	50                   	push   %eax
  1112a9:	ff 75 f0             	pushl  -0x10(%ebp)
  1112ac:	e8 63 c4 ff ff       	call   10d714 <net_if_ipv4_is_addr_bcast>
  1112b1:	59                   	pop    %ecx
  1112b2:	88 45 eb             	mov    %al,-0x15(%ebp)
  1112b5:	5b                   	pop    %ebx
	bool is_mcast_pkt = false, mcast_pkt_delivered = false;
  1112b6:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
  1112ba:	eb 08                	jmp    1112c4 <net_conn_input+0xf2>
	bool is_bcast_pkt = false;
  1112bc:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
			is_mcast_pkt = true;
  1112c0:	c6 45 f0 01          	movb   $0x1,-0x10(%ebp)
	return list->head;
  1112c4:	8b 1d f0 eb 12 00    	mov    0x12ebf0,%ebx
		if (net_ipv6_is_addr_mcast(&ip_hdr->ipv6->dst)) {
			is_mcast_pkt = true;
		}
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
  1112ca:	66 c7 45 e8 ff ff    	movw   $0xffff,-0x18(%ebp)
  1112d0:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  1112d4:	31 ff                	xor    %edi,%edi
  1112d6:	85 db                	test   %ebx,%ebx
  1112d8:	0f 84 1c 01 00 00    	je     1113fa <net_conn_input+0x228>
		    IS_ENABLED(CONFIG_NET_SOCKETS_PACKET)) {
			if ((conn->proto != proto) && (proto != ETH_P_ALL)) {
				continue;
			}
		} else {
			if ((conn->proto != proto)) {
  1112de:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  1112e2:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  1112e6:	0f 85 07 01 00 00    	jne    1113f3 <net_conn_input+0x221>
				continue;
			}
		}

		if (conn->family != AF_UNSPEC &&
  1112ec:	8a 43 1e             	mov    0x1e(%ebx),%al
  1112ef:	84 c0                	test   %al,%al
  1112f1:	74 10                	je     111303 <net_conn_input+0x131>
  1112f3:	8a 56 3f             	mov    0x3f(%esi),%dl
  1112f6:	d0 ea                	shr    %dl
  1112f8:	83 e2 07             	and    $0x7,%edx
  1112fb:	38 d0                	cmp    %dl,%al
  1112fd:	0f 85 f0 00 00 00    	jne    1113f3 <net_conn_input+0x221>
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_UDP) ||
		    IS_ENABLED(CONFIG_NET_TCP)) {
			if (net_sin(&conn->remote_addr)->sin_port) {
  111303:	66 8b 43 06          	mov    0x6(%ebx),%ax
				if (net_sin(&conn->remote_addr)->sin_port !=
  111307:	66 3b 45 ec          	cmp    -0x14(%ebp),%ax
  11130b:	74 09                	je     111316 <net_conn_input+0x144>
  11130d:	66 85 c0             	test   %ax,%ax
  111310:	0f 85 dd 00 00 00    	jne    1113f3 <net_conn_input+0x221>
				    src_port) {
					continue;
				}
			}

			if (net_sin(&conn->local_addr)->sin_port) {
  111316:	66 8b 43 0e          	mov    0xe(%ebx),%ax
				if (net_sin(&conn->local_addr)->sin_port !=
  11131a:	66 3b 45 ee          	cmp    -0x12(%ebp),%ax
  11131e:	74 09                	je     111329 <net_conn_input+0x157>
  111320:	66 85 c0             	test   %ax,%ax
  111323:	0f 85 ca 00 00 00    	jne    1113f3 <net_conn_input+0x221>
				    dst_port) {
					continue;
				}
			}

			if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
  111329:	8a 53 1f             	mov    0x1f(%ebx),%dl
  11132c:	f6 c2 02             	test   $0x2,%dl
  11132f:	74 2e                	je     11135f <net_conn_input+0x18d>
  111331:	8a 46 3f             	mov    0x3f(%esi),%al
  111334:	d0 e8                	shr    %al
  111336:	83 e0 07             	and    $0x7,%eax
	if (addr->sa_family != net_pkt_family(pkt)) {
  111339:	0f b6 c8             	movzbl %al,%ecx
  11133c:	66 39 4b 04          	cmp    %cx,0x4(%ebx)
  111340:	0f 85 ad 00 00 00    	jne    1113f3 <net_conn_input+0x221>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  111346:	fe c8                	dec    %al
  111348:	75 15                	jne    11135f <net_conn_input+0x18d>
		if (net_sin(addr)->sin_addr.s_addr) {
  11134a:	8b 43 08             	mov    0x8(%ebx),%eax
  11134d:	85 c0                	test   %eax,%eax
  11134f:	74 0e                	je     11135f <net_conn_input+0x18d>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
  111351:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  111354:	8b 09                	mov    (%ecx),%ecx
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
  111356:	3b 41 0c             	cmp    0xc(%ecx),%eax
  111359:	0f 85 94 00 00 00    	jne    1113f3 <net_conn_input+0x221>
						   true)) {
					continue;
				}
			}

			if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
  11135f:	f6 c2 04             	test   $0x4,%dl
  111362:	74 26                	je     11138a <net_conn_input+0x1b8>
  111364:	8a 46 3f             	mov    0x3f(%esi),%al
  111367:	d0 e8                	shr    %al
  111369:	83 e0 07             	and    $0x7,%eax
	if (addr->sa_family != net_pkt_family(pkt)) {
  11136c:	0f b6 c8             	movzbl %al,%ecx
  11136f:	66 39 4b 0c          	cmp    %cx,0xc(%ebx)
  111373:	75 7e                	jne    1113f3 <net_conn_input+0x221>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  111375:	fe c8                	dec    %al
  111377:	75 11                	jne    11138a <net_conn_input+0x1b8>
		if (net_sin(addr)->sin_addr.s_addr) {
  111379:	8b 43 10             	mov    0x10(%ebx),%eax
  11137c:	85 c0                	test   %eax,%eax
  11137e:	74 0a                	je     11138a <net_conn_input+0x1b8>
  111380:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  111383:	8b 09                	mov    (%ecx),%ecx
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
  111385:	3b 41 10             	cmp    0x10(%ecx),%eax
  111388:	75 69                	jne    1113f3 <net_conn_input+0x221>

			/* If we have an existing best_match, and that one
			 * specifies a remote port, then we've matched to a
			 * LISTENING connection that should not override.
			 */
			if (best_match != NULL &&
  11138a:	85 ff                	test   %edi,%edi
  11138c:	74 06                	je     111394 <net_conn_input+0x1c2>
  11138e:	f6 47 1f 08          	testb  $0x8,0x1f(%edi)
  111392:	75 5f                	jne    1113f3 <net_conn_input+0x221>
			    best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
				continue;
			}

			if (best_rank < NET_CONN_RANK(conn->flags)) {
  111394:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
  111398:	88 d1                	mov    %dl,%cl
  11139a:	83 e2 78             	and    $0x78,%edx
  11139d:	83 e1 78             	and    $0x78,%ecx
  1113a0:	39 d0                	cmp    %edx,%eax
  1113a2:	7d 4f                	jge    1113f3 <net_conn_input+0x221>
				struct net_pkt *mcast_pkt;

				if (!is_mcast_pkt) {
  1113a4:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  1113a8:	75 0b                	jne    1113b5 <net_conn_input+0x1e3>
					best_rank = NET_CONN_RANK(conn->flags);
  1113aa:	0f b6 c1             	movzbl %cl,%eax
  1113ad:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
					best_match = conn;

					continue;
  1113b1:	89 df                	mov    %ebx,%edi
  1113b3:	eb 3e                	jmp    1113f3 <net_conn_input+0x221>
				 */

				NET_DBG("[%p] mcast match found cb %p ud %p",
					conn, conn->cb,	conn->user_data);

				mcast_pkt = net_pkt_clone(pkt, CLONE_TIMEOUT);
  1113b5:	6a 00                	push   $0x0
  1113b7:	6a 0a                	push   $0xa
  1113b9:	56                   	push   %esi
  1113ba:	e8 e5 ee ff ff       	call   1102a4 <net_pkt_clone>
  1113bf:	83 c4 0c             	add    $0xc,%esp
				if (!mcast_pkt) {
  1113c2:	85 c0                	test   %eax,%eax
  1113c4:	0f 84 88 00 00 00    	je     111452 <net_conn_input+0x280>
					goto drop;
				}

				if (conn->cb(conn, mcast_pkt, ip_hdr,
  1113ca:	ff 73 18             	pushl  0x18(%ebx)
  1113cd:	ff 75 14             	pushl  0x14(%ebp)
  1113d0:	ff 75 0c             	pushl  0xc(%ebp)
  1113d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1113d6:	50                   	push   %eax
  1113d7:	53                   	push   %ebx
  1113d8:	ff 53 14             	call   *0x14(%ebx)
  1113db:	83 c4 14             	add    $0x14,%esp
  1113de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1113e1:	83 f8 02             	cmp    $0x2,%eax
  1113e4:	75 07                	jne    1113ed <net_conn_input+0x21b>
					     proto_hdr, conn->user_data) ==
								NET_DROP) {
					net_stats_update_per_proto_drop(
							pkt_iface, proto);
					net_pkt_unref(mcast_pkt);
  1113e6:	52                   	push   %edx
  1113e7:	e8 90 e6 ff ff       	call   10fa7c <net_pkt_unref>
  1113ec:	5a                   	pop    %edx
				} else {
					net_stats_update_per_proto_recv(
						pkt_iface, proto);
				}

				mcast_pkt_delivered = true;
  1113ed:	8a 45 f0             	mov    -0x10(%ebp),%al
  1113f0:	88 45 e4             	mov    %al,-0x1c(%ebp)
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1113f3:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  1113f5:	e9 dc fe ff ff       	jmp    1112d6 <net_conn_input+0x104>
			best_rank = 0;
			best_match = conn;
		}
	}

	if ((is_mcast_pkt && mcast_pkt_delivered) || raw_pkt_delivered) {
  1113fa:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  1113fe:	74 0f                	je     11140f <net_conn_input+0x23d>
  111400:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  111404:	74 09                	je     11140f <net_conn_input+0x23d>
		/* As one or more multicast or raw socket packets have already
		 * been delivered in the loop above, we shall not call the
		 * callback again here.
		 */

		net_pkt_unref(pkt);
  111406:	56                   	push   %esi
  111407:	e8 70 e6 ff ff       	call   10fa7c <net_pkt_unref>
  11140c:	58                   	pop    %eax

		return NET_OK;
  11140d:	eb 1a                	jmp    111429 <net_conn_input+0x257>
	}

	conn = best_match;
	if (conn) {
  11140f:	85 ff                	test   %edi,%edi
  111411:	74 1a                	je     11142d <net_conn_input+0x25b>
		NET_DBG("[%p] match found cb %p ud %p rank 0x%02x",
			conn, conn->cb, conn->user_data, conn->flags);

		if (conn->cb(conn, pkt, ip_hdr, proto_hdr,
  111413:	ff 77 18             	pushl  0x18(%edi)
  111416:	ff 75 14             	pushl  0x14(%ebp)
  111419:	ff 75 0c             	pushl  0xc(%ebp)
  11141c:	56                   	push   %esi
  11141d:	57                   	push   %edi
  11141e:	ff 57 14             	call   *0x14(%edi)
  111421:	83 c4 14             	add    $0x14,%esp
  111424:	83 f8 02             	cmp    $0x2,%eax
  111427:	74 29                	je     111452 <net_conn_input+0x280>
			goto drop;
		}

		net_stats_update_per_proto_recv(pkt_iface, proto);

		return NET_OK;
  111429:	31 c0                	xor    %eax,%eax
  11142b:	eb 3a                	jmp    111467 <net_conn_input+0x295>
  11142d:	8a 46 3f             	mov    0x3f(%esi),%al
  111430:	d0 e8                	shr    %al
  111432:	83 e0 07             	and    $0x7,%eax
	 * sense here.
	 */
	if (IS_ENABLED(CONFIG_NET_IPV6) &&
	    net_pkt_family(pkt) == AF_INET6 && is_mcast_pkt) {
		;
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  111435:	fe c8                	dec    %al
  111437:	75 0c                	jne    111445 <net_conn_input+0x273>
		   net_pkt_family(pkt) == AF_INET &&
  111439:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
  11143d:	75 13                	jne    111452 <net_conn_input+0x280>
  11143f:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  111443:	75 0d                	jne    111452 <net_conn_input+0x280>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
  111445:	6a 03                	push   $0x3
  111447:	6a 03                	push   $0x3
  111449:	56                   	push   %esi
  11144a:	e8 73 f4 ff ff       	call   1108c2 <net_icmpv4_send_error>
  11144f:	83 c4 0c             	add    $0xc,%esp
	}

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
  111452:	b8 02 00 00 00       	mov    $0x2,%eax
}
  111457:	eb 0e                	jmp    111467 <net_conn_input+0x295>
	if (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {
  111459:	8b 7d ec             	mov    -0x14(%ebp),%edi
  11145c:	66 39 7d ee          	cmp    %di,-0x12(%ebp)
  111460:	74 f0                	je     111452 <net_conn_input+0x280>
  111462:	e9 28 fe ff ff       	jmp    11128f <net_conn_input+0xbd>
}
  111467:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11146a:	5b                   	pop    %ebx
  11146b:	5e                   	pop    %esi
  11146c:	5f                   	pop    %edi
  11146d:	5d                   	pop    %ebp
  11146e:	c3                   	ret    

0011146f <net_conn_init>:
	list->head = NULL;
  11146f:	c7 05 f0 eb 12 00 00 	movl   $0x0,0x12ebf0
  111476:	00 00 00 
	list->tail = NULL;
  111479:	c7 05 f4 eb 12 00 00 	movl   $0x0,0x12ebf4
  111480:	00 00 00 
	parent->next = child;
  111483:	c7 05 40 af 12 00 00 	movl   $0x0,0x12af40
  11148a:	00 00 00 
  11148d:	c7 05 60 af 12 00 40 	movl   $0x12af40,0x12af60
  111494:	af 12 00 
  111497:	c7 05 80 af 12 00 60 	movl   $0x12af60,0x12af80
  11149e:	af 12 00 
  1114a1:	c7 05 a0 af 12 00 80 	movl   $0x12af80,0x12afa0
  1114a8:	af 12 00 
	int i;

	sys_slist_init(&conn_unused);
	sys_slist_init(&conn_used);

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
  1114ab:	c7 05 f8 eb 12 00 a0 	movl   $0x12afa0,0x12ebf8
  1114b2:	af 12 00 
  1114b5:	c7 05 fc eb 12 00 40 	movl   $0x12af40,0x12ebfc
  1114bc:	af 12 00 
		sys_slist_prepend(&conn_unused, &conns[i].node);
	}
}
  1114bf:	c3                   	ret    

001114c0 <net_buf_frags_len>:
	size_t bytes = 0;
  1114c0:	31 d2                	xor    %edx,%edx
	while (buf) {
  1114c2:	85 c0                	test   %eax,%eax
  1114c4:	74 0a                	je     1114d0 <net_buf_frags_len+0x10>
		bytes += buf->len;
  1114c6:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
  1114ca:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  1114cc:	01 ca                	add    %ecx,%edx
		buf = buf->frags;
  1114ce:	eb f2                	jmp    1114c2 <net_buf_frags_len+0x2>
}
  1114d0:	89 d0                	mov    %edx,%eax
  1114d2:	c3                   	ret    

001114d3 <tcp_fin_timeout>:
	/* Extra unref from net_tcp_put() */
	net_context_unref(conn->context);
}

static void tcp_fin_timeout(struct k_work *work)
{
  1114d3:	55                   	push   %ebp
  1114d4:	89 e5                	mov    %esp,%ebp

	NET_DBG("Did not receive FIN in %dms", FIN_TIMEOUT_MS);
	NET_DBG("conn: %p %s", conn, log_strdup(tcp_conn_state(conn, NULL)));

	/* Extra unref from net_tcp_put() */
	net_context_unref(conn->context);
  1114d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1114d9:	8b 80 10 ff ff ff    	mov    -0xf0(%eax),%eax
  1114df:	89 45 08             	mov    %eax,0x8(%ebp)
}
  1114e2:	5d                   	pop    %ebp
	net_context_unref(conn->context);
  1114e3:	e9 39 d8 ff ff       	jmp    10ed21 <net_context_unref>

001114e8 <tcp_timewait_timeout>:
{
  1114e8:	55                   	push   %ebp
  1114e9:	89 e5                	mov    %esp,%ebp
	net_context_unref(conn->context);
  1114eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1114ee:	8b 80 34 ff ff ff    	mov    -0xcc(%eax),%eax
  1114f4:	89 45 08             	mov    %eax,0x8(%ebp)
}
  1114f7:	5d                   	pop    %ebp
	net_context_unref(conn->context);
  1114f8:	e9 24 d8 ff ff       	jmp    10ed21 <net_context_unref>

001114fd <tcp_send>:
{
  1114fd:	55                   	push   %ebp
  1114fe:	89 e5                	mov    %esp,%ebp
  111500:	53                   	push   %ebx
	tcp_pkt_ref(pkt);
  111501:	50                   	push   %eax
{
  111502:	89 c3                	mov    %eax,%ebx
	tcp_pkt_ref(pkt);
  111504:	e8 3c e5 ff ff       	call   10fa45 <net_pkt_ref>
	if (tcp_send_cb) {
  111509:	a1 04 ec 12 00       	mov    0x12ec04,%eax
	tcp_pkt_ref(pkt);
  11150e:	59                   	pop    %ecx
	if (tcp_send_cb) {
  11150f:	85 c0                	test   %eax,%eax
  111511:	74 3a                	je     11154d <tcp_send+0x50>
		if (tcp_send_cb(pkt) < 0) {
  111513:	53                   	push   %ebx
  111514:	ff d0                	call   *%eax
  111516:	5a                   	pop    %edx
  111517:	85 c0                	test   %eax,%eax
  111519:	79 3a                	jns    111555 <tcp_send+0x58>
			NET_ERR("net_send_data()");
  11151b:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  111522:	74 20                	je     111544 <tcp_send+0x47>
  111524:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  111529:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11152e:	c1 e8 03             	shr    $0x3,%eax
  111531:	c1 e0 06             	shl    $0x6,%eax
  111534:	83 c8 01             	or     $0x1,%eax
  111537:	50                   	push   %eax
  111538:	68 d5 5f 12 00       	push   $0x125fd5
  11153d:	e8 0b 20 ff ff       	call   10354d <log_0>
  111542:	59                   	pop    %ecx
  111543:	58                   	pop    %eax
			tcp_pkt_unref(pkt);
  111544:	53                   	push   %ebx
  111545:	e8 32 e5 ff ff       	call   10fa7c <net_pkt_unref>
  11154a:	5a                   	pop    %edx
  11154b:	eb 08                	jmp    111555 <tcp_send+0x58>
	if (net_send_data(pkt) < 0) {
  11154d:	53                   	push   %ebx
  11154e:	e8 ef bb ff ff       	call   10d142 <net_send_data>
  111553:	eb c1                	jmp    111516 <tcp_send+0x19>
	tcp_pkt_unref(pkt);
  111555:	53                   	push   %ebx
  111556:	e8 21 e5 ff ff       	call   10fa7c <net_pkt_unref>
  11155b:	58                   	pop    %eax
}
  11155c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11155f:	c9                   	leave  
  111560:	c3                   	ret    

00111561 <k_delayed_work_submit>:
{
  111561:	55                   	push   %ebp
  111562:	89 e5                	mov    %esp,%ebp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
  111564:	51                   	push   %ecx
  111565:	52                   	push   %edx
  111566:	50                   	push   %eax
  111567:	68 00 ea 12 00       	push   $0x12ea00
  11156c:	e8 66 09 01 00       	call   121ed7 <k_delayed_work_submit_to_queue>
  111571:	83 c4 10             	add    $0x10,%esp
}
  111574:	c9                   	leave  
  111575:	c3                   	ret    

00111576 <k_mutex_unlock>:
{
  111576:	55                   	push   %ebp
  111577:	89 e5                	mov    %esp,%ebp
	return z_impl_k_mutex_unlock(mutex);
  111579:	50                   	push   %eax
  11157a:	e8 4f f7 00 00       	call   120cce <z_impl_k_mutex_unlock>
  11157f:	5a                   	pop    %edx
}
  111580:	c9                   	leave  
  111581:	c3                   	ret    

00111582 <th_get>:
{
  111582:	55                   	push   %ebp
  111583:	89 e5                	mov    %esp,%ebp
  111585:	57                   	push   %edi
  111586:	56                   	push   %esi
  111587:	53                   	push   %ebx
  111588:	89 c3                	mov    %eax,%ebx
  11158a:	83 ec 10             	sub    $0x10,%esp
	size_t ip_len = net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt);
  11158d:	0f b6 50 3c          	movzbl 0x3c(%eax),%edx
  111591:	0f b6 40 43          	movzbl 0x43(%eax),%eax
  111595:	01 d0                	add    %edx,%eax
  111597:	89 45 e8             	mov    %eax,-0x18(%ebp)
	net_pkt_cursor_init(pkt);
  11159a:	53                   	push   %ebx
  11159b:	e8 4a e6 ff ff       	call   10fbea <net_pkt_cursor_init>
  1115a0:	5f                   	pop    %edi
	pkt->overwrite = overwrite;
  1115a1:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	if (net_pkt_skip(pkt, ip_len) != 0) {
  1115a5:	ff 75 e8             	pushl  -0x18(%ebp)
  1115a8:	53                   	push   %ebx
  1115a9:	e8 5d ea ff ff       	call   11000b <net_pkt_skip>
  1115ae:	5a                   	pop    %edx
  1115af:	85 c0                	test   %eax,%eax
  1115b1:	59                   	pop    %ecx
  1115b2:	0f 85 31 01 00 00    	jne    1116e9 <th_get+0x167>
	if (!net_pkt_is_contiguous(pkt, sizeof(*th))) {
  1115b8:	6a 14                	push   $0x14
  1115ba:	53                   	push   %ebx
  1115bb:	e8 f7 ed ff ff       	call   1103b7 <net_pkt_is_contiguous>
  1115c0:	59                   	pop    %ecx
  1115c1:	84 c0                	test   %al,%al
  1115c3:	5e                   	pop    %esi
  1115c4:	0f 85 13 01 00 00    	jne    1116dd <th_get+0x15b>
	struct net_buf *buf, *first = pkt->cursor.buf, *second = first->frags;
  1115ca:	8b 43 14             	mov    0x14(%ebx),%eax
  1115cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1115d0:	8b 30                	mov    (%eax),%esi
	if (net_pkt_get_len(pkt) < (pos + len)) {
  1115d2:	8b 43 10             	mov    0x10(%ebx),%eax
  1115d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return net_buf_frags_len(pkt->frags);
  1115d8:	e8 e3 fe ff ff       	call   1114c0 <net_buf_frags_len>
  1115dd:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1115e0:	8d 79 14             	lea    0x14(%ecx),%edi
  1115e3:	39 f8                	cmp    %edi,%eax
  1115e5:	73 3e                	jae    111625 <th_get+0xa3>
		NET_ERR("Insufficient packet len=%zd (pos+len=%zu)",
  1115e7:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  1115ee:	0f 84 f5 00 00 00    	je     1116e9 <th_get+0x167>
  1115f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1115f7:	bb a0 31 12 00       	mov    $0x1231a0,%ebx
  1115fc:	e8 bf fe ff ff       	call   1114c0 <net_buf_frags_len>
  111601:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  111607:	c1 eb 03             	shr    $0x3,%ebx
  11160a:	c1 e3 06             	shl    $0x6,%ebx
  11160d:	83 cb 01             	or     $0x1,%ebx
  111610:	53                   	push   %ebx
  111611:	57                   	push   %edi
  111612:	50                   	push   %eax
  111613:	68 e5 5f 12 00       	push   $0x125fe5
  111618:	e8 93 1f ff ff       	call   1035b0 <log_2>
  11161d:	83 c4 10             	add    $0x10,%esp
	return ret;
  111620:	e9 c4 00 00 00       	jmp    1116e9 <th_get+0x167>
	buf = net_pkt_get_frag(pkt, TCP_PKT_ALLOC_TIMEOUT);
  111625:	6a 00                	push   $0x0
  111627:	6a 0a                	push   $0xa
  111629:	53                   	push   %ebx
  11162a:	e8 ef e3 ff ff       	call   10fa1e <net_pkt_get_frag>
  11162f:	83 c4 0c             	add    $0xc,%esp
  111632:	89 c7                	mov    %eax,%edi
	if (!buf || buf->size < len) {
  111634:	85 c0                	test   %eax,%eax
  111636:	0f 84 ad 00 00 00    	je     1116e9 <th_get+0x167>
  11163c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  111640:	83 f8 13             	cmp    $0x13,%eax
  111643:	0f 86 99 00 00 00    	jbe    1116e2 <th_get+0x160>
	net_buf_linearize(buf->data, buf->size, pkt->frags, pos, len);
  111649:	6a 14                	push   $0x14
  11164b:	ff 75 e8             	pushl  -0x18(%ebp)
  11164e:	ff 73 10             	pushl  0x10(%ebx)
  111651:	50                   	push   %eax
  111652:	ff 77 08             	pushl  0x8(%edi)
  111655:	e8 4d ab ff ff       	call   10c1a7 <net_buf_linearize>
  11165a:	83 c4 14             	add    $0x14,%esp
	net_buf_add(buf, len);
  11165d:	8d 47 08             	lea    0x8(%edi),%eax
  111660:	6a 14                	push   $0x14
  111662:	50                   	push   %eax
  111663:	e8 af ab ff ff       	call   10c217 <net_buf_simple_add>
  111668:	58                   	pop    %eax
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
  111669:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11166c:	8b 4b 14             	mov    0x14(%ebx),%ecx
	net_buf_add(buf, len);
  11166f:	5a                   	pop    %edx
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
  111670:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  111674:	8b 53 18             	mov    0x18(%ebx),%edx
  111677:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  11167b:	2b 51 08             	sub    0x8(%ecx),%edx
	first->len -= len1;
  11167e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	len1 = first->len - (pkt->cursor.pos - pkt->cursor.buf->data);
  111681:	29 d0                	sub    %edx,%eax
	len2 = len - len1;
  111683:	ba 14 00 00 00       	mov    $0x14,%edx
	first->len -= len1;
  111688:	29 c1                	sub    %eax,%ecx
	len2 = len - len1;
  11168a:	29 c2                	sub    %eax,%edx
	first->len -= len1;
  11168c:	89 c8                	mov    %ecx,%eax
  11168e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	len2 = len - len1;
  111691:	89 55 ec             	mov    %edx,-0x14(%ebp)
	first->len -= len1;
  111694:	66 89 41 0c          	mov    %ax,0xc(%ecx)
	while (len2) {
  111698:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  11169c:	74 33                	je     1116d1 <th_get+0x14f>
		size_t pull_len = MIN(second->len, len2);
  11169e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  1116a2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1116a5:	76 03                	jbe    1116aa <th_get+0x128>
  1116a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
		net_buf_pull(second, pull_len);
  1116aa:	50                   	push   %eax
		len2 -= pull_len;
  1116ab:	29 45 ec             	sub    %eax,-0x14(%ebp)
		net_buf_pull(second, pull_len);
  1116ae:	8d 46 08             	lea    0x8(%esi),%eax
  1116b1:	50                   	push   %eax
  1116b2:	e8 91 ab ff ff       	call   10c248 <net_buf_simple_pull>
  1116b7:	59                   	pop    %ecx
  1116b8:	58                   	pop    %eax
		next = second->frags;
  1116b9:	8b 06                	mov    (%esi),%eax
		if (second->len == 0) {
  1116bb:	66 83 7e 0c 00       	cmpw   $0x0,0xc(%esi)
		next = second->frags;
  1116c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (second->len == 0) {
  1116c3:	75 07                	jne    1116cc <th_get+0x14a>
			net_buf_unref(second);
  1116c5:	56                   	push   %esi
  1116c6:	e8 30 aa ff ff       	call   10c0fb <net_buf_unref>
  1116cb:	5a                   	pop    %edx
{
  1116cc:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  1116cf:	eb c7                	jmp    111698 <th_get+0x116>
	first->frags = buf;
  1116d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
	buf->frags = second;
  1116d4:	89 37                	mov    %esi,(%edi)
	first->frags = buf;
  1116d6:	89 38                	mov    %edi,(%eax)
	return ret;
  1116d8:	e9 bd fe ff ff       	jmp    11159a <th_get+0x18>
	th = net_pkt_cursor_get_pos(pkt);
  1116dd:	8b 43 18             	mov    0x18(%ebx),%eax
	return pkt->cursor.pos;
  1116e0:	eb 09                	jmp    1116eb <th_get+0x169>
			net_buf_unref(buf);
  1116e2:	57                   	push   %edi
  1116e3:	e8 13 aa ff ff       	call   10c0fb <net_buf_unref>
  1116e8:	58                   	pop    %eax
	struct tcphdr *th = NULL;
  1116e9:	31 c0                	xor    %eax,%eax
}
  1116eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1116ee:	5b                   	pop    %ebx
  1116ef:	5e                   	pop    %esi
  1116f0:	5f                   	pop    %edi
  1116f1:	5d                   	pop    %ebp
  1116f2:	c3                   	ret    

001116f3 <tcp_data_len>:
{
  1116f3:	55                   	push   %ebp
  1116f4:	89 e5                	mov    %esp,%ebp
  1116f6:	56                   	push   %esi
  1116f7:	53                   	push   %ebx
  1116f8:	89 c3                	mov    %eax,%ebx
	struct tcphdr *th = th_get(pkt);
  1116fa:	e8 83 fe ff ff       	call   111582 <th_get>
  1116ff:	89 c6                	mov    %eax,%esi
	return net_buf_frags_len(pkt->frags);
  111701:	8b 43 10             	mov    0x10(%ebx),%eax
  111704:	e8 b7 fd ff ff       	call   1114c0 <net_buf_frags_len>
	int len = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
  111709:	0f b6 53 3c          	movzbl 0x3c(%ebx),%edx
		net_pkt_ip_opts_len(pkt) - sizeof(*th) - tcp_options_len;
  11170d:	0f b6 4b 43          	movzbl 0x43(%ebx),%ecx
  111711:	01 ca                	add    %ecx,%edx
  111713:	29 d0                	sub    %edx,%eax
	size_t tcp_options_len = (th->th_off - 5) * 4;
  111715:	8a 56 0c             	mov    0xc(%esi),%dl
  111718:	c0 ea 04             	shr    $0x4,%dl
  11171b:	0f b6 d2             	movzbl %dl,%edx
  11171e:	c1 e2 02             	shl    $0x2,%edx
	return len > 0 ? (size_t)len : 0;
  111721:	29 d0                	sub    %edx,%eax
  111723:	79 02                	jns    111727 <tcp_data_len+0x34>
  111725:	31 c0                	xor    %eax,%eax
}
  111727:	5b                   	pop    %ebx
  111728:	5e                   	pop    %esi
  111729:	5d                   	pop    %ebp
  11172a:	c3                   	ret    

0011172b <tcp_data_get>:
{
  11172b:	55                   	push   %ebp
  11172c:	89 e5                	mov    %esp,%ebp
  11172e:	57                   	push   %edi
  11172f:	56                   	push   %esi
  111730:	89 c6                	mov    %eax,%esi
	int len = tcp_data_len(pkt);
  111732:	89 d0                	mov    %edx,%eax
{
  111734:	53                   	push   %ebx
  111735:	89 d3                	mov    %edx,%ebx
	int len = tcp_data_len(pkt);
  111737:	e8 b7 ff ff ff       	call   1116f3 <tcp_data_len>
  11173c:	89 c7                	mov    %eax,%edi
	if (tcp_recv_cb) {
  11173e:	a1 00 ec 12 00       	mov    0x12ec00,%eax
  111743:	85 c0                	test   %eax,%eax
  111745:	74 06                	je     11174d <tcp_data_get+0x22>
		tcp_recv_cb(conn, pkt);
  111747:	53                   	push   %ebx
  111748:	56                   	push   %esi
  111749:	ff d0                	call   *%eax
  11174b:	eb 4f                	jmp    11179c <tcp_data_get+0x71>
	if (len > 0) {
  11174d:	85 ff                	test   %edi,%edi
  11174f:	7e 4d                	jle    11179e <tcp_data_get+0x73>
		if (conn->context->recv_cb) {
  111751:	8b 46 04             	mov    0x4(%esi),%eax
  111754:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
  111758:	74 44                	je     11179e <tcp_data_get+0x73>
				net_pkt_clone(pkt, TCP_PKT_ALLOC_TIMEOUT);
  11175a:	6a 00                	push   $0x0
  11175c:	6a 0a                	push   $0xa
  11175e:	53                   	push   %ebx
  11175f:	e8 40 eb ff ff       	call   1102a4 <net_pkt_clone>
  111764:	83 c4 0c             	add    $0xc,%esp
  111767:	89 c3                	mov    %eax,%ebx
			if (!up) {
  111769:	85 c0                	test   %eax,%eax
  11176b:	75 07                	jne    111774 <tcp_data_get+0x49>
				len = -ENOBUFS;
  11176d:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
  111772:	eb 2a                	jmp    11179e <tcp_data_get+0x73>
			net_pkt_cursor_init(up);
  111774:	50                   	push   %eax
  111775:	e8 70 e4 ff ff       	call   10fbea <net_pkt_cursor_init>
  11177a:	59                   	pop    %ecx
  11177b:	8b 43 10             	mov    0x10(%ebx),%eax
	pkt->overwrite = overwrite;
  11177e:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	return net_buf_frags_len(pkt->frags);
  111782:	e8 39 fd ff ff       	call   1114c0 <net_buf_frags_len>
			k_fifo_put(&conn->recv_data, up);
  111787:	83 c6 5c             	add    $0x5c,%esi
			net_pkt_skip(up, net_pkt_get_len(up) - len);
  11178a:	29 f8                	sub    %edi,%eax
  11178c:	50                   	push   %eax
  11178d:	53                   	push   %ebx
  11178e:	e8 78 e8 ff ff       	call   11000b <net_pkt_skip>
  111793:	58                   	pop    %eax
  111794:	5a                   	pop    %edx
			k_fifo_put(&conn->recv_data, up);
  111795:	53                   	push   %ebx
  111796:	56                   	push   %esi
  111797:	e8 7d f7 00 00       	call   120f19 <k_queue_append>
  11179c:	58                   	pop    %eax
  11179d:	5a                   	pop    %edx
}
  11179e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1117a1:	89 f8                	mov    %edi,%eax
  1117a3:	5b                   	pop    %ebx
  1117a4:	5e                   	pop    %esi
  1117a5:	5f                   	pop    %edi
  1117a6:	5d                   	pop    %ebp
  1117a7:	c3                   	ret    

001117a8 <tcp_endpoint_set>:
{
  1117a8:	55                   	push   %ebp
  1117a9:	89 e5                	mov    %esp,%ebp
  1117ab:	57                   	push   %edi
  1117ac:	56                   	push   %esi
  1117ad:	89 ce                	mov    %ecx,%esi
  1117af:	53                   	push   %ebx
  1117b0:	53                   	push   %ebx
	return pkt->family;
  1117b1:	8a 4a 3f             	mov    0x3f(%edx),%cl
  1117b4:	d0 e9                	shr    %cl
  1117b6:	83 e1 07             	and    $0x7,%ecx
	switch (net_pkt_family(pkt)) {
  1117b9:	80 f9 01             	cmp    $0x1,%cl
  1117bc:	74 10                	je     1117ce <tcp_endpoint_set+0x26>
  1117be:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  1117c3:	80 f9 02             	cmp    $0x2,%cl
  1117c6:	0f 84 89 00 00 00    	je     111855 <tcp_endpoint_set+0xad>
  1117cc:	eb 53                	jmp    111821 <tcp_endpoint_set+0x79>
  1117ce:	89 c3                	mov    %eax,%ebx
  1117d0:	89 d0                	mov    %edx,%eax
	return pkt->frags->data;
  1117d2:	8b 52 10             	mov    0x10(%edx),%edx
  1117d5:	8b 7a 08             	mov    0x8(%edx),%edi
			th = th_get(pkt);
  1117d8:	e8 a5 fd ff ff       	call   111582 <th_get>
				return -ENOBUFS;
  1117dd:	ba c9 ff ff ff       	mov    $0xffffffc9,%edx
			if (!th) {
  1117e2:	85 c0                	test   %eax,%eax
  1117e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1117e7:	74 6c                	je     111855 <tcp_endpoint_set+0xad>
			memset(ep, 0, sizeof(*ep));
  1117e9:	6a 18                	push   $0x18
  1117eb:	6a 00                	push   $0x0
  1117ed:	53                   	push   %ebx
  1117ee:	e8 68 a6 ff ff       	call   10be5b <memset>
  1117f3:	83 c4 0c             	add    $0xc,%esp
			ep->sin.sin_port = src == TCP_EP_SRC ? th->th_sport :
  1117f6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1117f9:	83 fe 01             	cmp    $0x1,%esi
  1117fc:	75 04                	jne    111802 <tcp_endpoint_set+0x5a>
  1117fe:	8b 01                	mov    (%ecx),%eax
  111800:	eb 04                	jmp    111806 <tcp_endpoint_set+0x5e>
  111802:	66 8b 41 02          	mov    0x2(%ecx),%ax
  111806:	66 89 43 02          	mov    %ax,0x2(%ebx)
			net_ipaddr_copy(&ep->sin.sin_addr,
  11180a:	4e                   	dec    %esi
  11180b:	8d 47 10             	lea    0x10(%edi),%eax
  11180e:	75 03                	jne    111813 <tcp_endpoint_set+0x6b>
  111810:	8d 47 0c             	lea    0xc(%edi),%eax
  111813:	8b 00                	mov    (%eax),%eax
	int ret = 0;
  111815:	31 d2                	xor    %edx,%edx
			net_ipaddr_copy(&ep->sin.sin_addr,
  111817:	89 43 04             	mov    %eax,0x4(%ebx)
			ep->sa.sa_family = AF_INET;
  11181a:	66 c7 03 01 00       	movw   $0x1,(%ebx)
		break;
  11181f:	eb 34                	jmp    111855 <tcp_endpoint_set+0xad>
		NET_ERR("Unknown address family: %hu", net_pkt_family(pkt));
  111821:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  111828:	74 2b                	je     111855 <tcp_endpoint_set+0xad>
  11182a:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  11182f:	89 55 f0             	mov    %edx,-0x10(%ebp)
  111832:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  111837:	c1 e8 03             	shr    $0x3,%eax
  11183a:	c1 e0 06             	shl    $0x6,%eax
  11183d:	83 c8 01             	or     $0x1,%eax
  111840:	50                   	push   %eax
  111841:	0f b6 c9             	movzbl %cl,%ecx
  111844:	51                   	push   %ecx
  111845:	68 0f 60 12 00       	push   $0x12600f
  11184a:	e8 27 1d ff ff       	call   103576 <log_1>
  11184f:	83 c4 0c             	add    $0xc,%esp
  111852:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
  111855:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111858:	89 d0                	mov    %edx,%eax
  11185a:	5b                   	pop    %ebx
  11185b:	5e                   	pop    %esi
  11185c:	5f                   	pop    %edi
  11185d:	5d                   	pop    %ebp
  11185e:	c3                   	ret    

0011185f <tcp_endpoint_cmp>:
	return ret;
}

static bool tcp_endpoint_cmp(union tcp_endpoint *ep, struct net_pkt *pkt,
			     enum pkt_addr which)
{
  11185f:	55                   	push   %ebp
  111860:	89 e5                	mov    %esp,%ebp
  111862:	56                   	push   %esi
  111863:	53                   	push   %ebx
  111864:	89 c3                	mov    %eax,%ebx
	union tcp_endpoint ep_tmp;

	if (tcp_endpoint_set(&ep_tmp, pkt, which) < 0) {
  111866:	8d 75 e0             	lea    -0x20(%ebp),%esi
{
  111869:	83 ec 18             	sub    $0x18,%esp
	if (tcp_endpoint_set(&ep_tmp, pkt, which) < 0) {
  11186c:	89 f0                	mov    %esi,%eax
  11186e:	e8 35 ff ff ff       	call   1117a8 <tcp_endpoint_set>
  111873:	85 c0                	test   %eax,%eax
  111875:	78 22                	js     111899 <tcp_endpoint_cmp+0x3a>
	return (af == AF_INET) ? sizeof(struct sockaddr_in) :
  111877:	31 c0                	xor    %eax,%eax
  111879:	66 83 3b 01          	cmpw   $0x1,(%ebx)
  11187d:	0f 95 c0             	setne  %al
  111880:	48                   	dec    %eax
  111881:	83 e0 f0             	and    $0xfffffff0,%eax
  111884:	83 c0 18             	add    $0x18,%eax
		return false;
	}

	return !memcmp(ep, &ep_tmp, tcp_endpoint_len(ep->sa.sa_family));
  111887:	50                   	push   %eax
  111888:	56                   	push   %esi
  111889:	53                   	push   %ebx
  11188a:	e8 f0 a4 ff ff       	call   10bd7f <memcmp>
  11188f:	83 c4 0c             	add    $0xc,%esp
  111892:	85 c0                	test   %eax,%eax
  111894:	0f 94 c0             	sete   %al
  111897:	eb 02                	jmp    11189b <tcp_endpoint_cmp+0x3c>
		return false;
  111899:	31 c0                	xor    %eax,%eax
}
  11189b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11189e:	5b                   	pop    %ebx
  11189f:	5e                   	pop    %esi
  1118a0:	5d                   	pop    %ebp
  1118a1:	c3                   	ret    

001118a2 <k_mutex_lock.constprop.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
  1118a2:	55                   	push   %ebp
  1118a3:	89 e5                	mov    %esp,%ebp
  1118a5:	53                   	push   %ebx
	return z_impl_k_mutex_lock(mutex, timeout);
  1118a6:	51                   	push   %ecx
  1118a7:	52                   	push   %edx
  1118a8:	50                   	push   %eax
  1118a9:	e8 22 f3 00 00       	call   120bd0 <z_impl_k_mutex_lock>
  1118ae:	83 c4 0c             	add    $0xc,%esp
}
  1118b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1118b4:	c9                   	leave  
  1118b5:	c3                   	ret    

001118b6 <tcp_send_queue_flush>:
{
  1118b6:	55                   	push   %ebp
  1118b7:	89 e5                	mov    %esp,%ebp
  1118b9:	53                   	push   %ebx
  1118ba:	89 c3                	mov    %eax,%ebx
	k_delayed_work_cancel(&conn->send_timer);
  1118bc:	05 88 00 00 00       	add    $0x88,%eax
  1118c1:	50                   	push   %eax
  1118c2:	e8 97 06 01 00       	call   121f5e <k_delayed_work_cancel>
		tcp_pkt_unref(pkt);
  1118c7:	58                   	pop    %eax
Z_GENLIST_IS_EMPTY(slist)
  1118c8:	8b 43 14             	mov    0x14(%ebx),%eax
Z_GENLIST_GET(slist, snode)
  1118cb:	85 c0                	test   %eax,%eax
  1118cd:	74 1a                	je     1118e9 <tcp_send_queue_flush+0x33>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  1118cf:	8b 10                	mov    (%eax),%edx
  1118d1:	3b 43 18             	cmp    0x18(%ebx),%eax
	list->head = node;
  1118d4:	89 53 14             	mov    %edx,0x14(%ebx)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  1118d7:	75 03                	jne    1118dc <tcp_send_queue_flush+0x26>
	list->tail = node;
  1118d9:	89 53 18             	mov    %edx,0x18(%ebx)
	while ((pkt = tcp_slist(&conn->send_queue, get,
  1118dc:	83 e8 38             	sub    $0x38,%eax
  1118df:	74 08                	je     1118e9 <tcp_send_queue_flush+0x33>
		tcp_pkt_unref(pkt);
  1118e1:	50                   	push   %eax
  1118e2:	e8 95 e1 ff ff       	call   10fa7c <net_pkt_unref>
  1118e7:	eb de                	jmp    1118c7 <tcp_send_queue_flush+0x11>
}
  1118e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1118ec:	c9                   	leave  
  1118ed:	c3                   	ret    

001118ee <tcp_conn_unref>:
{
  1118ee:	55                   	push   %ebp
  1118ef:	89 e5                	mov    %esp,%ebp
  1118f1:	57                   	push   %edi
  1118f2:	56                   	push   %esi
  1118f3:	53                   	push   %ebx
  1118f4:	52                   	push   %edx
  1118f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1118f8:	8b b0 54 01 00 00    	mov    0x154(%eax),%esi
	if (conn->in_connect) {
  1118fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  111901:	f6 80 6d 01 00 00 02 	testb  $0x2,0x16d(%eax)
  111908:	74 0a                	je     111914 <tcp_conn_unref+0x26>
		tcp_send_queue_flush(conn);
  11190a:	e8 a7 ff ff ff       	call   1118b6 <tcp_send_queue_flush>
		goto out;
  11190f:	e9 4e 01 00 00       	jmp    111a62 <tcp_conn_unref+0x174>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  111914:	83 ce ff             	or     $0xffffffff,%esi
  111917:	f0 0f c1 b0 54 01 00 	lock xadd %esi,0x154(%eax)
  11191e:	00 
	if (ref_count) {
  11191f:	4e                   	dec    %esi
  111920:	0f 85 3c 01 00 00    	jne    111a62 <tcp_conn_unref+0x174>
  111926:	9c                   	pushf  
  111927:	fa                   	cli    
  111928:	5f                   	pop    %edi
	while ((pkt = k_fifo_get(&conn->recv_data, K_NO_WAIT)) != NULL) {
  111929:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11192c:	83 c0 5c             	add    $0x5c,%eax
	return z_impl_k_queue_get(queue, timeout);
  11192f:	6a 00                	push   $0x0
  111931:	6a 00                	push   $0x0
  111933:	50                   	push   %eax
  111934:	e8 1e f6 00 00       	call   120f57 <z_impl_k_queue_get>
  111939:	83 c4 0c             	add    $0xc,%esp
  11193c:	89 c3                	mov    %eax,%ebx
  11193e:	85 c0                	test   %eax,%eax
  111940:	8b 45 f0             	mov    -0x10(%ebp),%eax
  111943:	74 18                	je     11195d <tcp_conn_unref+0x6f>
		net_context_packet_received(
  111945:	ff 70 10             	pushl  0x10(%eax)
  111948:	6a 00                	push   $0x0
  11194a:	6a 00                	push   $0x0
  11194c:	53                   	push   %ebx
			(struct net_conn *)conn->context->conn_handler,
  11194d:	8b 40 04             	mov    0x4(%eax),%eax
		net_context_packet_received(
  111950:	ff 70 34             	pushl  0x34(%eax)
  111953:	e8 e2 d0 ff ff       	call   10ea3a <net_context_packet_received>
  111958:	83 c4 14             	add    $0x14,%esp
  11195b:	eb cc                	jmp    111929 <tcp_conn_unref+0x3b>
	if (conn->context->conn_handler) {
  11195d:	8b 40 04             	mov    0x4(%eax),%eax
  111960:	8b 40 34             	mov    0x34(%eax),%eax
  111963:	85 c0                	test   %eax,%eax
  111965:	74 14                	je     11197b <tcp_conn_unref+0x8d>
		net_conn_unregister(conn->context->conn_handler);
  111967:	50                   	push   %eax
  111968:	e8 ea f7 ff ff       	call   111157 <net_conn_unregister>
  11196d:	58                   	pop    %eax
		conn->context->conn_handler = NULL;
  11196e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  111971:	8b 40 04             	mov    0x4(%eax),%eax
  111974:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
	if (conn->context->recv_cb) {
  11197b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11197e:	8b 51 04             	mov    0x4(%ecx),%edx
  111981:	8b 42 38             	mov    0x38(%edx),%eax
  111984:	85 c0                	test   %eax,%eax
  111986:	74 11                	je     111999 <tcp_conn_unref+0xab>
		conn->context->recv_cb(conn->context, NULL, NULL, NULL,
  111988:	ff 71 10             	pushl  0x10(%ecx)
  11198b:	6a ca                	push   $0xffffffca
  11198d:	6a 00                	push   $0x0
  11198f:	6a 00                	push   $0x0
  111991:	6a 00                	push   $0x0
  111993:	52                   	push   %edx
  111994:	ff d0                	call   *%eax
  111996:	83 c4 18             	add    $0x18,%esp
	conn->context->tcp = NULL;
  111999:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11199c:	8b 40 04             	mov    0x4(%eax),%eax
  11199f:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	net_context_unref(conn->context);
  1119a6:	50                   	push   %eax
  1119a7:	e8 75 d3 ff ff       	call   10ed21 <net_context_unref>
	tcp_send_queue_flush(conn);
  1119ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
	net_context_unref(conn->context);
  1119af:	59                   	pop    %ecx
	tcp_send_queue_flush(conn);
  1119b0:	e8 01 ff ff ff       	call   1118b6 <tcp_send_queue_flush>
	k_delayed_work_cancel(&conn->send_data_timer);
  1119b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1119b8:	05 ac 00 00 00       	add    $0xac,%eax
  1119bd:	50                   	push   %eax
  1119be:	e8 9b 05 01 00       	call   121f5e <k_delayed_work_cancel>
  1119c3:	58                   	pop    %eax
	tcp_pkt_unref(conn->send_data);
  1119c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1119c7:	ff 70 08             	pushl  0x8(%eax)
  1119ca:	e8 ad e0 ff ff       	call   10fa7c <net_pkt_unref>
	k_delayed_work_cancel(&conn->timewait_timer);
  1119cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1119d2:	05 d0 00 00 00       	add    $0xd0,%eax
  1119d7:	89 04 24             	mov    %eax,(%esp)
  1119da:	e8 7f 05 01 00       	call   121f5e <k_delayed_work_cancel>
	k_delayed_work_cancel(&conn->fin_timer);
  1119df:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1119e2:	05 f4 00 00 00       	add    $0xf4,%eax
  1119e7:	89 04 24             	mov    %eax,(%esp)
  1119ea:	e8 6f 05 01 00       	call   121f5e <k_delayed_work_cancel>
  1119ef:	58                   	pop    %eax
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  1119f0:	8b 15 08 ec 12 00    	mov    0x12ec08,%edx
	sys_slist_find_and_remove(&tcp_conns, &conn->next);
  1119f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1119f9:	85 d2                	test   %edx,%edx
  1119fb:	74 3e                	je     111a3b <tcp_conn_unref+0x14d>
  1119fd:	39 d0                	cmp    %edx,%eax
  1119ff:	75 34                	jne    111a35 <tcp_conn_unref+0x147>
Z_GENLIST_REMOVE(slist, snode)
  111a01:	8b 10                	mov    (%eax),%edx
  111a03:	85 db                	test   %ebx,%ebx
  111a05:	75 16                	jne    111a1d <tcp_conn_unref+0x12f>
  111a07:	3b 05 0c ec 12 00    	cmp    0x12ec0c,%eax
	list->head = node;
  111a0d:	89 15 08 ec 12 00    	mov    %edx,0x12ec08
Z_GENLIST_REMOVE(slist, snode)
  111a13:	75 18                	jne    111a2d <tcp_conn_unref+0x13f>
	list->tail = node;
  111a15:	89 15 0c ec 12 00    	mov    %edx,0x12ec0c
}
  111a1b:	eb 10                	jmp    111a2d <tcp_conn_unref+0x13f>
	parent->next = child;
  111a1d:	89 13                	mov    %edx,(%ebx)
Z_GENLIST_REMOVE(slist, snode)
  111a1f:	3b 05 0c ec 12 00    	cmp    0x12ec0c,%eax
  111a25:	75 06                	jne    111a2d <tcp_conn_unref+0x13f>
	list->tail = node;
  111a27:	89 1d 0c ec 12 00    	mov    %ebx,0x12ec0c
	parent->next = child;
  111a2d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
Z_GENLIST_REMOVE(slist, snode)
  111a33:	eb 06                	jmp    111a3b <tcp_conn_unref+0x14d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  111a35:	89 d3                	mov    %edx,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  111a37:	8b 12                	mov    (%edx),%edx
  111a39:	eb be                	jmp    1119f9 <tcp_conn_unref+0x10b>
	memset(conn, 0, sizeof(*conn));
  111a3b:	68 70 01 00 00       	push   $0x170
  111a40:	6a 00                	push   $0x0
  111a42:	50                   	push   %eax
  111a43:	e8 13 a4 ff ff       	call   10be5b <memset>
  111a48:	83 c4 0c             	add    $0xc,%esp
	k_mem_slab_free(&tcp_conns_slab, (void **)&conn);
  111a4b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  111a4e:	50                   	push   %eax
  111a4f:	68 84 5c 14 00       	push   $0x145c84
  111a54:	e8 21 ef 00 00       	call   12097a <k_mem_slab_free>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  111a59:	0f ba e7 09          	bt     $0x9,%edi
  111a5d:	58                   	pop    %eax
  111a5e:	5a                   	pop    %edx
  111a5f:	73 01                	jae    111a62 <tcp_conn_unref+0x174>
		__asm__ volatile ("sti" ::: "memory");
  111a61:	fb                   	sti    
}
  111a62:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111a65:	89 f0                	mov    %esi,%eax
  111a67:	5b                   	pop    %ebx
  111a68:	5e                   	pop    %esi
  111a69:	5f                   	pop    %edi
  111a6a:	5d                   	pop    %ebp
  111a6b:	c3                   	ret    

00111a6c <tcp_send_timer_cancel>:
	if (conn->in_retransmission == false) {
  111a6c:	f6 80 6d 01 00 00 01 	testb  $0x1,0x16d(%eax)
  111a73:	74 66                	je     111adb <tcp_send_timer_cancel+0x6f>
{
  111a75:	55                   	push   %ebp
  111a76:	89 e5                	mov    %esp,%ebp
  111a78:	56                   	push   %esi
  111a79:	53                   	push   %ebx
  111a7a:	89 c3                	mov    %eax,%ebx
	k_delayed_work_cancel(&conn->send_timer);
  111a7c:	8d b0 88 00 00 00    	lea    0x88(%eax),%esi
  111a82:	56                   	push   %esi
  111a83:	e8 d6 04 01 00       	call   121f5e <k_delayed_work_cancel>
Z_GENLIST_IS_EMPTY(slist)
  111a88:	8b 43 14             	mov    0x14(%ebx),%eax
  111a8b:	5a                   	pop    %edx
Z_GENLIST_GET(slist, snode)
  111a8c:	85 c0                	test   %eax,%eax
  111a8e:	75 0e                	jne    111a9e <tcp_send_timer_cancel+0x32>
		conn->in_retransmission = false;
  111a90:	80 a3 6d 01 00 00 fe 	andb   $0xfe,0x16d(%ebx)
}
  111a97:	8d 65 f8             	lea    -0x8(%ebp),%esp
  111a9a:	5b                   	pop    %ebx
  111a9b:	5e                   	pop    %esi
  111a9c:	5d                   	pop    %ebp
  111a9d:	c3                   	ret    
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  111a9e:	8b 10                	mov    (%eax),%edx
  111aa0:	3b 43 18             	cmp    0x18(%ebx),%eax
	list->head = node;
  111aa3:	89 53 14             	mov    %edx,0x14(%ebx)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  111aa6:	75 03                	jne    111aab <tcp_send_timer_cancel+0x3f>
	list->tail = node;
  111aa8:	89 53 18             	mov    %edx,0x18(%ebx)
		if (pkt) {
  111aab:	83 e8 38             	sub    $0x38,%eax
  111aae:	74 07                	je     111ab7 <tcp_send_timer_cancel+0x4b>
			tcp_pkt_unref(pkt);
  111ab0:	50                   	push   %eax
  111ab1:	e8 c6 df ff ff       	call   10fa7c <net_pkt_unref>
  111ab6:	58                   	pop    %eax
	if (sys_slist_is_empty(&conn->send_queue)) {
  111ab7:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
  111abb:	74 d3                	je     111a90 <tcp_send_timer_cancel+0x24>
		conn->send_retries = tcp_retries;
  111abd:	c7 83 4c 01 00 00 09 	movl   $0x9,0x14c(%ebx)
  111ac4:	00 00 00 
}
  111ac7:	8d 65 f8             	lea    -0x8(%ebp),%esp
		k_delayed_work_submit(&conn->send_timer, K_MSEC(tcp_rto));
  111aca:	89 f0                	mov    %esi,%eax
  111acc:	ba 14 00 00 00       	mov    $0x14,%edx
}
  111ad1:	5b                   	pop    %ebx
		k_delayed_work_submit(&conn->send_timer, K_MSEC(tcp_rto));
  111ad2:	31 c9                	xor    %ecx,%ecx
}
  111ad4:	5e                   	pop    %esi
  111ad5:	5d                   	pop    %ebp
		k_delayed_work_submit(&conn->send_timer, K_MSEC(tcp_rto));
  111ad6:	e9 86 fa ff ff       	jmp    111561 <k_delayed_work_submit>
  111adb:	c3                   	ret    

00111adc <tcp_send_process_no_lock>:
{
  111adc:	55                   	push   %ebp
  111add:	89 e5                	mov    %esp,%ebp
  111adf:	56                   	push   %esi
  111ae0:	53                   	push   %ebx
	pkt = tcp_slist(&conn->send_queue, peek_head,
  111ae1:	8b 70 14             	mov    0x14(%eax),%esi
  111ae4:	85 f6                	test   %esi,%esi
  111ae6:	0f 84 05 01 00 00    	je     111bf1 <tcp_send_process_no_lock+0x115>
	if (!pkt) {
  111aec:	83 ee 38             	sub    $0x38,%esi
  111aef:	0f 84 fc 00 00 00    	je     111bf1 <tcp_send_process_no_lock+0x115>
	if (conn->in_retransmission) {
  111af5:	f6 80 6d 01 00 00 01 	testb  $0x1,0x16d(%eax)
  111afc:	89 c3                	mov    %eax,%ebx
  111afe:	74 34                	je     111b34 <tcp_send_process_no_lock+0x58>
		if (conn->send_retries > 0) {
  111b00:	83 bb 4c 01 00 00 00 	cmpl   $0x0,0x14c(%ebx)
			unref = true;
  111b07:	b0 01                	mov    $0x1,%al
		if (conn->send_retries > 0) {
  111b09:	0f 84 f0 00 00 00    	je     111bff <tcp_send_process_no_lock+0x123>
			struct net_pkt *clone = tcp_pkt_clone(pkt);
  111b0f:	6a 00                	push   $0x0
  111b11:	6a 0a                	push   $0xa
  111b13:	56                   	push   %esi
  111b14:	e8 8b e7 ff ff       	call   1102a4 <net_pkt_clone>
  111b19:	83 c4 0c             	add    $0xc,%esp
			if (clone) {
  111b1c:	85 c0                	test   %eax,%eax
  111b1e:	0f 84 b2 00 00 00    	je     111bd6 <tcp_send_process_no_lock+0xfa>
				tcp_send(clone);
  111b24:	e8 d4 f9 ff ff       	call   1114fd <tcp_send>
				conn->send_retries--;
  111b29:	ff 8b 4c 01 00 00    	decl   0x14c(%ebx)
  111b2f:	e9 a2 00 00 00       	jmp    111bd6 <tcp_send_process_no_lock+0xfa>
		uint8_t fl = th_get(pkt)->th_flags;
  111b34:	89 f0                	mov    %esi,%eax
  111b36:	e8 47 fa ff ff       	call   111582 <th_get>
  111b3b:	8a 40 0d             	mov    0xd(%eax),%al
		bool forget = ACK == fl || PSH == fl || (ACK | PSH) == fl ||
  111b3e:	88 c2                	mov    %al,%dl
  111b40:	83 e2 ef             	and    $0xffffffef,%edx
  111b43:	80 fa 08             	cmp    $0x8,%dl
  111b46:	74 08                	je     111b50 <tcp_send_process_no_lock+0x74>
  111b48:	3c 10                	cmp    $0x10,%al
  111b4a:	74 04                	je     111b50 <tcp_send_process_no_lock+0x74>
						next) : tcp_pkt_clone(pkt);
  111b4c:	a8 04                	test   $0x4,%al
  111b4e:	74 45                	je     111b95 <tcp_send_process_no_lock+0xb9>
Z_GENLIST_IS_EMPTY(slist)
  111b50:	8b 43 14             	mov    0x14(%ebx),%eax
Z_GENLIST_GET(slist, snode)
  111b53:	85 c0                	test   %eax,%eax
  111b55:	75 2f                	jne    111b86 <tcp_send_process_no_lock+0xaa>
			NET_ERR("net_pkt alloc failure");
  111b57:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  111b5e:	0f 84 8d 00 00 00    	je     111bf1 <tcp_send_process_no_lock+0x115>
  111b64:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  111b69:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  111b6e:	c1 e8 03             	shr    $0x3,%eax
  111b71:	c1 e0 06             	shl    $0x6,%eax
  111b74:	83 c8 01             	or     $0x1,%eax
  111b77:	50                   	push   %eax
  111b78:	68 2b 60 12 00       	push   $0x12602b
  111b7d:	e8 cb 19 ff ff       	call   10354d <log_0>
  111b82:	59                   	pop    %ecx
  111b83:	5b                   	pop    %ebx
			goto out;
  111b84:	eb 6b                	jmp    111bf1 <tcp_send_process_no_lock+0x115>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  111b86:	8b 10                	mov    (%eax),%edx
  111b88:	3b 43 18             	cmp    0x18(%ebx),%eax
	list->head = node;
  111b8b:	89 53 14             	mov    %edx,0x14(%ebx)
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  111b8e:	75 65                	jne    111bf5 <tcp_send_process_no_lock+0x119>
	list->tail = node;
  111b90:	89 53 18             	mov    %edx,0x18(%ebx)
}
  111b93:	eb 60                	jmp    111bf5 <tcp_send_process_no_lock+0x119>
						next) : tcp_pkt_clone(pkt);
  111b95:	6a 00                	push   $0x0
  111b97:	6a 0a                	push   $0xa
  111b99:	56                   	push   %esi
		bool forget = ACK == fl || PSH == fl || (ACK | PSH) == fl ||
  111b9a:	31 f6                	xor    %esi,%esi
						next) : tcp_pkt_clone(pkt);
  111b9c:	e8 03 e7 ff ff       	call   1102a4 <net_pkt_clone>
  111ba1:	83 c4 0c             	add    $0xc,%esp
		if (!pkt) {
  111ba4:	85 c0                	test   %eax,%eax
  111ba6:	74 af                	je     111b57 <tcp_send_process_no_lock+0x7b>
		tcp_send(pkt);
  111ba8:	e8 50 f9 ff ff       	call   1114fd <tcp_send>
		if (forget == false && !k_delayed_work_remaining_get(
  111bad:	85 f6                	test   %esi,%esi
  111baf:	75 25                	jne    111bd6 <tcp_send_process_no_lock+0xfa>
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
  111bb1:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
  111bb7:	50                   	push   %eax
  111bb8:	e8 37 06 01 00       	call   1221f4 <z_timeout_remaining>
			return ((uint32_t)t) * (to_hz / from_hz);
  111bbd:	6b c0 0a             	imul   $0xa,%eax,%eax
  111bc0:	5a                   	pop    %edx
  111bc1:	85 c0                	test   %eax,%eax
  111bc3:	75 11                	jne    111bd6 <tcp_send_process_no_lock+0xfa>
			conn->in_retransmission = true;
  111bc5:	80 8b 6d 01 00 00 01 	orb    $0x1,0x16d(%ebx)
			conn->send_retries = tcp_retries;
  111bcc:	c7 83 4c 01 00 00 09 	movl   $0x9,0x14c(%ebx)
  111bd3:	00 00 00 
	if (conn->in_retransmission) {
  111bd6:	f6 83 6d 01 00 00 01 	testb  $0x1,0x16d(%ebx)
  111bdd:	74 12                	je     111bf1 <tcp_send_process_no_lock+0x115>
		k_delayed_work_submit(&conn->send_timer, K_MSEC(tcp_rto));
  111bdf:	8d 83 88 00 00 00    	lea    0x88(%ebx),%eax
  111be5:	ba 14 00 00 00       	mov    $0x14,%edx
  111bea:	31 c9                	xor    %ecx,%ecx
  111bec:	e8 70 f9 ff ff       	call   111561 <k_delayed_work_submit>
	bool unref = false;
  111bf1:	31 c0                	xor    %eax,%eax
  111bf3:	eb 0a                	jmp    111bff <tcp_send_process_no_lock+0x123>
		pkt = forget ? tcp_slist(&conn->send_queue, get, struct net_pkt,
  111bf5:	83 e8 38             	sub    $0x38,%eax
  111bf8:	be 01 00 00 00       	mov    $0x1,%esi
  111bfd:	eb a5                	jmp    111ba4 <tcp_send_process_no_lock+0xc8>
}
  111bff:	8d 65 f8             	lea    -0x8(%ebp),%esp
  111c02:	5b                   	pop    %ebx
  111c03:	5e                   	pop    %esi
  111c04:	5d                   	pop    %ebp
  111c05:	c3                   	ret    

00111c06 <tcp_out_ext>:
{
  111c06:	55                   	push   %ebp
  111c07:	89 e5                	mov    %esp,%ebp
  111c09:	57                   	push   %edi
  111c0a:	56                   	push   %esi
  111c0b:	89 c6                	mov    %eax,%esi
  111c0d:	53                   	push   %ebx
  111c0e:	89 cb                	mov    %ecx,%ebx
  111c10:	83 ec 20             	sub    $0x20,%esp
  111c13:	89 55 d4             	mov    %edx,-0x2c(%ebp)
	pkt = tcp_pkt_alloc(conn, sizeof(struct tcphdr));
  111c16:	8b 40 04             	mov    0x4(%eax),%eax
  111c19:	6a 00                	push   $0x0
  111c1b:	0f b7 80 92 00 00 00 	movzwl 0x92(%eax),%eax
  111c22:	c1 e8 03             	shr    $0x3,%eax
  111c25:	6a 0a                	push   $0xa
  111c27:	6a 06                	push   $0x6
  111c29:	83 e0 07             	and    $0x7,%eax
  111c2c:	50                   	push   %eax
  111c2d:	6a 14                	push   $0x14
  111c2f:	ff 76 0c             	pushl  0xc(%esi)
  111c32:	e8 9f e3 ff ff       	call   10ffd6 <net_pkt_alloc_with_buffer>
  111c37:	83 c4 18             	add    $0x18,%esp
	if (!pkt) {
  111c3a:	85 c0                	test   %eax,%eax
  111c3c:	0f 84 56 01 00 00    	je     111d98 <tcp_out_ext+0x192>
  111c42:	89 c7                	mov    %eax,%edi
	if (data) {
  111c44:	85 db                	test   %ebx,%ebx
  111c46:	74 12                	je     111c5a <tcp_out_ext+0x54>
		net_pkt_append_buffer(pkt, data->buffer);
  111c48:	ff 73 10             	pushl  0x10(%ebx)
  111c4b:	50                   	push   %eax
  111c4c:	e8 8c e0 ff ff       	call   10fcdd <net_pkt_append_buffer>
  111c51:	58                   	pop    %eax
  111c52:	5a                   	pop    %edx
		data->buffer = NULL;
  111c53:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	return pkt->family;
  111c5a:	8a 47 3f             	mov    0x3f(%edi),%al
  111c5d:	d0 e8                	shr    %al
  111c5f:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
  111c62:	fe c8                	dec    %al
  111c64:	0f 85 dd 00 00 00    	jne    111d47 <tcp_out_ext+0x141>
						&conn->dst.sin.sin_addr);
  111c6a:	8d 86 34 01 00 00    	lea    0x134(%esi),%eax
		return net_context_create_ipv4_new(conn->context, pkt,
  111c70:	50                   	push   %eax
						&conn->src.sin.sin_addr,
  111c71:	8d 86 1c 01 00 00    	lea    0x11c(%esi),%eax
		return net_context_create_ipv4_new(conn->context, pkt,
  111c77:	50                   	push   %eax
  111c78:	57                   	push   %edi
  111c79:	ff 76 04             	pushl  0x4(%esi)
  111c7c:	e8 a0 d3 ff ff       	call   10f021 <net_context_create_ipv4_new>
  111c81:	83 c4 10             	add    $0x10,%esp
  111c84:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  111c86:	85 c0                	test   %eax,%eax
  111c88:	0f 88 be 00 00 00    	js     111d4c <tcp_out_ext+0x146>
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct tcphdr);
  111c8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  111c91:	c7 45 dc 14 00 00 00 	movl   $0x14,-0x24(%ebp)
  111c98:	89 45 d8             	mov    %eax,-0x28(%ebp)
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
  111c9b:	8d 45 d8             	lea    -0x28(%ebp),%eax
  111c9e:	50                   	push   %eax
  111c9f:	57                   	push   %edi
  111ca0:	e8 b0 e7 ff ff       	call   110455 <net_pkt_get_data>
  111ca5:	59                   	pop    %ecx
	if (!th) {
  111ca6:	85 c0                	test   %eax,%eax
	th = (struct tcphdr *)net_pkt_get_data(pkt, &tcp_access);
  111ca8:	5b                   	pop    %ebx
  111ca9:	89 c3                	mov    %eax,%ebx
	if (!th) {
  111cab:	75 0a                	jne    111cb7 <tcp_out_ext+0xb1>
		return -ENOBUFS;
  111cad:	bb c9 ff ff ff       	mov    $0xffffffc9,%ebx
  111cb2:	e9 95 00 00 00       	jmp    111d4c <tcp_out_ext+0x146>
	memset(th, 0, sizeof(struct tcphdr));
  111cb7:	6a 14                	push   $0x14
  111cb9:	6a 00                	push   $0x0
  111cbb:	50                   	push   %eax
  111cbc:	e8 9a a1 ff ff       	call   10be5b <memset>
	th->th_sport = conn->src.sin.sin_port;
  111cc1:	66 8b 86 1a 01 00 00 	mov    0x11a(%esi),%ax
	memset(th, 0, sizeof(struct tcphdr));
  111cc8:	83 c4 0c             	add    $0xc,%esp
	th->th_sport = conn->src.sin.sin_port;
  111ccb:	66 89 03             	mov    %ax,(%ebx)
	th->th_dport = conn->dst.sin.sin_port;
  111cce:	66 8b 86 32 01 00 00 	mov    0x132(%esi),%ax
  111cd5:	66 89 43 02          	mov    %ax,0x2(%ebx)
	th->th_off = 5;
  111cd9:	8a 43 0c             	mov    0xc(%ebx),%al
  111cdc:	83 e0 0f             	and    $0xf,%eax
  111cdf:	83 c8 50             	or     $0x50,%eax
  111ce2:	88 43 0c             	mov    %al,0xc(%ebx)
	th->th_flags = flags;
  111ce5:	8a 45 d4             	mov    -0x2c(%ebp),%al
  111ce8:	88 43 0d             	mov    %al,0xd(%ebx)
	th->th_win = htons(conn->recv_win);
  111ceb:	8b 86 68 01 00 00    	mov    0x168(%esi),%eax
  111cf1:	86 e0                	xchg   %ah,%al
  111cf3:	66 89 43 0e          	mov    %ax,0xe(%ebx)
	th->th_seq = htonl(seq);
  111cf7:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ACK & flags) {
  111cfa:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  111cfe:	0f c8                	bswap  %eax
	th->th_seq = htonl(seq);
  111d00:	89 43 04             	mov    %eax,0x4(%ebx)
	if (ACK & flags) {
  111d03:	74 0b                	je     111d10 <tcp_out_ext+0x10a>
		th->th_ack = htonl(conn->ack);
  111d05:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
  111d0b:	0f c8                	bswap  %eax
  111d0d:	89 43 08             	mov    %eax,0x8(%ebx)
	return net_pkt_set_data(pkt, &tcp_access);
  111d10:	8d 45 d8             	lea    -0x28(%ebp),%eax
  111d13:	50                   	push   %eax
  111d14:	57                   	push   %edi
  111d15:	e8 ce e7 ff ff       	call   1104e8 <net_pkt_set_data>
  111d1a:	5b                   	pop    %ebx
	if (ret < 0) {
  111d1b:	85 c0                	test   %eax,%eax
	return net_pkt_set_data(pkt, &tcp_access);
  111d1d:	5a                   	pop    %edx
  111d1e:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  111d20:	78 2a                	js     111d4c <tcp_out_ext+0x146>
	net_pkt_cursor_init(pkt);
  111d22:	57                   	push   %edi
  111d23:	e8 c2 de ff ff       	call   10fbea <net_pkt_cursor_init>
  111d28:	8a 47 3f             	mov    0x3f(%edi),%al
  111d2b:	59                   	pop    %ecx
  111d2c:	d0 e8                	shr    %al
  111d2e:	83 e0 07             	and    $0x7,%eax
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
  111d31:	fe c8                	dec    %al
  111d33:	75 12                	jne    111d47 <tcp_out_ext+0x141>
		return net_ipv4_finalize(pkt, IPPROTO_TCP);
  111d35:	6a 06                	push   $0x6
  111d37:	57                   	push   %edi
  111d38:	e8 c9 ee ff ff       	call   110c06 <net_ipv4_finalize>
  111d3d:	5b                   	pop    %ebx
	if (ret < 0) {
  111d3e:	85 c0                	test   %eax,%eax
		return net_ipv4_finalize(pkt, IPPROTO_TCP);
  111d40:	5a                   	pop    %edx
  111d41:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  111d43:	79 10                	jns    111d55 <tcp_out_ext+0x14f>
  111d45:	eb 05                	jmp    111d4c <tcp_out_ext+0x146>
	return -EINVAL;
  111d47:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		tcp_pkt_unref(pkt);
  111d4c:	57                   	push   %edi
  111d4d:	e8 2a dd ff ff       	call   10fa7c <net_pkt_unref>
  111d52:	59                   	pop    %ecx
		goto out;
  111d53:	eb 48                	jmp    111d9d <tcp_out_ext+0x197>
	if (tcp_send_cb) {
  111d55:	a1 04 ec 12 00       	mov    0x12ec04,%eax
  111d5a:	85 c0                	test   %eax,%eax
  111d5c:	74 08                	je     111d66 <tcp_out_ext+0x160>
		ret = tcp_send_cb(pkt);
  111d5e:	57                   	push   %edi
  111d5f:	ff d0                	call   *%eax
  111d61:	5a                   	pop    %edx
  111d62:	89 c3                	mov    %eax,%ebx
		goto out;
  111d64:	eb 37                	jmp    111d9d <tcp_out_ext+0x197>
	parent->next = child;
  111d66:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
	sys_slist_append(&conn->send_queue, &pkt->next);
  111d6d:	8d 47 38             	lea    0x38(%edi),%eax
Z_GENLIST_APPEND(slist, snode)
  111d70:	8b 56 18             	mov    0x18(%esi),%edx
  111d73:	85 d2                	test   %edx,%edx
  111d75:	75 08                	jne    111d7f <tcp_out_ext+0x179>
	list->tail = node;
  111d77:	89 46 18             	mov    %eax,0x18(%esi)
	list->head = node;
  111d7a:	89 46 14             	mov    %eax,0x14(%esi)
}
  111d7d:	eb 05                	jmp    111d84 <tcp_out_ext+0x17e>
	parent->next = child;
  111d7f:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  111d81:	89 46 18             	mov    %eax,0x18(%esi)
	if (tcp_send_process_no_lock(conn)) {
  111d84:	89 f0                	mov    %esi,%eax
  111d86:	e8 51 fd ff ff       	call   111adc <tcp_send_process_no_lock>
  111d8b:	84 c0                	test   %al,%al
  111d8d:	74 0e                	je     111d9d <tcp_out_ext+0x197>
		tcp_conn_unref(conn);
  111d8f:	89 f0                	mov    %esi,%eax
  111d91:	e8 58 fb ff ff       	call   1118ee <tcp_conn_unref>
  111d96:	eb 05                	jmp    111d9d <tcp_out_ext+0x197>
		ret = -ENOBUFS;
  111d98:	bb c9 ff ff ff       	mov    $0xffffffc9,%ebx
}
  111d9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111da0:	89 d8                	mov    %ebx,%eax
  111da2:	5b                   	pop    %ebx
  111da3:	5e                   	pop    %esi
  111da4:	5f                   	pop    %edi
  111da5:	5d                   	pop    %ebp
  111da6:	c3                   	ret    

00111da7 <tcp_send_data>:
{
  111da7:	55                   	push   %ebp
  111da8:	89 e5                	mov    %esp,%ebp
  111daa:	57                   	push   %edi
  111dab:	56                   	push   %esi
  111dac:	53                   	push   %ebx
  111dad:	89 c3                	mov    %eax,%ebx
  111daf:	83 ec 08             	sub    $0x8,%esp
	len = MIN3(conn->send_data_total - conn->unacked_len,
  111db2:	0f b7 b3 6a 01 00 00 	movzwl 0x16a(%ebx),%esi
	pos = conn->unacked_len;
  111db9:	8b 80 50 01 00 00    	mov    0x150(%eax),%eax
	len = MIN3(conn->send_data_total - conn->unacked_len,
  111dbf:	8b 93 48 01 00 00    	mov    0x148(%ebx),%edx
  111dc5:	29 c2                	sub    %eax,%edx
  111dc7:	29 c6                	sub    %eax,%esi
	pos = conn->unacked_len;
  111dc9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	len = MIN3(conn->send_data_total - conn->unacked_len,
  111dcc:	f6 83 84 00 00 00 01 	testb  $0x1,0x84(%ebx)
  111dd3:	0f 84 18 01 00 00    	je     111ef1 <tcp_send_data+0x14a>
  111dd9:	0f b7 83 80 00 00 00 	movzwl 0x80(%ebx),%eax
  111de0:	89 c1                	mov    %eax,%ecx
  111de2:	39 c6                	cmp    %eax,%esi
  111de4:	7d 02                	jge    111de8 <tcp_send_data+0x41>
  111de6:	89 f1                	mov    %esi,%ecx
  111de8:	39 ca                	cmp    %ecx,%edx
  111dea:	73 04                	jae    111df0 <tcp_send_data+0x49>
  111dec:	89 d6                	mov    %edx,%esi
  111dee:	eb 06                	jmp    111df6 <tcp_send_data+0x4f>
  111df0:	39 c6                	cmp    %eax,%esi
  111df2:	7e 02                	jle    111df6 <tcp_send_data+0x4f>
  111df4:	89 c6                	mov    %eax,%esi
	pkt = tcp_pkt_alloc(conn, len);
  111df6:	85 f6                	test   %esi,%esi
  111df8:	7e 25                	jle    111e1f <tcp_send_data+0x78>
  111dfa:	8b 43 04             	mov    0x4(%ebx),%eax
  111dfd:	6a 00                	push   $0x0
  111dff:	6a 0a                	push   $0xa
  111e01:	0f b7 80 92 00 00 00 	movzwl 0x92(%eax),%eax
  111e08:	c1 e8 03             	shr    $0x3,%eax
  111e0b:	6a 06                	push   $0x6
  111e0d:	83 e0 07             	and    $0x7,%eax
  111e10:	50                   	push   %eax
  111e11:	56                   	push   %esi
  111e12:	ff 73 0c             	pushl  0xc(%ebx)
  111e15:	e8 bc e1 ff ff       	call   10ffd6 <net_pkt_alloc_with_buffer>
  111e1a:	83 c4 18             	add    $0x18,%esp
  111e1d:	eb 0b                	jmp    111e2a <tcp_send_data+0x83>
  111e1f:	6a 00                	push   $0x0
  111e21:	6a 0a                	push   $0xa
  111e23:	e8 53 de ff ff       	call   10fc7b <net_pkt_alloc>
  111e28:	5f                   	pop    %edi
  111e29:	5a                   	pop    %edx
	if (!pkt) {
  111e2a:	85 c0                	test   %eax,%eax
  111e2c:	75 3b                	jne    111e69 <tcp_send_data+0xc2>
		NET_ERR("conn: %p packet allocation failed, len=%d", conn, len);
  111e2e:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
		ret = -ENOBUFS;
  111e35:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
		NET_ERR("conn: %p packet allocation failed, len=%d", conn, len);
  111e3a:	0f 84 cc 00 00 00    	je     111f0c <tcp_send_data+0x165>
  111e40:	ba a0 31 12 00       	mov    $0x1231a0,%edx
  111e45:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  111e4b:	c1 ea 03             	shr    $0x3,%edx
  111e4e:	c1 e2 06             	shl    $0x6,%edx
  111e51:	83 ca 01             	or     $0x1,%edx
  111e54:	52                   	push   %edx
  111e55:	56                   	push   %esi
  111e56:	53                   	push   %ebx
  111e57:	68 41 60 12 00       	push   $0x126041
  111e5c:	e8 4f 17 ff ff       	call   1035b0 <log_2>
  111e61:	83 c4 10             	add    $0x10,%esp
  111e64:	e9 a3 00 00 00       	jmp    111f0c <tcp_send_data+0x165>
	net_pkt_cursor_init(to);
  111e69:	50                   	push   %eax
	ret = tcp_pkt_peek(pkt, conn->send_data, pos, len);
  111e6a:	8b 7b 08             	mov    0x8(%ebx),%edi
	net_pkt_cursor_init(to);
  111e6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  111e70:	e8 75 dd ff ff       	call   10fbea <net_pkt_cursor_init>
	net_pkt_cursor_init(from);
  111e75:	89 3c 24             	mov    %edi,(%esp)
  111e78:	e8 6d dd ff ff       	call   10fbea <net_pkt_cursor_init>
  111e7d:	59                   	pop    %ecx
	if (pos) {
  111e7e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  111e81:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  111e85:	74 12                	je     111e99 <tcp_send_data+0xf2>
	pkt->overwrite = overwrite;
  111e87:	80 4f 3d 01          	orb    $0x1,0x3d(%edi)
		net_pkt_skip(from, pos);
  111e8b:	ff 75 f0             	pushl  -0x10(%ebp)
  111e8e:	57                   	push   %edi
  111e8f:	e8 77 e1 ff ff       	call   11000b <net_pkt_skip>
  111e94:	58                   	pop    %eax
  111e95:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  111e98:	5a                   	pop    %edx
	return net_pkt_copy(to, from, len);
  111e99:	56                   	push   %esi
  111e9a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  111e9d:	57                   	push   %edi
  111e9e:	51                   	push   %ecx
  111e9f:	e8 e0 e1 ff ff       	call   110084 <net_pkt_copy>
  111ea4:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  111ea7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  111eaa:	85 c0                	test   %eax,%eax
  111eac:	79 0e                	jns    111ebc <tcp_send_data+0x115>
		tcp_pkt_unref(pkt);
  111eae:	51                   	push   %ecx
		ret = -ENOBUFS;
  111eaf:	bf c9 ff ff ff       	mov    $0xffffffc9,%edi
		tcp_pkt_unref(pkt);
  111eb4:	e8 c3 db ff ff       	call   10fa7c <net_pkt_unref>
  111eb9:	59                   	pop    %ecx
		goto out;
  111eba:	eb 50                	jmp    111f0c <tcp_send_data+0x165>
	ret = tcp_out_ext(conn, PSH | ACK, pkt, conn->seq + conn->unacked_len);
  111ebc:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
  111ec2:	ba 18 00 00 00       	mov    $0x18,%edx
  111ec7:	03 83 60 01 00 00    	add    0x160(%ebx),%eax
  111ecd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  111ed0:	50                   	push   %eax
  111ed1:	89 d8                	mov    %ebx,%eax
  111ed3:	e8 2e fd ff ff       	call   111c06 <tcp_out_ext>
  111ed8:	5a                   	pop    %edx
  111ed9:	89 c7                	mov    %eax,%edi
	if (ret == 0) {
  111edb:	85 c0                	test   %eax,%eax
  111edd:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  111ee0:	75 06                	jne    111ee8 <tcp_send_data+0x141>
		conn->unacked_len += len;
  111ee2:	01 b3 50 01 00 00    	add    %esi,0x150(%ebx)
	tcp_pkt_unref(pkt);
  111ee8:	51                   	push   %ecx
  111ee9:	e8 8e db ff ff       	call   10fa7c <net_pkt_unref>
  111eee:	58                   	pop    %eax
	conn_send_data_dump(conn);
  111eef:	eb 1b                	jmp    111f0c <tcp_send_data+0x165>
	len = MIN3(conn->send_data_total - conn->unacked_len,
  111ef1:	b8 00 05 00 00       	mov    $0x500,%eax
  111ef6:	b9 00 05 00 00       	mov    $0x500,%ecx
  111efb:	81 fe ff 04 00 00    	cmp    $0x4ff,%esi
  111f01:	0f 8f e1 fe ff ff    	jg     111de8 <tcp_send_data+0x41>
  111f07:	e9 da fe ff ff       	jmp    111de6 <tcp_send_data+0x3f>
}
  111f0c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111f0f:	89 f8                	mov    %edi,%eax
  111f11:	5b                   	pop    %ebx
  111f12:	5e                   	pop    %esi
  111f13:	5f                   	pop    %edi
  111f14:	5d                   	pop    %ebp
  111f15:	c3                   	ret    

00111f16 <tcp_send_queued_data.part.0>:
static int tcp_send_queued_data(struct tcp *conn)
  111f16:	55                   	push   %ebp
  111f17:	89 e5                	mov    %esp,%ebp
  111f19:	57                   	push   %edi
  111f1a:	56                   	push   %esi
  111f1b:	53                   	push   %ebx
  111f1c:	89 c3                	mov    %eax,%ebx
  111f1e:	51                   	push   %ecx
	int ret = 0;
  111f1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (conn->unacked_len > conn->send_data_total) {
  111f26:	8b bb 50 01 00 00    	mov    0x150(%ebx),%edi
  111f2c:	8b 93 48 01 00 00    	mov    0x148(%ebx),%edx
  111f32:	39 d7                	cmp    %edx,%edi
  111f34:	76 30                	jbe    111f66 <tcp_send_queued_data.part.0+0x50>
	bool subscribe = false;
  111f36:	31 f6                	xor    %esi,%esi
		NET_ERR("total=%zu, unacked_len=%d",
  111f38:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  111f3f:	74 4f                	je     111f90 <tcp_send_queued_data.part.0+0x7a>
  111f41:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  111f46:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  111f4b:	c1 e8 03             	shr    $0x3,%eax
  111f4e:	c1 e0 06             	shl    $0x6,%eax
  111f51:	83 c8 01             	or     $0x1,%eax
  111f54:	50                   	push   %eax
  111f55:	57                   	push   %edi
  111f56:	52                   	push   %edx
  111f57:	68 6b 60 12 00       	push   $0x12606b
  111f5c:	e8 4f 16 ff ff       	call   1035b0 <log_2>
  111f61:	83 c4 10             	add    $0x10,%esp
	return unsent_len;
  111f64:	eb 2a                	jmp    111f90 <tcp_send_queued_data.part.0+0x7a>
	unsent_len = conn->send_data_total - conn->unacked_len;
  111f66:	29 fa                	sub    %edi,%edx
	while (tcp_unsent_len(conn) > 0) {
  111f68:	85 d2                	test   %edx,%edx
  111f6a:	7e 22                	jle    111f8e <tcp_send_queued_data.part.0+0x78>
	bool window_full = !(conn->unacked_len < conn->send_win);
  111f6c:	0f b7 83 6a 01 00 00 	movzwl 0x16a(%ebx),%eax
		if (tcp_window_full(conn)) {
  111f73:	39 f8                	cmp    %edi,%eax
  111f75:	7e 10                	jle    111f87 <tcp_send_queued_data.part.0+0x71>
		ret = tcp_send_data(conn);
  111f77:	89 d8                	mov    %ebx,%eax
  111f79:	e8 29 fe ff ff       	call   111da7 <tcp_send_data>
  111f7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (ret < 0) {
  111f81:	85 c0                	test   %eax,%eax
  111f83:	79 a1                	jns    111f26 <tcp_send_queued_data.part.0+0x10>
  111f85:	eb 07                	jmp    111f8e <tcp_send_queued_data.part.0+0x78>
			subscribe = true;
  111f87:	be 01 00 00 00       	mov    $0x1,%esi
  111f8c:	eb 02                	jmp    111f90 <tcp_send_queued_data.part.0+0x7a>
	bool subscribe = false;
  111f8e:	31 f6                	xor    %esi,%esi
	if (conn->unacked_len) {
  111f90:	83 bb 50 01 00 00 00 	cmpl   $0x0,0x150(%ebx)
  111f97:	74 05                	je     111f9e <tcp_send_queued_data.part.0+0x88>
		subscribe = true;
  111f99:	be 01 00 00 00       	mov    $0x1,%esi
  111f9e:	8d 83 b8 00 00 00    	lea    0xb8(%ebx),%eax
	if (k_delayed_work_remaining_get(&conn->send_data_timer)) {
  111fa4:	8d bb ac 00 00 00    	lea    0xac(%ebx),%edi
  111faa:	50                   	push   %eax
  111fab:	e8 44 02 01 00       	call   1221f4 <z_timeout_remaining>
  111fb0:	6b c0 0a             	imul   $0xa,%eax,%eax
  111fb3:	5a                   	pop    %edx
  111fb4:	85 c0                	test   %eax,%eax
  111fb6:	75 08                	jne    111fc0 <tcp_send_queued_data.part.0+0xaa>
	if (ret == -ENOBUFS) {
  111fb8:	83 7d f0 c9          	cmpl   $0xffffffc9,-0x10(%ebp)
  111fbc:	75 11                	jne    111fcf <tcp_send_queued_data.part.0+0xb9>
  111fbe:	eb 08                	jmp    111fc8 <tcp_send_queued_data.part.0+0xb2>
  111fc0:	83 7d f0 c9          	cmpl   $0xffffffc9,-0x10(%ebp)
  111fc4:	75 24                	jne    111fea <tcp_send_queued_data.part.0+0xd4>
		subscribe = false;
  111fc6:	31 f6                	xor    %esi,%esi
		k_delayed_work_cancel(&conn->send_data_timer);
  111fc8:	57                   	push   %edi
  111fc9:	e8 90 ff 00 00       	call   121f5e <k_delayed_work_cancel>
  111fce:	58                   	pop    %eax
	if (subscribe) {
  111fcf:	89 f0                	mov    %esi,%eax
  111fd1:	84 c0                	test   %al,%al
  111fd3:	74 15                	je     111fea <tcp_send_queued_data.part.0+0xd4>
		conn->send_data_retries = 0;
  111fd5:	c6 83 6c 01 00 00 00 	movb   $0x0,0x16c(%ebx)
		k_delayed_work_submit(&conn->send_data_timer, K_MSEC(tcp_rto));
  111fdc:	ba 14 00 00 00       	mov    $0x14,%edx
  111fe1:	31 c9                	xor    %ecx,%ecx
  111fe3:	89 f8                	mov    %edi,%eax
  111fe5:	e8 77 f5 ff ff       	call   111561 <k_delayed_work_submit>
}
  111fea:	8b 45 f0             	mov    -0x10(%ebp),%eax
  111fed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  111ff0:	5b                   	pop    %ebx
  111ff1:	5e                   	pop    %esi
  111ff2:	5f                   	pop    %edi
  111ff3:	5d                   	pop    %ebp
  111ff4:	c3                   	ret    

00111ff5 <tcp_out>:
{
  111ff5:	55                   	push   %ebp
	(void)tcp_out_ext(conn, flags, NULL /* no data */, conn->seq);
  111ff6:	31 c9                	xor    %ecx,%ecx
{
  111ff8:	89 e5                	mov    %esp,%ebp
	(void)tcp_out_ext(conn, flags, NULL /* no data */, conn->seq);
  111ffa:	ff b0 60 01 00 00    	pushl  0x160(%eax)
  112000:	0f b6 d2             	movzbl %dl,%edx
  112003:	e8 fe fb ff ff       	call   111c06 <tcp_out_ext>
  112008:	58                   	pop    %eax
}
  112009:	c9                   	leave  
  11200a:	c3                   	ret    

0011200b <tcp_in>:
	return conn;
}

/* TCP state machine, everything happens here */
static void tcp_in(struct tcp *conn, struct net_pkt *pkt)
{
  11200b:	55                   	push   %ebp
  11200c:	89 e5                	mov    %esp,%ebp
  11200e:	57                   	push   %edi
  11200f:	56                   	push   %esi
  112010:	89 c6                	mov    %eax,%esi
  112012:	53                   	push   %ebx
  112013:	83 ec 48             	sub    $0x48,%esp
  112016:	89 55 c4             	mov    %edx,-0x3c(%ebp)
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
  112019:	85 d2                	test   %edx,%edx
  11201b:	75 0a                	jne    112027 <tcp_in+0x1c>
	uint8_t next = 0, fl = 0;
  11201d:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
  112021:	31 ff                	xor    %edi,%edi
	size_t tcp_options_len = th ? (th->th_off - 5) * 4 : 0;
  112023:	31 db                	xor    %ebx,%ebx
  112025:	eb 2d                	jmp    112054 <tcp_in+0x49>
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
  112027:	8b 45 c4             	mov    -0x3c(%ebp),%eax
	size_t tcp_options_len = th ? (th->th_off - 5) * 4 : 0;
  11202a:	31 db                	xor    %ebx,%ebx
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
  11202c:	e8 51 f5 ff ff       	call   111582 <th_get>
	uint8_t next = 0, fl = 0;
  112031:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
	struct tcphdr *th = pkt ? th_get(pkt) : NULL;
  112035:	89 c7                	mov    %eax,%edi
	size_t tcp_options_len = th ? (th->th_off - 5) * 4 : 0;
  112037:	85 c0                	test   %eax,%eax
  112039:	74 19                	je     112054 <tcp_in+0x49>
  11203b:	8a 40 0c             	mov    0xc(%eax),%al
  11203e:	c0 e8 04             	shr    $0x4,%al
  112041:	0f b6 c0             	movzbl %al,%eax
  112044:	8d 1c 85 ec ff ff ff 	lea    -0x14(,%eax,4),%ebx
	size_t len;
	int ret;

	if (th) {
		/* Currently we ignore ECN and CWR flags */
		fl = th->th_flags & ~(ECN | CWR);
  11204b:	8a 47 0d             	mov    0xd(%edi),%al
  11204e:	83 e0 3f             	and    $0x3f,%eax
  112051:	88 45 cb             	mov    %al,-0x35(%ebp)
	}

	k_mutex_lock(&conn->lock, K_FOREVER);
  112054:	83 ca ff             	or     $0xffffffff,%edx
  112057:	8d 46 20             	lea    0x20(%esi),%eax
  11205a:	89 d1                	mov    %edx,%ecx
  11205c:	89 45 b0             	mov    %eax,-0x50(%ebp)
  11205f:	e8 3e f8 ff ff       	call   1118a2 <k_mutex_lock.constprop.0>

	NET_DBG("%s", log_strdup(tcp_conn_state(conn, pkt)));

	if (th && th->th_off < 5) {
  112064:	85 ff                	test   %edi,%edi
  112066:	74 1b                	je     112083 <tcp_in+0x78>
  112068:	80 7f 0c 4f          	cmpb   $0x4f,0xc(%edi)
  11206c:	0f 87 71 08 00 00    	ja     1128e3 <tcp_in+0x8d8>
		tcp_out(conn, RST);
  112072:	ba 04 00 00 00       	mov    $0x4,%edx
  112077:	89 f0                	mov    %esi,%eax
  112079:	e8 77 ff ff ff       	call   111ff5 <tcp_out>
		conn_state(conn, TCP_CLOSED);
  11207e:	e9 e0 00 00 00       	jmp    112163 <tcp_in+0x158>
		goto next_state;
	}

	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
  112083:	85 db                	test   %ebx,%ebx
  112085:	0f 84 bb 00 00 00    	je     112146 <tcp_in+0x13b>
	backup->buf = pkt->cursor.buf;
  11208b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11208e:	8b 40 14             	mov    0x14(%eax),%eax
  112091:	89 45 bc             	mov    %eax,-0x44(%ebp)
	backup->pos = pkt->cursor.pos;
  112094:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  112097:	8b 40 18             	mov    0x18(%eax),%eax
	net_pkt_cursor_init(pkt);
  11209a:	ff 75 c4             	pushl  -0x3c(%ebp)
  11209d:	89 45 b8             	mov    %eax,-0x48(%ebp)
  1120a0:	e8 45 db ff ff       	call   10fbea <net_pkt_cursor_init>
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt) +
  1120a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  1120a8:	0f b6 50 3c          	movzbl 0x3c(%eax),%edx
  1120ac:	0f b6 40 43          	movzbl 0x43(%eax),%eax
  1120b0:	8d 44 02 14          	lea    0x14(%edx,%eax,1),%eax
  1120b4:	89 04 24             	mov    %eax,(%esp)
  1120b7:	ff 75 c4             	pushl  -0x3c(%ebp)
  1120ba:	e8 4c df ff ff       	call   11000b <net_pkt_skip>
	ret = net_pkt_read(pkt, buf, MIN(tcp_options_len, buf_len));
  1120bf:	83 fb 28             	cmp    $0x28,%ebx
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) + net_pkt_ip_opts_len(pkt) +
  1120c2:	59                   	pop    %ecx
  1120c3:	58                   	pop    %eax
	ret = net_pkt_read(pkt, buf, MIN(tcp_options_len, buf_len));
  1120c4:	89 d8                	mov    %ebx,%eax
  1120c6:	76 05                	jbe    1120cd <tcp_in+0xc2>
  1120c8:	b8 28 00 00 00       	mov    $0x28,%eax
  1120cd:	50                   	push   %eax
  1120ce:	8d 55 cc             	lea    -0x34(%ebp),%edx
  1120d1:	52                   	push   %edx
  1120d2:	ff 75 c4             	pushl  -0x3c(%ebp)
  1120d5:	e8 69 df ff ff       	call   110043 <net_pkt_read>
	if (ret < 0) {
  1120da:	8d 55 cc             	lea    -0x34(%ebp),%edx
	ret = net_pkt_read(pkt, buf, MIN(tcp_options_len, buf_len));
  1120dd:	83 c4 0c             	add    $0xc,%esp
  1120e0:	89 55 c0             	mov    %edx,-0x40(%ebp)
	if (ret < 0) {
  1120e3:	85 c0                	test   %eax,%eax
  1120e5:	79 07                	jns    1120ee <tcp_in+0xe3>
		buf = NULL;
  1120e7:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
	pkt->cursor.buf = backup->buf;
  1120ee:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  1120f1:	8b 55 bc             	mov    -0x44(%ebp),%edx
  1120f4:	89 51 14             	mov    %edx,0x14(%ecx)
	pkt->cursor.pos = backup->pos;
  1120f7:	8b 55 b8             	mov    -0x48(%ebp),%edx
  1120fa:	89 51 18             	mov    %edx,0x18(%ecx)
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
  1120fd:	89 5d b8             	mov    %ebx,-0x48(%ebp)
	recv_options->mss_found = false;
  112100:	80 a6 84 00 00 00 fc 	andb   $0xfc,0x84(%esi)
	for ( ; options && len >= 1; options += opt_len, len -= opt_len) {
  112107:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  11210b:	74 16                	je     112123 <tcp_in+0x118>
  11210d:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  112111:	7e 10                	jle    112123 <tcp_in+0x118>
		opt = options[0];
  112113:	8b 45 c0             	mov    -0x40(%ebp),%eax
  112116:	8a 00                	mov    (%eax),%al
  112118:	88 45 bc             	mov    %al,-0x44(%ebp)
		if (opt == TCPOPT_END) {
  11211b:	84 c0                	test   %al,%al
  11211d:	0f 85 c2 06 00 00    	jne    1127e5 <tcp_in+0x7da>
	if (false == result) {
  112123:	85 db                	test   %ebx,%ebx
  112125:	0f 8e 66 07 00 00    	jle    112891 <tcp_in+0x886>
		tcp_out(conn, RST);
		conn_state(conn, TCP_CLOSED);
		goto next_state;
	}

	if (th) {
  11212b:	85 ff                	test   %edi,%edi
  11212d:	74 17                	je     112146 <tcp_in+0x13b>
		size_t max_win;

		conn->send_win = ntohs(th->th_win);
  11212f:	66 8b 47 0e          	mov    0xe(%edi),%ax
  112133:	86 e0                	xchg   %ah,%al
			max_win = (CONFIG_NET_BUF_TX_COUNT *
				   CONFIG_NET_BUF_DATA_SIZE) / 3;
		}

		max_win = MAX(max_win, NET_IPV6_MTU);
		if ((size_t)conn->send_win > max_win) {
  112135:	66 3d 00 06          	cmp    $0x600,%ax
  112139:	0f 87 96 07 00 00    	ja     1128d5 <tcp_in+0x8ca>
		conn->send_win = ntohs(th->th_win);
  11213f:	66 89 86 6a 01 00 00 	mov    %ax,0x16a(%esi)

			conn->send_win = max_win;
		}
	}

	if (FL(&fl, &, RST)) {
  112146:	8a 5d cb             	mov    -0x35(%ebp),%bl
  112149:	84 db                	test   %bl,%bl
  11214b:	74 20                	je     11216d <tcp_in+0x162>
  11214d:	68 02 4e 12 00       	push   $0x124e02
  112152:	e8 c5 9b ff ff       	call   10bd1c <strlen>
  112157:	58                   	pop    %eax
  112158:	f6 c3 04             	test   $0x4,%bl
  11215b:	74 10                	je     11216d <tcp_in+0x162>
  11215d:	83 e3 fb             	and    $0xfffffffb,%ebx
  112160:	88 5d cb             	mov    %bl,-0x35(%ebp)
		conn_state(conn, TCP_CLOSED);
  112163:	c7 86 58 01 00 00 0b 	movl   $0xb,0x158(%esi)
  11216a:	00 00 00 
	}
next_state:
	len = pkt ? tcp_data_len(pkt) : 0;
  11216d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  112171:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  112178:	74 0b                	je     112185 <tcp_in+0x17a>
  11217a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  11217d:	e8 71 f5 ff ff       	call   1116f3 <tcp_data_len>
  112182:	89 45 c0             	mov    %eax,-0x40(%ebp)

	switch (conn->state) {
  112185:	8b 86 58 01 00 00    	mov    0x158(%esi),%eax
  11218b:	48                   	dec    %eax
  11218c:	83 f8 0a             	cmp    $0xa,%eax
  11218f:	0f 87 4f 04 00 00    	ja     1125e4 <tcp_in+0x5d9>
  112195:	ff 24 85 84 43 12 00 	jmp    *0x124384(,%eax,4)
	case TCP_LISTEN:
		if (FL(&fl, ==, SYN)) {
  11219c:	8a 5d cb             	mov    -0x35(%ebp),%bl
  11219f:	84 db                	test   %bl,%bl
  1121a1:	74 45                	je     1121e8 <tcp_in+0x1dd>
  1121a3:	68 02 4e 12 00       	push   $0x124e02
  1121a8:	e8 6f 9b ff ff       	call   10bd1c <strlen>
  1121ad:	58                   	pop    %eax
  1121ae:	80 fb 02             	cmp    $0x2,%bl
  1121b1:	75 35                	jne    1121e8 <tcp_in+0x1dd>
  1121b3:	8b 47 04             	mov    0x4(%edi),%eax
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
  1121b6:	8b 96 64 01 00 00    	mov    0x164(%esi),%edx
  1121bc:	0f c8                	bswap  %eax
		if (FL(&fl, ==, SYN)) {
  1121be:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
  1121c2:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
			tcp_out(conn, SYN | ACK);
  1121c6:	ba 12 00 00 00       	mov    $0x12,%edx
			conn_ack(conn, th_seq(th) + 1); /* capture peer's isn */
  1121cb:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
			tcp_out(conn, SYN | ACK);
  1121d1:	89 f0                	mov    %esi,%eax
  1121d3:	e8 1d fe ff ff       	call   111ff5 <tcp_out>
			conn_seq(conn, + 1);
  1121d8:	ff 86 60 01 00 00    	incl   0x160(%esi)
			next = TCP_SYN_RECEIVED;
  1121de:	b8 03 00 00 00       	mov    $0x3,%eax
  1121e3:	e9 cf 03 00 00       	jmp    1125b7 <tcp_in+0x5ac>
		} else {
			tcp_out(conn, SYN);
  1121e8:	89 f0                	mov    %esi,%eax
  1121ea:	ba 02 00 00 00       	mov    $0x2,%edx
  1121ef:	e8 01 fe ff ff       	call   111ff5 <tcp_out>
			conn_seq(conn, + 1);
  1121f4:	ff 86 60 01 00 00    	incl   0x160(%esi)
			next = TCP_SYN_SENT;
  1121fa:	b8 02 00 00 00       	mov    $0x2,%eax
  1121ff:	e9 b3 03 00 00       	jmp    1125b7 <tcp_in+0x5ac>
		}
		break;
	case TCP_SYN_RECEIVED:
		if (FL(&fl, &, ACK, th_ack(th) == conn->seq &&
  112204:	8a 5d cb             	mov    -0x35(%ebp),%bl
  112207:	84 db                	test   %bl,%bl
  112209:	0f 84 d5 03 00 00    	je     1125e4 <tcp_in+0x5d9>
  11220f:	68 bb 60 12 00       	push   $0x1260bb
  112214:	e8 03 9b ff ff       	call   10bd1c <strlen>
  112219:	59                   	pop    %ecx
  11221a:	85 c0                	test   %eax,%eax
  11221c:	74 22                	je     112240 <tcp_in+0x235>
  11221e:	8b 47 08             	mov    0x8(%edi),%eax
  112221:	0f c8                	bswap  %eax
  112223:	3b 86 60 01 00 00    	cmp    0x160(%esi),%eax
  112229:	0f 85 b5 03 00 00    	jne    1125e4 <tcp_in+0x5d9>
  11222f:	8b 47 04             	mov    0x4(%edi),%eax
  112232:	0f c8                	bswap  %eax
  112234:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  11223a:	0f 85 a4 03 00 00    	jne    1125e4 <tcp_in+0x5d9>
  112240:	f6 c3 10             	test   $0x10,%bl
  112243:	0f 84 9b 03 00 00    	je     1125e4 <tcp_in+0x5d9>
  112249:	83 e3 ef             	and    $0xffffffef,%ebx
				th_seq(th) == conn->ack)) {
			tcp_send_timer_cancel(conn);
  11224c:	89 f0                	mov    %esi,%eax
		if (FL(&fl, &, ACK, th_ack(th) == conn->seq &&
  11224e:	88 5d cb             	mov    %bl,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  112251:	e8 16 f8 ff ff       	call   111a6c <tcp_send_timer_cancel>
			next = TCP_ESTABLISHED;
			net_context_set_state(conn->context,
  112256:	8b 56 04             	mov    0x4(%esi),%edx
					      NET_CONTEXT_CONNECTED);

			if (conn->accepted_conn) {
  112259:	8b 4e 1c             	mov    0x1c(%esi),%ecx
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
  11225c:	66 8b 82 92 00 00 00 	mov    0x92(%edx),%ax
  112263:	83 e0 f9             	and    $0xfffffff9,%eax
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
  112266:	83 c8 04             	or     $0x4,%eax
  112269:	85 c9                	test   %ecx,%ecx
  11226b:	66 89 82 92 00 00 00 	mov    %ax,0x92(%edx)
  112272:	74 1a                	je     11228e <tcp_in+0x283>
				conn->accepted_conn->accept_cb(
					conn->context,
					&conn->accepted_conn->context->remote,
					sizeof(struct sockaddr), 0,
					conn->accepted_conn->context);
  112274:	8b 41 04             	mov    0x4(%ecx),%eax
				conn->accepted_conn->accept_cb(
  112277:	50                   	push   %eax
  112278:	83 c0 2c             	add    $0x2c,%eax
  11227b:	6a 00                	push   $0x0
  11227d:	6a 08                	push   $0x8
  11227f:	50                   	push   %eax
  112280:	52                   	push   %edx
  112281:	ff 51 1c             	call   *0x1c(%ecx)
  112284:	83 c4 14             	add    $0x14,%esp

				/* Make sure the accept_cb is only called once.
				 */
				conn->accepted_conn = NULL;
  112287:	c7 46 1c 00 00 00 00 	movl   $0x0,0x1c(%esi)
			}

			if (len) {
  11228e:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  112292:	0f 84 1a 03 00 00    	je     1125b2 <tcp_in+0x5a7>
				if (tcp_data_get(conn, pkt) < 0) {
  112298:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  11229b:	89 f0                	mov    %esi,%eax
  11229d:	e8 89 f4 ff ff       	call   11172b <tcp_data_get>
  1122a2:	85 c0                	test   %eax,%eax
  1122a4:	0f 88 08 03 00 00    	js     1125b2 <tcp_in+0x5a7>
					break;
				}
				conn_ack(conn, + len);
  1122aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1122ad:	01 86 64 01 00 00    	add    %eax,0x164(%esi)
				tcp_out(conn, ACK);
  1122b3:	e9 a0 00 00 00       	jmp    112358 <tcp_in+0x34d>
	case TCP_SYN_SENT:
		/* if we are in SYN SENT and receive only a SYN without an
		 * ACK , shouldn't we go to SYN RECEIVED state? See Figure
		 * 6 of RFC 793
		 */
		if (FL(&fl, &, SYN | ACK, th && th_ack(th) == conn->seq)) {
  1122b8:	8a 5d cb             	mov    -0x35(%ebp),%bl
  1122bb:	84 db                	test   %bl,%bl
  1122bd:	0f 84 21 03 00 00    	je     1125e4 <tcp_in+0x5d9>
  1122c3:	68 ee 60 12 00       	push   $0x1260ee
  1122c8:	e8 4f 9a ff ff       	call   10bd1c <strlen>
  1122cd:	5a                   	pop    %edx
  1122ce:	85 c0                	test   %eax,%eax
  1122d0:	74 19                	je     1122eb <tcp_in+0x2e0>
  1122d2:	85 ff                	test   %edi,%edi
  1122d4:	0f 84 0a 03 00 00    	je     1125e4 <tcp_in+0x5d9>
  1122da:	8b 47 08             	mov    0x8(%edi),%eax
  1122dd:	0f c8                	bswap  %eax
  1122df:	3b 86 60 01 00 00    	cmp    0x160(%esi),%eax
  1122e5:	0f 85 f9 02 00 00    	jne    1125e4 <tcp_in+0x5d9>
  1122eb:	f6 c3 12             	test   $0x12,%bl
  1122ee:	0f 84 f0 02 00 00    	je     1125e4 <tcp_in+0x5d9>
  1122f4:	83 e3 ed             	and    $0xffffffed,%ebx
			tcp_send_timer_cancel(conn);
  1122f7:	89 f0                	mov    %esi,%eax
		if (FL(&fl, &, SYN | ACK, th && th_ack(th) == conn->seq)) {
  1122f9:	88 5d cb             	mov    %bl,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  1122fc:	e8 6b f7 ff ff       	call   111a6c <tcp_send_timer_cancel>
			conn_ack(conn, th_seq(th) + 1);
  112301:	8b 47 04             	mov    0x4(%edi),%eax
  112304:	8b 96 64 01 00 00    	mov    0x164(%esi),%edx
  11230a:	0f c8                	bswap  %eax
			if (len) {
  11230c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
			conn_ack(conn, th_seq(th) + 1);
  112310:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  112314:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
			if (len) {
  11231a:	74 1b                	je     112337 <tcp_in+0x32c>
				if (tcp_data_get(conn, pkt) < 0) {
  11231c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  11231f:	89 f0                	mov    %esi,%eax
  112321:	e8 05 f4 ff ff       	call   11172b <tcp_data_get>
  112326:	85 c0                	test   %eax,%eax
  112328:	0f 88 b6 02 00 00    	js     1125e4 <tcp_in+0x5d9>
					break;
				}
				conn_ack(conn, + len);
  11232e:	8b 45 c0             	mov    -0x40(%ebp),%eax
  112331:	01 86 64 01 00 00    	add    %eax,0x164(%esi)
			}
			k_sem_give(&conn->connect_sem);
  112337:	8d 46 3c             	lea    0x3c(%esi),%eax
	z_impl_k_sem_give(sem);
  11233a:	50                   	push   %eax
  11233b:	e8 59 f5 00 00       	call   121899 <z_impl_k_sem_give>
			next = TCP_ESTABLISHED;
			net_context_set_state(conn->context,
  112340:	8b 56 04             	mov    0x4(%esi),%edx
  112343:	59                   	pop    %ecx
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
  112344:	66 8b 82 92 00 00 00 	mov    0x92(%edx),%ax
  11234b:	83 e0 f9             	and    $0xfffffff9,%eax
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
  11234e:	83 c8 04             	or     $0x4,%eax
  112351:	66 89 82 92 00 00 00 	mov    %ax,0x92(%edx)
					      NET_CONTEXT_CONNECTED);
			tcp_out(conn, ACK);
  112358:	ba 10 00 00 00       	mov    $0x10,%edx
  11235d:	89 f0                	mov    %esi,%eax
  11235f:	e8 91 fc ff ff       	call   111ff5 <tcp_out>
	default:
		NET_ASSERT(false, "%s is unimplemented",
			   tcp_state_to_str(conn->state, true));
	}

	if (next) {
  112364:	e9 49 02 00 00       	jmp    1125b2 <tcp_in+0x5a7>
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
  112369:	85 ff                	test   %edi,%edi
  11236b:	0f 84 73 02 00 00    	je     1125e4 <tcp_in+0x5d9>
  112371:	8a 5d cb             	mov    -0x35(%ebp),%bl
  112374:	84 db                	test   %bl,%bl
  112376:	0f 84 bc 02 00 00    	je     112638 <tcp_in+0x62d>
  11237c:	68 d6 60 12 00       	push   $0x1260d6
  112381:	e8 96 99 ff ff       	call   10bd1c <strlen>
  112386:	5a                   	pop    %edx
  112387:	85 c0                	test   %eax,%eax
  112389:	74 0d                	je     112398 <tcp_in+0x38d>
  11238b:	8b 47 04             	mov    0x4(%edi),%eax
  11238e:	0f c8                	bswap  %eax
  112390:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  112396:	75 11                	jne    1123a9 <tcp_in+0x39e>
  112398:	80 fb 11             	cmp    $0x11,%bl
  11239b:	75 0c                	jne    1123a9 <tcp_in+0x39e>
			conn_ack(conn, + 1);
  11239d:	ff 86 64 01 00 00    	incl   0x164(%esi)
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
  1123a3:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_out(conn, FIN | ACK);
  1123a7:	eb 6e                	jmp    112417 <tcp_in+0x40c>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
  1123a9:	68 d6 60 12 00       	push   $0x1260d6
  1123ae:	e8 69 99 ff ff       	call   10bd1c <strlen>
  1123b3:	5a                   	pop    %edx
  1123b4:	85 c0                	test   %eax,%eax
  1123b6:	0f 84 34 05 00 00    	je     1128f0 <tcp_in+0x8e5>
  1123bc:	8b 47 04             	mov    0x4(%edi),%eax
  1123bf:	0f c8                	bswap  %eax
  1123c1:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  1123c7:	0f 84 23 05 00 00    	je     1128f0 <tcp_in+0x8e5>
		} else if (th && FL(&fl, ==, (FIN | ACK | PSH),
  1123cd:	68 d6 60 12 00       	push   $0x1260d6
  1123d2:	e8 45 99 ff ff       	call   10bd1c <strlen>
  1123d7:	59                   	pop    %ecx
  1123d8:	85 c0                	test   %eax,%eax
  1123da:	74 11                	je     1123ed <tcp_in+0x3e2>
  1123dc:	8b 47 04             	mov    0x4(%edi),%eax
  1123df:	0f c8                	bswap  %eax
  1123e1:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  1123e7:	0f 85 4b 02 00 00    	jne    112638 <tcp_in+0x62d>
  1123ed:	80 fb 19             	cmp    $0x19,%bl
  1123f0:	0f 85 42 02 00 00    	jne    112638 <tcp_in+0x62d>
			if (len) {
  1123f6:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
		} else if (th && FL(&fl, ==, (FIN | ACK | PSH),
  1123fa:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			if (len) {
  1123fe:	0f 85 ce 01 00 00    	jne    1125d2 <tcp_in+0x5c7>
			conn_ack(conn, + len + 1);
  112404:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
  11240a:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  11240d:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  112411:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
			tcp_out(conn, FIN | ACK);
  112417:	ba 11 00 00 00       	mov    $0x11,%edx
  11241c:	eb 05                	jmp    112423 <tcp_in+0x418>
		tcp_out(conn, FIN);
  11241e:	ba 01 00 00 00       	mov    $0x1,%edx
  112423:	89 f0                	mov    %esi,%eax
  112425:	e8 cb fb ff ff       	call   111ff5 <tcp_out>
		next = TCP_LAST_ACK;
  11242a:	b8 09 00 00 00       	mov    $0x9,%eax
  11242f:	e9 83 01 00 00       	jmp    1125b7 <tcp_in+0x5ac>
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
  112434:	85 ff                	test   %edi,%edi
  112436:	0f 84 a8 01 00 00    	je     1125e4 <tcp_in+0x5d9>
  11243c:	8a 5d cb             	mov    -0x35(%ebp),%bl
  11243f:	84 db                	test   %bl,%bl
  112441:	0f 84 9d 01 00 00    	je     1125e4 <tcp_in+0x5d9>
  112447:	68 d6 60 12 00       	push   $0x1260d6
  11244c:	e8 cb 98 ff ff       	call   10bd1c <strlen>
  112451:	5a                   	pop    %edx
  112452:	85 c0                	test   %eax,%eax
  112454:	74 11                	je     112467 <tcp_in+0x45c>
  112456:	8b 47 04             	mov    0x4(%edi),%eax
  112459:	0f c8                	bswap  %eax
  11245b:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  112461:	0f 85 7d 01 00 00    	jne    1125e4 <tcp_in+0x5d9>
  112467:	80 fb 10             	cmp    $0x10,%bl
  11246a:	0f 85 74 01 00 00    	jne    1125e4 <tcp_in+0x5d9>
			tcp_send_timer_cancel(conn);
  112470:	89 f0                	mov    %esi,%eax
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
  112472:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  112476:	e8 f1 f5 ff ff       	call   111a6c <tcp_send_timer_cancel>
			next = TCP_CLOSED;
  11247b:	b8 0b 00 00 00       	mov    $0xb,%eax
  112480:	e9 32 01 00 00       	jmp    1125b7 <tcp_in+0x5ac>
		tcp_conn_unref(conn);
  112485:	89 f0                	mov    %esi,%eax
  112487:	e8 62 f4 ff ff       	call   1118ee <tcp_conn_unref>
	if (next) {
  11248c:	e9 53 01 00 00       	jmp    1125e4 <tcp_in+0x5d9>
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
  112491:	85 ff                	test   %edi,%edi
  112493:	0f 84 4b 01 00 00    	je     1125e4 <tcp_in+0x5d9>
  112499:	8a 5d cb             	mov    -0x35(%ebp),%bl
  11249c:	84 db                	test   %bl,%bl
  11249e:	0f 84 40 01 00 00    	je     1125e4 <tcp_in+0x5d9>
  1124a4:	68 d6 60 12 00       	push   $0x1260d6
  1124a9:	e8 6e 98 ff ff       	call   10bd1c <strlen>
  1124ae:	59                   	pop    %ecx
  1124af:	85 c0                	test   %eax,%eax
  1124b1:	74 11                	je     1124c4 <tcp_in+0x4b9>
  1124b3:	8b 47 04             	mov    0x4(%edi),%eax
  1124b6:	0f c8                	bswap  %eax
  1124b8:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  1124be:	0f 85 55 04 00 00    	jne    112919 <tcp_in+0x90e>
  1124c4:	80 fb 11             	cmp    $0x11,%bl
  1124c7:	0f 85 4c 04 00 00    	jne    112919 <tcp_in+0x90e>
			tcp_send_timer_cancel(conn);
  1124cd:	89 f0                	mov    %esi,%eax
		if (th && FL(&fl, ==, (FIN | ACK), th_seq(th) == conn->ack)) {
  1124cf:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  1124d3:	e8 94 f5 ff ff       	call   111a6c <tcp_send_timer_cancel>
			conn_ack(conn, + 1);
  1124d8:	eb 6e                	jmp    112548 <tcp_in+0x53d>
		if (th && (FL(&fl, ==, FIN, th_seq(th) == conn->ack) ||
  1124da:	85 ff                	test   %edi,%edi
  1124dc:	0f 84 02 01 00 00    	je     1125e4 <tcp_in+0x5d9>
  1124e2:	8a 5d cb             	mov    -0x35(%ebp),%bl
  1124e5:	84 db                	test   %bl,%bl
  1124e7:	0f 84 f7 00 00 00    	je     1125e4 <tcp_in+0x5d9>
  1124ed:	68 d6 60 12 00       	push   $0x1260d6
  1124f2:	e8 25 98 ff ff       	call   10bd1c <strlen>
  1124f7:	5a                   	pop    %edx
  1124f8:	85 c0                	test   %eax,%eax
  1124fa:	74 0d                	je     112509 <tcp_in+0x4fe>
  1124fc:	8b 47 04             	mov    0x4(%edi),%eax
  1124ff:	0f c8                	bswap  %eax
  112501:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  112507:	75 05                	jne    11250e <tcp_in+0x503>
  112509:	80 fb 01             	cmp    $0x1,%bl
  11250c:	74 29                	je     112537 <tcp_in+0x52c>
			   FL(&fl, ==, FIN | ACK, th_seq(th) == conn->ack))) {
  11250e:	68 d6 60 12 00       	push   $0x1260d6
  112513:	e8 04 98 ff ff       	call   10bd1c <strlen>
  112518:	5a                   	pop    %edx
  112519:	85 c0                	test   %eax,%eax
  11251b:	74 11                	je     11252e <tcp_in+0x523>
  11251d:	8b 47 04             	mov    0x4(%edi),%eax
  112520:	0f c8                	bswap  %eax
  112522:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  112528:	0f 85 b6 00 00 00    	jne    1125e4 <tcp_in+0x5d9>
  11252e:	80 fb 11             	cmp    $0x11,%bl
  112531:	0f 85 ad 00 00 00    	jne    1125e4 <tcp_in+0x5d9>
			k_delayed_work_cancel(&conn->fin_timer);
  112537:	8d 86 f4 00 00 00    	lea    0xf4(%esi),%eax
			   FL(&fl, ==, FIN | ACK, th_seq(th) == conn->ack))) {
  11253d:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			k_delayed_work_cancel(&conn->fin_timer);
  112541:	50                   	push   %eax
  112542:	e8 17 fa 00 00       	call   121f5e <k_delayed_work_cancel>
  112547:	5b                   	pop    %ebx
			conn_ack(conn, + 1);
  112548:	ff 86 64 01 00 00    	incl   0x164(%esi)
			tcp_out(conn, ACK);
  11254e:	ba 10 00 00 00       	mov    $0x10,%edx
  112553:	89 f0                	mov    %esi,%eax
  112555:	e8 9b fa ff ff       	call   111ff5 <tcp_out>
	if (next) {
  11255a:	eb 3b                	jmp    112597 <tcp_in+0x58c>
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
  11255c:	85 ff                	test   %edi,%edi
  11255e:	0f 84 80 00 00 00    	je     1125e4 <tcp_in+0x5d9>
  112564:	8a 5d cb             	mov    -0x35(%ebp),%bl
  112567:	84 db                	test   %bl,%bl
  112569:	74 79                	je     1125e4 <tcp_in+0x5d9>
  11256b:	68 d6 60 12 00       	push   $0x1260d6
  112570:	e8 a7 97 ff ff       	call   10bd1c <strlen>
  112575:	59                   	pop    %ecx
  112576:	85 c0                	test   %eax,%eax
  112578:	74 0d                	je     112587 <tcp_in+0x57c>
  11257a:	8b 47 04             	mov    0x4(%edi),%eax
  11257d:	0f c8                	bswap  %eax
  11257f:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  112585:	75 5d                	jne    1125e4 <tcp_in+0x5d9>
  112587:	80 fb 10             	cmp    $0x10,%bl
  11258a:	75 58                	jne    1125e4 <tcp_in+0x5d9>
			tcp_send_timer_cancel(conn);
  11258c:	89 f0                	mov    %esi,%eax
		if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
  11258e:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  112592:	e8 d5 f4 ff ff       	call   111a6c <tcp_send_timer_cancel>
			next = TCP_TIME_WAIT;
  112597:	b8 0a 00 00 00       	mov    $0xa,%eax
  11259c:	eb 19                	jmp    1125b7 <tcp_in+0x5ac>
		k_delayed_work_submit(&conn->timewait_timer,
  11259e:	8d 86 d0 00 00 00    	lea    0xd0(%esi),%eax
  1125a4:	ba 19 00 00 00       	mov    $0x19,%edx
  1125a9:	31 c9                	xor    %ecx,%ecx
  1125ab:	e8 b1 ef ff ff       	call   111561 <k_delayed_work_submit>
	if (next) {
  1125b0:	eb 32                	jmp    1125e4 <tcp_in+0x5d9>
			next = TCP_ESTABLISHED;
  1125b2:	b8 04 00 00 00       	mov    $0x4,%eax
		pkt = NULL;
		th = NULL;
		conn_state(conn, next);
  1125b7:	89 86 58 01 00 00    	mov    %eax,0x158(%esi)
		th = NULL;
  1125bd:	31 ff                	xor    %edi,%edi
		pkt = NULL;
  1125bf:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
	len = pkt ? tcp_data_len(pkt) : 0;
  1125c6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  1125cd:	e9 b3 fb ff ff       	jmp    112185 <tcp_in+0x17a>
				if (tcp_data_get(conn, pkt) < 0) {
  1125d2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1125d5:	89 f0                	mov    %esi,%eax
  1125d7:	e8 4f f1 ff ff       	call   11172b <tcp_data_get>
  1125dc:	85 c0                	test   %eax,%eax
  1125de:	0f 89 20 fe ff ff    	jns    112404 <tcp_in+0x3f9>
	}

	/* If the conn->context is not set, then the connection was already
	 * closed.
	 */
	if (conn->context) {
  1125e4:	8b 7e 04             	mov    0x4(%esi),%edi
  1125e7:	85 ff                	test   %edi,%edi
  1125e9:	74 03                	je     1125ee <tcp_in+0x5e3>
		conn_handler = (struct net_conn *)conn->context->conn_handler;
  1125eb:	8b 7f 34             	mov    0x34(%edi),%edi
	}

	recv_user_data = conn->recv_user_data;
	recv_data_fifo = &conn->recv_data;

	k_mutex_unlock(&conn->lock);
  1125ee:	8b 45 b0             	mov    -0x50(%ebp),%eax
	recv_user_data = conn->recv_user_data;
  1125f1:	8b 5e 10             	mov    0x10(%esi),%ebx
	k_mutex_unlock(&conn->lock);
  1125f4:	e8 7d ef ff ff       	call   111576 <k_mutex_unlock>

	/* Pass all the received data stored in recv fifo to the application.
	 * This is done like this so that we do not have any connection lock
	 * held.
	 */
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
  1125f9:	85 ff                	test   %edi,%edi
  1125fb:	0f 84 9e 03 00 00    	je     11299f <tcp_in+0x994>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  112601:	8b 86 54 01 00 00    	mov    0x154(%esi),%eax
  112607:	85 c0                	test   %eax,%eax
  112609:	0f 8e 90 03 00 00    	jle    11299f <tcp_in+0x994>
	return z_impl_k_queue_get(queue, timeout);
  11260f:	6a 00                	push   $0x0
	       (recv_pkt = k_fifo_get(recv_data_fifo, K_NO_WAIT)) != NULL) {
  112611:	8d 46 5c             	lea    0x5c(%esi),%eax
  112614:	6a 00                	push   $0x0
  112616:	50                   	push   %eax
  112617:	e8 3b e9 00 00       	call   120f57 <z_impl_k_queue_get>
  11261c:	83 c4 0c             	add    $0xc,%esp
	while (conn_handler && atomic_get(&conn->ref_count) > 0 &&
  11261f:	85 c0                	test   %eax,%eax
  112621:	0f 84 78 03 00 00    	je     11299f <tcp_in+0x994>
		net_context_packet_received(conn_handler, recv_pkt, NULL, NULL,
  112627:	53                   	push   %ebx
  112628:	6a 00                	push   $0x0
  11262a:	6a 00                	push   $0x0
  11262c:	50                   	push   %eax
  11262d:	57                   	push   %edi
  11262e:	e8 07 c4 ff ff       	call   10ea3a <net_context_packet_received>
  112633:	83 c4 14             	add    $0x14,%esp
  112636:	eb c1                	jmp    1125f9 <tcp_in+0x5ee>
		if (th && net_tcp_seq_cmp(th_ack(th), conn->seq) > 0) {
  112638:	8b 86 60 01 00 00    	mov    0x160(%esi),%eax
  11263e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  112641:	8b 47 08             	mov    0x8(%edi),%eax
  112644:	0f c8                	bswap  %eax
  112646:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 *
 * @return < 0 if seq1 < seq2, 0 if seq1 == seq2, > 0 if seq > seq2
 */
static inline int32_t net_tcp_seq_cmp(uint32_t seq1, uint32_t seq2)
{
	return (int32_t)(seq1 - seq2);
  112649:	2b 45 b8             	sub    -0x48(%ebp),%eax
  11264c:	89 45 bc             	mov    %eax,-0x44(%ebp)
  11264f:	85 c0                	test   %eax,%eax
  112651:	0f 8e 35 01 00 00    	jle    11278c <tcp_in+0x781>
			if ((conn->send_data_total < len_acked) ||
  112657:	8b 96 48 01 00 00    	mov    0x148(%esi),%edx
  11265d:	39 55 bc             	cmp    %edx,-0x44(%ebp)
  112660:	77 6e                	ja     1126d0 <tcp_in+0x6c5>
					(tcp_pkt_pull(conn->send_data,
  112662:	8b 5e 08             	mov    0x8(%esi),%ebx
	return net_buf_frags_len(pkt->frags);
  112665:	89 55 ac             	mov    %edx,-0x54(%ebp)
  112668:	8b 43 10             	mov    0x10(%ebx),%eax
  11266b:	e8 50 ee ff ff       	call   1114c0 <net_buf_frags_len>
	if (len > total) {
  112670:	8b 55 ac             	mov    -0x54(%ebp),%edx
  112673:	39 45 bc             	cmp    %eax,-0x44(%ebp)
  112676:	77 58                	ja     1126d0 <tcp_in+0x6c5>
	net_pkt_cursor_init(pkt);
  112678:	53                   	push   %ebx
  112679:	e8 6c d5 ff ff       	call   10fbea <net_pkt_cursor_init>
  11267e:	58                   	pop    %eax
	pkt->overwrite = overwrite;
  11267f:	80 4b 3d 01          	orb    $0x1,0x3d(%ebx)
	net_pkt_pull(pkt, len);
  112683:	ff 75 bc             	pushl  -0x44(%ebp)
  112686:	53                   	push   %ebx
  112687:	e8 4f db ff ff       	call   1101db <net_pkt_pull>
  11268c:	58                   	pop    %eax
  11268d:	5a                   	pop    %edx
	net_pkt_trim_buffer(pkt);
  11268e:	53                   	push   %ebx
  11268f:	e8 0e d5 ff ff       	call   10fba2 <net_pkt_trim_buffer>
			conn->send_data_total -= len_acked;
  112694:	8b 45 b8             	mov    -0x48(%ebp),%eax
			if (!k_delayed_work_remaining_get(&conn->send_data_timer)) {
  112697:	8d 9e ac 00 00 00    	lea    0xac(%esi),%ebx
  11269d:	2b 45 b4             	sub    -0x4c(%ebp),%eax
			conn->send_data_total -= len_acked;
  1126a0:	01 86 48 01 00 00    	add    %eax,0x148(%esi)
			conn->unacked_len -= len_acked;
  1126a6:	01 86 50 01 00 00    	add    %eax,0x150(%esi)
			conn_seq(conn, + len_acked);
  1126ac:	8b 45 bc             	mov    -0x44(%ebp),%eax
  1126af:	01 86 60 01 00 00    	add    %eax,0x160(%esi)
  1126b5:	8d 86 b8 00 00 00    	lea    0xb8(%esi),%eax
  1126bb:	89 04 24             	mov    %eax,(%esp)
  1126be:	e8 31 fb 00 00       	call   1221f4 <z_timeout_remaining>
  1126c3:	6b c0 0a             	imul   $0xa,%eax,%eax
  1126c6:	59                   	pop    %ecx
			if (!k_delayed_work_remaining_get(&conn->send_data_timer)) {
  1126c7:	85 c0                	test   %eax,%eax
  1126c9:	75 4f                	jne    11271a <tcp_in+0x70f>
  1126cb:	e9 14 ff ff ff       	jmp    1125e4 <tcp_in+0x5d9>
				NET_ERR("conn: %p, Invalid len_acked=%u "
  1126d0:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  1126d7:	74 26                	je     1126ff <tcp_in+0x6f4>
  1126d9:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  1126de:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1126e3:	c1 e8 03             	shr    $0x3,%eax
  1126e6:	c1 e0 06             	shl    $0x6,%eax
  1126e9:	83 c8 01             	or     $0x1,%eax
  1126ec:	50                   	push   %eax
  1126ed:	52                   	push   %edx
  1126ee:	ff 75 bc             	pushl  -0x44(%ebp)
  1126f1:	56                   	push   %esi
  1126f2:	68 0c 61 12 00       	push   $0x12610c
  1126f7:	e8 fd 0e ff ff       	call   1035f9 <log_3>
  1126fc:	83 c4 14             	add    $0x14,%esp
				tcp_out(conn, RST);
  1126ff:	ba 04 00 00 00       	mov    $0x4,%edx
  112704:	89 f0                	mov    %esi,%eax
  112706:	e8 ea f8 ff ff       	call   111ff5 <tcp_out>
				conn_state(conn, TCP_CLOSED);
  11270b:	c7 86 58 01 00 00 0b 	movl   $0xb,0x158(%esi)
  112712:	00 00 00 
	if (next) {
  112715:	e9 ca fe ff ff       	jmp    1125e4 <tcp_in+0x5d9>
			k_delayed_work_cancel(&conn->send_data_timer);
  11271a:	53                   	push   %ebx
			conn->send_data_retries = 0;
  11271b:	c6 86 6c 01 00 00 00 	movb   $0x0,0x16c(%esi)
			k_delayed_work_cancel(&conn->send_data_timer);
  112722:	e8 37 f8 00 00       	call   121f5e <k_delayed_work_cancel>
  112727:	59                   	pop    %ecx
			if (conn->data_mode == TCP_DATA_MODE_RESEND) {
  112728:	83 be 5c 01 00 00 01 	cmpl   $0x1,0x15c(%esi)
  11272f:	75 0a                	jne    11273b <tcp_in+0x730>
				conn->unacked_len = 0;
  112731:	c7 86 50 01 00 00 00 	movl   $0x0,0x150(%esi)
  112738:	00 00 00 
			if (conn->in_close && conn->send_data_total == 0) {
  11273b:	f6 86 6d 01 00 00 04 	testb  $0x4,0x16d(%esi)
			conn->data_mode = TCP_DATA_MODE_SEND;
  112742:	c7 86 5c 01 00 00 00 	movl   $0x0,0x15c(%esi)
  112749:	00 00 00 
				tcp_send_timer_cancel(conn);
  11274c:	89 f0                	mov    %esi,%eax
			if (conn->in_close && conn->send_data_total == 0) {
  11274e:	74 2a                	je     11277a <tcp_in+0x76f>
  112750:	83 be 48 01 00 00 00 	cmpl   $0x0,0x148(%esi)
  112757:	75 21                	jne    11277a <tcp_in+0x76f>
				tcp_send_timer_cancel(conn);
  112759:	e8 0e f3 ff ff       	call   111a6c <tcp_send_timer_cancel>
				tcp_out(conn, FIN | ACK);
  11275e:	89 f0                	mov    %esi,%eax
  112760:	ba 11 00 00 00       	mov    $0x11,%edx
  112765:	e8 8b f8 ff ff       	call   111ff5 <tcp_out>
				conn_seq(conn, + 1);
  11276a:	ff 86 60 01 00 00    	incl   0x160(%esi)
				next = TCP_FIN_WAIT_1;
  112770:	b8 05 00 00 00       	mov    $0x5,%eax
  112775:	e9 3d fe ff ff       	jmp    1125b7 <tcp_in+0x5ac>
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
  11277a:	e8 97 f7 ff ff       	call   111f16 <tcp_send_queued_data.part.0>
			if (ret < 0 && ret != -ENOBUFS) {
  11277f:	85 c0                	test   %eax,%eax
  112781:	79 09                	jns    11278c <tcp_in+0x781>
  112783:	83 f8 c9             	cmp    $0xffffffc9,%eax
  112786:	0f 85 73 ff ff ff    	jne    1126ff <tcp_in+0x6f4>
		if (th && len) {
  11278c:	85 ff                	test   %edi,%edi
  11278e:	0f 84 50 fe ff ff    	je     1125e4 <tcp_in+0x5d9>
  112794:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  112798:	0f 84 46 fe ff ff    	je     1125e4 <tcp_in+0x5d9>
			if (th_seq(th) == conn->ack) {
  11279e:	8b 57 04             	mov    0x4(%edi),%edx
  1127a1:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
  1127a7:	0f ca                	bswap  %edx
  1127a9:	39 c2                	cmp    %eax,%edx
  1127ab:	75 1d                	jne    1127ca <tcp_in+0x7bf>
				if (tcp_data_get(conn, pkt) < 0) {
  1127ad:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1127b0:	89 f0                	mov    %esi,%eax
  1127b2:	e8 74 ef ff ff       	call   11172b <tcp_data_get>
  1127b7:	85 c0                	test   %eax,%eax
  1127b9:	0f 88 25 fe ff ff    	js     1125e4 <tcp_in+0x5d9>
				conn_ack(conn, + len);
  1127bf:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1127c2:	01 86 64 01 00 00    	add    %eax,0x164(%esi)
				tcp_out(conn, ACK);
  1127c8:	eb 0a                	jmp    1127d4 <tcp_in+0x7c9>
  1127ca:	29 d0                	sub    %edx,%eax
			} else if (net_tcp_seq_greater(conn->ack, th_seq(th))) {
  1127cc:	85 c0                	test   %eax,%eax
  1127ce:	0f 8e 10 fe ff ff    	jle    1125e4 <tcp_in+0x5d9>
				tcp_out(conn, ACK); /* peer has resent */
  1127d4:	ba 10 00 00 00       	mov    $0x10,%edx
  1127d9:	89 f0                	mov    %esi,%eax
  1127db:	e8 15 f8 ff ff       	call   111ff5 <tcp_out>
	if (next) {
  1127e0:	e9 ff fd ff ff       	jmp    1125e4 <tcp_in+0x5d9>
		} else if (opt == TCPOPT_NOP) {
  1127e5:	fe c8                	dec    %al
  1127e7:	0f 84 94 00 00 00    	je     112881 <tcp_in+0x876>
			if (len < 2) { /* Only END and NOP can have length 1 */
  1127ed:	83 7d b8 01          	cmpl   $0x1,-0x48(%ebp)
  1127f1:	75 37                	jne    11282a <tcp_in+0x81f>
				NET_ERR("Illegal option %d with length %zd",
  1127f3:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  1127fa:	0f 84 91 00 00 00    	je     112891 <tcp_in+0x886>
  112800:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  112805:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11280a:	c1 e8 03             	shr    $0x3,%eax
  11280d:	c1 e0 06             	shl    $0x6,%eax
  112810:	83 c8 01             	or     $0x1,%eax
  112813:	50                   	push   %eax
  112814:	0f b6 4d bc          	movzbl -0x44(%ebp),%ecx
  112818:	6a 01                	push   $0x1
  11281a:	51                   	push   %ecx
  11281b:	68 85 60 12 00       	push   $0x126085
  112820:	e8 8b 0d ff ff       	call   1035b0 <log_2>
  112825:	83 c4 10             	add    $0x10,%esp
  112828:	eb 67                	jmp    112891 <tcp_in+0x886>
			opt_len = options[1];
  11282a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  11282d:	0f b6 50 01          	movzbl 0x1(%eax),%edx
		if (opt_len < 2 || opt_len > len) {
  112831:	80 fa 01             	cmp    $0x1,%dl
  112834:	76 5b                	jbe    112891 <tcp_in+0x886>
  112836:	0f b6 ca             	movzbl %dl,%ecx
  112839:	39 4d b8             	cmp    %ecx,-0x48(%ebp)
  11283c:	7c 53                	jl     112891 <tcp_in+0x886>
		switch (opt) {
  11283e:	80 7d bc 02          	cmpb   $0x2,-0x44(%ebp)
  112842:	74 08                	je     11284c <tcp_in+0x841>
  112844:	80 7d bc 03          	cmpb   $0x3,-0x44(%ebp)
  112848:	74 20                	je     11286a <tcp_in+0x85f>
  11284a:	eb 3a                	jmp    112886 <tcp_in+0x87b>
			if (opt_len != 4) {
  11284c:	80 fa 04             	cmp    $0x4,%dl
  11284f:	75 40                	jne    112891 <tcp_in+0x886>
				ntohs(UNALIGNED_GET((uint16_t *)(options + 2)));
  112851:	8b 45 c0             	mov    -0x40(%ebp),%eax
			recv_options->mss_found = true;
  112854:	80 8e 84 00 00 00 01 	orb    $0x1,0x84(%esi)
				ntohs(UNALIGNED_GET((uint16_t *)(options + 2)));
  11285b:	66 8b 48 02          	mov    0x2(%eax),%cx
  11285f:	86 e9                	xchg   %ch,%cl
  112861:	66 89 8e 80 00 00 00 	mov    %cx,0x80(%esi)
			NET_DBG("MSS=%hu", recv_options->mss);
  112868:	eb 1c                	jmp    112886 <tcp_in+0x87b>
			if (opt_len != 3) {
  11286a:	80 fa 03             	cmp    $0x3,%dl
  11286d:	75 22                	jne    112891 <tcp_in+0x886>
			recv_options->wnd_found = true;
  11286f:	80 8e 84 00 00 00 02 	orb    $0x2,0x84(%esi)
			recv_options->window = opt;
  112876:	66 c7 86 82 00 00 00 	movw   $0x3,0x82(%esi)
  11287d:	03 00 
			break;
  11287f:	eb 05                	jmp    112886 <tcp_in+0x87b>
			opt_len = 1;
  112881:	ba 01 00 00 00       	mov    $0x1,%edx
	for ( ; options && len >= 1; options += opt_len, len -= opt_len) {
  112886:	01 55 c0             	add    %edx,-0x40(%ebp)
  112889:	29 55 b8             	sub    %edx,-0x48(%ebp)
  11288c:	e9 76 f8 ff ff       	jmp    112107 <tcp_in+0xfc>
		NET_WARN("Invalid TCP options");
  112891:	f6 05 10 5c 14 00 06 	testb  $0x6,0x145c10
  112898:	74 20                	je     1128ba <tcp_in+0x8af>
  11289a:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  11289f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1128a4:	c1 e8 03             	shr    $0x3,%eax
  1128a7:	c1 e0 06             	shl    $0x6,%eax
  1128aa:	83 c8 02             	or     $0x2,%eax
  1128ad:	50                   	push   %eax
  1128ae:	68 a7 60 12 00       	push   $0x1260a7
  1128b3:	e8 95 0c ff ff       	call   10354d <log_0>
  1128b8:	58                   	pop    %eax
  1128b9:	5a                   	pop    %edx
		tcp_out(conn, RST);
  1128ba:	ba 04 00 00 00       	mov    $0x4,%edx
  1128bf:	89 f0                	mov    %esi,%eax
  1128c1:	e8 2f f7 ff ff       	call   111ff5 <tcp_out>
		conn_state(conn, TCP_CLOSED);
  1128c6:	c7 86 58 01 00 00 0b 	movl   $0xb,0x158(%esi)
  1128cd:	00 00 00 
	len = pkt ? tcp_data_len(pkt) : 0;
  1128d0:	e9 a5 f8 ff ff       	jmp    11217a <tcp_in+0x16f>
			conn->send_win = max_win;
  1128d5:	66 c7 86 6a 01 00 00 	movw   $0x600,0x16a(%esi)
  1128dc:	00 06 
  1128de:	e9 63 f8 ff ff       	jmp    112146 <tcp_in+0x13b>
	if (tcp_options_len && !tcp_options_check(&conn->recv_options, pkt,
  1128e3:	85 db                	test   %ebx,%ebx
  1128e5:	0f 84 44 f8 ff ff    	je     11212f <tcp_in+0x124>
  1128eb:	e9 9b f7 ff ff       	jmp    11208b <tcp_in+0x80>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
  1128f0:	80 fb 01             	cmp    $0x1,%bl
  1128f3:	0f 85 d4 fa ff ff    	jne    1123cd <tcp_in+0x3c2>
			conn_ack(conn, + 1);
  1128f9:	ff 86 64 01 00 00    	incl   0x164(%esi)
			tcp_out(conn, ACK);
  1128ff:	89 f0                	mov    %esi,%eax
  112901:	ba 10 00 00 00       	mov    $0x10,%edx
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
  112906:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_out(conn, ACK);
  11290a:	e8 e6 f6 ff ff       	call   111ff5 <tcp_out>
			next = TCP_CLOSE_WAIT;
  11290f:	b8 07 00 00 00       	mov    $0x7,%eax
  112914:	e9 9e fc ff ff       	jmp    1125b7 <tcp_in+0x5ac>
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
  112919:	68 d6 60 12 00       	push   $0x1260d6
  11291e:	e8 f9 93 ff ff       	call   10bd1c <strlen>
  112923:	5a                   	pop    %edx
  112924:	85 c0                	test   %eax,%eax
  112926:	74 0d                	je     112935 <tcp_in+0x92a>
  112928:	8b 47 04             	mov    0x4(%edi),%eax
  11292b:	0f c8                	bswap  %eax
  11292d:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  112933:	75 2c                	jne    112961 <tcp_in+0x956>
  112935:	80 fb 01             	cmp    $0x1,%bl
  112938:	75 27                	jne    112961 <tcp_in+0x956>
			tcp_send_timer_cancel(conn);
  11293a:	89 f0                	mov    %esi,%eax
		} else if (th && FL(&fl, ==, FIN, th_seq(th) == conn->ack)) {
  11293c:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  112940:	e8 27 f1 ff ff       	call   111a6c <tcp_send_timer_cancel>
			conn_ack(conn, + 1);
  112945:	ff 86 64 01 00 00    	incl   0x164(%esi)
			tcp_out(conn, ACK);
  11294b:	89 f0                	mov    %esi,%eax
  11294d:	ba 10 00 00 00       	mov    $0x10,%edx
  112952:	e8 9e f6 ff ff       	call   111ff5 <tcp_out>
			next = TCP_CLOSING;
  112957:	b8 08 00 00 00       	mov    $0x8,%eax
  11295c:	e9 56 fc ff ff       	jmp    1125b7 <tcp_in+0x5ac>
		} else if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
  112961:	68 d6 60 12 00       	push   $0x1260d6
  112966:	e8 b1 93 ff ff       	call   10bd1c <strlen>
  11296b:	59                   	pop    %ecx
  11296c:	85 c0                	test   %eax,%eax
  11296e:	74 11                	je     112981 <tcp_in+0x976>
  112970:	8b 47 04             	mov    0x4(%edi),%eax
  112973:	0f c8                	bswap  %eax
  112975:	3b 86 64 01 00 00    	cmp    0x164(%esi),%eax
  11297b:	0f 85 63 fc ff ff    	jne    1125e4 <tcp_in+0x5d9>
  112981:	80 fb 10             	cmp    $0x10,%bl
  112984:	0f 85 5a fc ff ff    	jne    1125e4 <tcp_in+0x5d9>
			tcp_send_timer_cancel(conn);
  11298a:	89 f0                	mov    %esi,%eax
		} else if (th && FL(&fl, ==, ACK, th_seq(th) == conn->ack)) {
  11298c:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
			tcp_send_timer_cancel(conn);
  112990:	e8 d7 f0 ff ff       	call   111a6c <tcp_send_timer_cancel>
			next = TCP_FIN_WAIT_2;
  112995:	b8 06 00 00 00       	mov    $0x6,%eax
  11299a:	e9 18 fc ff ff       	jmp    1125b7 <tcp_in+0x5ac>
					    recv_user_data);
	}
}
  11299f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1129a2:	5b                   	pop    %ebx
  1129a3:	5e                   	pop    %esi
  1129a4:	5f                   	pop    %edi
  1129a5:	5d                   	pop    %ebp
  1129a6:	c3                   	ret    

001129a7 <tcp_recv>:
{
  1129a7:	55                   	push   %ebp
  1129a8:	89 e5                	mov    %esp,%ebp
  1129aa:	57                   	push   %edi
  1129ab:	56                   	push   %esi
  1129ac:	53                   	push   %ebx
  1129ad:	83 ec 18             	sub    $0x18,%esp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
  1129b0:	8b 1d 08 ec 12 00    	mov    0x12ec08,%ebx
{
  1129b6:	8b 75 0c             	mov    0xc(%ebp),%esi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
  1129b9:	85 db                	test   %ebx,%ebx
  1129bb:	75 17                	jne    1129d4 <tcp_recv+0x2d>
	th = th_get(pkt);
  1129bd:	89 f0                	mov    %esi,%eax
  1129bf:	e8 be eb ff ff       	call   111582 <th_get>
	if (th->th_flags & SYN && !(th->th_flags & ACK)) {
  1129c4:	8a 40 0d             	mov    0xd(%eax),%al
  1129c7:	83 e0 12             	and    $0x12,%eax
  1129ca:	3c 02                	cmp    $0x2,%al
  1129cc:	0f 85 4a 02 00 00    	jne    112c1c <tcp_recv+0x275>
  1129d2:	eb 3a                	jmp    112a0e <tcp_recv+0x67>
	return node->next;
  1129d4:	8b 3b                	mov    (%ebx),%edi
	return tcp_endpoint_cmp(&conn->src, pkt, TCP_EP_DST) &&
  1129d6:	31 c9                	xor    %ecx,%ecx
  1129d8:	8d 83 18 01 00 00    	lea    0x118(%ebx),%eax
  1129de:	89 f2                	mov    %esi,%edx
  1129e0:	e8 7a ee ff ff       	call   11185f <tcp_endpoint_cmp>
  1129e5:	84 c0                	test   %al,%al
  1129e7:	75 0a                	jne    1129f3 <tcp_recv+0x4c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp_conns, conn, tmp, next) {
  1129e9:	85 ff                	test   %edi,%edi
  1129eb:	74 d0                	je     1129bd <tcp_recv+0x16>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1129ed:	89 fb                	mov    %edi,%ebx
  1129ef:	8b 3f                	mov    (%edi),%edi
  1129f1:	eb e3                	jmp    1129d6 <tcp_recv+0x2f>
		tcp_endpoint_cmp(&conn->dst, pkt, TCP_EP_SRC);
  1129f3:	8d 83 30 01 00 00    	lea    0x130(%ebx),%eax
  1129f9:	b9 01 00 00 00       	mov    $0x1,%ecx
  1129fe:	89 f2                	mov    %esi,%edx
  112a00:	e8 5a ee ff ff       	call   11185f <tcp_endpoint_cmp>
		if (found) {
  112a05:	84 c0                	test   %al,%al
  112a07:	74 e0                	je     1129e9 <tcp_recv+0x42>
  112a09:	e9 05 02 00 00       	jmp    112c13 <tcp_recv+0x26c>
		struct tcp *conn_old = ((struct net_context *)user_data)->tcp;
  112a0e:	8b 45 18             	mov    0x18(%ebp),%eax
	struct sockaddr local_addr = { 0 };
  112a11:	8d 7d ec             	lea    -0x14(%ebp),%edi
  112a14:	b9 02 00 00 00       	mov    $0x2,%ecx
	struct net_context *context = NULL;
  112a19:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		struct tcp *conn_old = ((struct net_context *)user_data)->tcp;
  112a20:	8b 40 44             	mov    0x44(%eax),%eax
  112a23:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return pkt->family;
  112a26:	8a 46 3f             	mov    0x3f(%esi),%al
  112a29:	d0 e8                	shr    %al
  112a2b:	88 45 e7             	mov    %al,-0x19(%ebp)
	struct sockaddr local_addr = { 0 };
  112a2e:	31 c0                	xor    %eax,%eax
  112a30:	80 65 e7 07          	andb   $0x7,-0x19(%ebp)
  112a34:	f3 ab                	rep stos %eax,%es:(%edi)
	ret = net_context_get(af, SOCK_STREAM, IPPROTO_TCP, &context);
  112a36:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  112a3a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  112a3d:	8d 45 e8             	lea    -0x18(%ebp),%eax
  112a40:	50                   	push   %eax
  112a41:	6a 06                	push   $0x6
  112a43:	6a 01                	push   $0x1
  112a45:	ff 75 dc             	pushl  -0x24(%ebp)
  112a48:	e8 9e c0 ff ff       	call   10eaeb <net_context_get>
  112a4d:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
  112a50:	85 c0                	test   %eax,%eax
  112a52:	79 35                	jns    112a89 <tcp_recv+0xe2>
		NET_ERR("net_context_get(): %d", ret);
  112a54:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  112a5b:	0f 84 bb 01 00 00    	je     112c1c <tcp_recv+0x275>
  112a61:	ba a0 31 12 00       	mov    $0x1231a0,%edx
  112a66:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  112a6c:	c1 ea 03             	shr    $0x3,%edx
  112a6f:	c1 e2 06             	shl    $0x6,%edx
  112a72:	83 ca 01             	or     $0x1,%edx
  112a75:	52                   	push   %edx
  112a76:	50                   	push   %eax
  112a77:	68 37 61 12 00       	push   $0x126137
  112a7c:	e8 f5 0a ff ff       	call   103576 <log_1>
  112a81:	83 c4 0c             	add    $0xc,%esp
		if (!conn) {
  112a84:	e9 5f 01 00 00       	jmp    112be8 <tcp_recv+0x241>
	conn = context->tcp;
  112a89:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8_t flag = 0U;
  112a8c:	31 d2                	xor    %edx,%edx
  112a8e:	8b 58 44             	mov    0x44(%eax),%ebx
	conn->iface = pkt->iface;
  112a91:	8b 46 20             	mov    0x20(%esi),%eax
  112a94:	89 43 0c             	mov    %eax,0xc(%ebx)
  112a97:	8a 46 3f             	mov    0x3f(%esi),%al
  112a9a:	d0 e8                	shr    %al
	net_context_set_family(conn->context, net_pkt_family(pkt));
  112a9c:	8b 4b 04             	mov    0x4(%ebx),%ecx
  112a9f:	83 e0 07             	and    $0x7,%eax
	if (family == AF_UNSPEC || family == AF_INET || family == AF_INET6 ||
  112aa2:	3c 04                	cmp    $0x4,%al
  112aa4:	77 07                	ja     112aad <tcp_recv+0x106>
		flag = family << 3;
  112aa6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
	context->flags |= flag;
  112aad:	0f b6 d2             	movzbl %dl,%edx
  112ab0:	66 09 91 92 00 00 00 	or     %dx,0x92(%ecx)
	if (tcp_endpoint_set(&conn->dst, pkt, TCP_EP_SRC) < 0) {
  112ab7:	8d bb 30 01 00 00    	lea    0x130(%ebx),%edi
  112abd:	b9 01 00 00 00       	mov    $0x1,%ecx
  112ac2:	89 f2                	mov    %esi,%edx
  112ac4:	89 f8                	mov    %edi,%eax
  112ac6:	e8 dd ec ff ff       	call   1117a8 <tcp_endpoint_set>
  112acb:	85 c0                	test   %eax,%eax
  112acd:	0f 88 e1 00 00 00    	js     112bb4 <tcp_recv+0x20d>
	if (tcp_endpoint_set(&conn->src, pkt, TCP_EP_DST) < 0) {
  112ad3:	31 c9                	xor    %ecx,%ecx
  112ad5:	8d 83 18 01 00 00    	lea    0x118(%ebx),%eax
  112adb:	89 f2                	mov    %esi,%edx
  112add:	e8 c6 ec ff ff       	call   1117a8 <tcp_endpoint_set>
  112ae2:	85 c0                	test   %eax,%eax
  112ae4:	0f 88 ca 00 00 00    	js     112bb4 <tcp_recv+0x20d>
	memcpy(&context->remote, &conn->dst, sizeof(context->remote));
  112aea:	6a 08                	push   $0x8
  112aec:	8b 45 e8             	mov    -0x18(%ebp),%eax
  112aef:	57                   	push   %edi
  112af0:	83 c0 2c             	add    $0x2c,%eax
  112af3:	50                   	push   %eax
  112af4:	e8 f3 92 ff ff       	call   10bdec <memcpy>
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
  112af9:	8b 55 e8             	mov    -0x18(%ebp),%edx
	memcpy(&context->remote, &conn->dst, sizeof(context->remote));
  112afc:	83 c4 0c             	add    $0xc,%esp
	sa_family_t af = net_pkt_family(pkt);
  112aff:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
  112b03:	66 8b 82 92 00 00 00 	mov    0x92(%edx),%ax
	sa_family_t af = net_pkt_family(pkt);
  112b0a:	66 89 4a 24          	mov    %cx,0x24(%edx)
	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
  112b0e:	80 cc 01             	or     $0x1,%ah
  112b11:	66 89 82 92 00 00 00 	mov    %ax,0x92(%edx)
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  112b18:	66 c1 e8 03          	shr    $0x3,%ax
  112b1c:	83 e0 07             	and    $0x7,%eax
	local_addr.sa_family = net_context_get_family(context);
  112b1f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
  112b23:	66 48                	dec    %ax
  112b25:	75 0c                	jne    112b33 <tcp_recv+0x18c>
		if (net_sin_ptr(&context->local)->sin_addr) {
  112b27:	8b 42 28             	mov    0x28(%edx),%eax
  112b2a:	85 c0                	test   %eax,%eax
  112b2c:	74 05                	je     112b33 <tcp_recv+0x18c>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
  112b2e:	8b 00                	mov    (%eax),%eax
  112b30:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ret = net_context_bind(context, &local_addr, sizeof(local_addr));
  112b33:	6a 08                	push   $0x8
  112b35:	8d 7d ec             	lea    -0x14(%ebp),%edi
  112b38:	57                   	push   %edi
  112b39:	52                   	push   %edx
  112b3a:	e8 a9 c2 ff ff       	call   10ede8 <net_context_bind>
  112b3f:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  112b42:	85 c0                	test   %eax,%eax
  112b44:	78 6e                	js     112bb4 <tcp_recv+0x20d>
	ret = net_conn_register(IPPROTO_TCP, af,
  112b46:	8b 4d e8             	mov    -0x18(%ebp),%ecx
				ntohs(conn->src.sin.sin_port),/* remote port */
  112b49:	66 8b 93 1a 01 00 00 	mov    0x11a(%ebx),%dx
	ret = net_conn_register(IPPROTO_TCP, af,
  112b50:	83 c1 34             	add    $0x34,%ecx
				ntohs(conn->dst.sin.sin_port),/* local port */
  112b53:	66 8b 83 32 01 00 00 	mov    0x132(%ebx),%ax
	ret = net_conn_register(IPPROTO_TCP, af,
  112b5a:	51                   	push   %ecx
				ntohs(conn->src.sin.sin_port),/* remote port */
  112b5b:	86 f2                	xchg   %dh,%dl
	ret = net_conn_register(IPPROTO_TCP, af,
  112b5d:	ff 75 e8             	pushl  -0x18(%ebp)
				ntohs(conn->dst.sin.sin_port),/* local port */
  112b60:	86 e0                	xchg   %ah,%al
	ret = net_conn_register(IPPROTO_TCP, af,
  112b62:	0f b7 d2             	movzwl %dx,%edx
  112b65:	68 a7 29 11 00       	push   $0x1129a7
  112b6a:	52                   	push   %edx
  112b6b:	0f b7 c0             	movzwl %ax,%eax
  112b6e:	50                   	push   %eax
				&context->remote, &local_addr,
  112b6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
	ret = net_conn_register(IPPROTO_TCP, af,
  112b72:	57                   	push   %edi
				&context->remote, &local_addr,
  112b73:	83 c0 2c             	add    $0x2c,%eax
	ret = net_conn_register(IPPROTO_TCP, af,
  112b76:	50                   	push   %eax
  112b77:	ff 75 dc             	pushl  -0x24(%ebp)
  112b7a:	6a 06                	push   $0x6
  112b7c:	e8 2e e3 ff ff       	call   110eaf <net_conn_register>
  112b81:	83 c4 24             	add    $0x24,%esp
	if (ret < 0) {
  112b84:	85 c0                	test   %eax,%eax
  112b86:	79 37                	jns    112bbf <tcp_recv+0x218>
		NET_ERR("net_conn_register(): %d", ret);
  112b88:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  112b8f:	74 23                	je     112bb4 <tcp_recv+0x20d>
  112b91:	ba a0 31 12 00       	mov    $0x1231a0,%edx
  112b96:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  112b9c:	c1 ea 03             	shr    $0x3,%edx
  112b9f:	c1 e2 06             	shl    $0x6,%edx
  112ba2:	83 ca 01             	or     $0x1,%edx
  112ba5:	52                   	push   %edx
  112ba6:	50                   	push   %eax
  112ba7:	68 4d 61 12 00       	push   $0x12614d
  112bac:	e8 c5 09 ff ff       	call   103576 <log_1>
  112bb1:	83 c4 0c             	add    $0xc,%esp
		net_context_unref(context);
  112bb4:	ff 75 e8             	pushl  -0x18(%ebp)
  112bb7:	e8 65 c1 ff ff       	call   10ed21 <net_context_unref>
  112bbc:	59                   	pop    %ecx
		if (!conn) {
  112bbd:	eb 29                	jmp    112be8 <tcp_recv+0x241>
		net_ipaddr_copy(&conn_old->context->remote, &conn->dst.sa);
  112bbf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  112bc2:	8b 93 30 01 00 00    	mov    0x130(%ebx),%edx
  112bc8:	8b 40 04             	mov    0x4(%eax),%eax
  112bcb:	89 55 ec             	mov    %edx,-0x14(%ebp)
  112bce:	8b 8b 34 01 00 00    	mov    0x134(%ebx),%ecx
  112bd4:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  112bd7:	89 50 2c             	mov    %edx,0x2c(%eax)
  112bda:	8b 55 f0             	mov    -0x10(%ebp),%edx
  112bdd:	89 50 30             	mov    %edx,0x30(%eax)
		conn->accepted_conn = conn_old;
  112be0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  112be3:	89 43 1c             	mov    %eax,0x1c(%ebx)
  112be6:	eb 2b                	jmp    112c13 <tcp_recv+0x26c>
			NET_ERR("Cannot allocate a new TCP connection");
  112be8:	f6 05 10 5c 14 00 07 	testb  $0x7,0x145c10
  112bef:	74 2b                	je     112c1c <tcp_recv+0x275>
  112bf1:	b8 a0 31 12 00       	mov    $0x1231a0,%eax
  112bf6:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  112bfb:	c1 e8 03             	shr    $0x3,%eax
  112bfe:	c1 e0 06             	shl    $0x6,%eax
  112c01:	83 c8 01             	or     $0x1,%eax
  112c04:	50                   	push   %eax
  112c05:	68 65 61 12 00       	push   $0x126165
  112c0a:	e8 3e 09 ff ff       	call   10354d <log_0>
  112c0f:	58                   	pop    %eax
  112c10:	5a                   	pop    %edx
	if (conn) {
  112c11:	eb 09                	jmp    112c1c <tcp_recv+0x275>
		tcp_in(conn, pkt);
  112c13:	89 f2                	mov    %esi,%edx
  112c15:	89 d8                	mov    %ebx,%eax
  112c17:	e8 ef f3 ff ff       	call   11200b <tcp_in>
}
  112c1c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  112c1f:	b8 02 00 00 00       	mov    $0x2,%eax
  112c24:	5b                   	pop    %ebx
  112c25:	5e                   	pop    %esi
  112c26:	5f                   	pop    %edi
  112c27:	5d                   	pop    %ebp
  112c28:	c3                   	ret    

00112c29 <tcp_resend_data>:
{
  112c29:	55                   	push   %ebp
	k_mutex_lock(&conn->lock, K_FOREVER);
  112c2a:	83 ca ff             	or     $0xffffffff,%edx
{
  112c2d:	89 e5                	mov    %esp,%ebp
  112c2f:	57                   	push   %edi
  112c30:	56                   	push   %esi
  112c31:	53                   	push   %ebx
  112c32:	51                   	push   %ecx
	k_mutex_lock(&conn->lock, K_FOREVER);
  112c33:	89 d1                	mov    %edx,%ecx
{
  112c35:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&conn->lock, K_FOREVER);
  112c38:	8d bb 74 ff ff ff    	lea    -0x8c(%ebx),%edi
	struct tcp *conn = CONTAINER_OF(work, struct tcp, send_data_timer);
  112c3e:	8d b3 54 ff ff ff    	lea    -0xac(%ebx),%esi
	k_mutex_lock(&conn->lock, K_FOREVER);
  112c44:	89 f8                	mov    %edi,%eax
  112c46:	e8 57 ec ff ff       	call   1118a2 <k_mutex_lock.constprop.0>
		conn_unref = true;
  112c4b:	b2 01                	mov    $0x1,%dl
	if (conn->send_data_retries >= tcp_retries) {
  112c4d:	80 bb c0 00 00 00 08 	cmpb   $0x8,0xc0(%ebx)
  112c54:	0f 87 88 00 00 00    	ja     112ce2 <tcp_resend_data+0xb9>
	conn->data_mode = TCP_DATA_MODE_RESEND;
  112c5a:	c7 83 b0 00 00 00 01 	movl   $0x1,0xb0(%ebx)
  112c61:	00 00 00 
	conn->unacked_len = 0;
  112c64:	c7 83 a4 00 00 00 00 	movl   $0x0,0xa4(%ebx)
  112c6b:	00 00 00 
	ret = tcp_send_data(conn);
  112c6e:	89 f0                	mov    %esi,%eax
  112c70:	e8 32 f1 ff ff       	call   111da7 <tcp_send_data>
	if (ret == 0) {
  112c75:	85 c0                	test   %eax,%eax
  112c77:	75 59                	jne    112cd2 <tcp_resend_data+0xa9>
		conn->send_data_retries++;
  112c79:	fe 83 c0 00 00 00    	incb   0xc0(%ebx)
		if (conn->in_close && conn->send_data_total == 0) {
  112c7f:	f6 83 c1 00 00 00 04 	testb  $0x4,0xc1(%ebx)
  112c86:	74 4a                	je     112cd2 <tcp_resend_data+0xa9>
  112c88:	83 bb 9c 00 00 00 00 	cmpl   $0x0,0x9c(%ebx)
  112c8f:	75 41                	jne    112cd2 <tcp_resend_data+0xa9>
			k_delayed_work_submit(&conn->fin_timer, FIN_TIMEOUT);
  112c91:	31 c9                	xor    %ecx,%ecx
  112c93:	ba 64 00 00 00       	mov    $0x64,%edx
  112c98:	8d 43 48             	lea    0x48(%ebx),%eax
  112c9b:	e8 c1 e8 ff ff       	call   111561 <k_delayed_work_submit>
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
  112ca0:	8b 83 a4 00 00 00    	mov    0xa4(%ebx),%eax
  112ca6:	03 83 b4 00 00 00    	add    0xb4(%ebx),%eax
			conn_state(conn, TCP_FIN_WAIT_1);
  112cac:	c7 83 ac 00 00 00 05 	movl   $0x5,0xac(%ebx)
  112cb3:	00 00 00 
			ret = tcp_out_ext(conn, FIN | ACK, NULL,
  112cb6:	31 c9                	xor    %ecx,%ecx
  112cb8:	50                   	push   %eax
  112cb9:	ba 11 00 00 00       	mov    $0x11,%edx
  112cbe:	89 f0                	mov    %esi,%eax
  112cc0:	e8 41 ef ff ff       	call   111c06 <tcp_out_ext>
  112cc5:	5a                   	pop    %edx
			if (ret == 0) {
  112cc6:	85 c0                	test   %eax,%eax
  112cc8:	75 16                	jne    112ce0 <tcp_resend_data+0xb7>
				conn_seq(conn, + 1);
  112cca:	ff 83 b4 00 00 00    	incl   0xb4(%ebx)
			goto out;
  112cd0:	eb 0e                	jmp    112ce0 <tcp_resend_data+0xb7>
	k_delayed_work_submit(&conn->send_data_timer, K_MSEC(tcp_rto));
  112cd2:	ba 14 00 00 00       	mov    $0x14,%edx
  112cd7:	31 c9                	xor    %ecx,%ecx
  112cd9:	89 d8                	mov    %ebx,%eax
  112cdb:	e8 81 e8 ff ff       	call   111561 <k_delayed_work_submit>
	bool conn_unref = false;
  112ce0:	31 d2                	xor    %edx,%edx
	k_mutex_unlock(&conn->lock);
  112ce2:	89 f8                	mov    %edi,%eax
  112ce4:	88 55 f3             	mov    %dl,-0xd(%ebp)
  112ce7:	e8 8a e8 ff ff       	call   111576 <k_mutex_unlock>
	if (conn_unref) {
  112cec:	8a 55 f3             	mov    -0xd(%ebp),%dl
  112cef:	84 d2                	test   %dl,%dl
  112cf1:	74 0e                	je     112d01 <tcp_resend_data+0xd8>
}
  112cf3:	8d 65 f4             	lea    -0xc(%ebp),%esp
		tcp_conn_unref(conn);
  112cf6:	89 f0                	mov    %esi,%eax
}
  112cf8:	5b                   	pop    %ebx
  112cf9:	5e                   	pop    %esi
  112cfa:	5f                   	pop    %edi
  112cfb:	5d                   	pop    %ebp
		tcp_conn_unref(conn);
  112cfc:	e9 ed eb ff ff       	jmp    1118ee <tcp_conn_unref>
}
  112d01:	8d 65 f4             	lea    -0xc(%ebp),%esp
  112d04:	5b                   	pop    %ebx
  112d05:	5e                   	pop    %esi
  112d06:	5f                   	pop    %edi
  112d07:	5d                   	pop    %ebp
  112d08:	c3                   	ret    

00112d09 <tcp_send_process>:
{
  112d09:	55                   	push   %ebp
	k_mutex_lock(&conn->lock, K_FOREVER);
  112d0a:	83 ca ff             	or     $0xffffffff,%edx
{
  112d0d:	89 e5                	mov    %esp,%ebp
  112d0f:	57                   	push   %edi
  112d10:	56                   	push   %esi
	k_mutex_lock(&conn->lock, K_FOREVER);
  112d11:	89 d1                	mov    %edx,%ecx
{
  112d13:	53                   	push   %ebx
  112d14:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_mutex_lock(&conn->lock, K_FOREVER);
  112d17:	8d 73 98             	lea    -0x68(%ebx),%esi
	struct tcp *conn = CONTAINER_OF(work, struct tcp, send_timer);
  112d1a:	8d bb 78 ff ff ff    	lea    -0x88(%ebx),%edi
	k_mutex_lock(&conn->lock, K_FOREVER);
  112d20:	89 f0                	mov    %esi,%eax
  112d22:	e8 7b eb ff ff       	call   1118a2 <k_mutex_lock.constprop.0>
	unref = tcp_send_process_no_lock(conn);
  112d27:	89 f8                	mov    %edi,%eax
  112d29:	e8 ae ed ff ff       	call   111adc <tcp_send_process_no_lock>
  112d2e:	88 c3                	mov    %al,%bl
	k_mutex_unlock(&conn->lock);
  112d30:	89 f0                	mov    %esi,%eax
  112d32:	e8 3f e8 ff ff       	call   111576 <k_mutex_unlock>
	if (unref) {
  112d37:	84 db                	test   %bl,%bl
  112d39:	74 0b                	je     112d46 <tcp_send_process+0x3d>
}
  112d3b:	5b                   	pop    %ebx
		tcp_conn_unref(conn);
  112d3c:	89 f8                	mov    %edi,%eax
}
  112d3e:	5e                   	pop    %esi
  112d3f:	5f                   	pop    %edi
  112d40:	5d                   	pop    %ebp
		tcp_conn_unref(conn);
  112d41:	e9 a8 eb ff ff       	jmp    1118ee <tcp_conn_unref>
}
  112d46:	5b                   	pop    %ebx
  112d47:	5e                   	pop    %esi
  112d48:	5f                   	pop    %edi
  112d49:	5d                   	pop    %ebp
  112d4a:	c3                   	ret    

00112d4b <net_tcp_unref>:
{
  112d4b:	55                   	push   %ebp
  112d4c:	89 e5                	mov    %esp,%ebp
	if (context->tcp) {
  112d4e:	8b 45 08             	mov    0x8(%ebp),%eax
  112d51:	8b 40 44             	mov    0x44(%eax),%eax
  112d54:	85 c0                	test   %eax,%eax
  112d56:	74 06                	je     112d5e <net_tcp_unref+0x13>
}
  112d58:	5d                   	pop    %ebp
		ref_count = tcp_conn_unref(context->tcp);
  112d59:	e9 90 eb ff ff       	jmp    1118ee <tcp_conn_unref>
}
  112d5e:	31 c0                	xor    %eax,%eax
  112d60:	5d                   	pop    %ebp
  112d61:	c3                   	ret    

00112d62 <net_tcp_get>:
{
  112d62:	55                   	push   %ebp
  112d63:	89 e5                	mov    %esp,%ebp
  112d65:	57                   	push   %edi
  112d66:	56                   	push   %esi
  112d67:	53                   	push   %ebx
  112d68:	51                   	push   %ecx
  112d69:	8b 5d 08             	mov    0x8(%ebp),%ebx
  112d6c:	9c                   	pushf  
  112d6d:	fa                   	cli    
  112d6e:	5e                   	pop    %esi
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
  112d6f:	6a 00                	push   $0x0
  112d71:	8d 45 f0             	lea    -0x10(%ebp),%eax
  112d74:	6a 00                	push   $0x0
	struct tcp *conn = NULL;
  112d76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	ret = k_mem_slab_alloc(&tcp_conns_slab, (void **)&conn, K_NO_WAIT);
  112d7d:	50                   	push   %eax
  112d7e:	68 84 5c 14 00       	push   $0x145c84
  112d83:	e8 84 db 00 00       	call   12090c <k_mem_slab_alloc>
  112d88:	83 c4 10             	add    $0x10,%esp
	if (ret) {
  112d8b:	85 c0                	test   %eax,%eax
  112d8d:	0f 85 09 01 00 00    	jne    112e9c <net_tcp_get+0x13a>
	memset(conn, 0, sizeof(*conn));
  112d93:	68 70 01 00 00       	push   $0x170
  112d98:	6a 00                	push   $0x0
  112d9a:	ff 75 f0             	pushl  -0x10(%ebp)
  112d9d:	e8 b9 90 ff ff       	call   10be5b <memset>
	k_mutex_init(&conn->lock);
  112da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memset(conn, 0, sizeof(*conn));
  112da5:	83 c4 0c             	add    $0xc,%esp
	k_mutex_init(&conn->lock);
  112da8:	83 c0 20             	add    $0x20,%eax
	return z_impl_k_mutex_init(mutex);
  112dab:	50                   	push   %eax
  112dac:	e8 f5 dd 00 00       	call   120ba6 <z_impl_k_mutex_init>
	k_fifo_init(&conn->recv_data);
  112db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  112db4:	83 c0 5c             	add    $0x5c,%eax
	z_impl_k_queue_init(queue);
  112db7:	89 04 24             	mov    %eax,(%esp)
  112dba:	e8 d1 e0 00 00       	call   120e90 <z_impl_k_queue_init>
	conn->state = TCP_LISTEN;
  112dbf:	8b 7d f0             	mov    -0x10(%ebp),%edi
  112dc2:	58                   	pop    %eax
  112dc3:	c7 87 58 01 00 00 01 	movl   $0x1,0x158(%edi)
  112dca:	00 00 00 
	conn->recv_win = tcp_window;
  112dcd:	66 c7 87 68 01 00 00 	movw   $0x500,0x168(%edi)
  112dd4:	00 05 
  112dd6:	e8 77 d1 00 00       	call   11ff52 <z_impl_sys_rand32_get>
	conn->seq = (IS_ENABLED(CONFIG_NET_TEST_PROTOCOL) ||
  112ddb:	89 87 60 01 00 00    	mov    %eax,0x160(%edi)
	sys_slist_init(&conn->send_queue);
  112de1:	8b 45 f0             	mov    -0x10(%ebp),%eax
	k_delayed_work_init(&conn->send_timer, tcp_send_process);
  112de4:	05 88 00 00 00       	add    $0x88,%eax
	list->head = NULL;
  112de9:	c7 40 8c 00 00 00 00 	movl   $0x0,-0x74(%eax)
	list->tail = NULL;
  112df0:	c7 40 90 00 00 00 00 	movl   $0x0,-0x70(%eax)
  112df7:	68 09 2d 11 00       	push   $0x112d09
  112dfc:	50                   	push   %eax
  112dfd:	e8 a5 f0 00 00       	call   121ea7 <k_delayed_work_init>
  112e02:	5a                   	pop    %edx
	k_delayed_work_init(&conn->timewait_timer, tcp_timewait_timeout);
  112e03:	8b 45 f0             	mov    -0x10(%ebp),%eax
	k_delayed_work_init(&conn->send_timer, tcp_send_process);
  112e06:	59                   	pop    %ecx
	k_delayed_work_init(&conn->timewait_timer, tcp_timewait_timeout);
  112e07:	05 d0 00 00 00       	add    $0xd0,%eax
  112e0c:	68 e8 14 11 00       	push   $0x1114e8
  112e11:	50                   	push   %eax
  112e12:	e8 90 f0 00 00       	call   121ea7 <k_delayed_work_init>
  112e17:	5f                   	pop    %edi
  112e18:	58                   	pop    %eax
	k_delayed_work_init(&conn->fin_timer, tcp_fin_timeout);
  112e19:	8b 45 f0             	mov    -0x10(%ebp),%eax
  112e1c:	68 d3 14 11 00       	push   $0x1114d3
  112e21:	05 f4 00 00 00       	add    $0xf4,%eax
  112e26:	50                   	push   %eax
  112e27:	e8 7b f0 00 00       	call   121ea7 <k_delayed_work_init>
  112e2c:	58                   	pop    %eax
  112e2d:	5a                   	pop    %edx
	conn->send_data = tcp_pkt_alloc(conn, 0);
  112e2e:	6a 00                	push   $0x0
  112e30:	6a 0a                	push   $0xa
  112e32:	e8 44 ce ff ff       	call   10fc7b <net_pkt_alloc>
  112e37:	59                   	pop    %ecx
  112e38:	8b 55 f0             	mov    -0x10(%ebp),%edx
  112e3b:	5f                   	pop    %edi
  112e3c:	89 42 08             	mov    %eax,0x8(%edx)
	k_delayed_work_init(&conn->send_data_timer, tcp_resend_data);
  112e3f:	68 29 2c 11 00       	push   $0x112c29
  112e44:	8d 82 ac 00 00 00    	lea    0xac(%edx),%eax
  112e4a:	50                   	push   %eax
  112e4b:	e8 57 f0 00 00       	call   121ea7 <k_delayed_work_init>
  112e50:	58                   	pop    %eax
	k_sem_init(&conn->connect_sem, 0, UINT_MAX);
  112e51:	8b 45 f0             	mov    -0x10(%ebp),%eax
	k_delayed_work_init(&conn->send_data_timer, tcp_resend_data);
  112e54:	5a                   	pop    %edx
	k_sem_init(&conn->connect_sem, 0, UINT_MAX);
  112e55:	83 c0 3c             	add    $0x3c,%eax
	return z_impl_k_sem_init(sem, initial_count, limit);
  112e58:	6a ff                	push   $0xffffffff
  112e5a:	6a 00                	push   $0x0
  112e5c:	50                   	push   %eax
  112e5d:	e8 f5 e9 00 00       	call   121857 <z_impl_k_sem_init>
	conn->in_connect = false;
  112e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
  112e65:	83 c4 0c             	add    $0xc,%esp
  112e68:	80 a0 6d 01 00 00 fd 	andb   $0xfd,0x16d(%eax)
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  112e6f:	f0 ff 80 54 01 00 00 	lock incl 0x154(%eax)
	sys_slist_append(&tcp_conns, &conn->next);
  112e76:	8b 45 f0             	mov    -0x10(%ebp),%eax
	parent->next = child;
  112e79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
Z_GENLIST_APPEND(slist, snode)
  112e7f:	8b 15 0c ec 12 00    	mov    0x12ec0c,%edx
  112e85:	85 d2                	test   %edx,%edx
  112e87:	75 0c                	jne    112e95 <net_tcp_get+0x133>
	list->tail = node;
  112e89:	a3 0c ec 12 00       	mov    %eax,0x12ec0c
	list->head = node;
  112e8e:	a3 08 ec 12 00       	mov    %eax,0x12ec08
}
  112e93:	eb 07                	jmp    112e9c <net_tcp_get+0x13a>
	parent->next = child;
  112e95:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  112e97:	a3 0c ec 12 00       	mov    %eax,0x12ec0c
	return conn;
  112e9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
		ret = -ENOMEM;
  112e9f:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (conn == NULL) {
  112ea4:	85 c0                	test   %eax,%eax
  112ea6:	74 08                	je     112eb0 <net_tcp_get+0x14e>
	conn->context = context;
  112ea8:	89 58 04             	mov    %ebx,0x4(%eax)
	int ret = 0, key = irq_lock();
  112eab:	31 d2                	xor    %edx,%edx
	context->tcp = conn;
  112ead:	89 43 44             	mov    %eax,0x44(%ebx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  112eb0:	0f ba e6 09          	bt     $0x9,%esi
  112eb4:	73 01                	jae    112eb7 <net_tcp_get+0x155>
		__asm__ volatile ("sti" ::: "memory");
  112eb6:	fb                   	sti    
}
  112eb7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  112eba:	89 d0                	mov    %edx,%eax
  112ebc:	5b                   	pop    %ebx
  112ebd:	5e                   	pop    %esi
  112ebe:	5f                   	pop    %edi
  112ebf:	5d                   	pop    %ebp
  112ec0:	c3                   	ret    

00112ec1 <net_tcp_put>:

/* Active connection close: send FIN and go to FIN_WAIT_1 state */
int net_tcp_put(struct net_context *context)
{
  112ec1:	55                   	push   %ebp
  112ec2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  112ec7:	89 e5                	mov    %esp,%ebp
  112ec9:	57                   	push   %edi
  112eca:	56                   	push   %esi
  112ecb:	8b 75 08             	mov    0x8(%ebp),%esi
  112ece:	53                   	push   %ebx
	struct tcp *conn = context->tcp;
  112ecf:	8b 5e 44             	mov    0x44(%esi),%ebx

	if (!conn) {
  112ed2:	85 db                	test   %ebx,%ebx
  112ed4:	0f 84 95 00 00 00    	je     112f6f <net_tcp_put+0xae>
		return -ENOENT;
	}

	k_mutex_lock(&conn->lock, K_FOREVER);
  112eda:	83 ca ff             	or     $0xffffffff,%edx
  112edd:	8d 7b 20             	lea    0x20(%ebx),%edi
  112ee0:	89 d1                	mov    %edx,%ecx
  112ee2:	89 f8                	mov    %edi,%eax
  112ee4:	e8 b9 e9 ff ff       	call   1118a2 <k_mutex_lock.constprop.0>
	NET_DBG("%s", conn ? log_strdup(tcp_conn_state(conn, NULL)) : "");
	NET_DBG("context %p %s", context,
		log_strdup(({ const char *state = net_context_state(context);
					state ? state : "<unknown>"; })));

	if (conn && conn->state == TCP_ESTABLISHED) {
  112ee9:	83 bb 58 01 00 00 04 	cmpl   $0x4,0x158(%ebx)
  112ef0:	75 6d                	jne    112f5f <net_tcp_put+0x9e>
		/* Send all remaining data if possible. */
		if (conn->send_data_total > 0) {
  112ef2:	83 bb 48 01 00 00 00 	cmpl   $0x0,0x148(%ebx)
  112ef9:	74 1b                	je     112f16 <net_tcp_put+0x55>
			NET_DBG("conn %p pending %zu bytes", conn,
				conn->send_data_total);
			conn->in_close = true;
  112efb:	80 8b 6d 01 00 00 04 	orb    $0x4,0x16d(%ebx)

			/* How long to wait until all the data has been sent?
			 */
			k_delayed_work_submit(&conn->send_data_timer,
  112f02:	8d 83 ac 00 00 00    	lea    0xac(%ebx),%eax
  112f08:	ba 14 00 00 00       	mov    $0x14,%edx
  112f0d:	31 c9                	xor    %ecx,%ecx
  112f0f:	e8 4d e6 ff ff       	call   111561 <k_delayed_work_submit>
  112f14:	eb 42                	jmp    112f58 <net_tcp_put+0x97>
		} else {
			int ret;

			NET_DBG("TCP connection in active close, not "
				"disposing yet (waiting %dms)", FIN_TIMEOUT_MS);
			k_delayed_work_submit(&conn->fin_timer, FIN_TIMEOUT);
  112f16:	31 c9                	xor    %ecx,%ecx
  112f18:	ba 64 00 00 00       	mov    $0x64,%edx
  112f1d:	8d 83 f4 00 00 00    	lea    0xf4(%ebx),%eax
  112f23:	e8 39 e6 ff ff       	call   111561 <k_delayed_work_submit>

			ret = tcp_out_ext(conn, FIN | ACK, NULL,
  112f28:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
  112f2e:	03 83 60 01 00 00    	add    0x160(%ebx),%eax
  112f34:	31 c9                	xor    %ecx,%ecx
  112f36:	50                   	push   %eax
  112f37:	ba 11 00 00 00       	mov    $0x11,%edx
  112f3c:	89 d8                	mov    %ebx,%eax
  112f3e:	e8 c3 ec ff ff       	call   111c06 <tcp_out_ext>
  112f43:	59                   	pop    %ecx
				    conn->seq + conn->unacked_len);
			if (ret == 0) {
  112f44:	85 c0                	test   %eax,%eax
  112f46:	75 06                	jne    112f4e <net_tcp_put+0x8d>
				conn_seq(conn, + 1);
  112f48:	ff 83 60 01 00 00    	incl   0x160(%ebx)
			}

			conn_state(conn, TCP_FIN_WAIT_1);
  112f4e:	c7 83 58 01 00 00 05 	movl   $0x5,0x158(%ebx)
  112f55:	00 00 00 
		}

		/* Make sure we do not delete the connection yet until we have
		 * sent the final ACK.
		 */
		net_context_ref(context);
  112f58:	56                   	push   %esi
  112f59:	e8 b0 bd ff ff       	call   10ed0e <net_context_ref>
  112f5e:	5a                   	pop    %edx
	}

	k_mutex_unlock(&conn->lock);
  112f5f:	89 f8                	mov    %edi,%eax
  112f61:	e8 10 e6 ff ff       	call   111576 <k_mutex_unlock>

	net_context_unref(context);
  112f66:	56                   	push   %esi
  112f67:	e8 b5 bd ff ff       	call   10ed21 <net_context_unref>
  112f6c:	58                   	pop    %eax

	return 0;
  112f6d:	31 c0                	xor    %eax,%eax
}
  112f6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  112f72:	5b                   	pop    %ebx
  112f73:	5e                   	pop    %esi
  112f74:	5f                   	pop    %edi
  112f75:	5d                   	pop    %ebp
  112f76:	c3                   	ret    

00112f77 <net_tcp_listen>:

int net_tcp_listen(struct net_context *context)
{
  112f77:	55                   	push   %ebp
  112f78:	89 e5                	mov    %esp,%ebp
  112f7a:	8b 45 08             	mov    0x8(%ebp),%eax
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
  112f7d:	66 83 88 92 00 00 00 	orw    $0x6,0x92(%eax)
  112f84:	06 
	/* when created, tcp connections are in state TCP_LISTEN */
	net_context_set_state(context, NET_CONTEXT_LISTENING);

	return 0;
}
  112f85:	31 c0                	xor    %eax,%eax
  112f87:	5d                   	pop    %ebp
  112f88:	c3                   	ret    

00112f89 <net_tcp_update_recv_wnd>:
{
	ARG_UNUSED(context);
	ARG_UNUSED(delta);

	return -EPROTONOSUPPORT;
}
  112f89:	b8 d5 ff ff ff       	mov    $0xffffffd5,%eax
  112f8e:	c3                   	ret    

00112f8f <net_tcp_queue_data>:

/* net_context queues the outgoing data for the TCP connection */
int net_tcp_queue_data(struct net_context *context, struct net_pkt *pkt)
{
  112f8f:	55                   	push   %ebp
  112f90:	89 e5                	mov    %esp,%ebp
  112f92:	57                   	push   %edi
  112f93:	56                   	push   %esi
	struct net_buf *orig_buf = NULL;
	int ret = 0;
	size_t len;

	if (!conn || conn->state != TCP_ESTABLISHED) {
		return -ENOTCONN;
  112f94:	be c7 ff ff ff       	mov    $0xffffffc7,%esi
{
  112f99:	53                   	push   %ebx
  112f9a:	83 ec 0c             	sub    $0xc,%esp
	struct tcp *conn = context->tcp;
  112f9d:	8b 45 08             	mov    0x8(%ebp),%eax
{
  112fa0:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct tcp *conn = context->tcp;
  112fa3:	8b 58 44             	mov    0x44(%eax),%ebx
	if (!conn || conn->state != TCP_ESTABLISHED) {
  112fa6:	85 db                	test   %ebx,%ebx
  112fa8:	0f 84 04 01 00 00    	je     1130b2 <net_tcp_queue_data+0x123>
  112fae:	83 bb 58 01 00 00 04 	cmpl   $0x4,0x158(%ebx)
  112fb5:	0f 85 f7 00 00 00    	jne    1130b2 <net_tcp_queue_data+0x123>
	}

	k_mutex_lock(&conn->lock, K_FOREVER);
  112fbb:	83 ca ff             	or     $0xffffffff,%edx
  112fbe:	8d 43 20             	lea    0x20(%ebx),%eax
  112fc1:	89 d1                	mov    %edx,%ecx
  112fc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  112fc6:	e8 d7 e8 ff ff       	call   1118a2 <k_mutex_lock.constprop.0>
	bool window_full = !(conn->unacked_len < conn->send_win);
  112fcb:	0f b7 83 6a 01 00 00 	movzwl 0x16a(%ebx),%eax

	if (tcp_window_full(conn)) {
  112fd2:	3b 83 50 01 00 00    	cmp    0x150(%ebx),%eax
  112fd8:	7f 2e                	jg     113008 <net_tcp_queue_data+0x79>
  112fda:	8d bb ac 00 00 00    	lea    0xac(%ebx),%edi
  112fe0:	81 c3 b8 00 00 00    	add    $0xb8,%ebx
  112fe6:	53                   	push   %ebx
  112fe7:	e8 08 f2 00 00       	call   1221f4 <z_timeout_remaining>
  112fec:	6b c0 0a             	imul   $0xa,%eax,%eax
  112fef:	5a                   	pop    %edx
		if (!k_delayed_work_remaining_get(&conn->send_data_timer)) {
			NET_DBG("Window full, trigger resend");
			tcp_resend_data(&conn->send_data_timer.work);
		}

		ret = -EAGAIN;
  112ff0:	be f5 ff ff ff       	mov    $0xfffffff5,%esi
		if (!k_delayed_work_remaining_get(&conn->send_data_timer)) {
  112ff5:	85 c0                	test   %eax,%eax
  112ff7:	0f 85 ad 00 00 00    	jne    1130aa <net_tcp_queue_data+0x11b>
			tcp_resend_data(&conn->send_data_timer.work);
  112ffd:	57                   	push   %edi
  112ffe:	e8 26 fc ff ff       	call   112c29 <tcp_resend_data>
  113003:	e9 a1 00 00 00       	jmp    1130a9 <net_tcp_queue_data+0x11a>
	return net_buf_frags_len(pkt->frags);
  113008:	8b 47 10             	mov    0x10(%edi),%eax
  11300b:	e8 b0 e4 ff ff       	call   1114c0 <net_buf_frags_len>
  113010:	89 45 f0             	mov    %eax,-0x10(%ebp)
		goto out;
	}

	len = net_pkt_get_len(pkt);

	if (conn->send_data->buffer) {
  113013:	8b 43 08             	mov    0x8(%ebx),%eax
  113016:	8b 50 10             	mov    0x10(%eax),%edx
  113019:	85 d2                	test   %edx,%edx
  11301b:	74 09                	je     113026 <net_tcp_queue_data+0x97>
		orig_buf = net_buf_frag_last(conn->send_data->buffer);
  11301d:	52                   	push   %edx
  11301e:	e8 4f 91 ff ff       	call   10c172 <net_buf_frag_last>
  113023:	5e                   	pop    %esi
  113024:	89 c2                	mov    %eax,%edx
	}

	net_pkt_append_buffer(conn->send_data, pkt->buffer);
  113026:	ff 77 10             	pushl  0x10(%edi)
  113029:	ff 73 08             	pushl  0x8(%ebx)
  11302c:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11302f:	e8 a9 cc ff ff       	call   10fcdd <net_pkt_append_buffer>
  113034:	5a                   	pop    %edx
	conn->send_data_total += len;
  113035:	8b 45 f0             	mov    -0x10(%ebp),%eax
	net_pkt_append_buffer(conn->send_data, pkt->buffer);
  113038:	59                   	pop    %ecx
	int ret = 0;
  113039:	31 f6                	xor    %esi,%esi
	conn->send_data_total += len;
  11303b:	01 83 48 01 00 00    	add    %eax,0x148(%ebx)
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
  113041:	8b 55 e8             	mov    -0x18(%ebp),%edx
  113044:	83 bb 5c 01 00 00 01 	cmpl   $0x1,0x15c(%ebx)
	NET_DBG("conn: %p Queued %zu bytes (total %zu)", conn, len,
		conn->send_data_total);
	pkt->buffer = NULL;
  11304b:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
	if (conn->data_mode == TCP_DATA_MODE_RESEND) {
  113052:	74 0c                	je     113060 <net_tcp_queue_data+0xd1>
  113054:	89 d8                	mov    %ebx,%eax
  113056:	e8 bb ee ff ff       	call   111f16 <tcp_send_queued_data.part.0>
  11305b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11305e:	89 c6                	mov    %eax,%esi

	ret = tcp_send_queued_data(conn);
	if (ret < 0 && ret != -ENOBUFS) {
  113060:	85 f6                	test   %esi,%esi
  113062:	79 0e                	jns    113072 <net_tcp_queue_data+0xe3>
  113064:	83 fe c9             	cmp    $0xffffffc9,%esi
  113067:	74 0e                	je     113077 <net_tcp_queue_data+0xe8>
		tcp_conn_unref(conn);
  113069:	89 d8                	mov    %ebx,%eax
  11306b:	e8 7e e8 ff ff       	call   1118ee <tcp_conn_unref>
		goto out;
  113070:	eb 38                	jmp    1130aa <net_tcp_queue_data+0x11b>
	}

	if (ret == -ENOBUFS) {
  113072:	83 fe c9             	cmp    $0xffffffc9,%esi
  113075:	75 2c                	jne    1130a3 <net_tcp_queue_data+0x114>
		/* Restore the original data so that we do not resend the pkt
		 * data multiple times.
		 */
		conn->send_data_total -= len;
  113077:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11307a:	29 83 48 01 00 00    	sub    %eax,0x148(%ebx)

		if (orig_buf) {
  113080:	85 d2                	test   %edx,%edx
  113082:	74 0d                	je     113091 <net_tcp_queue_data+0x102>
			pkt->buffer = orig_buf->frags;
  113084:	8b 02                	mov    (%edx),%eax
  113086:	89 47 10             	mov    %eax,0x10(%edi)
			orig_buf->frags = NULL;
  113089:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  11308f:	eb 19                	jmp    1130aa <net_tcp_queue_data+0x11b>
		} else {
			pkt->buffer = conn->send_data->buffer;
  113091:	8b 43 08             	mov    0x8(%ebx),%eax
  113094:	8b 50 10             	mov    0x10(%eax),%edx
  113097:	89 57 10             	mov    %edx,0x10(%edi)
			conn->send_data->buffer = NULL;
  11309a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  1130a1:	eb 07                	jmp    1130aa <net_tcp_queue_data+0x11b>
		}
	} else {
		/* We should not free the pkt if there was an error. It will be
		 * freed in net_context.c:context_sendto()
		 */
		tcp_pkt_unref(pkt);
  1130a3:	57                   	push   %edi
  1130a4:	e8 d3 c9 ff ff       	call   10fa7c <net_pkt_unref>
  1130a9:	58                   	pop    %eax
	}
out:
	k_mutex_unlock(&conn->lock);
  1130aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1130ad:	e8 c4 e4 ff ff       	call   111576 <k_mutex_unlock>

	return ret;
}
  1130b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1130b5:	89 f0                	mov    %esi,%eax
  1130b7:	5b                   	pop    %ebx
  1130b8:	5e                   	pop    %esi
  1130b9:	5f                   	pop    %edi
  1130ba:	5d                   	pop    %ebp
  1130bb:	c3                   	ret    

001130bc <net_tcp_send_data>:

/* net context is about to send out queued data - inform caller only */
int net_tcp_send_data(struct net_context *context, net_context_send_cb_t cb,
		      void *user_data)
{
  1130bc:	55                   	push   %ebp
  1130bd:	89 e5                	mov    %esp,%ebp
  1130bf:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (cb) {
  1130c2:	85 c0                	test   %eax,%eax
  1130c4:	74 0d                	je     1130d3 <net_tcp_send_data+0x17>
		cb(context, 0, user_data);
  1130c6:	ff 75 10             	pushl  0x10(%ebp)
  1130c9:	6a 00                	push   $0x0
  1130cb:	ff 75 08             	pushl  0x8(%ebp)
  1130ce:	ff d0                	call   *%eax
  1130d0:	83 c4 0c             	add    $0xc,%esp
	}

	return 0;
}
  1130d3:	31 c0                	xor    %eax,%eax
  1130d5:	c9                   	leave  
  1130d6:	c3                   	ret    

001130d7 <net_tcp_connect>:
		    const struct sockaddr *remote_addr,
		    struct sockaddr *local_addr,
		    uint16_t remote_port, uint16_t local_port,
		    k_timeout_t timeout, net_context_connect_cb_t cb,
		    void *user_data)
{
  1130d7:	55                   	push   %ebp
  1130d8:	89 e5                	mov    %esp,%ebp
  1130da:	57                   	push   %edi
  1130db:	56                   	push   %esi
  1130dc:	8b 55 08             	mov    0x8(%ebp),%edx
  1130df:	53                   	push   %ebx
  1130e0:	8b 75 18             	mov    0x18(%ebp),%esi
  1130e3:	8b 5d 14             	mov    0x14(%ebp),%ebx
	return net_if_get_by_index(context->iface);
  1130e6:	0f be 82 94 00 00 00 	movsbl 0x94(%edx),%eax
			    (const void *)&net_sin(local_addr)->sin_addr)),
		log_strdup(net_sprint_addr(
			    remote_addr->sa_family,
			    (const void *)&net_sin(remote_addr)->sin_addr)));

	conn = context->tcp;
  1130ed:	8b 7a 44             	mov    0x44(%edx),%edi
  1130f0:	50                   	push   %eax
  1130f1:	e8 eb a4 ff ff       	call   10d5e1 <z_impl_net_if_get_by_index>
  1130f6:	5a                   	pop    %edx
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  1130f7:	8b 55 08             	mov    0x8(%ebp),%edx
	conn->iface = net_context_get_iface(context);
  1130fa:	89 47 0c             	mov    %eax,0xc(%edi)
  1130fd:	0f b7 82 92 00 00 00 	movzwl 0x92(%edx),%eax
  113104:	c1 e8 03             	shr    $0x3,%eax
  113107:	83 e0 07             	and    $0x7,%eax

	switch (net_context_get_family(context)) {
  11310a:	66 83 f8 01          	cmp    $0x1,%ax
  11310e:	74 75                	je     113185 <net_tcp_connect+0xae>
  113110:	66 83 f8 02          	cmp    $0x2,%ax
  113114:	0f 85 ec 00 00 00    	jne    113206 <net_tcp_connect+0x12f>
		net_ipaddr_copy(&conn->dst.sin.sin_addr,
				&net_sin(remote_addr)->sin_addr);
		break;

	case AF_INET6:
		memset(&conn->src, 0, sizeof(struct sockaddr_in6));
  11311a:	6a 18                	push   $0x18
  11311c:	8d 87 18 01 00 00    	lea    0x118(%edi),%eax
  113122:	6a 00                	push   $0x0
  113124:	89 55 08             	mov    %edx,0x8(%ebp)
  113127:	50                   	push   %eax
  113128:	e8 2e 8d ff ff       	call   10be5b <memset>
  11312d:	83 c4 0c             	add    $0xc,%esp
		memset(&conn->dst, 0, sizeof(struct sockaddr_in6));
  113130:	8d 87 30 01 00 00    	lea    0x130(%edi),%eax
  113136:	6a 18                	push   $0x18
  113138:	6a 00                	push   $0x0
  11313a:	50                   	push   %eax
  11313b:	e8 1b 8d ff ff       	call   10be5b <memset>
	return net_if_get_by_index(context->iface);
  113140:	8b 55 08             	mov    0x8(%ebp),%edx

		conn->src.sin6.sin6_family = AF_INET6;
  113143:	66 c7 87 18 01 00 00 	movw   $0x2,0x118(%edi)
  11314a:	02 00 
		conn->dst.sin6.sin6_family = AF_INET6;
  11314c:	66 c7 87 30 01 00 00 	movw   $0x2,0x130(%edi)
  113153:	02 00 

		conn->dst.sin6.sin6_port = remote_port;
  113155:	66 89 9f 32 01 00 00 	mov    %bx,0x132(%edi)
		conn->src.sin6.sin6_port = local_port;
  11315c:	66 89 b7 1a 01 00 00 	mov    %si,0x11a(%edi)
		memset(&conn->dst, 0, sizeof(struct sockaddr_in6));
  113163:	83 c4 0c             	add    $0xc,%esp
  113166:	0f be 82 94 00 00 00 	movsbl 0x94(%edx),%eax

		ip6 = net_if_ipv6_select_src_addr(
					net_context_get_iface(context),
					&net_sin6(remote_addr)->sin6_addr);
		conn->src.sin6.sin6_addr = *ip6;
  11316d:	31 f6                	xor    %esi,%esi
  11316f:	50                   	push   %eax
  113170:	81 c7 1c 01 00 00    	add    $0x11c,%edi
  113176:	e8 66 a4 ff ff       	call   10d5e1 <z_impl_net_if_get_by_index>
  11317b:	b9 04 00 00 00       	mov    $0x4,%ecx
  113180:	58                   	pop    %eax
  113181:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  113183:	0f 0b                	ud2    
		memset(&conn->src, 0, sizeof(struct sockaddr_in));
  113185:	6a 08                	push   $0x8
  113187:	8d 87 18 01 00 00    	lea    0x118(%edi),%eax
  11318d:	6a 00                	push   $0x0
  11318f:	89 55 08             	mov    %edx,0x8(%ebp)
  113192:	50                   	push   %eax
  113193:	e8 c3 8c ff ff       	call   10be5b <memset>
  113198:	83 c4 0c             	add    $0xc,%esp
		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
  11319b:	8d 87 30 01 00 00    	lea    0x130(%edi),%eax
  1131a1:	6a 08                	push   $0x8
  1131a3:	6a 00                	push   $0x0
  1131a5:	50                   	push   %eax
  1131a6:	e8 b0 8c ff ff       	call   10be5b <memset>
  1131ab:	8b 55 08             	mov    0x8(%ebp),%edx
		conn->src.sa.sa_family = AF_INET;
  1131ae:	66 c7 87 18 01 00 00 	movw   $0x1,0x118(%edi)
  1131b5:	01 00 
		conn->dst.sa.sa_family = AF_INET;
  1131b7:	66 c7 87 30 01 00 00 	movw   $0x1,0x130(%edi)
  1131be:	01 00 
		conn->dst.sin.sin_port = remote_port;
  1131c0:	66 89 9f 32 01 00 00 	mov    %bx,0x132(%edi)
		conn->src.sin.sin_port = local_port;
  1131c7:	66 89 b7 1a 01 00 00 	mov    %si,0x11a(%edi)
		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
  1131ce:	83 c4 0c             	add    $0xc,%esp
  1131d1:	0f be 82 94 00 00 00 	movsbl 0x94(%edx),%eax
  1131d8:	50                   	push   %eax
  1131d9:	e8 03 a4 ff ff       	call   10d5e1 <z_impl_net_if_get_by_index>
			&net_sin(remote_addr)->sin_addr);
  1131de:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1131e1:	83 c1 04             	add    $0x4,%ecx
		ip4 = net_if_ipv4_select_src_addr(
  1131e4:	89 0c 24             	mov    %ecx,(%esp)
  1131e7:	50                   	push   %eax
  1131e8:	e8 c9 a5 ff ff       	call   10d7b6 <net_if_ipv4_select_src_addr>
  1131ed:	5a                   	pop    %edx
  1131ee:	59                   	pop    %ecx
		break;
  1131ef:	8b 55 08             	mov    0x8(%ebp),%edx
		conn->src.sin.sin_addr = *ip4;
  1131f2:	8b 00                	mov    (%eax),%eax
  1131f4:	89 87 1c 01 00 00    	mov    %eax,0x11c(%edi)
		net_ipaddr_copy(&conn->dst.sin.sin_addr,
  1131fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1131fd:	8b 40 04             	mov    0x4(%eax),%eax
  113200:	89 87 34 01 00 00    	mov    %eax,0x134(%edi)
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
  113206:	66 8b 82 92 00 00 00 	mov    0x92(%edx),%ax
		log_strdup(net_sprint_addr(conn->dst.sa.sa_family,
				(const void *)&conn->dst.sin.sin_addr)));

	net_context_set_state(context, NET_CONTEXT_CONNECTING);

	ret = net_conn_register(net_context_get_ip_proto(context),
  11320d:	8d 4a 34             	lea    0x34(%edx),%ecx
  113210:	83 e0 f9             	and    $0xfffffff9,%eax
  113213:	86 fb                	xchg   %bh,%bl
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
  113215:	83 c8 02             	or     $0x2,%eax
  113218:	66 89 82 92 00 00 00 	mov    %ax,0x92(%edx)
  11321f:	51                   	push   %ecx
  113220:	52                   	push   %edx
  113221:	66 c1 c6 08          	rol    $0x8,%si
  113225:	68 a7 29 11 00       	push   $0x1129a7
  11322a:	0f b7 f6             	movzwl %si,%esi
  11322d:	56                   	push   %esi
  11322e:	0f b7 db             	movzwl %bx,%ebx
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  113231:	66 c1 e8 03          	shr    $0x3,%ax
  113235:	53                   	push   %ebx
  113236:	ff 75 10             	pushl  0x10(%ebp)
  113239:	ff 75 0c             	pushl  0xc(%ebp)
  11323c:	83 e0 07             	and    $0x7,%eax
  11323f:	50                   	push   %eax
  113240:	0f b7 82 90 00 00 00 	movzwl 0x90(%edx),%eax
  113247:	50                   	push   %eax
  113248:	e8 62 dc ff ff       	call   110eaf <net_conn_register>
  11324d:	83 c4 24             	add    $0x24,%esp
  113250:	89 c3                	mov    %eax,%ebx
				net_context_get_family(context),
				remote_addr, local_addr,
				ntohs(remote_port), ntohs(local_port),
				tcp_recv, context,
				&context->conn_handler);
	if (ret < 0) {
  113252:	85 c0                	test   %eax,%eax
  113254:	78 55                	js     1132ab <net_tcp_connect+0x1d4>
	}

	/* Input of a (nonexistent) packet with no flags set will cause
	 * a TCP connection to be established
	 */
	tcp_in(conn, NULL);
  113256:	31 d2                	xor    %edx,%edx
  113258:	89 f8                	mov    %edi,%eax
  11325a:	e8 ac ed ff ff       	call   11200b <tcp_in>

	if (!IS_ENABLED(CONFIG_NET_TEST_PROTOCOL)) {
		conn->in_connect = true;
  11325f:	80 8f 6d 01 00 00 02 	orb    $0x2,0x16d(%edi)
	return z_impl_k_sem_take(sem, timeout);
  113266:	ff 75 20             	pushl  0x20(%ebp)
  113269:	ff 75 1c             	pushl  0x1c(%ebp)

		if (k_sem_take(&conn->connect_sem, timeout) != 0 &&
  11326c:	8d 47 3c             	lea    0x3c(%edi),%eax
  11326f:	50                   	push   %eax
  113270:	e8 7d e6 00 00       	call   1218f2 <z_impl_k_sem_take>
  113275:	83 c4 0c             	add    $0xc,%esp
  113278:	85 c0                	test   %eax,%eax
  11327a:	8a 87 6d 01 00 00    	mov    0x16d(%edi),%al
  113280:	74 20                	je     1132a2 <net_tcp_connect+0x1cb>
  113282:	83 bf 58 01 00 00 04 	cmpl   $0x4,0x158(%edi)
  113289:	74 17                	je     1132a2 <net_tcp_connect+0x1cb>
		    conn->state != TCP_ESTABLISHED) {
			conn->in_connect = false;
  11328b:	83 e0 fd             	and    $0xfffffffd,%eax
			tcp_conn_unref(conn);
			ret = -ETIMEDOUT;
  11328e:	bb c4 ff ff ff       	mov    $0xffffffc4,%ebx
			conn->in_connect = false;
  113293:	88 87 6d 01 00 00    	mov    %al,0x16d(%edi)
			tcp_conn_unref(conn);
  113299:	89 f8                	mov    %edi,%eax
  11329b:	e8 4e e6 ff ff       	call   1118ee <tcp_conn_unref>
			goto out;
  1132a0:	eb 09                	jmp    1132ab <net_tcp_connect+0x1d4>
		}
		conn->in_connect = false;
  1132a2:	83 e0 fd             	and    $0xfffffffd,%eax
  1132a5:	88 87 6d 01 00 00    	mov    %al,0x16d(%edi)
	}
 out:
	NET_DBG("conn: %p, ret=%d", conn, ret);

	return ret;
}
  1132ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1132ae:	89 d8                	mov    %ebx,%eax
  1132b0:	5b                   	pop    %ebx
  1132b1:	5e                   	pop    %esi
  1132b2:	5f                   	pop    %edi
  1132b3:	5d                   	pop    %ebp
  1132b4:	c3                   	ret    

001132b5 <net_tcp_accept>:

int net_tcp_accept(struct net_context *context, net_tcp_accept_cb_t cb,
		   void *user_data)
{
  1132b5:	55                   	push   %ebp
	struct tcp *conn = context->tcp;
	struct sockaddr local_addr = { };
  1132b6:	31 c0                	xor    %eax,%eax
{
  1132b8:	89 e5                	mov    %esp,%ebp
  1132ba:	57                   	push   %edi
  1132bb:	56                   	push   %esi
	struct sockaddr local_addr = { };
  1132bc:	b9 02 00 00 00       	mov    $0x2,%ecx
{
  1132c1:	53                   	push   %ebx
	struct sockaddr local_addr = { };
  1132c2:	8d 7d dc             	lea    -0x24(%ebp),%edi
{
  1132c5:	83 ec 18             	sub    $0x18,%esp
  1132c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct sockaddr local_addr = { };
  1132cb:	f3 ab                	rep stos %eax,%es:(%edi)
	struct tcp *conn = context->tcp;
  1132cd:	8b 53 44             	mov    0x44(%ebx),%edx
	uint16_t local_port, remote_port;

	if (!conn) {
		return -EINVAL;
  1132d0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!conn) {
  1132d5:	85 d2                	test   %edx,%edx
  1132d7:	0f 84 c2 00 00 00    	je     11339f <net_tcp_accept+0xea>
	}

	NET_DBG("context: %p, tcp: %p, cb: %p", context, conn, cb);

	if (conn->state != TCP_LISTEN) {
  1132dd:	83 ba 58 01 00 00 01 	cmpl   $0x1,0x158(%edx)
  1132e4:	0f 85 b5 00 00 00    	jne    11339f <net_tcp_accept+0xea>
		return -EINVAL;
	}

	conn->accept_cb = cb;
  1132ea:	8b 45 0c             	mov    0xc(%ebp),%eax
  1132ed:	89 42 1c             	mov    %eax,0x1c(%edx)
  1132f0:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
  1132f7:	c1 e8 03             	shr    $0x3,%eax
  1132fa:	83 e0 07             	and    $0x7,%eax
	local_addr.sa_family = net_context_get_family(context);

	switch (local_addr.sa_family) {
  1132fd:	66 83 f8 01          	cmp    $0x1,%ax
	local_addr.sa_family = net_context_get_family(context);
  113301:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
	switch (local_addr.sa_family) {
  113305:	74 10                	je     113317 <net_tcp_accept+0x62>
  113307:	66 83 f8 02          	cmp    $0x2,%ax
  11330b:	74 18                	je     113325 <net_tcp_accept+0x70>
  11330d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  113312:	e9 88 00 00 00       	jmp    11339f <net_tcp_accept+0xea>
		struct sockaddr_in6 *in6;

	case AF_INET:
		in = (struct sockaddr_in *)&local_addr;

		if (net_sin_ptr(&context->local)->sin_addr) {
  113317:	8b 43 28             	mov    0x28(%ebx),%eax
  11331a:	85 c0                	test   %eax,%eax
  11331c:	74 25                	je     113343 <net_tcp_accept+0x8e>
			net_ipaddr_copy(&in->sin_addr,
  11331e:	8b 00                	mov    (%eax),%eax
  113320:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return (struct sockaddr_in *)addr;
  113323:	eb 1e                	jmp    113343 <net_tcp_accept+0x8e>
		break;

	case AF_INET6:
		in6 = (struct sockaddr_in6 *)&local_addr;

		if (net_sin6_ptr(&context->local)->sin6_addr) {
  113325:	8b 73 28             	mov    0x28(%ebx),%esi
  113328:	85 f6                	test   %esi,%esi
  11332a:	74 17                	je     113343 <net_tcp_accept+0x8e>
			net_ipaddr_copy(&in6->sin6_addr,
  11332c:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  11332f:	b9 04 00 00 00       	mov    $0x4,%ecx
  113334:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  113336:	8d 7d e0             	lea    -0x20(%ebp),%edi
  113339:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  11333c:	b9 04 00 00 00       	mov    $0x4,%ecx
  113341:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
				net_sin6_ptr(&context->local)->sin6_addr);
		}

		in6->sin6_port =
			net_sin6((struct sockaddr *)&context->local)->sin6_port;
  113343:	66 8b 7b 26          	mov    0x26(%ebx),%di

	default:
		return -EINVAL;
	}

	context->user_data = user_data;
  113347:	8b 45 10             	mov    0x10(%ebp),%eax
		in6->sin6_port =
  11334a:	66 89 7d de          	mov    %di,-0x22(%ebp)
	context->user_data = user_data;
  11334e:	89 03                	mov    %eax,(%ebx)
		remote_port = ntohs(net_sin6(&context->remote)->sin6_port);
  113350:	66 8b 73 2e          	mov    0x2e(%ebx),%si

	/* Remove the temporary connection handler and register
	 * a proper now as we have an established connection.
	 */
	net_conn_unregister(context->conn_handler);
  113354:	ff 73 34             	pushl  0x34(%ebx)
		local_port = ntohs(in6->sin6_port);
  113357:	66 c1 c7 08          	rol    $0x8,%di
		remote_port = ntohs(net_sin6(&context->remote)->sin6_port);
  11335b:	66 c1 c6 08          	rol    $0x8,%si
	net_conn_unregister(context->conn_handler);
  11335f:	e8 f3 dd ff ff       	call   111157 <net_conn_unregister>
  113364:	58                   	pop    %eax

	return net_conn_register(net_context_get_ip_proto(context),
  113365:	31 d2                	xor    %edx,%edx
  113367:	8d 43 34             	lea    0x34(%ebx),%eax
  11336a:	f6 83 93 00 00 00 01 	testb  $0x1,0x93(%ebx)
  113371:	0f b7 ff             	movzwl %di,%edi
  113374:	0f b7 f6             	movzwl %si,%esi
  113377:	74 03                	je     11337c <net_tcp_accept+0xc7>
  113379:	8d 53 2c             	lea    0x2c(%ebx),%edx
  11337c:	50                   	push   %eax
  11337d:	8d 45 dc             	lea    -0x24(%ebp),%eax
  113380:	53                   	push   %ebx
  113381:	68 a7 29 11 00       	push   $0x1129a7
  113386:	57                   	push   %edi
  113387:	56                   	push   %esi
  113388:	50                   	push   %eax
  113389:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  11338d:	52                   	push   %edx
  11338e:	50                   	push   %eax
  11338f:	0f b7 83 90 00 00 00 	movzwl 0x90(%ebx),%eax
  113396:	50                   	push   %eax
  113397:	e8 13 db ff ff       	call   110eaf <net_conn_register>
  11339c:	83 c4 24             	add    $0x24,%esp
				 &context->remote : NULL,
				 &local_addr,
				 remote_port, local_port,
				 tcp_recv, context,
				 &context->conn_handler);
}
  11339f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1133a2:	5b                   	pop    %ebx
  1133a3:	5e                   	pop    %esi
  1133a4:	5f                   	pop    %edi
  1133a5:	5d                   	pop    %ebp
  1133a6:	c3                   	ret    

001133a7 <net_tcp_recv>:

int net_tcp_recv(struct net_context *context, net_context_recv_cb_t cb,
		 void *user_data)
{
  1133a7:	55                   	push   %ebp
  1133a8:	89 e5                	mov    %esp,%ebp
  1133aa:	8b 55 08             	mov    0x8(%ebp),%edx
	struct tcp *conn = context->tcp;

	NET_DBG("context: %p, cb: %p, user_data: %p", context, cb, user_data);

	context->recv_cb = cb;
  1133ad:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	struct tcp *conn = context->tcp;
  1133b0:	8b 42 44             	mov    0x44(%edx),%eax
	context->recv_cb = cb;
  1133b3:	89 4a 38             	mov    %ecx,0x38(%edx)

	if (conn) {
  1133b6:	85 c0                	test   %eax,%eax
  1133b8:	74 06                	je     1133c0 <net_tcp_recv+0x19>
		conn->recv_user_data = user_data;
  1133ba:	8b 55 10             	mov    0x10(%ebp),%edx
  1133bd:	89 50 10             	mov    %edx,0x10(%eax)
	}

	return 0;
}
  1133c0:	31 c0                	xor    %eax,%eax
  1133c2:	5d                   	pop    %ebp
  1133c3:	c3                   	ret    

001133c4 <net_tcp_finalize>:

int net_tcp_finalize(struct net_pkt *pkt)
{
  1133c4:	55                   	push   %ebp
  1133c5:	89 e5                	mov    %esp,%ebp
  1133c7:	57                   	push   %edi
  1133c8:	56                   	push   %esi
  1133c9:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
	struct net_tcp_hdr *tcp_hdr;

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
  1133ca:	8d 7d d8             	lea    -0x28(%ebp),%edi
{
  1133cd:	83 ec 1c             	sub    $0x1c,%esp
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
  1133d0:	8d 45 e0             	lea    -0x20(%ebp),%eax
{
  1133d3:	8b 75 08             	mov    0x8(%ebp),%esi
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
  1133d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
  1133d9:	57                   	push   %edi
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
  1133da:	c7 45 dc 14 00 00 00 	movl   $0x14,-0x24(%ebp)
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
  1133e1:	56                   	push   %esi
  1133e2:	e8 6e d0 ff ff       	call   110455 <net_pkt_get_data>
  1133e7:	59                   	pop    %ecx
  1133e8:	5b                   	pop    %ebx
  1133e9:	89 c3                	mov    %eax,%ebx
	if (!tcp_hdr) {
  1133eb:	85 db                	test   %ebx,%ebx
  1133ed:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
  1133f2:	74 2a                	je     11341e <net_tcp_finalize+0x5a>
		return -ENOBUFS;
	}

	tcp_hdr->chksum = 0U;
  1133f4:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
  1133fa:	ff 76 20             	pushl  0x20(%esi)
  1133fd:	e8 aa a7 ff ff       	call   10dbac <net_if_need_calc_tx_checksum>
  113402:	5a                   	pop    %edx
  113403:	84 c0                	test   %al,%al
  113405:	74 0e                	je     113415 <net_tcp_finalize+0x51>
	return net_calc_chksum(pkt, IPPROTO_UDP);
}

static inline uint16_t net_calc_chksum_tcp(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_TCP);
  113407:	6a 06                	push   $0x6
  113409:	56                   	push   %esi
  11340a:	e8 ce af ff ff       	call   10e3dd <net_calc_chksum>
  11340f:	5a                   	pop    %edx
  113410:	59                   	pop    %ecx
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
  113411:	66 89 43 10          	mov    %ax,0x10(%ebx)
	}

	return net_pkt_set_data(pkt, &tcp_access);
  113415:	57                   	push   %edi
  113416:	56                   	push   %esi
  113417:	e8 cc d0 ff ff       	call   1104e8 <net_pkt_set_data>
  11341c:	5a                   	pop    %edx
  11341d:	59                   	pop    %ecx
}
  11341e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  113421:	5b                   	pop    %ebx
  113422:	5e                   	pop    %esi
  113423:	5f                   	pop    %edi
  113424:	5d                   	pop    %ebp
  113425:	c3                   	ret    

00113426 <net_tcp_input>:

struct net_tcp_hdr *net_tcp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *tcp_access)
{
  113426:	55                   	push   %ebp
  113427:	89 e5                	mov    %esp,%ebp
  113429:	57                   	push   %edi
  11342a:	56                   	push   %esi
  11342b:	8b 75 08             	mov    0x8(%ebp),%esi
  11342e:	53                   	push   %ebx
  11342f:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_tcp_hdr *tcp_hdr;

	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
			net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
  113432:	ff 76 20             	pushl  0x20(%esi)
  113435:	e8 97 a7 ff ff       	call   10dbd1 <net_if_need_calc_rx_checksum>
  11343a:	5a                   	pop    %edx
	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
  11343b:	84 c0                	test   %al,%al
  11343d:	75 11                	jne    113450 <net_tcp_input+0x2a>
			net_calc_chksum_tcp(pkt) != 0U) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
  11343f:	57                   	push   %edi
  113440:	56                   	push   %esi
  113441:	e8 0f d0 ff ff       	call   110455 <net_pkt_get_data>
  113446:	59                   	pop    %ecx
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
  113447:	85 c0                	test   %eax,%eax
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
  113449:	5b                   	pop    %ebx
  11344a:	89 c3                	mov    %eax,%ebx
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
  11344c:	75 15                	jne    113463 <net_tcp_input+0x3d>
  11344e:	eb 0f                	jmp    11345f <net_tcp_input+0x39>
  113450:	6a 06                	push   $0x6
  113452:	56                   	push   %esi
  113453:	e8 85 af ff ff       	call   10e3dd <net_calc_chksum>
			net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
  113458:	66 85 c0             	test   %ax,%ax
  11345b:	5b                   	pop    %ebx
  11345c:	5a                   	pop    %edx
  11345d:	74 e0                	je     11343f <net_tcp_input+0x19>
		return tcp_hdr;
	}

drop:
	net_stats_update_tcp_seg_chkerr(net_pkt_iface(pkt));
	return NULL;
  11345f:	31 db                	xor    %ebx,%ebx
  113461:	eb 0d                	jmp    113470 <net_tcp_input+0x4a>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
  113463:	57                   	push   %edi
  113464:	56                   	push   %esi
  113465:	e8 7e d0 ff ff       	call   1104e8 <net_pkt_set_data>
  11346a:	5a                   	pop    %edx
  11346b:	85 c0                	test   %eax,%eax
  11346d:	59                   	pop    %ecx
  11346e:	75 ef                	jne    11345f <net_tcp_input+0x39>
}
  113470:	8d 65 f4             	lea    -0xc(%ebp),%esp
  113473:	89 d8                	mov    %ebx,%eax
  113475:	5b                   	pop    %ebx
  113476:	5e                   	pop    %esi
  113477:	5f                   	pop    %edi
  113478:	5d                   	pop    %ebp
  113479:	c3                   	ret    

0011347a <net_tcp_init>:
	test_cb_register(AF_INET,  IPPROTO_UDP, 4242, 4242, tp_input);
	test_cb_register(AF_INET6, IPPROTO_UDP, 4242, 4242, tp_input);

	tcp_recv_cb = tp_tcp_recv_cb;
#endif
}
  11347a:	c3                   	ret    

0011347b <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, uint16_t src_port, uint16_t dst_port)
{
  11347b:	55                   	push   %ebp
  11347c:	89 e5                	mov    %esp,%ebp
  11347e:	57                   	push   %edi
  11347f:	56                   	push   %esi
  113480:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  113481:	8d 75 e4             	lea    -0x1c(%ebp),%esi
{
  113484:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  113487:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  11348a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  11348d:	8b 7d 10             	mov    0x10(%ebp),%edi
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  113490:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  113491:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  113494:	ff 75 08             	pushl  0x8(%ebp)
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  113497:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  11349e:	e8 b2 cf ff ff       	call   110455 <net_pkt_get_data>
  1134a3:	5a                   	pop    %edx
	if (!udp_hdr) {
  1134a4:	85 c0                	test   %eax,%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  1134a6:	59                   	pop    %ecx
	if (!udp_hdr) {
  1134a7:	b9 c9 ff ff ff       	mov    $0xffffffc9,%ecx
  1134ac:	74 1b                	je     1134c9 <net_udp_create+0x4e>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
  1134ae:	66 89 18             	mov    %bx,(%eax)
	udp_hdr->dst_port = dst_port;
  1134b1:	66 89 78 02          	mov    %di,0x2(%eax)
	udp_hdr->len      = 0U;
  1134b5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	udp_hdr->chksum   = 0U;

	return net_pkt_set_data(pkt, &udp_access);
  1134bc:	56                   	push   %esi
  1134bd:	ff 75 08             	pushl  0x8(%ebp)
  1134c0:	e8 23 d0 ff ff       	call   1104e8 <net_pkt_set_data>
  1134c5:	5a                   	pop    %edx
  1134c6:	59                   	pop    %ecx
  1134c7:	89 c1                	mov    %eax,%ecx
}
  1134c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1134cc:	89 c8                	mov    %ecx,%eax
  1134ce:	5b                   	pop    %ebx
  1134cf:	5e                   	pop    %esi
  1134d0:	5f                   	pop    %edi
  1134d1:	5d                   	pop    %ebp
  1134d2:	c3                   	ret    

001134d3 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
  1134d3:	55                   	push   %ebp
  1134d4:	89 e5                	mov    %esp,%ebp
  1134d6:	57                   	push   %edi
  1134d7:	56                   	push   %esi
  1134d8:	53                   	push   %ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
	struct net_udp_hdr *udp_hdr;
	uint16_t length = 0;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  1134d9:	8d 75 e4             	lea    -0x1c(%ebp),%esi
{
  1134dc:	83 ec 10             	sub    $0x10,%esp
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  1134df:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  1134e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  1134e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  1134e8:	56                   	push   %esi
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
  1134e9:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
  1134f0:	53                   	push   %ebx
  1134f1:	e8 5f cf ff ff       	call   110455 <net_pkt_get_data>
  1134f6:	59                   	pop    %ecx
  1134f7:	5f                   	pop    %edi
  1134f8:	89 c7                	mov    %eax,%edi
	if (!udp_hdr) {
  1134fa:	85 ff                	test   %edi,%edi
  1134fc:	b8 c9 ff ff ff       	mov    $0xffffffc9,%eax
  113501:	74 51                	je     113554 <net_udp_finalize+0x81>
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
  113503:	8b 53 10             	mov    0x10(%ebx),%edx
	size_t bytes = 0;
  113506:	31 c0                	xor    %eax,%eax
	while (buf) {
  113508:	85 d2                	test   %edx,%edx
  11350a:	74 0a                	je     113516 <net_udp_finalize+0x43>
		bytes += buf->len;
  11350c:	0f b7 4a 0c          	movzwl 0xc(%edx),%ecx
		buf = buf->frags;
  113510:	8b 12                	mov    (%edx),%edx
		bytes += buf->len;
  113512:	01 c8                	add    %ecx,%eax
		buf = buf->frags;
  113514:	eb f2                	jmp    113508 <net_udp_finalize+0x35>
  113516:	0f b6 53 3c          	movzbl 0x3c(%ebx),%edx
	return pkt->ipv4_opts_len;
  11351a:	0f b6 4b 43          	movzbl 0x43(%ebx),%ecx
  11351e:	01 ca                	add    %ecx,%edx
  113520:	29 d0                	sub    %edx,%eax
		 net_pkt_ip_opts_len(pkt);

	udp_hdr->len = htons(length);
  113522:	86 e0                	xchg   %ah,%al
  113524:	66 89 47 04          	mov    %ax,0x4(%edi)

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
  113528:	ff 73 20             	pushl  0x20(%ebx)
  11352b:	e8 7c a6 ff ff       	call   10dbac <net_if_need_calc_tx_checksum>
  113530:	5a                   	pop    %edx
  113531:	84 c0                	test   %al,%al
  113533:	74 16                	je     11354b <net_udp_finalize+0x78>
	uint16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
  113535:	6a 11                	push   $0x11
  113537:	53                   	push   %ebx
  113538:	e8 a0 ae ff ff       	call   10e3dd <net_calc_chksum>
	return chksum == 0U ? 0xffff : chksum;
  11353d:	66 85 c0             	test   %ax,%ax
	uint16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
  113540:	5a                   	pop    %edx
  113541:	59                   	pop    %ecx
	return chksum == 0U ? 0xffff : chksum;
  113542:	75 03                	jne    113547 <net_udp_finalize+0x74>
  113544:	83 c8 ff             	or     $0xffffffff,%eax
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
  113547:	66 89 47 06          	mov    %ax,0x6(%edi)
	}

	return net_pkt_set_data(pkt, &udp_access);
  11354b:	56                   	push   %esi
  11354c:	53                   	push   %ebx
  11354d:	e8 96 cf ff ff       	call   1104e8 <net_pkt_set_data>
  113552:	5a                   	pop    %edx
  113553:	59                   	pop    %ecx
}
  113554:	8d 65 f4             	lea    -0xc(%ebp),%esp
  113557:	5b                   	pop    %ebx
  113558:	5e                   	pop    %esi
  113559:	5f                   	pop    %edi
  11355a:	5d                   	pop    %ebp
  11355b:	c3                   	ret    

0011355c <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
  11355c:	55                   	push   %ebp
  11355d:	89 e5                	mov    %esp,%ebp
  11355f:	57                   	push   %edi
  113560:	56                   	push   %esi
  113561:	53                   	push   %ebx
  113562:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
  113565:	57                   	push   %edi
{
  113566:	8b 75 08             	mov    0x8(%ebp),%esi
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
  113569:	56                   	push   %esi
  11356a:	e8 e6 ce ff ff       	call   110455 <net_pkt_get_data>
  11356f:	5b                   	pop    %ebx
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
  113570:	85 c0                	test   %eax,%eax
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
  113572:	5a                   	pop    %edx
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
  113573:	74 5c                	je     1135d1 <net_udp_input+0x75>
  113575:	57                   	push   %edi
  113576:	89 c3                	mov    %eax,%ebx
  113578:	56                   	push   %esi
  113579:	e8 6a cf ff ff       	call   1104e8 <net_pkt_set_data>
  11357e:	5a                   	pop    %edx
  11357f:	85 c0                	test   %eax,%eax
  113581:	59                   	pop    %ecx
  113582:	75 4d                	jne    1135d1 <net_udp_input+0x75>
		NET_DBG("DROP: corrupted header");
		goto drop;
	}

	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
  113584:	66 8b 53 04          	mov    0x4(%ebx),%dx
  113588:	8b 4e 10             	mov    0x10(%esi),%ecx
  11358b:	86 f2                	xchg   %dh,%dl
  11358d:	0f b7 d2             	movzwl %dx,%edx
	while (buf) {
  113590:	85 c9                	test   %ecx,%ecx
  113592:	74 0a                	je     11359e <net_udp_input+0x42>
		bytes += buf->len;
  113594:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
		buf = buf->frags;
  113598:	8b 09                	mov    (%ecx),%ecx
		bytes += buf->len;
  11359a:	01 f8                	add    %edi,%eax
		buf = buf->frags;
  11359c:	eb f2                	jmp    113590 <net_udp_input+0x34>
				    net_pkt_ip_hdr_len(pkt) -
  11359e:	0f b6 4e 3c          	movzbl 0x3c(%esi),%ecx
				    net_pkt_ip_opts_len(pkt))) {
  1135a2:	0f b6 7e 43          	movzbl 0x43(%esi),%edi
				    net_pkt_ip_hdr_len(pkt) -
  1135a6:	01 f9                	add    %edi,%ecx
  1135a8:	29 c8                	sub    %ecx,%eax
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
  1135aa:	39 c2                	cmp    %eax,%edx
  1135ac:	75 23                	jne    1135d1 <net_udp_input+0x75>
		NET_DBG("DROP: Invalid hdr length");
		goto drop;
	}

	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
  1135ae:	ff 76 20             	pushl  0x20(%esi)
  1135b1:	e8 1b a6 ff ff       	call   10dbd1 <net_if_need_calc_rx_checksum>
  1135b6:	5f                   	pop    %edi
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
  1135b7:	84 c0                	test   %al,%al
  1135b9:	74 18                	je     1135d3 <net_udp_input+0x77>
		if (!udp_hdr->chksum) {
  1135bb:	66 83 7b 06 00       	cmpw   $0x0,0x6(%ebx)
  1135c0:	74 0f                	je     1135d1 <net_udp_input+0x75>
	return net_calc_chksum(pkt, IPPROTO_UDP);
  1135c2:	6a 11                	push   $0x11
  1135c4:	56                   	push   %esi
  1135c5:	e8 13 ae ff ff       	call   10e3dd <net_calc_chksum>
			}

			goto drop;
		}

		if (net_calc_verify_chksum_udp(pkt) != 0U) {
  1135ca:	66 85 c0             	test   %ax,%ax
  1135cd:	5a                   	pop    %edx
  1135ce:	59                   	pop    %ecx
  1135cf:	74 02                	je     1135d3 <net_udp_input+0x77>
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
  1135d1:	31 db                	xor    %ebx,%ebx
}
  1135d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1135d6:	89 d8                	mov    %ebx,%eax
  1135d8:	5b                   	pop    %ebx
  1135d9:	5e                   	pop    %esi
  1135da:	5f                   	pop    %edi
  1135db:	5d                   	pop    %ebp
  1135dc:	c3                   	ret    

001135dd <cmd_net_tcp>:
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	return 0;
}
  1135dd:	31 c0                	xor    %eax,%eax
  1135df:	c3                   	ret    

001135e0 <cmd_net_websocket>:
}
#endif /* CONFIG_WEBSOCKET_CLIENT */

static int cmd_net_websocket(const struct shell *shell, size_t argc,
			     char *argv[])
{
  1135e0:	55                   	push   %ebp
  1135e1:	89 e5                	mov    %esp,%ebp

	if (count == 0) {
		PR("No connections\n");
	}
#else
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_WEBSOCKET_CLIENT",
  1135e3:	68 9a 61 12 00       	push   $0x12619a
  1135e8:	68 a4 61 12 00       	push   $0x1261a4
  1135ed:	68 bc 61 12 00       	push   $0x1261bc
  1135f2:	6a 03                	push   $0x3
  1135f4:	ff 75 08             	pushl  0x8(%ebp)
  1135f7:	e8 23 2a ff ff       	call   10601f <shell_fprintf>
  1135fc:	83 c4 14             	add    $0x14,%esp
		"Websocket");
#endif /* CONFIG_WEBSOCKET_CLIENT */

	return 0;
}
  1135ff:	31 c0                	xor    %eax,%eax
  113601:	c9                   	leave  
  113602:	c3                   	ret    

00113603 <cmd_net_vlan>:
{
  113603:	55                   	push   %ebp
  113604:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_VLAN", "VLAN");
  113606:	68 e5 61 12 00       	push   $0x1261e5
  11360b:	68 da 61 12 00       	push   $0x1261da
  113610:	68 bc 61 12 00       	push   $0x1261bc
  113615:	6a 03                	push   $0x3
  113617:	ff 75 08             	pushl  0x8(%ebp)
  11361a:	e8 00 2a ff ff       	call   10601f <shell_fprintf>
  11361f:	83 c4 14             	add    $0x14,%esp
}
  113622:	31 c0                	xor    %eax,%eax
  113624:	c9                   	leave  
  113625:	c3                   	ret    

00113626 <cmd_net_vlan_add>:
  113626:	e9 d8 ff ff ff       	jmp    113603 <cmd_net_vlan>

0011362b <cmd_net_vlan_del>:
  11362b:	e9 d3 ff ff ff       	jmp    113603 <cmd_net_vlan>

00113630 <tcp_sent_cb>:
{
  113630:	55                   	push   %ebp
	PR_SHELL(tcp_shell, "Message sent\n");
  113631:	a1 48 ec 12 00       	mov    0x12ec48,%eax
{
  113636:	89 e5                	mov    %esp,%ebp
	PR_SHELL(tcp_shell, "Message sent\n");
  113638:	c7 45 10 ea 61 12 00 	movl   $0x1261ea,0x10(%ebp)
  11363f:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  113646:	89 45 08             	mov    %eax,0x8(%ebp)
}
  113649:	5d                   	pop    %ebp
	PR_SHELL(tcp_shell, "Message sent\n");
  11364a:	e9 d0 29 ff ff       	jmp    10601f <shell_fprintf>

0011364f <cmd_net_suspend>:
{
  11364f:	55                   	push   %ebp
  113650:	89 e5                	mov    %esp,%ebp
	PR_INFO("You need a network driver supporting Power Management.\n");
  113652:	68 f8 61 12 00       	push   $0x1261f8
  113657:	6a 03                	push   $0x3
  113659:	ff 75 08             	pushl  0x8(%ebp)
  11365c:	e8 be 29 ff ff       	call   10601f <shell_fprintf>
  113661:	83 c4 0c             	add    $0xc,%esp
}
  113664:	31 c0                	xor    %eax,%eax
  113666:	c9                   	leave  
  113667:	c3                   	ret    

00113668 <cmd_net_stats_all>:
{
  113668:	55                   	push   %ebp
  113669:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_STATISTICS",
  11366b:	68 30 62 12 00       	push   $0x126230
  113670:	68 3b 62 12 00       	push   $0x12623b
  113675:	68 bc 61 12 00       	push   $0x1261bc
  11367a:	6a 03                	push   $0x3
  11367c:	ff 75 08             	pushl  0x8(%ebp)
  11367f:	e8 9b 29 ff ff       	call   10601f <shell_fprintf>
  113684:	83 c4 14             	add    $0x14,%esp
}
  113687:	31 c0                	xor    %eax,%eax
  113689:	c9                   	leave  
  11368a:	c3                   	ret    

0011368b <cmd_net_stats_iface>:
  11368b:	e9 d8 ff ff ff       	jmp    113668 <cmd_net_stats_all>

00113690 <cmd_net_stats>:
  113690:	e9 d3 ff ff ff       	jmp    113668 <cmd_net_stats_all>

00113695 <cmd_net_stacks>:
{
  113695:	55                   	push   %ebp
  113696:	89 e5                	mov    %esp,%ebp
	PR("Type \"kernel stacks\" to see stack information.\n");
  113698:	68 51 62 12 00       	push   $0x126251
  11369d:	6a 00                	push   $0x0
  11369f:	ff 75 08             	pushl  0x8(%ebp)
  1136a2:	e8 78 29 ff ff       	call   10601f <shell_fprintf>
  1136a7:	83 c4 0c             	add    $0xc,%esp
}
  1136aa:	31 c0                	xor    %eax,%eax
  1136ac:	c9                   	leave  
  1136ad:	c3                   	ret    

001136ae <cmd_net_route>:
{
  1136ae:	55                   	push   %ebp
  1136af:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_ROUTE",
  1136b1:	68 81 62 12 00       	push   $0x126281
  1136b6:	68 8f 62 12 00       	push   $0x12628f
  1136bb:	68 bc 61 12 00       	push   $0x1261bc
  1136c0:	6a 03                	push   $0x3
  1136c2:	ff 75 08             	pushl  0x8(%ebp)
  1136c5:	e8 55 29 ff ff       	call   10601f <shell_fprintf>
  1136ca:	83 c4 14             	add    $0x14,%esp
}
  1136cd:	31 c0                	xor    %eax,%eax
  1136cf:	c9                   	leave  
  1136d0:	c3                   	ret    

001136d1 <cmd_net_ppp_status>:
{
  1136d1:	55                   	push   %ebp
  1136d2:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n",
  1136d4:	68 d3 62 12 00       	push   $0x1262d3
  1136d9:	68 a0 62 12 00       	push   $0x1262a0
  1136de:	68 bc 61 12 00       	push   $0x1261bc
  1136e3:	6a 03                	push   $0x3
  1136e5:	ff 75 08             	pushl  0x8(%ebp)
  1136e8:	e8 32 29 ff ff       	call   10601f <shell_fprintf>
  1136ed:	83 c4 14             	add    $0x14,%esp
}
  1136f0:	31 c0                	xor    %eax,%eax
  1136f2:	c9                   	leave  
  1136f3:	c3                   	ret    

001136f4 <cmd_net_ppp_ping>:
{
  1136f4:	55                   	push   %ebp
  1136f5:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_L2_PPP", "PPP");
  1136f7:	68 d3 62 12 00       	push   $0x1262d3
  1136fc:	68 c5 62 12 00       	push   $0x1262c5
  113701:	68 bc 61 12 00       	push   $0x1261bc
  113706:	6a 03                	push   $0x3
  113708:	ff 75 08             	pushl  0x8(%ebp)
  11370b:	e8 0f 29 ff ff       	call   10601f <shell_fprintf>
  113710:	83 c4 14             	add    $0x14,%esp
}
  113713:	31 c0                	xor    %eax,%eax
  113715:	c9                   	leave  
  113716:	c3                   	ret    

00113717 <cmd_net_nbr_rm>:
{
  113717:	55                   	push   %ebp
  113718:	89 e5                	mov    %esp,%ebp
	PR_INFO("IPv6 not enabled.\n");
  11371a:	68 d7 62 12 00       	push   $0x1262d7
  11371f:	6a 03                	push   $0x3
  113721:	ff 75 08             	pushl  0x8(%ebp)
  113724:	e8 f6 28 ff ff       	call   10601f <shell_fprintf>
  113729:	83 c4 0c             	add    $0xc,%esp
}
  11372c:	31 c0                	xor    %eax,%eax
  11372e:	c9                   	leave  
  11372f:	c3                   	ret    

00113730 <cmd_net_ipv6>:
{
  113730:	55                   	push   %ebp
  113731:	89 e5                	mov    %esp,%ebp
	PR("IPv6 support                              : %s\n",
  113733:	68 e5 49 12 00       	push   $0x1249e5
  113738:	68 ea 62 12 00       	push   $0x1262ea
  11373d:	6a 00                	push   $0x0
  11373f:	ff 75 08             	pushl  0x8(%ebp)
  113742:	e8 d8 28 ff ff       	call   10601f <shell_fprintf>
  113747:	83 c4 10             	add    $0x10,%esp
}
  11374a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  11374f:	c9                   	leave  
  113750:	c3                   	ret    

00113751 <cmd_net_gptp_port>:
{
  113751:	55                   	push   %ebp
  113752:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_NET_GPTP", "gPTP");
  113754:	68 1a 63 12 00       	push   $0x12631a
  113759:	68 1f 63 12 00       	push   $0x12631f
  11375e:	68 bc 61 12 00       	push   $0x1261bc
  113763:	6a 03                	push   $0x3
  113765:	ff 75 08             	pushl  0x8(%ebp)
  113768:	e8 b2 28 ff ff       	call   10601f <shell_fprintf>
  11376d:	83 c4 14             	add    $0x14,%esp
}
  113770:	31 c0                	xor    %eax,%eax
  113772:	c9                   	leave  
  113773:	c3                   	ret    

00113774 <cmd_net_gptp>:
  113774:	e9 d8 ff ff ff       	jmp    113751 <cmd_net_gptp_port>

00113779 <cmd_net_events_on>:
{
  113779:	55                   	push   %ebp
  11377a:	89 e5                	mov    %esp,%ebp
	PR_INFO("Network management events are not supported. "
  11377c:	68 2f 63 12 00       	push   $0x12632f
  113781:	6a 03                	push   $0x3
  113783:	ff 75 08             	pushl  0x8(%ebp)
  113786:	e8 94 28 ff ff       	call   10601f <shell_fprintf>
  11378b:	83 c4 0c             	add    $0xc,%esp
}
  11378e:	31 c0                	xor    %eax,%eax
  113790:	c9                   	leave  
  113791:	c3                   	ret    

00113792 <cmd_net_dns_query>:
{
  113792:	55                   	push   %ebp
  113793:	89 e5                	mov    %esp,%ebp
	PR_INFO("DNS resolver not supported. Set CONFIG_DNS_RESOLVER to "
  113795:	68 8d 63 12 00       	push   $0x12638d
  11379a:	6a 03                	push   $0x3
  11379c:	ff 75 08             	pushl  0x8(%ebp)
  11379f:	e8 7b 28 ff ff       	call   10601f <shell_fprintf>
  1137a4:	83 c4 0c             	add    $0xc,%esp
}
  1137a7:	31 c0                	xor    %eax,%eax
  1137a9:	c9                   	leave  
  1137aa:	c3                   	ret    

001137ab <cmd_net_dns_cancel>:
{
  1137ab:	55                   	push   %ebp
  1137ac:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n", "CONFIG_DNS_RESOLVER",
  1137ae:	68 d0 63 12 00       	push   $0x1263d0
  1137b3:	68 dd 63 12 00       	push   $0x1263dd
  1137b8:	68 bc 61 12 00       	push   $0x1261bc
  1137bd:	6a 03                	push   $0x3
  1137bf:	ff 75 08             	pushl  0x8(%ebp)
  1137c2:	e8 58 28 ff ff       	call   10601f <shell_fprintf>
  1137c7:	83 c4 14             	add    $0x14,%esp
}
  1137ca:	31 c0                	xor    %eax,%eax
  1137cc:	c9                   	leave  
  1137cd:	c3                   	ret    

001137ce <cmd_net_allocs>:
{
  1137ce:	55                   	push   %ebp
  1137cf:	89 e5                	mov    %esp,%ebp
	PR_INFO("Set %s to enable %s support.\n",
  1137d1:	68 f1 63 12 00       	push   $0x1263f1
  1137d6:	68 04 64 12 00       	push   $0x126404
  1137db:	68 bc 61 12 00       	push   $0x1261bc
  1137e0:	6a 03                	push   $0x3
  1137e2:	ff 75 08             	pushl  0x8(%ebp)
  1137e5:	e8 35 28 ff ff       	call   10601f <shell_fprintf>
  1137ea:	83 c4 14             	add    $0x14,%esp
}
  1137ed:	31 c0                	xor    %eax,%eax
  1137ef:	c9                   	leave  
  1137f0:	c3                   	ret    

001137f1 <cmd_net_tcp_send>:
{
  1137f1:	55                   	push   %ebp
  1137f2:	89 e5                	mov    %esp,%ebp
  1137f4:	56                   	push   %esi
  1137f5:	53                   	push   %ebx
  1137f6:	83 ec 08             	sub    $0x8,%esp
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  1137f9:	a1 4c ec 12 00       	mov    0x12ec4c,%eax
{
  1137fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  113801:	8b 75 10             	mov    0x10(%ebp),%esi
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  113804:	85 c0                	test   %eax,%eax
  113806:	74 09                	je     113811 <cmd_net_tcp_send+0x20>
  113808:	f6 80 92 00 00 00 01 	testb  $0x1,0x92(%eax)
  11380f:	75 07                	jne    113818 <cmd_net_tcp_send+0x27>
		PR_WARNING("Not connected\n");
  113811:	68 23 64 12 00       	push   $0x126423
  113816:	eb 0c                	jmp    113824 <cmd_net_tcp_send+0x33>
	if (!argv[++arg]) {
  113818:	8b 46 04             	mov    0x4(%esi),%eax
  11381b:	85 c0                	test   %eax,%eax
  11381d:	75 12                	jne    113831 <cmd_net_tcp_send+0x40>
		PR_WARNING("No data to send.\n");
  11381f:	68 32 64 12 00       	push   $0x126432
  113824:	6a 04                	push   $0x4
  113826:	53                   	push   %ebx
  113827:	e8 f3 27 ff ff       	call   10601f <shell_fprintf>
  11382c:	83 c4 0c             	add    $0xc,%esp
		return -ENOEXEC;
  11382f:	eb 46                	jmp    113877 <cmd_net_tcp_send+0x86>
	ret = net_context_send(tcp_ctx, (uint8_t *)argv[arg],
  113831:	50                   	push   %eax
	user_data.shell = shell;
  113832:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	ret = net_context_send(tcp_ctx, (uint8_t *)argv[arg],
  113835:	e8 e2 84 ff ff       	call   10bd1c <strlen>
  11383a:	8d 55 f0             	lea    -0x10(%ebp),%edx
  11383d:	89 14 24             	mov    %edx,(%esp)
  113840:	6a 00                	push   $0x0
  113842:	68 c8 00 00 00       	push   $0xc8
  113847:	68 30 36 11 00       	push   $0x113630
  11384c:	50                   	push   %eax
  11384d:	ff 76 04             	pushl  0x4(%esi)
  113850:	ff 35 4c ec 12 00    	pushl  0x12ec4c
  113856:	e8 23 bc ff ff       	call   10f47e <net_context_send>
  11385b:	83 c4 1c             	add    $0x1c,%esp
  11385e:	89 c2                	mov    %eax,%edx
	return 0;
  113860:	31 c0                	xor    %eax,%eax
	if (ret < 0) {
  113862:	85 d2                	test   %edx,%edx
  113864:	79 16                	jns    11387c <cmd_net_tcp_send+0x8b>
		PR_WARNING("Cannot send msg (%d)\n", ret);
  113866:	52                   	push   %edx
  113867:	68 44 64 12 00       	push   $0x126444
  11386c:	6a 04                	push   $0x4
  11386e:	53                   	push   %ebx
  11386f:	e8 ab 27 ff ff       	call   10601f <shell_fprintf>
  113874:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  113877:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
}
  11387c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11387f:	5b                   	pop    %ebx
  113880:	5e                   	pop    %esi
  113881:	5d                   	pop    %ebp
  113882:	c3                   	ret    

00113883 <parse_arg>:
{
  113883:	55                   	push   %ebp
  113884:	89 e5                	mov    %esp,%ebp
  113886:	57                   	push   %edi
  113887:	56                   	push   %esi
  113888:	53                   	push   %ebx
  113889:	53                   	push   %ebx
	const char *str = argv[*i] + 2;
  11388a:	8b 30                	mov    (%eax),%esi
  11388c:	8b 1c b1             	mov    (%ecx,%esi,4),%ebx
	if (*str == 0) {
  11388f:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
  113893:	74 05                	je     11389a <parse_arg+0x17>
	const char *str = argv[*i] + 2;
  113895:	83 c3 02             	add    $0x2,%ebx
  113898:	eb 12                	jmp    1138ac <parse_arg+0x29>
  11389a:	8d 3c b5 00 00 00 00 	lea    0x0(,%esi,4),%edi
		if (*i + 1 >= argc) {
  1138a1:	46                   	inc    %esi
  1138a2:	39 d6                	cmp    %edx,%esi
  1138a4:	73 26                	jae    1138cc <parse_arg+0x49>
		*i += 1;
  1138a6:	89 30                	mov    %esi,(%eax)
		str = argv[*i];
  1138a8:	8b 5c 39 04          	mov    0x4(%ecx,%edi,1),%ebx
	res = strtol(str, &endptr, 10);
  1138ac:	6a 0a                	push   $0xa
  1138ae:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1138b1:	50                   	push   %eax
  1138b2:	53                   	push   %ebx
  1138b3:	e8 dc 80 ff ff       	call   10b994 <strtol>
  1138b8:	83 c4 0c             	add    $0xc,%esp
  1138bb:	89 c6                	mov    %eax,%esi
  1138bd:	e8 a3 cb 00 00       	call   120465 <z_impl_z_errno>
	if (errno || (endptr == str)) {
  1138c2:	83 38 00             	cmpl   $0x0,(%eax)
  1138c5:	75 05                	jne    1138cc <parse_arg+0x49>
  1138c7:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
  1138ca:	75 03                	jne    1138cf <parse_arg+0x4c>
		return -1;
  1138cc:	83 ce ff             	or     $0xffffffff,%esi
}
  1138cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1138d2:	89 f0                	mov    %esi,%eax
  1138d4:	5b                   	pop    %ebx
  1138d5:	5e                   	pop    %esi
  1138d6:	5f                   	pop    %edi
  1138d7:	5d                   	pop    %ebp
  1138d8:	c3                   	ret    

001138d9 <net_if_get_by_index>:
{
  1138d9:	55                   	push   %ebp
  1138da:	89 e5                	mov    %esp,%ebp
	return z_impl_net_if_get_by_index(index);
  1138dc:	50                   	push   %eax
  1138dd:	e8 ff 9c ff ff       	call   10d5e1 <z_impl_net_if_get_by_index>
  1138e2:	5a                   	pop    %edx
}
  1138e3:	c9                   	leave  
  1138e4:	c3                   	ret    

001138e5 <cmd_net_mem>:
{
  1138e5:	55                   	push   %ebp
  1138e6:	89 e5                	mov    %esp,%ebp
  1138e8:	53                   	push   %ebx
  1138e9:	83 ec 10             	sub    $0x10,%esp
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
  1138ec:	8d 45 f8             	lea    -0x8(%ebp),%eax
{
  1138ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
	net_pkt_get_info(&rx, &tx, &rx_data, &tx_data);
  1138f2:	50                   	push   %eax
  1138f3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  1138f6:	50                   	push   %eax
  1138f7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  1138fa:	50                   	push   %eax
  1138fb:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1138fe:	50                   	push   %eax
  1138ff:	e8 e6 c1 ff ff       	call   10faea <net_pkt_get_info>
  113904:	83 c4 10             	add    $0x10,%esp
	PR("Fragment length %d bytes\n", CONFIG_NET_BUF_DATA_SIZE);
  113907:	68 80 00 00 00       	push   $0x80
  11390c:	68 5a 64 12 00       	push   $0x12645a
  113911:	6a 00                	push   $0x0
  113913:	53                   	push   %ebx
  113914:	e8 06 27 ff ff       	call   10601f <shell_fprintf>
  113919:	83 c4 10             	add    $0x10,%esp
	PR("Network buffer pools:\n");
  11391c:	68 74 64 12 00       	push   $0x126474
  113921:	6a 00                	push   $0x0
  113923:	53                   	push   %ebx
  113924:	e8 f6 26 ff ff       	call   10601f <shell_fprintf>
  113929:	83 c4 0c             	add    $0xc,%esp
	PR("Address\t\tTotal\tName\n");
  11392c:	68 8b 64 12 00       	push   $0x12648b
  113931:	6a 00                	push   $0x0
  113933:	53                   	push   %ebx
  113934:	e8 e6 26 ff ff       	call   10601f <shell_fprintf>
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
  113939:	8b 45 ec             	mov    -0x14(%ebp),%eax
	PR("Address\t\tTotal\tName\n");
  11393c:	83 c4 0c             	add    $0xc,%esp
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
  11393f:	ff 70 10             	pushl  0x10(%eax)
  113942:	50                   	push   %eax
  113943:	68 a0 64 12 00       	push   $0x1264a0
  113948:	6a 00                	push   $0x0
  11394a:	53                   	push   %ebx
  11394b:	e8 cf 26 ff ff       	call   10601f <shell_fprintf>
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
  113950:	8b 45 f0             	mov    -0x10(%ebp),%eax
	PR("%p\t%d\tRX\n", rx, rx->num_blocks);
  113953:	83 c4 14             	add    $0x14,%esp
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
  113956:	ff 70 10             	pushl  0x10(%eax)
  113959:	50                   	push   %eax
  11395a:	68 aa 64 12 00       	push   $0x1264aa
  11395f:	6a 00                	push   $0x0
  113961:	53                   	push   %ebx
  113962:	e8 b8 26 ff ff       	call   10601f <shell_fprintf>
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
  113967:	8b 45 f4             	mov    -0xc(%ebp),%eax
	PR("%p\t%d\tTX\n", tx, tx->num_blocks);
  11396a:	83 c4 14             	add    $0x14,%esp
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
  11396d:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  113971:	52                   	push   %edx
  113972:	50                   	push   %eax
  113973:	68 b4 64 12 00       	push   $0x1264b4
  113978:	6a 00                	push   $0x0
  11397a:	53                   	push   %ebx
  11397b:	e8 9f 26 ff ff       	call   10601f <shell_fprintf>
	PR("%p\t%d\tTX DATA\n", tx_data, tx_data->buf_count);
  113980:	8b 45 f8             	mov    -0x8(%ebp),%eax
	PR("%p\t%d\tRX DATA\n", rx_data, rx_data->buf_count);
  113983:	83 c4 14             	add    $0x14,%esp
	PR("%p\t%d\tTX DATA\n", tx_data, tx_data->buf_count);
  113986:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  11398a:	52                   	push   %edx
  11398b:	50                   	push   %eax
  11398c:	68 c3 64 12 00       	push   $0x1264c3
  113991:	6a 00                	push   $0x0
  113993:	53                   	push   %ebx
  113994:	e8 86 26 ff ff       	call   10601f <shell_fprintf>
  113999:	83 c4 14             	add    $0x14,%esp
	PR_INFO("Set %s to enable %s support.\n",
  11399c:	68 d2 64 12 00       	push   $0x1264d2
  1139a1:	68 e5 64 12 00       	push   $0x1264e5
  1139a6:	68 bc 61 12 00       	push   $0x1261bc
  1139ab:	6a 03                	push   $0x3
  1139ad:	53                   	push   %ebx
  1139ae:	e8 6c 26 ff ff       	call   10601f <shell_fprintf>
  1139b3:	83 c4 14             	add    $0x14,%esp
}
  1139b6:	31 c0                	xor    %eax,%eax
  1139b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1139bb:	c9                   	leave  
  1139bc:	c3                   	ret    

001139bd <cmd_net_arp_flush>:
{
  1139bd:	55                   	push   %ebp
  1139be:	89 e5                	mov    %esp,%ebp
	PR("Flushing ARP cache.\n");
  1139c0:	68 ff 64 12 00       	push   $0x1264ff
  1139c5:	6a 00                	push   $0x0
  1139c7:	ff 75 08             	pushl  0x8(%ebp)
  1139ca:	e8 50 26 ff ff       	call   10601f <shell_fprintf>
  1139cf:	83 c4 0c             	add    $0xc,%esp
	net_arp_clear_cache(NULL);
  1139d2:	6a 00                	push   $0x0
  1139d4:	e8 41 95 ff ff       	call   10cf1a <net_arp_clear_cache>
  1139d9:	58                   	pop    %eax
}
  1139da:	31 c0                	xor    %eax,%eax
  1139dc:	c9                   	leave  
  1139dd:	c3                   	ret    

001139de <cmd_net_tcp_close>:
{
  1139de:	55                   	push   %ebp
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  1139df:	a1 4c ec 12 00       	mov    0x12ec4c,%eax
{
  1139e4:	89 e5                	mov    %esp,%ebp
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  1139e6:	85 c0                	test   %eax,%eax
{
  1139e8:	53                   	push   %ebx
  1139e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  1139ec:	74 09                	je     1139f7 <cmd_net_tcp_close+0x19>
  1139ee:	f6 80 92 00 00 00 01 	testb  $0x1,0x92(%eax)
  1139f5:	75 12                	jne    113a09 <cmd_net_tcp_close+0x2b>
		PR_WARNING("Not connected\n");
  1139f7:	68 23 64 12 00       	push   $0x126423
  1139fc:	6a 04                	push   $0x4
  1139fe:	53                   	push   %ebx
  1139ff:	e8 1b 26 ff ff       	call   10601f <shell_fprintf>
  113a04:	83 c4 0c             	add    $0xc,%esp
		return -ENOEXEC;
  113a07:	eb 1c                	jmp    113a25 <cmd_net_tcp_close+0x47>
	ret = net_context_put(tcp_ctx);
  113a09:	50                   	push   %eax
  113a0a:	e8 6d b3 ff ff       	call   10ed7c <net_context_put>
  113a0f:	5a                   	pop    %edx
	if (ret < 0) {
  113a10:	85 c0                	test   %eax,%eax
  113a12:	79 18                	jns    113a2c <cmd_net_tcp_close+0x4e>
		PR_WARNING("Cannot close the connection (%d)\n", ret);
  113a14:	50                   	push   %eax
  113a15:	68 14 65 12 00       	push   $0x126514
  113a1a:	6a 04                	push   $0x4
  113a1c:	53                   	push   %ebx
  113a1d:	e8 fd 25 ff ff       	call   10601f <shell_fprintf>
  113a22:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  113a25:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  113a2a:	eb 1c                	jmp    113a48 <cmd_net_tcp_close+0x6a>
	PR("Connection closed.\n");
  113a2c:	68 36 65 12 00       	push   $0x126536
  113a31:	6a 00                	push   $0x0
  113a33:	53                   	push   %ebx
  113a34:	e8 e6 25 ff ff       	call   10601f <shell_fprintf>
  113a39:	83 c4 0c             	add    $0xc,%esp
	tcp_ctx = NULL;
  113a3c:	c7 05 4c ec 12 00 00 	movl   $0x0,0x12ec4c
  113a43:	00 00 00 
	return 0;
  113a46:	31 c0                	xor    %eax,%eax
}
  113a48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  113a4b:	c9                   	leave  
  113a4c:	c3                   	ret    

00113a4d <tcp_recv_cb>:
{
  113a4d:	55                   	push   %ebp
  113a4e:	89 e5                	mov    %esp,%ebp
  113a50:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (pkt == NULL) {
  113a53:	85 c0                	test   %eax,%eax
  113a55:	75 4a                	jne    113aa1 <tcp_recv_cb+0x54>
		if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  113a57:	a1 4c ec 12 00       	mov    0x12ec4c,%eax
  113a5c:	85 c0                	test   %eax,%eax
  113a5e:	74 73                	je     113ad3 <tcp_recv_cb+0x86>
  113a60:	f6 80 92 00 00 00 01 	testb  $0x1,0x92(%eax)
  113a67:	74 6a                	je     113ad3 <tcp_recv_cb+0x86>
		ret = net_context_put(tcp_ctx);
  113a69:	50                   	push   %eax
  113a6a:	e8 0d b3 ff ff       	call   10ed7c <net_context_put>
  113a6f:	5a                   	pop    %edx
		if (ret < 0) {
  113a70:	85 c0                	test   %eax,%eax
  113a72:	79 0c                	jns    113a80 <tcp_recv_cb+0x33>
			PR_SHELL(tcp_shell,
  113a74:	89 45 14             	mov    %eax,0x14(%ebp)
  113a77:	c7 45 10 14 65 12 00 	movl   $0x126514,0x10(%ebp)
  113a7e:	eb 3e                	jmp    113abe <tcp_recv_cb+0x71>
		PR_SHELL(tcp_shell, "Connection closed by remote peer.\n");
  113a80:	68 4a 65 12 00       	push   $0x12654a
  113a85:	6a 00                	push   $0x0
  113a87:	ff 35 48 ec 12 00    	pushl  0x12ec48
  113a8d:	e8 8d 25 ff ff       	call   10601f <shell_fprintf>
  113a92:	83 c4 0c             	add    $0xc,%esp
		tcp_ctx = NULL;
  113a95:	c7 05 4c ec 12 00 00 	movl   $0x0,0x12ec4c
  113a9c:	00 00 00 
		return;
  113a9f:	eb 32                	jmp    113ad3 <tcp_recv_cb+0x86>
	PR_SHELL(tcp_shell, "%d bytes received\n", net_pkt_get_len(pkt));
  113aa1:	8b 40 10             	mov    0x10(%eax),%eax
	size_t bytes = 0;
  113aa4:	31 d2                	xor    %edx,%edx
	while (buf) {
  113aa6:	85 c0                	test   %eax,%eax
  113aa8:	74 0a                	je     113ab4 <tcp_recv_cb+0x67>
		bytes += buf->len;
  113aaa:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
		buf = buf->frags;
  113aae:	8b 00                	mov    (%eax),%eax
		bytes += buf->len;
  113ab0:	01 ca                	add    %ecx,%edx
		buf = buf->frags;
  113ab2:	eb f2                	jmp    113aa6 <tcp_recv_cb+0x59>
  113ab4:	89 55 14             	mov    %edx,0x14(%ebp)
  113ab7:	c7 45 10 6d 65 12 00 	movl   $0x12656d,0x10(%ebp)
  113abe:	a1 48 ec 12 00       	mov    0x12ec48,%eax
  113ac3:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  113aca:	89 45 08             	mov    %eax,0x8(%ebp)
}
  113acd:	c9                   	leave  
	PR_SHELL(tcp_shell, "%d bytes received\n", net_pkt_get_len(pkt));
  113ace:	e9 4c 25 ff ff       	jmp    10601f <shell_fprintf>
}
  113ad3:	c9                   	leave  
  113ad4:	c3                   	ret    

00113ad5 <tcp_connected>:
{
  113ad5:	55                   	push   %ebp
  113ad6:	a1 48 ec 12 00       	mov    0x12ec48,%eax
  113adb:	89 e5                	mov    %esp,%ebp
  113add:	53                   	push   %ebx
  113ade:	8b 55 0c             	mov    0xc(%ebp),%edx
  113ae1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (status < 0) {
  113ae4:	85 d2                	test   %edx,%edx
  113ae6:	79 27                	jns    113b0f <tcp_connected+0x3a>
		PR_SHELL(tcp_shell, "TCP connection failed (%d)\n", status);
  113ae8:	52                   	push   %edx
  113ae9:	68 80 65 12 00       	push   $0x126580
  113aee:	6a 00                	push   $0x0
  113af0:	50                   	push   %eax
  113af1:	e8 29 25 ff ff       	call   10601f <shell_fprintf>
  113af6:	83 c4 10             	add    $0x10,%esp
		net_context_put(context);
  113af9:	53                   	push   %ebx
  113afa:	e8 7d b2 ff ff       	call   10ed7c <net_context_put>
  113aff:	58                   	pop    %eax
		tcp_ctx = NULL;
  113b00:	c7 05 4c ec 12 00 00 	movl   $0x0,0x12ec4c
  113b07:	00 00 00 
}
  113b0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  113b0d:	c9                   	leave  
  113b0e:	c3                   	ret    
  113b0f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		PR_SHELL(tcp_shell, "TCP connected\n");
  113b12:	c7 45 10 9c 65 12 00 	movl   $0x12659c,0x10(%ebp)
  113b19:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
  113b20:	89 45 08             	mov    %eax,0x8(%ebp)
}
  113b23:	c9                   	leave  
		PR_SHELL(tcp_shell, "TCP connected\n");
  113b24:	e9 f6 24 ff ff       	jmp    10601f <shell_fprintf>

00113b29 <cmd_net_tcp_recv>:
{
  113b29:	55                   	push   %ebp
  113b2a:	89 e5                	mov    %esp,%ebp
  113b2c:	53                   	push   %ebx
  113b2d:	83 ec 08             	sub    $0x8,%esp
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  113b30:	a1 4c ec 12 00       	mov    0x12ec4c,%eax
{
  113b35:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!tcp_ctx || !net_context_is_used(tcp_ctx)) {
  113b38:	85 c0                	test   %eax,%eax
  113b3a:	74 09                	je     113b45 <cmd_net_tcp_recv+0x1c>
  113b3c:	f6 80 92 00 00 00 01 	testb  $0x1,0x92(%eax)
  113b43:	75 12                	jne    113b57 <cmd_net_tcp_recv+0x2e>
		PR_WARNING("Not connected\n");
  113b45:	68 23 64 12 00       	push   $0x126423
  113b4a:	6a 04                	push   $0x4
  113b4c:	53                   	push   %ebx
  113b4d:	e8 cd 24 ff ff       	call   10601f <shell_fprintf>
  113b52:	83 c4 0c             	add    $0xc,%esp
		return -ENOEXEC;
  113b55:	eb 30                	jmp    113b87 <cmd_net_tcp_recv+0x5e>
	ret = net_context_recv(tcp_ctx, tcp_recv_cb, K_NO_WAIT, &user_data);
  113b57:	8d 55 f4             	lea    -0xc(%ebp),%edx
	user_data.shell = shell;
  113b5a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
	ret = net_context_recv(tcp_ctx, tcp_recv_cb, K_NO_WAIT, &user_data);
  113b5d:	52                   	push   %edx
  113b5e:	6a 00                	push   $0x0
  113b60:	6a 00                	push   $0x0
  113b62:	68 4d 3a 11 00       	push   $0x113a4d
  113b67:	50                   	push   %eax
  113b68:	e8 0d ba ff ff       	call   10f57a <net_context_recv>
  113b6d:	83 c4 14             	add    $0x14,%esp
	return 0;
  113b70:	31 d2                	xor    %edx,%edx
	if (ret < 0) {
  113b72:	85 c0                	test   %eax,%eax
  113b74:	79 16                	jns    113b8c <cmd_net_tcp_recv+0x63>
		PR_WARNING("Cannot recv data (%d)\n", ret);
  113b76:	50                   	push   %eax
  113b77:	68 ab 65 12 00       	push   $0x1265ab
  113b7c:	6a 04                	push   $0x4
  113b7e:	53                   	push   %ebx
  113b7f:	e8 9b 24 ff ff       	call   10601f <shell_fprintf>
  113b84:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  113b87:	ba f8 ff ff ff       	mov    $0xfffffff8,%edx
}
  113b8c:	89 d0                	mov    %edx,%eax
  113b8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  113b91:	c9                   	leave  
  113b92:	c3                   	ret    

00113b93 <get_iface_idx>:
{
  113b93:	55                   	push   %ebp
	if (!index_str) {
  113b94:	85 d2                	test   %edx,%edx
{
  113b96:	89 e5                	mov    %esp,%ebp
  113b98:	56                   	push   %esi
  113b99:	53                   	push   %ebx
  113b9a:	89 c3                	mov    %eax,%ebx
  113b9c:	51                   	push   %ecx
	if (!index_str) {
  113b9d:	75 17                	jne    113bb6 <get_iface_idx+0x23>
		PR_WARNING("Interface index is missing.\n");
  113b9f:	68 c2 65 12 00       	push   $0x1265c2
  113ba4:	6a 04                	push   $0x4
  113ba6:	50                   	push   %eax
  113ba7:	e8 73 24 ff ff       	call   10601f <shell_fprintf>
  113bac:	83 c4 0c             	add    $0xc,%esp
  113baf:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  113bb4:	eb 4e                	jmp    113c04 <get_iface_idx+0x71>
	idx = strtol(index_str, &endptr, 10);
  113bb6:	6a 0a                	push   $0xa
  113bb8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  113bbb:	50                   	push   %eax
  113bbc:	89 d6                	mov    %edx,%esi
  113bbe:	52                   	push   %edx
  113bbf:	e8 d0 7d ff ff       	call   10b994 <strtol>
	if (*endptr != '\0') {
  113bc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
	idx = strtol(index_str, &endptr, 10);
  113bc7:	83 c4 0c             	add    $0xc,%esp
	if (*endptr != '\0') {
  113bca:	80 3a 00             	cmpb   $0x0,(%edx)
  113bcd:	74 18                	je     113be7 <get_iface_idx+0x54>
		PR_WARNING("Invalid index %s\n", index_str);
  113bcf:	56                   	push   %esi
  113bd0:	68 df 65 12 00       	push   $0x1265df
  113bd5:	6a 04                	push   $0x4
  113bd7:	53                   	push   %ebx
  113bd8:	e8 42 24 ff ff       	call   10601f <shell_fprintf>
  113bdd:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
  113be0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  113be5:	eb 1d                	jmp    113c04 <get_iface_idx+0x71>
	if (idx < 0 || idx > 255) {
  113be7:	3d ff 00 00 00       	cmp    $0xff,%eax
  113bec:	76 16                	jbe    113c04 <get_iface_idx+0x71>
		PR_WARNING("Invalid index %d\n", idx);
  113bee:	50                   	push   %eax
  113bef:	68 f1 65 12 00       	push   $0x1265f1
  113bf4:	6a 04                	push   $0x4
  113bf6:	53                   	push   %ebx
  113bf7:	e8 23 24 ff ff       	call   10601f <shell_fprintf>
  113bfc:	83 c4 10             	add    $0x10,%esp
		return -ERANGE;
  113bff:	b8 da ff ff ff       	mov    $0xffffffda,%eax
}
  113c04:	8d 65 f8             	lea    -0x8(%ebp),%esp
  113c07:	5b                   	pop    %ebx
  113c08:	5e                   	pop    %esi
  113c09:	5d                   	pop    %ebp
  113c0a:	c3                   	ret    

00113c0b <cmd_net_iface>:
{
  113c0b:	55                   	push   %ebp
  113c0c:	89 e5                	mov    %esp,%ebp
  113c0e:	56                   	push   %esi
  113c0f:	53                   	push   %ebx
  113c10:	83 ec 08             	sub    $0x8,%esp
	if (argv[1]) {
  113c13:	8b 45 10             	mov    0x10(%ebp),%eax
{
  113c16:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (argv[1]) {
  113c19:	8b 50 04             	mov    0x4(%eax),%edx
  113c1c:	85 d2                	test   %edx,%edx
  113c1e:	74 37                	je     113c57 <cmd_net_iface+0x4c>
		idx = get_iface_idx(shell, argv[1]);
  113c20:	89 d8                	mov    %ebx,%eax
  113c22:	e8 6c ff ff ff       	call   113b93 <get_iface_idx>
  113c27:	89 c6                	mov    %eax,%esi
			return -ENOEXEC;
  113c29:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
		if (idx < 0) {
  113c2e:	85 f6                	test   %esi,%esi
  113c30:	78 3d                	js     113c6f <cmd_net_iface+0x64>
		iface = net_if_get_by_index(idx);
  113c32:	89 f0                	mov    %esi,%eax
  113c34:	e8 a0 fc ff ff       	call   1138d9 <net_if_get_by_index>
  113c39:	89 c2                	mov    %eax,%edx
		if (!iface) {
  113c3b:	85 c0                	test   %eax,%eax
  113c3d:	75 18                	jne    113c57 <cmd_net_iface+0x4c>
			PR_WARNING("No such interface in index %d\n", idx);
  113c3f:	56                   	push   %esi
  113c40:	68 03 66 12 00       	push   $0x126603
  113c45:	6a 04                	push   $0x4
  113c47:	53                   	push   %ebx
  113c48:	e8 d2 23 ff ff       	call   10601f <shell_fprintf>
  113c4d:	83 c4 10             	add    $0x10,%esp
			return -ENOEXEC;
  113c50:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  113c55:	eb 18                	jmp    113c6f <cmd_net_iface+0x64>
	net_if_foreach(iface_cb, &user_data);
  113c57:	8d 45 f0             	lea    -0x10(%ebp),%eax
	user_data.user_data = iface;
  113c5a:	89 55 f4             	mov    %edx,-0xc(%ebp)
	net_if_foreach(iface_cb, &user_data);
  113c5d:	50                   	push   %eax
	user_data.shell = shell;
  113c5e:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	net_if_foreach(iface_cb, &user_data);
  113c61:	68 ea 43 11 00       	push   $0x1143ea
  113c66:	e8 af 9f ff ff       	call   10dc1a <net_if_foreach>
  113c6b:	58                   	pop    %eax
	return 0;
  113c6c:	31 c0                	xor    %eax,%eax
	net_if_foreach(iface_cb, &user_data);
  113c6e:	5a                   	pop    %edx
}
  113c6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  113c72:	5b                   	pop    %ebx
  113c73:	5e                   	pop    %esi
  113c74:	5d                   	pop    %ebp
  113c75:	c3                   	ret    

00113c76 <cmd_net_iface_down>:
{
  113c76:	55                   	push   %ebp
  113c77:	89 e5                	mov    %esp,%ebp
  113c79:	56                   	push   %esi
  113c7a:	53                   	push   %ebx
  113c7b:	51                   	push   %ecx
	idx = get_iface_idx(shell, argv[1]);
  113c7c:	8b 45 10             	mov    0x10(%ebp),%eax
{
  113c7f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	idx = get_iface_idx(shell, argv[1]);
  113c82:	8b 50 04             	mov    0x4(%eax),%edx
  113c85:	89 d8                	mov    %ebx,%eax
  113c87:	e8 07 ff ff ff       	call   113b93 <get_iface_idx>
  113c8c:	89 c6                	mov    %eax,%esi
		return -ENOEXEC;
  113c8e:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	if (idx < 0) {
  113c93:	85 f6                	test   %esi,%esi
  113c95:	78 59                	js     113cf0 <cmd_net_iface_down+0x7a>
	iface = net_if_get_by_index(idx);
  113c97:	89 f0                	mov    %esi,%eax
  113c99:	e8 3b fc ff ff       	call   1138d9 <net_if_get_by_index>
	if (!iface) {
  113c9e:	85 c0                	test   %eax,%eax
  113ca0:	75 13                	jne    113cb5 <cmd_net_iface_down+0x3f>
		PR_WARNING("No such interface in index %d\n", idx);
  113ca2:	56                   	push   %esi
  113ca3:	68 03 66 12 00       	push   $0x126603
  113ca8:	6a 04                	push   $0x4
  113caa:	53                   	push   %ebx
  113cab:	e8 6f 23 ff ff       	call   10601f <shell_fprintf>
  113cb0:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  113cb3:	eb 1d                	jmp    113cd2 <cmd_net_iface_down+0x5c>
	ret = net_if_down(iface);
  113cb5:	50                   	push   %eax
  113cb6:	e8 dc 9f ff ff       	call   10dc97 <net_if_down>
  113cbb:	5a                   	pop    %edx
	if (ret) {
  113cbc:	85 c0                	test   %eax,%eax
  113cbe:	74 19                	je     113cd9 <cmd_net_iface_down+0x63>
		PR_WARNING("Cannot take interface %d down (%d)\n", idx, ret);
  113cc0:	50                   	push   %eax
  113cc1:	56                   	push   %esi
  113cc2:	68 22 66 12 00       	push   $0x126622
  113cc7:	6a 04                	push   $0x4
  113cc9:	53                   	push   %ebx
  113cca:	e8 50 23 ff ff       	call   10601f <shell_fprintf>
  113ccf:	83 c4 14             	add    $0x14,%esp
		return -ENOEXEC;
  113cd2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  113cd7:	eb 17                	jmp    113cf0 <cmd_net_iface_down+0x7a>
		PR("Interface %d is down\n", idx);
  113cd9:	56                   	push   %esi
  113cda:	89 45 f4             	mov    %eax,-0xc(%ebp)
  113cdd:	68 46 66 12 00       	push   $0x126646
  113ce2:	6a 00                	push   $0x0
  113ce4:	53                   	push   %ebx
  113ce5:	e8 35 23 ff ff       	call   10601f <shell_fprintf>
  113cea:	83 c4 10             	add    $0x10,%esp
  113ced:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  113cf0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  113cf3:	5b                   	pop    %ebx
  113cf4:	5e                   	pop    %esi
  113cf5:	5d                   	pop    %ebp
  113cf6:	c3                   	ret    

00113cf7 <cmd_net_conn>:
{
  113cf7:	55                   	push   %ebp
  113cf8:	89 e5                	mov    %esp,%ebp
  113cfa:	53                   	push   %ebx
  113cfb:	83 ec 0c             	sub    $0xc,%esp
  113cfe:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int count = 0;
  113d01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	PR("     Context   \tIface         Flags Local           \tRemote\n");
  113d08:	68 5c 66 12 00       	push   $0x12665c
  113d0d:	6a 00                	push   $0x0
  113d0f:	53                   	push   %ebx
  113d10:	e8 0a 23 ff ff       	call   10601f <shell_fprintf>
  113d15:	83 c4 0c             	add    $0xc,%esp
	user_data.user_data = &count;
  113d18:	8d 45 f0             	lea    -0x10(%ebp),%eax
  113d1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	net_context_foreach(context_cb, &user_data);
  113d1e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  113d21:	50                   	push   %eax
	user_data.shell = shell;
  113d22:	89 5d f4             	mov    %ebx,-0xc(%ebp)
	net_context_foreach(context_cb, &user_data);
  113d25:	68 9c 3d 11 00       	push   $0x113d9c
  113d2a:	e8 f0 b9 ff ff       	call   10f71f <net_context_foreach>
  113d2f:	58                   	pop    %eax
	if (count == 0) {
  113d30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
	net_context_foreach(context_cb, &user_data);
  113d34:	5a                   	pop    %edx
	if (count == 0) {
  113d35:	75 10                	jne    113d47 <cmd_net_conn+0x50>
		PR("No connections\n");
  113d37:	68 99 66 12 00       	push   $0x126699
  113d3c:	6a 00                	push   $0x0
  113d3e:	53                   	push   %ebx
  113d3f:	e8 db 22 ff ff       	call   10601f <shell_fprintf>
  113d44:	83 c4 0c             	add    $0xc,%esp
}
  113d47:	31 c0                	xor    %eax,%eax
  113d49:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  113d4c:	c9                   	leave  
  113d4d:	c3                   	ret    

00113d4e <cmd_net_arp>:
{
  113d4e:	55                   	push   %ebp
  113d4f:	89 e5                	mov    %esp,%ebp
  113d51:	53                   	push   %ebx
  113d52:	83 ec 0c             	sub    $0xc,%esp
	if (!argv[arg]) {
  113d55:	8b 45 10             	mov    0x10(%ebp),%eax
{
  113d58:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!argv[arg]) {
  113d5b:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  113d5f:	75 34                	jne    113d95 <cmd_net_arp+0x47>
		user_data.user_data = &count;
  113d61:	8d 45 f0             	lea    -0x10(%ebp),%eax
		int count = 0;
  113d64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		user_data.user_data = &count;
  113d6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
  113d6e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  113d71:	50                   	push   %eax
		user_data.shell = shell;
  113d72:	89 5d f4             	mov    %ebx,-0xc(%ebp)
		if (net_arp_foreach(arp_cb, &user_data) == 0) {
  113d75:	68 a4 46 11 00       	push   $0x1146a4
  113d7a:	e8 6e 92 ff ff       	call   10cfed <net_arp_foreach>
  113d7f:	5a                   	pop    %edx
  113d80:	85 c0                	test   %eax,%eax
  113d82:	59                   	pop    %ecx
  113d83:	75 10                	jne    113d95 <cmd_net_arp+0x47>
			PR("ARP cache is empty.\n");
  113d85:	68 a9 66 12 00       	push   $0x1266a9
  113d8a:	6a 00                	push   $0x0
  113d8c:	53                   	push   %ebx
  113d8d:	e8 8d 22 ff ff       	call   10601f <shell_fprintf>
  113d92:	83 c4 0c             	add    $0xc,%esp
}
  113d95:	31 c0                	xor    %eax,%eax
  113d97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  113d9a:	c9                   	leave  
  113d9b:	c3                   	ret    

00113d9c <context_cb>:
{
  113d9c:	55                   	push   %ebp
	char addr_remote[ADDR_LEN + 7] = "";
  113d9d:	b9 13 00 00 00       	mov    $0x13,%ecx
{
  113da2:	89 e5                	mov    %esp,%ebp
  113da4:	57                   	push   %edi
  113da5:	56                   	push   %esi
  113da6:	53                   	push   %ebx
  113da7:	83 ec 3c             	sub    $0x3c,%esp
	char addr_remote[ADDR_LEN + 7] = "";
  113daa:	c7 45 dd 00 00 00 00 	movl   $0x0,-0x23(%ebp)
{
  113db1:	8b 45 0c             	mov    0xc(%ebp),%eax
  113db4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const struct shell *shell = data->shell;
  113db7:	8b 38                	mov    (%eax),%edi
	int *count = data->user_data;
  113db9:	8b 40 04             	mov    0x4(%eax),%eax
	const struct shell *shell = data->shell;
  113dbc:	89 7d bc             	mov    %edi,-0x44(%ebp)
	int *count = data->user_data;
  113dbf:	89 45 c0             	mov    %eax,-0x40(%ebp)
	char addr_remote[ADDR_LEN + 7] = "";
  113dc2:	8d 7d e1             	lea    -0x1f(%ebp),%edi
  113dc5:	31 c0                	xor    %eax,%eax
  113dc7:	f3 aa                	rep stos %al,%es:(%edi)
	if (context->local.family == AF_INET) {
  113dc9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  113dcd:	66 83 f8 01          	cmp    $0x1,%ax
  113dd1:	75 5b                	jne    113e2e <context_cb+0x92>
			 ntohs(net_sin_ptr(&context->local)->sin_port));
  113dd3:	66 8b 73 26          	mov    0x26(%ebx),%si
		snprintk(addr_local, local_len, "%s:%d",
  113dd7:	ff 73 28             	pushl  0x28(%ebx)
			 ntohs(net_sin_ptr(&context->local)->sin_port));
  113dda:	66 c1 c6 08          	rol    $0x8,%si
		snprintk(addr_local, local_len, "%s:%d",
  113dde:	6a 01                	push   $0x1
  113de0:	e8 bf a3 ff ff       	call   10e1a4 <net_sprint_addr>
  113de5:	5a                   	pop    %edx
  113de6:	59                   	pop    %ecx
  113de7:	0f b7 f6             	movzwl %si,%esi
  113dea:	56                   	push   %esi
  113deb:	50                   	push   %eax
  113dec:	8d 45 c6             	lea    -0x3a(%ebp),%eax
  113def:	68 be 66 12 00       	push   $0x1266be
  113df4:	6a 17                	push   $0x17
  113df6:	50                   	push   %eax
  113df7:	e8 03 d5 fe ff       	call   1012ff <snprintk>
  113dfc:	83 c4 14             	add    $0x14,%esp
			 net_sprint_ipv4_addr(
  113dff:	8d 43 30             	lea    0x30(%ebx),%eax
			 ntohs(net_sin(&context->remote)->sin_port));
  113e02:	66 8b 73 2e          	mov    0x2e(%ebx),%si
		snprintk(addr_remote, remote_len, "%s:%d",
  113e06:	50                   	push   %eax
  113e07:	6a 01                	push   $0x1
  113e09:	e8 96 a3 ff ff       	call   10e1a4 <net_sprint_addr>
			 ntohs(net_sin(&context->remote)->sin_port));
  113e0e:	66 c1 c6 08          	rol    $0x8,%si
		snprintk(addr_remote, remote_len, "%s:%d",
  113e12:	5f                   	pop    %edi
  113e13:	5a                   	pop    %edx
  113e14:	0f b7 f6             	movzwl %si,%esi
  113e17:	56                   	push   %esi
  113e18:	50                   	push   %eax
  113e19:	8d 45 dd             	lea    -0x23(%ebp),%eax
  113e1c:	68 be 66 12 00       	push   $0x1266be
  113e21:	6a 17                	push   $0x17
  113e23:	50                   	push   %eax
  113e24:	e8 d6 d4 fe ff       	call   1012ff <snprintk>
  113e29:	83 c4 14             	add    $0x14,%esp
  113e2c:	eb 45                	jmp    113e73 <context_cb+0xd7>
	if (context->local.family == AF_UNSPEC) {
  113e2e:	66 85 c0             	test   %ax,%ax
  113e31:	8d 55 c6             	lea    -0x3a(%ebp),%edx
  113e34:	75 07                	jne    113e3d <context_cb+0xa1>
		snprintk(addr_local, local_len, "AF_UNSPEC");
  113e36:	68 43 5e 12 00       	push   $0x125e43
  113e3b:	eb 0b                	jmp    113e48 <context_cb+0xac>
	} else if (context->local.family == AF_PACKET) {
  113e3d:	66 83 f8 03          	cmp    $0x3,%ax
  113e41:	75 12                	jne    113e55 <context_cb+0xb9>
		snprintk(addr_local, local_len, "AF_PACKET");
  113e43:	68 5e 5e 12 00       	push   $0x125e5e
  113e48:	6a 17                	push   $0x17
  113e4a:	52                   	push   %edx
  113e4b:	e8 af d4 fe ff       	call   1012ff <snprintk>
  113e50:	83 c4 0c             	add    $0xc,%esp
  113e53:	eb 1e                	jmp    113e73 <context_cb+0xd7>
	} else if (context->local.family == AF_CAN) {
  113e55:	66 83 f8 04          	cmp    $0x4,%ax
  113e59:	75 07                	jne    113e62 <context_cb+0xc6>
		snprintk(addr_local, local_len, "AF_CAN");
  113e5b:	68 68 5e 12 00       	push   $0x125e68
  113e60:	eb e6                	jmp    113e48 <context_cb+0xac>
		snprintk(addr_local, local_len, "AF_UNK(%d)",
  113e62:	50                   	push   %eax
  113e63:	68 c4 66 12 00       	push   $0x1266c4
  113e68:	6a 17                	push   $0x17
  113e6a:	52                   	push   %edx
  113e6b:	e8 8f d4 fe ff       	call   1012ff <snprintk>
  113e70:	83 c4 10             	add    $0x10,%esp
	PR("[%2d] %p\t%p    %c%c%c   %16s\t%16s\n",
  113e73:	66 8b 83 90 00 00 00 	mov    0x90(%ebx),%ax
  113e7a:	ba 55 00 00 00       	mov    $0x55,%edx
  113e7f:	66 83 f8 11          	cmp    $0x11,%ax
  113e83:	74 10                	je     113e95 <context_cb+0xf9>
  113e85:	31 d2                	xor    %edx,%edx
  113e87:	66 83 f8 06          	cmp    $0x6,%ax
  113e8b:	0f 94 c2             	sete   %dl
  113e8e:	4a                   	dec    %edx
  113e8f:	83 e2 cc             	and    $0xffffffcc,%edx
  113e92:	83 c2 54             	add    $0x54,%edx
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
  113e95:	0f b7 83 92 00 00 00 	movzwl 0x92(%ebx),%eax
  113e9c:	89 c1                	mov    %eax,%ecx
  113e9e:	be 44 00 00 00       	mov    $0x44,%esi
  113ea3:	c1 e9 06             	shr    $0x6,%ecx
  113ea6:	83 e1 03             	and    $0x3,%ecx
  113ea9:	83 f9 02             	cmp    $0x2,%ecx
  113eac:	74 1c                	je     113eca <context_cb+0x12e>
  113eae:	be 53 00 00 00       	mov    $0x53,%esi
  113eb3:	83 f9 01             	cmp    $0x1,%ecx
  113eb6:	74 12                	je     113eca <context_cb+0x12e>
  113eb8:	83 f9 03             	cmp    $0x3,%ecx
  113ebb:	0f 94 c1             	sete   %cl
  113ebe:	0f b6 c9             	movzbl %cl,%ecx
  113ec1:	89 ce                	mov    %ecx,%esi
  113ec3:	4e                   	dec    %esi
  113ec4:	83 e6 ce             	and    $0xffffffce,%esi
  113ec7:	83 c6 52             	add    $0x52,%esi
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
  113eca:	c1 e8 03             	shr    $0x3,%eax
  113ecd:	bf 36 00 00 00       	mov    $0x36,%edi
  113ed2:	83 e0 07             	and    $0x7,%eax
  113ed5:	66 83 f8 02          	cmp    $0x2,%ax
  113ed9:	74 11                	je     113eec <context_cb+0x150>
  113edb:	66 48                	dec    %ax
  113edd:	0f 94 c0             	sete   %al
  113ee0:	0f b6 c0             	movzbl %al,%eax
  113ee3:	89 c7                	mov    %eax,%edi
  113ee5:	4f                   	dec    %edi
  113ee6:	83 e7 ec             	and    $0xffffffec,%edi
  113ee9:	83 c7 34             	add    $0x34,%edi
	return net_if_get_by_index(context->iface);
  113eec:	0f be 83 94 00 00 00 	movsbl 0x94(%ebx),%eax
  113ef3:	89 55 b8             	mov    %edx,-0x48(%ebp)
  113ef6:	e8 de f9 ff ff       	call   1138d9 <net_if_get_by_index>
  113efb:	8d 4d dd             	lea    -0x23(%ebp),%ecx
  113efe:	8b 55 b8             	mov    -0x48(%ebp),%edx
  113f01:	51                   	push   %ecx
  113f02:	8d 4d c6             	lea    -0x3a(%ebp),%ecx
  113f05:	51                   	push   %ecx
  113f06:	52                   	push   %edx
  113f07:	56                   	push   %esi
  113f08:	57                   	push   %edi
  113f09:	50                   	push   %eax
  113f0a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  113f0d:	53                   	push   %ebx
  113f0e:	8b 00                	mov    (%eax),%eax
  113f10:	89 45 b8             	mov    %eax,-0x48(%ebp)
  113f13:	40                   	inc    %eax
  113f14:	50                   	push   %eax
  113f15:	68 cf 66 12 00       	push   $0x1266cf
  113f1a:	6a 00                	push   $0x0
  113f1c:	ff 75 bc             	pushl  -0x44(%ebp)
  113f1f:	e8 fb 20 ff ff       	call   10601f <shell_fprintf>
	(*count)++;
  113f24:	8b 45 c0             	mov    -0x40(%ebp),%eax
  113f27:	ff 00                	incl   (%eax)
	PR("[%2d] %p\t%p    %c%c%c   %16s\t%16s\n",
  113f29:	83 c4 2c             	add    $0x2c,%esp
}
  113f2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  113f2f:	5b                   	pop    %ebx
  113f30:	5e                   	pop    %esi
  113f31:	5f                   	pop    %edi
  113f32:	5d                   	pop    %ebp
  113f33:	c3                   	ret    

00113f34 <cmd_net_tcp_connect>:
{
  113f34:	55                   	push   %ebp
  113f35:	89 e5                	mov    %esp,%ebp
  113f37:	57                   	push   %edi
  113f38:	56                   	push   %esi
  113f39:	53                   	push   %ebx
  113f3a:	83 ec 1c             	sub    $0x1c,%esp
	if (tcp_ctx && net_context_is_used(tcp_ctx)) {
  113f3d:	a1 4c ec 12 00       	mov    0x12ec4c,%eax
{
  113f42:	8b 5d 08             	mov    0x8(%ebp),%ebx
  113f45:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (tcp_ctx && net_context_is_used(tcp_ctx)) {
  113f48:	85 c0                	test   %eax,%eax
  113f4a:	74 12                	je     113f5e <cmd_net_tcp_connect+0x2a>
  113f4c:	f6 80 92 00 00 00 01 	testb  $0x1,0x92(%eax)
  113f53:	74 09                	je     113f5e <cmd_net_tcp_connect+0x2a>
		PR("Already connected\n");
  113f55:	68 f2 66 12 00       	push   $0x1266f2
  113f5a:	6a 00                	push   $0x0
  113f5c:	eb 1c                	jmp    113f7a <cmd_net_tcp_connect+0x46>
	if (!argv[++arg]) {
  113f5e:	8b 77 04             	mov    0x4(%edi),%esi
  113f61:	85 f6                	test   %esi,%esi
  113f63:	75 07                	jne    113f6c <cmd_net_tcp_connect+0x38>
		PR_WARNING("Peer IP address missing.\n");
  113f65:	68 05 67 12 00       	push   $0x126705
  113f6a:	eb 0c                	jmp    113f78 <cmd_net_tcp_connect+0x44>
	if (!argv[++arg]) {
  113f6c:	8b 47 08             	mov    0x8(%edi),%eax
  113f6f:	85 c0                	test   %eax,%eax
  113f71:	75 12                	jne    113f85 <cmd_net_tcp_connect+0x51>
		PR_WARNING("Peer port missing.\n");
  113f73:	68 1f 67 12 00       	push   $0x12671f
  113f78:	6a 04                	push   $0x4
  113f7a:	53                   	push   %ebx
  113f7b:	e8 9f 20 ff ff       	call   10601f <shell_fprintf>
  113f80:	83 c4 0c             	add    $0xc,%esp
		return -ENOEXEC;
  113f83:	eb 2d                	jmp    113fb2 <cmd_net_tcp_connect+0x7e>
	port = strtol(argv[arg], &endptr, 10);
  113f85:	6a 0a                	push   $0xa
  113f87:	8d 55 e0             	lea    -0x20(%ebp),%edx
  113f8a:	52                   	push   %edx
  113f8b:	50                   	push   %eax
  113f8c:	e8 03 7a ff ff       	call   10b994 <strtol>
  113f91:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (*endptr != '\0') {
  113f94:	8b 45 e0             	mov    -0x20(%ebp),%eax
	port = strtol(argv[arg], &endptr, 10);
  113f97:	83 c4 0c             	add    $0xc,%esp
	if (*endptr != '\0') {
  113f9a:	80 38 00             	cmpb   $0x0,(%eax)
  113f9d:	74 1d                	je     113fbc <cmd_net_tcp_connect+0x88>
		PR_WARNING("Invalid port %s\n", argv[arg]);
  113f9f:	ff 77 08             	pushl  0x8(%edi)
  113fa2:	68 33 67 12 00       	push   $0x126733
  113fa7:	6a 04                	push   $0x4
  113fa9:	53                   	push   %ebx
  113faa:	e8 70 20 ff ff       	call   10601f <shell_fprintf>
  113faf:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  113fb2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  113fb7:	e9 13 01 00 00       	jmp    1140cf <cmd_net_tcp_connect+0x19b>
	struct net_if *iface = net_if_get_default();
  113fbc:	e8 97 96 ff ff       	call   10d658 <net_if_get_default>
  113fc1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return z_impl_net_addr_pton(family, src, dst);
  113fc4:	8d 7d f0             	lea    -0x10(%ebp),%edi
  113fc7:	57                   	push   %edi
  113fc8:	56                   	push   %esi
  113fc9:	6a 01                	push   $0x1
  113fcb:	e8 0d a2 ff ff       	call   10e1dd <z_impl_net_addr_pton>
  113fd0:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
  113fd3:	8b 55 d8             	mov    -0x28(%ebp),%edx
  113fd6:	85 c0                	test   %eax,%eax
  113fd8:	79 15                	jns    113fef <cmd_net_tcp_connect+0xbb>
			PR_WARNING("Invalid IPv4 address\n");
  113fda:	68 44 67 12 00       	push   $0x126744
  113fdf:	6a 04                	push   $0x4
  113fe1:	53                   	push   %ebx
  113fe2:	e8 38 20 ff ff       	call   10601f <shell_fprintf>
  113fe7:	83 c4 0c             	add    $0xc,%esp
			return;
  113fea:	e9 de 00 00 00       	jmp    1140cd <cmd_net_tcp_connect+0x199>
	       &iface->config.ip.ipv4->unicast[0].address.in_addr,
  113fef:	8b 42 04             	mov    0x4(%edx),%eax
	memcpy(&net_sin(myaddr)->sin_addr,
  113ff2:	6a 04                	push   $0x4
	       &iface->config.ip.ipv4->unicast[0].address.in_addr,
  113ff4:	83 c0 04             	add    $0x4,%eax
	memcpy(&net_sin(myaddr)->sin_addr,
  113ff7:	8d 75 e8             	lea    -0x18(%ebp),%esi
  113ffa:	50                   	push   %eax
  113ffb:	56                   	push   %esi
  113ffc:	e8 eb 7d ff ff       	call   10bdec <memcpy>
  114001:	83 c4 0c             	add    $0xc,%esp
		net_sin(&addr)->sin_port = htons(port);
  114004:	8b 45 dc             	mov    -0x24(%ebp),%eax
  114007:	86 e0                	xchg   %ah,%al
		family = addr.sa_family = myaddr.sa_family = AF_INET;
  114009:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			PR("Connecting from %s:%u ",
  114010:	56                   	push   %esi
		net_sin(&addr)->sin_port = htons(port);
  114011:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
			PR("Connecting from %s:%u ",
  114015:	6a 01                	push   $0x1
		family = addr.sa_family = myaddr.sa_family = AF_INET;
  114017:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
			PR("Connecting from %s:%u ",
  11401d:	e8 82 a1 ff ff       	call   10e1a4 <net_sprint_addr>
  114022:	5a                   	pop    %edx
  114023:	59                   	pop    %ecx
  114024:	6a 00                	push   $0x0
  114026:	50                   	push   %eax
  114027:	68 5a 67 12 00       	push   $0x12675a
  11402c:	6a 00                	push   $0x0
  11402e:	53                   	push   %ebx
  11402f:	e8 eb 1f ff ff       	call   10601f <shell_fprintf>
  114034:	83 c4 14             	add    $0x14,%esp
			PR("to %s:%u\n",
  114037:	66 8b 75 ee          	mov    -0x12(%ebp),%si
  11403b:	66 c1 c6 08          	rol    $0x8,%si
  11403f:	57                   	push   %edi
  114040:	6a 01                	push   $0x1
  114042:	e8 5d a1 ff ff       	call   10e1a4 <net_sprint_addr>
  114047:	5f                   	pop    %edi
  114048:	5a                   	pop    %edx
  114049:	0f b7 f6             	movzwl %si,%esi
  11404c:	56                   	push   %esi
  11404d:	50                   	push   %eax
  11404e:	68 71 67 12 00       	push   $0x126771
  114053:	6a 00                	push   $0x0
  114055:	53                   	push   %ebx
  114056:	e8 c4 1f ff ff       	call   10601f <shell_fprintf>
  11405b:	83 c4 14             	add    $0x14,%esp
	ret = net_context_get(family, SOCK_STREAM, IPPROTO_TCP, ctx);
  11405e:	68 4c ec 12 00       	push   $0x12ec4c
  114063:	6a 06                	push   $0x6
  114065:	6a 01                	push   $0x1
  114067:	6a 01                	push   $0x1
  114069:	e8 7d aa ff ff       	call   10eaeb <net_context_get>
  11406e:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
  114071:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  114074:	85 c0                	test   %eax,%eax
  114076:	79 08                	jns    114080 <cmd_net_tcp_connect+0x14c>
		PR_WARNING("Cannot get TCP context (%d)\n", ret);
  114078:	50                   	push   %eax
  114079:	68 7b 67 12 00       	push   $0x12677b
  11407e:	eb 1b                	jmp    11409b <cmd_net_tcp_connect+0x167>
	ret = net_context_bind(*ctx, &myaddr, addrlen);
  114080:	6a 08                	push   $0x8
  114082:	52                   	push   %edx
  114083:	ff 35 4c ec 12 00    	pushl  0x12ec4c
  114089:	e8 5a ad ff ff       	call   10ede8 <net_context_bind>
  11408e:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  114091:	85 c0                	test   %eax,%eax
  114093:	79 13                	jns    1140a8 <cmd_net_tcp_connect+0x174>
		PR_WARNING("Cannot bind TCP (%d)\n", ret);
  114095:	50                   	push   %eax
  114096:	68 98 67 12 00       	push   $0x126798
  11409b:	6a 04                	push   $0x4
  11409d:	53                   	push   %ebx
  11409e:	e8 7c 1f ff ff       	call   10601f <shell_fprintf>
  1140a3:	83 c4 10             	add    $0x10,%esp
		return;
  1140a6:	eb 25                	jmp    1140cd <cmd_net_tcp_connect+0x199>
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
  1140a8:	6a 00                	push   $0x0
  1140aa:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1140ad:	6a 00                	push   $0x0
	tcp_shell = shell;
  1140af:	89 1d 48 ec 12 00    	mov    %ebx,0x12ec48
	net_context_connect(*ctx, &addr, addrlen, tcp_connected,
  1140b5:	6a 00                	push   $0x0
  1140b7:	68 d5 3a 11 00       	push   $0x113ad5
  1140bc:	6a 08                	push   $0x8
  1140be:	50                   	push   %eax
  1140bf:	ff 35 4c ec 12 00    	pushl  0x12ec4c
  1140c5:	e8 00 b2 ff ff       	call   10f2ca <net_context_connect>
  1140ca:	83 c4 1c             	add    $0x1c,%esp
	return 0;
  1140cd:	31 c0                	xor    %eax,%eax
}
  1140cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1140d2:	5b                   	pop    %ebx
  1140d3:	5e                   	pop    %esi
  1140d4:	5f                   	pop    %edi
  1140d5:	5d                   	pop    %ebp
  1140d6:	c3                   	ret    

001140d7 <handle_ipv4_echo_reply>:
{
  1140d7:	55                   	push   %ebp
  1140d8:	89 e5                	mov    %esp,%ebp
  1140da:	57                   	push   %edi
  1140db:	56                   	push   %esi
  1140dc:	53                   	push   %ebx
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
  1140dd:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  1140e0:	83 ec 20             	sub    $0x20,%esp
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
  1140e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
{
  1140ea:	8b 7d 0c             	mov    0xc(%ebp),%edi
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
  1140ed:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
  1140f4:	50                   	push   %eax
  1140f5:	ff 75 08             	pushl  0x8(%ebp)
  1140f8:	e8 58 c3 ff ff       	call   110455 <net_pkt_get_data>
  1140fd:	5e                   	pop    %esi
	if (icmp_echo == NULL) {
  1140fe:	85 c0                	test   %eax,%eax
	icmp_echo = (struct net_icmpv4_echo_req *)net_pkt_get_data(pkt,
  114100:	5a                   	pop    %edx
	if (icmp_echo == NULL) {
  114101:	75 0a                	jne    11410d <handle_ipv4_echo_reply+0x36>
		return -NET_DROP;
  114103:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  114108:	e9 e2 00 00 00       	jmp    1141ef <handle_ipv4_echo_reply+0x118>
	net_pkt_skip(pkt, sizeof(*icmp_echo));
  11410d:	6a 04                	push   $0x4
  11410f:	89 c6                	mov    %eax,%esi
  114111:	ff 75 08             	pushl  0x8(%ebp)
  114114:	e8 f2 be ff ff       	call   11000b <net_pkt_skip>
  114119:	58                   	pop    %eax
	if (net_pkt_read_be32(pkt, &cycles)) {
  11411a:	8d 45 e8             	lea    -0x18(%ebp),%eax
	net_pkt_skip(pkt, sizeof(*icmp_echo));
  11411d:	5a                   	pop    %edx
	if (net_pkt_read_be32(pkt, &cycles)) {
  11411e:	50                   	push   %eax
  11411f:	ff 75 08             	pushl  0x8(%ebp)
  114122:	e8 3c bf ff ff       	call   110063 <net_pkt_read_be32>
  114127:	59                   	pop    %ecx
  114128:	85 c0                	test   %eax,%eax
  11412a:	5b                   	pop    %ebx
  11412b:	75 d6                	jne    114103 <handle_ipv4_echo_reply+0x2c>
	return z_timer_cycle_get_32();
  11412d:	e8 d0 6a ff ff       	call   10ac02 <z_timer_cycle_get_32>
	PR_SHELL(shell_for_ping, "%d bytes from %s to %s: icmp_seq=%d ttl=%d "
  114132:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	cycles = k_cycle_get_32() - cycles;
  114139:	2b 45 e8             	sub    -0x18(%ebp),%eax
  11413c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	PR_SHELL(shell_for_ping, "%d bytes from %s to %s: icmp_seq=%d ttl=%d "
  11413f:	89 45 e0             	mov    %eax,-0x20(%ebp)
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint64_t k_cyc_to_ns_floor64(uint64_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ns, Z_CCYC, false, false, false);
  114142:	8b 0d 44 5b 14 00    	mov    0x145b44,%ecx
	if (from_hz == to_hz) {
  114148:	81 f9 00 ca 9a 3b    	cmp    $0x3b9aca00,%ecx
  11414e:	74 1b                	je     11416b <handle_ipv4_echo_reply+0x94>
			return (t * to_hz + off) / from_hz;
  114150:	ba 00 ca 9a 3b       	mov    $0x3b9aca00,%edx
  114155:	31 db                	xor    %ebx,%ebx
  114157:	f7 e2                	mul    %edx
  114159:	53                   	push   %ebx
  11415a:	51                   	push   %ecx
  11415b:	52                   	push   %edx
  11415c:	50                   	push   %eax
  11415d:	e8 be c0 fe ff       	call   100220 <__udivdi3>
  114162:	83 c4 10             	add    $0x10,%esp
  114165:	89 45 e0             	mov    %eax,-0x20(%ebp)
  114168:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  11416b:	0f b6 47 08          	movzbl 0x8(%edi),%eax
  11416f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  114172:	66 8b 46 02          	mov    0x2(%esi),%ax
  114176:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  11417a:	8d 47 10             	lea    0x10(%edi),%eax
  11417d:	50                   	push   %eax
  11417e:	6a 01                	push   $0x1
  114180:	e8 1f a0 ff ff       	call   10e1a4 <net_sprint_addr>
  114185:	5a                   	pop    %edx
  114186:	89 c3                	mov    %eax,%ebx
  114188:	59                   	pop    %ecx
  114189:	8d 47 0c             	lea    0xc(%edi),%eax
  11418c:	50                   	push   %eax
  11418d:	6a 01                	push   $0x1
  11418f:	e8 10 a0 ff ff       	call   10e1a4 <net_sprint_addr>
  114194:	5e                   	pop    %esi
  114195:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  114198:	5a                   	pop    %edx
  114199:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11419c:	be 40 42 0f 00       	mov    $0xf4240,%esi
  1141a1:	31 d2                	xor    %edx,%edx
  1141a3:	f7 f6                	div    %esi
  1141a5:	66 8b 4f 02          	mov    0x2(%edi),%cx
  1141a9:	50                   	push   %eax
  1141aa:	ff 75 dc             	pushl  -0x24(%ebp)
  1141ad:	86 e9                	xchg   %ch,%cl
  1141af:	66 8b 45 da          	mov    -0x26(%ebp),%ax
  1141b3:	86 e0                	xchg   %ah,%al
  1141b5:	0f b7 c0             	movzwl %ax,%eax
  1141b8:	50                   	push   %eax
  1141b9:	53                   	push   %ebx
  1141ba:	ff 75 d4             	pushl  -0x2c(%ebp)
  1141bd:	0f b7 c9             	movzwl %cx,%ecx
  1141c0:	83 e9 04             	sub    $0x4,%ecx
  1141c3:	51                   	push   %ecx
  1141c4:	68 ae 67 12 00       	push   $0x1267ae
  1141c9:	6a 00                	push   $0x0
  1141cb:	ff 35 50 ec 12 00    	pushl  0x12ec50
  1141d1:	e8 49 1e ff ff       	call   10601f <shell_fprintf>
  1141d6:	83 c4 24             	add    $0x24,%esp
	z_impl_k_sem_give(sem);
  1141d9:	68 98 5d 14 00       	push   $0x145d98
  1141de:	e8 b6 d6 00 00       	call   121899 <z_impl_k_sem_give>
  1141e3:	59                   	pop    %ecx
	net_pkt_unref(pkt);
  1141e4:	ff 75 08             	pushl  0x8(%ebp)
  1141e7:	e8 90 b8 ff ff       	call   10fa7c <net_pkt_unref>
	return NET_OK;
  1141ec:	31 c0                	xor    %eax,%eax
	net_pkt_unref(pkt);
  1141ee:	5b                   	pop    %ebx
}
  1141ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1141f2:	5b                   	pop    %ebx
  1141f3:	5e                   	pop    %esi
  1141f4:	5f                   	pop    %edi
  1141f5:	5d                   	pop    %ebp
  1141f6:	c3                   	ret    

001141f7 <cmd_net_resume>:
  1141f7:	55                   	push   %ebp
  1141f8:	89 e5                	mov    %esp,%ebp
  1141fa:	68 f8 61 12 00       	push   $0x1261f8
  1141ff:	6a 03                	push   $0x3
  114201:	ff 75 08             	pushl  0x8(%ebp)
  114204:	e8 16 1e ff ff       	call   10601f <shell_fprintf>
  114209:	83 c4 0c             	add    $0xc,%esp
  11420c:	31 c0                	xor    %eax,%eax
  11420e:	c9                   	leave  
  11420f:	c3                   	ret    

00114210 <cmd_net_dns>:
  114210:	55                   	push   %ebp
  114211:	89 e5                	mov    %esp,%ebp
  114213:	68 8d 63 12 00       	push   $0x12638d
  114218:	6a 03                	push   $0x3
  11421a:	ff 75 08             	pushl  0x8(%ebp)
  11421d:	e8 fd 1d ff ff       	call   10601f <shell_fprintf>
  114222:	83 c4 0c             	add    $0xc,%esp
  114225:	31 c0                	xor    %eax,%eax
  114227:	c9                   	leave  
  114228:	c3                   	ret    

00114229 <cmd_net_events_off>:
  114229:	55                   	push   %ebp
  11422a:	89 e5                	mov    %esp,%ebp
  11422c:	68 2f 63 12 00       	push   $0x12632f
  114231:	6a 03                	push   $0x3
  114233:	ff 75 08             	pushl  0x8(%ebp)
  114236:	e8 e4 1d ff ff       	call   10601f <shell_fprintf>
  11423b:	83 c4 0c             	add    $0xc,%esp
  11423e:	31 c0                	xor    %eax,%eax
  114240:	c9                   	leave  
  114241:	c3                   	ret    

00114242 <cmd_net_events>:
  114242:	55                   	push   %ebp
  114243:	89 e5                	mov    %esp,%ebp
  114245:	68 2f 63 12 00       	push   $0x12632f
  11424a:	6a 03                	push   $0x3
  11424c:	ff 75 08             	pushl  0x8(%ebp)
  11424f:	e8 cb 1d ff ff       	call   10601f <shell_fprintf>
  114254:	83 c4 0c             	add    $0xc,%esp
  114257:	31 c0                	xor    %eax,%eax
  114259:	c9                   	leave  
  11425a:	c3                   	ret    

0011425b <cmd_net_nbr>:
  11425b:	55                   	push   %ebp
  11425c:	89 e5                	mov    %esp,%ebp
  11425e:	68 d7 62 12 00       	push   $0x1262d7
  114263:	6a 03                	push   $0x3
  114265:	ff 75 08             	pushl  0x8(%ebp)
  114268:	e8 b2 1d ff ff       	call   10601f <shell_fprintf>
  11426d:	83 c4 0c             	add    $0xc,%esp
  114270:	31 c0                	xor    %eax,%eax
  114272:	c9                   	leave  
  114273:	c3                   	ret    

00114274 <cmd_net_pkt>:
{
  114274:	55                   	push   %ebp
  114275:	89 e5                	mov    %esp,%ebp
  114277:	57                   	push   %edi
  114278:	56                   	push   %esi
  114279:	53                   	push   %ebx
  11427a:	83 ec 08             	sub    $0x8,%esp
	if (argv[1]) {
  11427d:	8b 45 10             	mov    0x10(%ebp),%eax
{
  114280:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (argv[1]) {
  114283:	8b 70 04             	mov    0x4(%eax),%esi
  114286:	85 f6                	test   %esi,%esi
  114288:	0f 84 3f 01 00 00    	je     1143cd <cmd_net_pkt+0x159>
	if (ptr_str[0] == '0' && ptr_str[1] == 'x') {
  11428e:	80 3e 30             	cmpb   $0x30,(%esi)
  114291:	75 09                	jne    11429c <cmd_net_pkt+0x28>
  114293:	80 7e 01 78          	cmpb   $0x78,0x1(%esi)
  114297:	75 03                	jne    11429c <cmd_net_pkt+0x28>
		ptr_str += 2;
  114299:	83 c6 02             	add    $0x2,%esi
	len = hex2bin(ptr_str, strlen(ptr_str), buf, sizeof(buf));
  11429c:	56                   	push   %esi
  11429d:	e8 7a 7a ff ff       	call   10bd1c <strlen>
  1142a2:	8d 7d f0             	lea    -0x10(%ebp),%edi
  1142a5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1142ac:	57                   	push   %edi
  1142ad:	50                   	push   %eax
  1142ae:	56                   	push   %esi
  1142af:	e8 46 cb fe ff       	call   100dfa <hex2bin>
  1142b4:	83 c4 10             	add    $0x10,%esp
	if (!len) {
  1142b7:	85 c0                	test   %eax,%eax
  1142b9:	74 1d                	je     1142d8 <cmd_net_pkt+0x64>
	for (i = len - 1; i >= 0; i--) {
  1142bb:	48                   	dec    %eax
  1142bc:	31 c9                	xor    %ecx,%ecx
	intptr_t ptr = 0;
  1142be:	31 f6                	xor    %esi,%esi
		ptr |= buf[i] << 8 * (len - 1 - i);
  1142c0:	89 fa                	mov    %edi,%edx
	for (i = len - 1; i >= 0; i--) {
  1142c2:	85 c0                	test   %eax,%eax
  1142c4:	78 0e                	js     1142d4 <cmd_net_pkt+0x60>
		ptr |= buf[i] << 8 * (len - 1 - i);
  1142c6:	0f b6 3c 10          	movzbl (%eax,%edx,1),%edi
  1142ca:	d3 e7                	shl    %cl,%edi
  1142cc:	09 fe                	or     %edi,%esi
	for (i = len - 1; i >= 0; i--) {
  1142ce:	48                   	dec    %eax
  1142cf:	83 c1 08             	add    $0x8,%ecx
  1142d2:	eb ee                	jmp    1142c2 <cmd_net_pkt+0x4e>
		if (!pkt) {
  1142d4:	85 f6                	test   %esi,%esi
  1142d6:	75 1b                	jne    1142f3 <cmd_net_pkt+0x7f>
			PR_ERROR("Invalid ptr value (%s). "
  1142d8:	8b 45 10             	mov    0x10(%ebp),%eax
  1142db:	ff 70 04             	pushl  0x4(%eax)
  1142de:	68 e5 67 12 00       	push   $0x1267e5
  1142e3:	6a 02                	push   $0x2
  1142e5:	53                   	push   %ebx
  1142e6:	e8 34 1d ff ff       	call   10601f <shell_fprintf>
  1142eb:	83 c4 10             	add    $0x10,%esp
			return -ENOEXEC;
  1142ee:	e9 ea 00 00 00       	jmp    1143dd <cmd_net_pkt+0x169>
	struct net_buf *buf = pkt->buffer;
  1142f3:	8b 7e 10             	mov    0x10(%esi),%edi
	PR("net_pkt %p buffer chain:\n", pkt);
  1142f6:	56                   	push   %esi
  1142f7:	68 12 68 12 00       	push   $0x126812
  1142fc:	6a 00                	push   $0x0
  1142fe:	53                   	push   %ebx
  1142ff:	e8 1b 1d ff ff       	call   10601f <shell_fprintf>
	PR("%p[%d]", pkt, atomic_get(&pkt->atomic_ref));
  114304:	8d 46 24             	lea    0x24(%esi),%eax
	PR("net_pkt %p buffer chain:\n", pkt);
  114307:	83 c4 10             	add    $0x10,%esp
	PR("%p[%d]", pkt, atomic_get(&pkt->atomic_ref));
  11430a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  11430d:	8b 46 24             	mov    0x24(%esi),%eax
  114310:	50                   	push   %eax
  114311:	56                   	push   %esi
  114312:	68 2c 68 12 00       	push   $0x12682c
  114317:	6a 00                	push   $0x0
  114319:	53                   	push   %ebx
  11431a:	e8 00 1d ff ff       	call   10601f <shell_fprintf>
  11431f:	83 c4 14             	add    $0x14,%esp
		if (buf) {
  114322:	85 ff                	test   %edi,%edi
  114324:	75 29                	jne    11434f <cmd_net_pkt+0xdb>
	PR("\n");
  114326:	68 01 4e 12 00       	push   $0x124e01
  11432b:	6a 00                	push   $0x0
  11432d:	53                   	push   %ebx
  11432e:	e8 ec 1c ff ff       	call   10601f <shell_fprintf>
  114333:	83 c4 0c             	add    $0xc,%esp
		PR("\n");
  114336:	68 01 4e 12 00       	push   $0x124e01
  11433b:	6a 00                	push   $0x0
  11433d:	53                   	push   %ebx
  11433e:	e8 dc 1c ff ff       	call   10601f <shell_fprintf>
	struct net_buf *buf = pkt->buffer;
  114343:	8b 7e 10             	mov    0x10(%esi),%edi
		PR("\n");
  114346:	83 c4 0c             	add    $0xc,%esp
	if (!buf || buf->ref == 0) {
  114349:	85 ff                	test   %edi,%edi
  11434b:	75 37                	jne    114384 <cmd_net_pkt+0x110>
  11434d:	eb 7a                	jmp    1143c9 <cmd_net_pkt+0x155>
		PR("->");
  11434f:	68 33 68 12 00       	push   $0x126833
  114354:	6a 00                	push   $0x0
  114356:	53                   	push   %ebx
  114357:	e8 c3 1c ff ff       	call   10601f <shell_fprintf>
		PR("%p[%d/%u (%u)]",
  11435c:	0f b7 4f 0e          	movzwl 0xe(%edi),%ecx
  114360:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
		PR("->");
  114364:	83 c4 0c             	add    $0xc,%esp
  114367:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11436a:	8b 00                	mov    (%eax),%eax
		PR("%p[%d/%u (%u)]",
  11436c:	51                   	push   %ecx
  11436d:	52                   	push   %edx
  11436e:	50                   	push   %eax
  11436f:	57                   	push   %edi
  114370:	68 36 68 12 00       	push   $0x126836
  114375:	6a 00                	push   $0x0
  114377:	53                   	push   %ebx
  114378:	e8 a2 1c ff ff       	call   10601f <shell_fprintf>
  11437d:	83 c4 1c             	add    $0x1c,%esp
		buf = buf->frags;
  114380:	8b 3f                	mov    (%edi),%edi
  114382:	eb 9e                	jmp    114322 <cmd_net_pkt+0xae>
	if (!buf || buf->ref == 0) {
  114384:	80 7f 04 00          	cmpb   $0x0,0x4(%edi)
  114388:	74 3f                	je     1143c9 <cmd_net_pkt+0x155>
	PR("net_pkt %p buffer chain hexdump:\n", pkt);
  11438a:	56                   	push   %esi
	int i = 0;
  11438b:	31 f6                	xor    %esi,%esi
	PR("net_pkt %p buffer chain hexdump:\n", pkt);
  11438d:	68 45 68 12 00       	push   $0x126845
  114392:	6a 00                	push   $0x0
  114394:	53                   	push   %ebx
  114395:	e8 85 1c ff ff       	call   10601f <shell_fprintf>
  11439a:	83 c4 10             	add    $0x10,%esp
		PR("net_buf[%d] %p\n", i++, buf);
  11439d:	57                   	push   %edi
  11439e:	89 f0                	mov    %esi,%eax
  1143a0:	50                   	push   %eax
  1143a1:	46                   	inc    %esi
  1143a2:	68 67 68 12 00       	push   $0x126867
  1143a7:	6a 00                	push   $0x0
  1143a9:	53                   	push   %ebx
  1143aa:	e8 70 1c ff ff       	call   10601f <shell_fprintf>
  1143af:	83 c4 14             	add    $0x14,%esp
		shell_hexdump(shell, buf->data, buf->len);
  1143b2:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  1143b6:	50                   	push   %eax
  1143b7:	ff 77 08             	pushl  0x8(%edi)
  1143ba:	53                   	push   %ebx
  1143bb:	e8 75 1d ff ff       	call   106135 <shell_hexdump>
		buf = buf->frags;
  1143c0:	8b 3f                	mov    (%edi),%edi
		shell_hexdump(shell, buf->data, buf->len);
  1143c2:	83 c4 0c             	add    $0xc,%esp
	while (buf) {
  1143c5:	85 ff                	test   %edi,%edi
  1143c7:	75 d4                	jne    11439d <cmd_net_pkt+0x129>
	return 0;
  1143c9:	31 c0                	xor    %eax,%eax
  1143cb:	eb 15                	jmp    1143e2 <cmd_net_pkt+0x16e>
		PR_INFO("Pointer value must be given.\n");
  1143cd:	68 77 68 12 00       	push   $0x126877
  1143d2:	6a 03                	push   $0x3
  1143d4:	53                   	push   %ebx
  1143d5:	e8 45 1c ff ff       	call   10601f <shell_fprintf>
  1143da:	83 c4 0c             	add    $0xc,%esp
		return -ENOEXEC;
  1143dd:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
}
  1143e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1143e5:	5b                   	pop    %ebx
  1143e6:	5e                   	pop    %esi
  1143e7:	5f                   	pop    %edi
  1143e8:	5d                   	pop    %ebp
  1143e9:	c3                   	ret    

001143ea <iface_cb>:
{
  1143ea:	55                   	push   %ebp
  1143eb:	89 e5                	mov    %esp,%ebp
  1143ed:	57                   	push   %edi
  1143ee:	56                   	push   %esi
  1143ef:	53                   	push   %ebx
  1143f0:	83 ec 0c             	sub    $0xc,%esp
  1143f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1143f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (data->user_data && data->user_data != iface) {
  1143f9:	8b 50 04             	mov    0x4(%eax),%edx
  1143fc:	39 da                	cmp    %ebx,%edx
  1143fe:	74 08                	je     114408 <iface_cb+0x1e>
  114400:	85 d2                	test   %edx,%edx
  114402:	0f 85 94 02 00 00    	jne    11469c <iface_cb+0x2b2>
	const struct shell *shell = data->shell;
  114408:	8b 30                	mov    (%eax),%esi
	PR("\nInterface %p (%s) [%d]\n", iface, iface2str(iface, &extra),
  11440a:	53                   	push   %ebx
  11440b:	e8 e6 97 ff ff       	call   10dbf6 <net_if_get_by_iface>
  114410:	5a                   	pop    %edx
	if (!iface || !iface->if_dev) {
  114411:	85 db                	test   %ebx,%ebx
  114413:	74 1b                	je     114430 <iface_cb+0x46>
  114415:	8b 13                	mov    (%ebx),%edx
  114417:	85 d2                	test   %edx,%edx
  114419:	74 15                	je     114430 <iface_cb+0x46>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
  11441b:	81 7a 04 64 5e 14 00 	cmpl   $0x145e64,0x4(%edx)
  114422:	75 0c                	jne    114430 <iface_cb+0x46>
			*extra = "========";
  114424:	bf 9b 68 12 00       	mov    $0x12689b,%edi
		return "Ethernet";
  114429:	ba b3 68 12 00       	mov    $0x1268b3,%edx
  11442e:	eb 0a                	jmp    11443a <iface_cb+0x50>
		*extra = "==============";
  114430:	bf 95 68 12 00       	mov    $0x126895,%edi
	return "<unknown type>";
  114435:	ba a4 68 12 00       	mov    $0x1268a4,%edx
	PR("\nInterface %p (%s) [%d]\n", iface, iface2str(iface, &extra),
  11443a:	50                   	push   %eax
  11443b:	52                   	push   %edx
  11443c:	53                   	push   %ebx
  11443d:	68 e5 68 12 00       	push   $0x1268e5
  114442:	6a 00                	push   $0x0
  114444:	56                   	push   %esi
  114445:	e8 d5 1b ff ff       	call   10601f <shell_fprintf>
  11444a:	83 c4 18             	add    $0x18,%esp
	PR("===========================%s\n", extra);
  11444d:	57                   	push   %edi
  11444e:	68 fe 68 12 00       	push   $0x1268fe
  114453:	6a 00                	push   $0x0
  114455:	56                   	push   %esi
  114456:	e8 c4 1b ff ff       	call   10601f <shell_fprintf>
  11445b:	8b 03                	mov    (%ebx),%eax
  11445d:	83 c4 10             	add    $0x10,%esp
  114460:	8b 40 0c             	mov    0xc(%eax),%eax
	if (!net_if_is_up(iface)) {
  114463:	a8 01                	test   $0x1,%al
  114465:	75 15                	jne    11447c <iface_cb+0x92>
		PR_INFO("Interface is down.\n");
  114467:	68 1d 69 12 00       	push   $0x12691d
  11446c:	6a 03                	push   $0x3
  11446e:	56                   	push   %esi
  11446f:	e8 ab 1b ff ff       	call   10601f <shell_fprintf>
  114474:	83 c4 0c             	add    $0xc,%esp
		return;
  114477:	e9 20 02 00 00       	jmp    11469c <iface_cb+0x2b2>
	if (net_if_get_link_addr(iface) &&
  11447c:	8b 03                	mov    (%ebx),%eax
  11447e:	83 f8 f0             	cmp    $0xfffffff0,%eax
  114481:	74 2d                	je     1144b0 <iface_cb+0xc6>
	    net_if_get_link_addr(iface)->addr) {
  114483:	8b 50 10             	mov    0x10(%eax),%edx
	if (net_if_get_link_addr(iface) &&
  114486:	85 d2                	test   %edx,%edx
  114488:	74 26                	je     1144b0 <iface_cb+0xc6>

static inline char *net_sprint_ll_addr(const uint8_t *ll, uint8_t ll_len)
{
	static char buf[sizeof("xx:xx:xx:xx:xx:xx:xx:xx")];

	return net_sprint_ll_addr_buf(ll, ll_len, (char *)buf, sizeof(buf));
  11448a:	6a 18                	push   $0x18
  11448c:	68 10 ec 12 00       	push   $0x12ec10
		PR("Link addr : %s\n",
  114491:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  114495:	50                   	push   %eax
  114496:	52                   	push   %edx
  114497:	e8 42 9a ff ff       	call   10dede <net_sprint_ll_addr_buf>
  11449c:	83 c4 10             	add    $0x10,%esp
  11449f:	50                   	push   %eax
  1144a0:	68 31 69 12 00       	push   $0x126931
  1144a5:	6a 00                	push   $0x0
  1144a7:	56                   	push   %esi
  1144a8:	e8 72 1b ff ff       	call   10601f <shell_fprintf>
  1144ad:	83 c4 10             	add    $0x10,%esp
	return iface->if_dev->mtu;
  1144b0:	8b 03                	mov    (%ebx),%eax
	PR("MTU       : %d\n", net_if_get_mtu(iface));
  1144b2:	0f b7 40 18          	movzwl 0x18(%eax),%eax
  1144b6:	50                   	push   %eax
  1144b7:	68 41 69 12 00       	push   $0x126941
  1144bc:	6a 00                	push   $0x0
  1144be:	56                   	push   %esi
  1144bf:	e8 5b 1b ff ff       	call   10601f <shell_fprintf>
	if (!iface || !iface->if_dev) {
  1144c4:	8b 03                	mov    (%ebx),%eax
  1144c6:	83 c4 10             	add    $0x10,%esp
  1144c9:	85 c0                	test   %eax,%eax
  1144cb:	74 5b                	je     114528 <iface_cb+0x13e>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
  1144cd:	81 78 04 64 5e 14 00 	cmpl   $0x145e64,0x4(%eax)
  1144d4:	75 52                	jne    114528 <iface_cb+0x13e>
		PR("Ethernet capabilities supported:\n");
  1144d6:	68 51 69 12 00       	push   $0x126951
  1144db:	6a 00                	push   $0x0
  1144dd:	56                   	push   %esi
  1144de:	e8 3c 1b ff ff       	call   10601f <shell_fprintf>
	return iface->if_dev->dev;
  1144e3:	8b 03                	mov    (%ebx),%eax
  1144e5:	83 c4 0c             	add    $0xc,%esp
  1144e8:	8b 08                	mov    (%eax),%ecx
	if (!eth->get_capabilities) {
  1144ea:	8b 41 08             	mov    0x8(%ecx),%eax
  1144ed:	8b 50 0c             	mov    0xc(%eax),%edx
		return (enum ethernet_hw_caps)0;
  1144f0:	31 c0                	xor    %eax,%eax
	if (!eth->get_capabilities) {
  1144f2:	85 d2                	test   %edx,%edx
  1144f4:	74 04                	je     1144fa <iface_cb+0x110>
	return eth->get_capabilities(net_if_get_device(iface));
  1144f6:	51                   	push   %ecx
  1144f7:	ff d2                	call   *%edx
  1144f9:	5f                   	pop    %edi
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
  1144fa:	31 ff                	xor    %edi,%edi
		if (caps & eth_hw_caps[i].capability) {
  1144fc:	85 04 fd e0 3b 12 00 	test   %eax,0x123be0(,%edi,8)
  114503:	74 1d                	je     114522 <iface_cb+0x138>
			PR("\t%s\n", eth_hw_caps[i].description);
  114505:	ff 34 fd e4 3b 12 00 	pushl  0x123be4(,%edi,8)
  11450c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11450f:	68 73 69 12 00       	push   $0x126973
  114514:	6a 00                	push   $0x0
  114516:	56                   	push   %esi
  114517:	e8 03 1b ff ff       	call   10601f <shell_fprintf>
  11451c:	83 c4 10             	add    $0x10,%esp
  11451f:	8b 45 f0             	mov    -0x10(%ebp),%eax
	for (i = 0; i < ARRAY_SIZE(eth_hw_caps); i++) {
  114522:	47                   	inc    %edi
  114523:	83 ff 0e             	cmp    $0xe,%edi
  114526:	75 d4                	jne    1144fc <iface_cb+0x112>
	ipv4 = iface->config.ip.ipv4;
  114528:	8b 7b 04             	mov    0x4(%ebx),%edi
	PR("IPv4 unicast addresses (max %d):\n", NET_IF_MAX_IPV4_ADDR);
  11452b:	6a 01                	push   $0x1
  11452d:	68 78 69 12 00       	push   $0x126978
  114532:	6a 00                	push   $0x0
  114534:	56                   	push   %esi
  114535:	e8 e5 1a ff ff       	call   10601f <shell_fprintf>
  11453a:	83 c4 10             	add    $0x10,%esp
	count = 0;
  11453d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_ADDR; i++) {
  114544:	31 c0                	xor    %eax,%eax
  114546:	85 ff                	test   %edi,%edi
  114548:	0f 95 c3             	setne  %bl
  11454b:	85 c0                	test   %eax,%eax
  11454d:	0f 85 89 00 00 00    	jne    1145dc <iface_cb+0x1f2>
  114553:	84 db                	test   %bl,%bl
  114555:	0f 84 81 00 00 00    	je     1145dc <iface_cb+0x1f2>
		if (!unicast->is_used) {
  11455b:	8a 57 16             	mov    0x16(%edi),%dl
  11455e:	b8 01 00 00 00       	mov    $0x1,%eax
  114563:	f6 c2 02             	test   $0x2,%dl
  114566:	74 de                	je     114546 <iface_cb+0x15c>
		PR("\t%s %s %s%s\n",
  114568:	b9 bc 68 12 00       	mov    $0x1268bc,%ecx
  11456d:	80 e2 01             	and    $0x1,%dl
  114570:	75 05                	jne    114577 <iface_cb+0x18d>
  114572:	b9 02 4e 12 00       	mov    $0x124e02,%ecx
	switch (addr_state) {
  114577:	8a 47 15             	mov    0x15(%edi),%al
  11457a:	ba c6 68 12 00       	mov    $0x1268c6,%edx
  11457f:	40                   	inc    %eax
  114580:	3c 03                	cmp    $0x3,%al
  114582:	77 0a                	ja     11458e <iface_cb+0x1a4>
  114584:	0f b6 c0             	movzbl %al,%eax
  114587:	8b 14 85 b0 43 12 00 	mov    0x1243b0(,%eax,4),%edx
		PR("\t%s %s %s%s\n",
  11458e:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  114592:	bb d6 68 12 00       	mov    $0x1268d6,%ebx
  114597:	3c 04                	cmp    $0x4,%al
  114599:	77 07                	ja     1145a2 <iface_cb+0x1b8>
  11459b:	8b 1c 85 c0 43 12 00 	mov    0x1243c0(,%eax,4),%ebx
  1145a2:	8d 47 04             	lea    0x4(%edi),%eax
  1145a5:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1145a8:	50                   	push   %eax
  1145a9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1145ac:	6a 01                	push   $0x1
  1145ae:	e8 f1 9b ff ff       	call   10e1a4 <net_sprint_addr>
  1145b3:	5a                   	pop    %edx
  1145b4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1145b7:	59                   	pop    %ecx
  1145b8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1145bb:	51                   	push   %ecx
  1145bc:	52                   	push   %edx
  1145bd:	53                   	push   %ebx
  1145be:	50                   	push   %eax
  1145bf:	68 9a 69 12 00       	push   $0x12699a
  1145c4:	6a 00                	push   $0x0
  1145c6:	56                   	push   %esi
  1145c7:	e8 53 1a ff ff       	call   10601f <shell_fprintf>
		count++;
  1145cc:	ff 45 f0             	incl   -0x10(%ebp)
		PR("\t%s %s %s%s\n",
  1145cf:	83 c4 1c             	add    $0x1c,%esp
		count++;
  1145d2:	b8 01 00 00 00       	mov    $0x1,%eax
  1145d7:	e9 6a ff ff ff       	jmp    114546 <iface_cb+0x15c>
	if (count == 0) {
  1145dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1145e0:	75 10                	jne    1145f2 <iface_cb+0x208>
		PR("\t<none>\n");
  1145e2:	68 a7 69 12 00       	push   $0x1269a7
  1145e7:	6a 00                	push   $0x0
  1145e9:	56                   	push   %esi
  1145ea:	e8 30 1a ff ff       	call   10601f <shell_fprintf>
  1145ef:	83 c4 0c             	add    $0xc,%esp
	PR("IPv4 multicast addresses (max %d):\n", NET_IF_MAX_IPV4_MADDR);
  1145f2:	6a 01                	push   $0x1
  1145f4:	68 b0 69 12 00       	push   $0x1269b0
  1145f9:	6a 00                	push   $0x0
  1145fb:	56                   	push   %esi
  1145fc:	e8 1e 1a ff ff       	call   10601f <shell_fprintf>
  114601:	83 c4 10             	add    $0x10,%esp
	count = 0;
  114604:	31 d2                	xor    %edx,%edx
	for (i = 0; ipv4 && i < NET_IF_MAX_IPV4_MADDR; i++) {
  114606:	31 c9                	xor    %ecx,%ecx
  114608:	85 c9                	test   %ecx,%ecx
  11460a:	75 3c                	jne    114648 <iface_cb+0x25e>
  11460c:	84 db                	test   %bl,%bl
  11460e:	74 38                	je     114648 <iface_cb+0x25e>
		if (!mcast->is_used) {
  114610:	f6 47 2c 01          	testb  $0x1,0x2c(%edi)
  114614:	b9 01 00 00 00       	mov    $0x1,%ecx
  114619:	74 ed                	je     114608 <iface_cb+0x21e>
		PR("\t%s\n", net_sprint_ipv4_addr(&mcast->address.in_addr));
  11461b:	8d 47 1c             	lea    0x1c(%edi),%eax
  11461e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  114621:	50                   	push   %eax
  114622:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  114625:	6a 01                	push   $0x1
  114627:	e8 78 9b ff ff       	call   10e1a4 <net_sprint_addr>
  11462c:	5a                   	pop    %edx
  11462d:	59                   	pop    %ecx
  11462e:	50                   	push   %eax
  11462f:	68 73 69 12 00       	push   $0x126973
  114634:	6a 00                	push   $0x0
  114636:	56                   	push   %esi
  114637:	e8 e3 19 ff ff       	call   10601f <shell_fprintf>
		count++;
  11463c:	8b 55 ec             	mov    -0x14(%ebp),%edx
		PR("\t%s\n", net_sprint_ipv4_addr(&mcast->address.in_addr));
  11463f:	83 c4 10             	add    $0x10,%esp
		count++;
  114642:	42                   	inc    %edx
  114643:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  114646:	eb c0                	jmp    114608 <iface_cb+0x21e>
	if (count == 0) {
  114648:	85 d2                	test   %edx,%edx
  11464a:	75 10                	jne    11465c <iface_cb+0x272>
		PR("\t<none>\n");
  11464c:	68 a7 69 12 00       	push   $0x1269a7
  114651:	6a 00                	push   $0x0
  114653:	56                   	push   %esi
  114654:	e8 c6 19 ff ff       	call   10601f <shell_fprintf>
  114659:	83 c4 0c             	add    $0xc,%esp
	if (ipv4) {
  11465c:	85 ff                	test   %edi,%edi
  11465e:	74 3c                	je     11469c <iface_cb+0x2b2>
		PR("IPv4 gateway : %s\n",
  114660:	8d 47 30             	lea    0x30(%edi),%eax
		PR("IPv4 netmask : %s\n",
  114663:	83 c7 34             	add    $0x34,%edi
		PR("IPv4 gateway : %s\n",
  114666:	50                   	push   %eax
  114667:	6a 01                	push   $0x1
  114669:	e8 36 9b ff ff       	call   10e1a4 <net_sprint_addr>
  11466e:	5a                   	pop    %edx
  11466f:	59                   	pop    %ecx
  114670:	50                   	push   %eax
  114671:	68 d4 69 12 00       	push   $0x1269d4
  114676:	6a 00                	push   $0x0
  114678:	56                   	push   %esi
  114679:	e8 a1 19 ff ff       	call   10601f <shell_fprintf>
  11467e:	83 c4 10             	add    $0x10,%esp
		PR("IPv4 netmask : %s\n",
  114681:	57                   	push   %edi
  114682:	6a 01                	push   $0x1
  114684:	e8 1b 9b ff ff       	call   10e1a4 <net_sprint_addr>
  114689:	5b                   	pop    %ebx
  11468a:	5f                   	pop    %edi
  11468b:	50                   	push   %eax
  11468c:	68 e7 69 12 00       	push   $0x1269e7
  114691:	6a 00                	push   $0x0
  114693:	56                   	push   %esi
  114694:	e8 86 19 ff ff       	call   10601f <shell_fprintf>
  114699:	83 c4 10             	add    $0x10,%esp
}
  11469c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11469f:	5b                   	pop    %ebx
  1146a0:	5e                   	pop    %esi
  1146a1:	5f                   	pop    %edi
  1146a2:	5d                   	pop    %ebp
  1146a3:	c3                   	ret    

001146a4 <arp_cb>:
{
  1146a4:	55                   	push   %ebp
  1146a5:	89 e5                	mov    %esp,%ebp
  1146a7:	57                   	push   %edi
  1146a8:	56                   	push   %esi
  1146a9:	53                   	push   %ebx
  1146aa:	53                   	push   %ebx
  1146ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  1146ae:	8b 75 08             	mov    0x8(%ebp),%esi
	int *count = data->user_data;
  1146b1:	8b 58 04             	mov    0x4(%eax),%ebx
	const struct shell *shell = data->shell;
  1146b4:	8b 38                	mov    (%eax),%edi
	if (*count == 0) {
  1146b6:	83 3b 00             	cmpl   $0x0,(%ebx)
  1146b9:	75 10                	jne    1146cb <arp_cb+0x27>
		PR("     Interface  Link              Address\n");
  1146bb:	68 fa 69 12 00       	push   $0x1269fa
  1146c0:	6a 00                	push   $0x0
  1146c2:	57                   	push   %edi
  1146c3:	e8 57 19 ff ff       	call   10601f <shell_fprintf>
  1146c8:	83 c4 0c             	add    $0xc,%esp
	PR("[%2d] %p %s %s\n", *count, entry->iface,
  1146cb:	8d 46 0c             	lea    0xc(%esi),%eax
  1146ce:	50                   	push   %eax
  1146cf:	6a 01                	push   $0x1
  1146d1:	e8 ce 9a ff ff       	call   10e1a4 <net_sprint_addr>
  1146d6:	5a                   	pop    %edx
  1146d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1146da:	59                   	pop    %ecx
  1146db:	8d 46 10             	lea    0x10(%esi),%eax
  1146de:	6a 18                	push   $0x18
  1146e0:	68 10 ec 12 00       	push   $0x12ec10
  1146e5:	6a 06                	push   $0x6
  1146e7:	50                   	push   %eax
  1146e8:	e8 f1 97 ff ff       	call   10dede <net_sprint_ll_addr_buf>
  1146ed:	83 c4 10             	add    $0x10,%esp
  1146f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1146f3:	52                   	push   %edx
  1146f4:	50                   	push   %eax
  1146f5:	ff 76 08             	pushl  0x8(%esi)
  1146f8:	ff 33                	pushl  (%ebx)
  1146fa:	68 25 6a 12 00       	push   $0x126a25
  1146ff:	6a 00                	push   $0x0
  114701:	57                   	push   %edi
  114702:	e8 18 19 ff ff       	call   10601f <shell_fprintf>
	(*count)++;
  114707:	ff 03                	incl   (%ebx)
	PR("[%2d] %p %s %s\n", *count, entry->iface,
  114709:	83 c4 1c             	add    $0x1c,%esp
}
  11470c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11470f:	5b                   	pop    %ebx
  114710:	5e                   	pop    %esi
  114711:	5f                   	pop    %edi
  114712:	5d                   	pop    %ebp
  114713:	c3                   	ret    

00114714 <cmd_net_ping>:
{
  114714:	55                   	push   %ebp
  114715:	89 e5                	mov    %esp,%ebp
  114717:	57                   	push   %edi
  114718:	56                   	push   %esi
	char *host = NULL;
  114719:	31 ff                	xor    %edi,%edi
{
  11471b:	53                   	push   %ebx
	int interval = 1000;
  11471c:	bb e8 03 00 00       	mov    $0x3e8,%ebx
{
  114721:	83 ec 1c             	sub    $0x1c,%esp
	for (size_t i = 1; i < argc; ++i) {
  114724:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
{
  11472b:	8b 75 10             	mov    0x10(%ebp),%esi
	int iface_idx = -1;
  11472e:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
	int count = 3;
  114735:	c7 45 e4 03 00 00 00 	movl   $0x3,-0x1c(%ebp)
	for (size_t i = 1; i < argc; ++i) {
  11473c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11473f:	3b 45 0c             	cmp    0xc(%ebp),%eax
  114742:	0f 83 9a 00 00 00    	jae    1147e2 <cmd_net_ping+0xce>
		if (*argv[i] != '-') {
  114748:	8b 04 86             	mov    (%esi,%eax,4),%eax
  11474b:	80 38 2d             	cmpb   $0x2d,(%eax)
  11474e:	0f 85 84 00 00 00    	jne    1147d8 <cmd_net_ping+0xc4>
		switch (argv[i][1]) {
  114754:	8a 50 01             	mov    0x1(%eax),%dl
  114757:	80 fa 63             	cmp    $0x63,%dl
  11475a:	74 0c                	je     114768 <cmd_net_ping+0x54>
  11475c:	80 fa 69             	cmp    $0x69,%dl
  11475f:	74 1b                	je     11477c <cmd_net_ping+0x68>
  114761:	80 fa 49             	cmp    $0x49,%dl
  114764:	75 5a                	jne    1147c0 <cmd_net_ping+0xac>
  114766:	eb 29                	jmp    114791 <cmd_net_ping+0x7d>
			count = parse_arg(&i, argc, argv);
  114768:	89 f1                	mov    %esi,%ecx
  11476a:	8b 55 0c             	mov    0xc(%ebp),%edx
  11476d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  114770:	e8 0e f1 ff ff       	call   113883 <parse_arg>
  114775:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if (count < 0) {
  114778:	85 c0                	test   %eax,%eax
  11477a:	eb 11                	jmp    11478d <cmd_net_ping+0x79>
			interval = parse_arg(&i, argc, argv);
  11477c:	89 f1                	mov    %esi,%ecx
  11477e:	8b 55 0c             	mov    0xc(%ebp),%edx
  114781:	8d 45 f0             	lea    -0x10(%ebp),%eax
  114784:	e8 fa f0 ff ff       	call   113883 <parse_arg>
  114789:	89 c3                	mov    %eax,%ebx
			if (interval < 0) {
  11478b:	85 c0                	test   %eax,%eax
  11478d:	79 4b                	jns    1147da <cmd_net_ping+0xc6>
  11478f:	eb 14                	jmp    1147a5 <cmd_net_ping+0x91>
			iface_idx = parse_arg(&i, argc, argv);
  114791:	89 f1                	mov    %esi,%ecx
  114793:	8b 55 0c             	mov    0xc(%ebp),%edx
  114796:	8d 45 f0             	lea    -0x10(%ebp),%eax
  114799:	e8 e5 f0 ff ff       	call   113883 <parse_arg>
  11479e:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (iface_idx < 0 || !net_if_get_by_index(iface_idx)) {
  1147a1:	85 c0                	test   %eax,%eax
  1147a3:	79 0d                	jns    1147b2 <cmd_net_ping+0x9e>
				PR_WARNING("Parse error: %s\n", argv[i]);
  1147a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1147a8:	ff 34 86             	pushl  (%esi,%eax,4)
  1147ab:	68 35 6a 12 00       	push   $0x126a35
  1147b0:	eb 14                	jmp    1147c6 <cmd_net_ping+0xb2>
			if (iface_idx < 0 || !net_if_get_by_index(iface_idx)) {
  1147b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1147b5:	e8 1f f1 ff ff       	call   1138d9 <net_if_get_by_index>
  1147ba:	85 c0                	test   %eax,%eax
  1147bc:	75 1c                	jne    1147da <cmd_net_ping+0xc6>
  1147be:	eb e5                	jmp    1147a5 <cmd_net_ping+0x91>
			PR_WARNING("Unrecognized argument: %s\n", argv[i]);
  1147c0:	50                   	push   %eax
  1147c1:	68 46 6a 12 00       	push   $0x126a46
  1147c6:	6a 04                	push   $0x4
  1147c8:	ff 75 08             	pushl  0x8(%ebp)
  1147cb:	e8 4f 18 ff ff       	call   10601f <shell_fprintf>
  1147d0:	83 c4 10             	add    $0x10,%esp
			return -ENOEXEC;
  1147d3:	e9 8b 01 00 00       	jmp    114963 <cmd_net_ping+0x24f>
  1147d8:	89 c7                	mov    %eax,%edi
	for (size_t i = 1; i < argc; ++i) {
  1147da:	ff 45 f0             	incl   -0x10(%ebp)
  1147dd:	e9 5a ff ff ff       	jmp    11473c <cmd_net_ping+0x28>
	if (!host) {
  1147e2:	85 ff                	test   %edi,%edi
  1147e4:	75 0a                	jne    1147f0 <cmd_net_ping+0xdc>
		PR_WARNING("Target host missing\n");
  1147e6:	68 61 6a 12 00       	push   $0x126a61
  1147eb:	e9 27 01 00 00       	jmp    114917 <cmd_net_ping+0x203>
	shell_for_ping = shell;
  1147f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1147f3:	a3 50 ec 12 00       	mov    %eax,0x12ec50
	struct net_if *iface = net_if_get_by_index(iface_idx);
  1147f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1147fb:	e8 d9 f0 ff ff       	call   1138d9 <net_if_get_by_index>
  114800:	89 45 e8             	mov    %eax,-0x18(%ebp)
  114803:	8d 75 ec             	lea    -0x14(%ebp),%esi
  114806:	56                   	push   %esi
  114807:	57                   	push   %edi
  114808:	6a 01                	push   $0x1
  11480a:	e8 ce 99 ff ff       	call   10e1dd <z_impl_net_addr_pton>
  11480f:	83 c4 0c             	add    $0xc,%esp
	if (net_addr_pton(AF_INET, host, &ipv4_target) < 0) {
  114812:	85 c0                	test   %eax,%eax
  114814:	0f 88 f8 00 00 00    	js     114912 <cmd_net_ping+0x1fe>
	if (!iface) {
  11481a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  11481e:	75 0a                	jne    11482a <cmd_net_ping+0x116>
		iface = net_if_ipv4_select_src_iface(&ipv4_target);
  114820:	56                   	push   %esi
  114821:	e8 2e 8f ff ff       	call   10d754 <net_if_ipv4_select_src_iface>
  114826:	5e                   	pop    %esi
  114827:	89 45 e8             	mov    %eax,-0x18(%ebp)
	net_icmpv4_register_handler(&ping4_handler);
  11482a:	68 10 5b 14 00       	push   $0x145b10
  11482f:	e8 e9 c1 ff ff       	call   110a1d <net_icmpv4_register_handler>
	PR("PING %s\n", host);
  114834:	89 3c 24             	mov    %edi,(%esp)
  114837:	68 76 6a 12 00       	push   $0x126a76
  11483c:	6a 00                	push   $0x0
  11483e:	ff 75 08             	pushl  0x8(%ebp)
  114841:	e8 d9 17 ff ff       	call   10601f <shell_fprintf>
  114846:	83 c4 10             	add    $0x10,%esp
	return k_sleep(Z_TIMEOUT_MS(ms));
  114849:	89 d8                	mov    %ebx,%eax
			return t / (from_hz / to_hz);
  11484b:	6a 00                	push   $0x0
  11484d:	99                   	cltd   
		t += off;
  11484e:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  114851:	6a 0a                	push   $0xa
		t += off;
  114853:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  114856:	52                   	push   %edx
  114857:	50                   	push   %eax
  114858:	e8 c3 b9 fe ff       	call   100220 <__udivdi3>
  11485d:	83 c4 10             	add    $0x10,%esp
  114860:	89 45 d8             	mov    %eax,-0x28(%ebp)
  114863:	89 55 dc             	mov    %edx,-0x24(%ebp)
	for (int i = 0; i < count; ++i) {
  114866:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  11486d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  114870:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  114873:	74 76                	je     1148eb <cmd_net_ping+0x1d7>
  114875:	e8 88 63 ff ff       	call   10ac02 <z_timer_cycle_get_32>
  11487a:	89 c3                	mov    %eax,%ebx
  11487c:	e8 81 63 ff ff       	call   10ac02 <z_timer_cycle_get_32>
		uint32_t time_stamp = htonl(k_cycle_get_32());
  114881:	c1 eb 18             	shr    $0x18,%ebx
  114884:	89 c7                	mov    %eax,%edi
  114886:	c1 ef 08             	shr    $0x8,%edi
  114889:	e8 74 63 ff ff       	call   10ac02 <z_timer_cycle_get_32>
  11488e:	89 c6                	mov    %eax,%esi
  114890:	e8 6d 63 ff ff       	call   10ac02 <z_timer_cycle_get_32>
  114895:	c1 e0 18             	shl    $0x18,%eax
  114898:	81 e7 00 ff 00 00    	and    $0xff00,%edi
  11489e:	c1 e6 08             	shl    $0x8,%esi
  1148a1:	09 c3                	or     %eax,%ebx
  1148a3:	09 fb                	or     %edi,%ebx
  1148a5:	81 e6 00 00 ff 00    	and    $0xff0000,%esi
  1148ab:	09 f3                	or     %esi,%ebx
  1148ad:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  1148b0:	e8 9d b6 00 00       	call   11ff52 <z_impl_sys_rand32_get>
		ret = net_icmpv4_send_echo_request(iface,
  1148b5:	6a 04                	push   $0x4
  1148b7:	8d 55 f0             	lea    -0x10(%ebp),%edx
  1148ba:	52                   	push   %edx
  1148bb:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  1148bf:	0f b7 c0             	movzwl %ax,%eax
  1148c2:	52                   	push   %edx
  1148c3:	50                   	push   %eax
  1148c4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  1148c7:	50                   	push   %eax
  1148c8:	ff 75 e8             	pushl  -0x18(%ebp)
  1148cb:	e8 f7 be ff ff       	call   1107c7 <net_icmpv4_send_echo_request>
  1148d0:	83 c4 18             	add    $0x18,%esp
  1148d3:	89 c3                	mov    %eax,%ebx
		if (ret) {
  1148d5:	85 c0                	test   %eax,%eax
  1148d7:	75 14                	jne    1148ed <cmd_net_ping+0x1d9>
	return z_impl_k_sleep(timeout);
  1148d9:	ff 75 dc             	pushl  -0x24(%ebp)
  1148dc:	ff 75 d8             	pushl  -0x28(%ebp)
  1148df:	e8 2f cf 00 00       	call   121813 <z_impl_k_sleep>
	for (int i = 0; i < count; ++i) {
  1148e4:	ff 45 e0             	incl   -0x20(%ebp)
  1148e7:	59                   	pop    %ecx
  1148e8:	5b                   	pop    %ebx
  1148e9:	eb 82                	jmp    11486d <cmd_net_ping+0x159>
  1148eb:	31 db                	xor    %ebx,%ebx
	net_icmpv4_unregister_handler(&ping4_handler);
  1148ed:	68 10 5b 14 00       	push   $0x145b10
  1148f2:	e8 49 c1 ff ff       	call   110a40 <net_icmpv4_unregister_handler>
  1148f7:	5a                   	pop    %edx
		if (ret) {
  1148f8:	85 db                	test   %ebx,%ebx
  1148fa:	74 2a                	je     114926 <cmd_net_ping+0x212>
			if (ret == -EIO || ret == -ENETUNREACH) {
  1148fc:	83 fb fb             	cmp    $0xfffffffb,%ebx
  1148ff:	74 05                	je     114906 <cmd_net_ping+0x1f2>
  114901:	83 fb cd             	cmp    $0xffffffcd,%ebx
  114904:	75 07                	jne    11490d <cmd_net_ping+0x1f9>
				PR_WARNING("Cannot send IPv4 ping\n");
  114906:	68 7f 6a 12 00       	push   $0x126a7f
  11490b:	eb 0a                	jmp    114917 <cmd_net_ping+0x203>
			} else if (ret == -EINVAL) {
  11490d:	83 fb ea             	cmp    $0xffffffea,%ebx
  114910:	75 51                	jne    114963 <cmd_net_ping+0x24f>
				PR_WARNING("Invalid IP address\n");
  114912:	68 96 6a 12 00       	push   $0x126a96
  114917:	6a 04                	push   $0x4
  114919:	ff 75 08             	pushl  0x8(%ebp)
  11491c:	e8 fe 16 ff ff       	call   10601f <shell_fprintf>
  114921:	83 c4 0c             	add    $0xc,%esp
  114924:	eb 3d                	jmp    114963 <cmd_net_ping+0x24f>
	return z_impl_k_sem_take(sem, timeout);
  114926:	6a 00                	push   $0x0
  114928:	68 c8 00 00 00       	push   $0xc8
  11492d:	68 98 5d 14 00       	push   $0x145d98
  114932:	e8 bb cf 00 00       	call   1218f2 <z_impl_k_sem_take>
  114937:	83 c4 0c             	add    $0xc,%esp
	if (ret == -EAGAIN) {
  11493a:	83 f8 f5             	cmp    $0xfffffff5,%eax
  11493d:	75 29                	jne    114968 <cmd_net_ping+0x254>
		PR_INFO("Ping timeout\n");
  11493f:	68 aa 6a 12 00       	push   $0x126aaa
		return -ETIMEDOUT;
  114944:	bb c4 ff ff ff       	mov    $0xffffffc4,%ebx
		PR_INFO("Ping timeout\n");
  114949:	6a 03                	push   $0x3
  11494b:	ff 75 08             	pushl  0x8(%ebp)
  11494e:	e8 cc 16 ff ff       	call   10601f <shell_fprintf>
  114953:	83 c4 0c             	add    $0xc,%esp
	net_icmpv4_unregister_handler(&ping4_handler);
  114956:	68 10 5b 14 00       	push   $0x145b10
  11495b:	e8 e0 c0 ff ff       	call   110a40 <net_icmpv4_unregister_handler>
  114960:	58                   	pop    %eax
}
  114961:	eb 05                	jmp    114968 <cmd_net_ping+0x254>
			return -ENOEXEC;
  114963:	bb f8 ff ff ff       	mov    $0xfffffff8,%ebx
}
  114968:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11496b:	89 d8                	mov    %ebx,%eax
  11496d:	5b                   	pop    %ebx
  11496e:	5e                   	pop    %esi
  11496f:	5f                   	pop    %edi
  114970:	5d                   	pop    %ebp
  114971:	c3                   	ret    

00114972 <cmd_net_iface_up>:
{
  114972:	55                   	push   %ebp
  114973:	89 e5                	mov    %esp,%ebp
  114975:	56                   	push   %esi
  114976:	53                   	push   %ebx
  114977:	51                   	push   %ecx
	idx = get_iface_idx(shell, argv[1]);
  114978:	8b 45 10             	mov    0x10(%ebp),%eax
{
  11497b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	idx = get_iface_idx(shell, argv[1]);
  11497e:	8b 50 04             	mov    0x4(%eax),%edx
  114981:	89 d8                	mov    %ebx,%eax
  114983:	e8 0b f2 ff ff       	call   113b93 <get_iface_idx>
  114988:	89 c6                	mov    %eax,%esi
		return -ENOEXEC;
  11498a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	if (idx < 0) {
  11498f:	85 f6                	test   %esi,%esi
  114991:	78 6b                	js     1149fe <cmd_net_iface_up+0x8c>
	iface = net_if_get_by_index(idx);
  114993:	89 f0                	mov    %esi,%eax
  114995:	e8 3f ef ff ff       	call   1138d9 <net_if_get_by_index>
	if (!iface) {
  11499a:	85 c0                	test   %eax,%eax
  11499c:	75 08                	jne    1149a6 <cmd_net_iface_up+0x34>
		PR_WARNING("No such interface in index %d\n", idx);
  11499e:	56                   	push   %esi
  11499f:	68 03 66 12 00       	push   $0x126603
  1149a4:	eb 10                	jmp    1149b6 <cmd_net_iface_up+0x44>
  1149a6:	8b 10                	mov    (%eax),%edx
  1149a8:	8b 52 0c             	mov    0xc(%edx),%edx
	if (net_if_is_up(iface)) {
  1149ab:	80 e2 01             	and    $0x1,%dl
  1149ae:	74 18                	je     1149c8 <cmd_net_iface_up+0x56>
		PR_WARNING("Interface %d is already up.\n", idx);
  1149b0:	56                   	push   %esi
  1149b1:	68 b8 6a 12 00       	push   $0x126ab8
  1149b6:	6a 04                	push   $0x4
  1149b8:	53                   	push   %ebx
  1149b9:	e8 61 16 ff ff       	call   10601f <shell_fprintf>
  1149be:	83 c4 10             	add    $0x10,%esp
		return -ENOEXEC;
  1149c1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  1149c6:	eb 36                	jmp    1149fe <cmd_net_iface_up+0x8c>
	ret = net_if_up(iface);
  1149c8:	50                   	push   %eax
  1149c9:	e8 70 92 ff ff       	call   10dc3e <net_if_up>
  1149ce:	5a                   	pop    %edx
	if (ret) {
  1149cf:	85 c0                	test   %eax,%eax
  1149d1:	74 14                	je     1149e7 <cmd_net_iface_up+0x75>
		PR_WARNING("Cannot take interface %d up (%d)\n", idx, ret);
  1149d3:	50                   	push   %eax
  1149d4:	56                   	push   %esi
  1149d5:	68 d5 6a 12 00       	push   $0x126ad5
  1149da:	6a 04                	push   $0x4
  1149dc:	53                   	push   %ebx
  1149dd:	e8 3d 16 ff ff       	call   10601f <shell_fprintf>
  1149e2:	83 c4 14             	add    $0x14,%esp
		return -ENOEXEC;
  1149e5:	eb da                	jmp    1149c1 <cmd_net_iface_up+0x4f>
		PR("Interface %d is up\n", idx);
  1149e7:	56                   	push   %esi
  1149e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1149eb:	68 f7 6a 12 00       	push   $0x126af7
  1149f0:	6a 00                	push   $0x0
  1149f2:	53                   	push   %ebx
  1149f3:	e8 27 16 ff ff       	call   10601f <shell_fprintf>
  1149f8:	83 c4 10             	add    $0x10,%esp
  1149fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  1149fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
  114a01:	5b                   	pop    %ebx
  114a02:	5e                   	pop    %esi
  114a03:	5d                   	pop    %ebp
  114a04:	c3                   	ret    

00114a05 <iface_index_get>:
static void iface_index_get(size_t idx, struct shell_static_entry *entry);

SHELL_DYNAMIC_CMD_CREATE(iface_index, iface_index_get);

static void iface_index_get(size_t idx, struct shell_static_entry *entry)
{
  114a05:	55                   	push   %ebp
  114a06:	89 e5                	mov    %esp,%ebp
  114a08:	57                   	push   %edi
  114a09:	56                   	push   %esi
  114a0a:	8b 75 0c             	mov    0xc(%ebp),%esi
  114a0d:	53                   	push   %ebx
  114a0e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	entry->handler = NULL;
  114a11:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
	struct net_if *iface = net_if_get_by_index(idx);
  114a18:	89 d8                	mov    %ebx,%eax
  114a1a:	e8 ba ee ff ff       	call   1138d9 <net_if_get_by_index>
	if (!iface) {
  114a1f:	85 c0                	test   %eax,%eax
  114a21:	74 36                	je     114a59 <iface_index_get+0x54>
	if (!iface || !iface->if_dev) {
  114a23:	8b 08                	mov    (%eax),%ecx
	return "<unknown type>";
  114a25:	ba a4 68 12 00       	mov    $0x1268a4,%edx
  114a2a:	85 c9                	test   %ecx,%ecx
  114a2c:	74 0e                	je     114a3c <iface_index_get+0x37>
	if (net_if_l2(iface) == &NET_L2_GET_NAME(ETHERNET)) {
  114a2e:	81 79 04 64 5e 14 00 	cmpl   $0x145e64,0x4(%ecx)
  114a35:	75 05                	jne    114a3c <iface_index_get+0x37>
		return "Ethernet";
  114a37:	ba b3 68 12 00       	mov    $0x1268b3,%edx
	snprintk(iface_help_buffer[idx], MAX_IFACE_HELP_STR_LEN,
  114a3c:	6b fb 1c             	imul   $0x1c,%ebx,%edi
  114a3f:	50                   	push   %eax
  114a40:	81 c7 2c ec 12 00    	add    $0x12ec2c,%edi
  114a46:	52                   	push   %edx
  114a47:	68 0b 6b 12 00       	push   $0x126b0b
  114a4c:	6a 1c                	push   $0x1c
  114a4e:	57                   	push   %edi
  114a4f:	e8 ab c8 fe ff       	call   1012ff <snprintk>
  114a54:	83 c4 14             	add    $0x14,%esp
	return iface_help_buffer[idx];
  114a57:	89 f8                	mov    %edi,%eax
	entry->help  = set_iface_index_help(idx);
  114a59:	89 46 04             	mov    %eax,0x4(%esi)
	entry->subcmd = &iface_index;
  114a5c:	c7 46 08 30 44 12 00 	movl   $0x124430,0x8(%esi)
	struct net_if *iface = net_if_get_by_index(idx);
  114a63:	89 d8                	mov    %ebx,%eax
  114a65:	e8 6f ee ff ff       	call   1138d9 <net_if_get_by_index>
  114a6a:	89 c7                	mov    %eax,%edi
	if (!iface) {
  114a6c:	85 c0                	test   %eax,%eax
  114a6e:	74 18                	je     114a88 <iface_index_get+0x83>
	snprintk(iface_index_buffer[idx], MAX_IFACE_STR_LEN, "%zu", idx);
  114a70:	53                   	push   %ebx
  114a71:	8d 3c 9d 28 ec 12 00 	lea    0x12ec28(,%ebx,4),%edi
  114a78:	68 13 6b 12 00       	push   $0x126b13
  114a7d:	6a 04                	push   $0x4
  114a7f:	57                   	push   %edi
  114a80:	e8 7a c8 fe ff       	call   1012ff <snprintk>
  114a85:	83 c4 10             	add    $0x10,%esp
	entry->syntax = set_iface_index_buffer(idx);
  114a88:	89 3e                	mov    %edi,(%esi)
}
  114a8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114a8d:	5b                   	pop    %ebx
  114a8e:	5e                   	pop    %esi
  114a8f:	5f                   	pop    %edi
  114a90:	5d                   	pop    %ebp
  114a91:	c3                   	ret    

00114a92 <net_shell_init>:

	(void)cmd_net_events_on(shell_backend_uart_get_ptr(), 1, argv);
#endif

	return 0;
}
  114a92:	31 c0                	xor    %eax,%eax
  114a94:	c3                   	ret    

00114a95 <sys_slist_append>:
	parent->next = child;
  114a95:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
Z_GENLIST_APPEND(slist, snode)
  114a9b:	8b 48 04             	mov    0x4(%eax),%ecx
  114a9e:	85 c9                	test   %ecx,%ecx
  114aa0:	75 06                	jne    114aa8 <sys_slist_append+0x13>
	list->tail = node;
  114aa2:	89 50 04             	mov    %edx,0x4(%eax)
	list->head = node;
  114aa5:	89 10                	mov    %edx,(%eax)
}
  114aa7:	c3                   	ret    
	parent->next = child;
  114aa8:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
  114aaa:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_APPEND(slist, snode)
  114aad:	c3                   	ret    

00114aae <sys_slist_remove>:
Z_GENLIST_REMOVE(slist, snode)
  114aae:	55                   	push   %ebp
  114aaf:	85 d2                	test   %edx,%edx
  114ab1:	89 e5                	mov    %esp,%ebp
  114ab3:	53                   	push   %ebx
  114ab4:	8b 19                	mov    (%ecx),%ebx
  114ab6:	75 0c                	jne    114ac4 <sys_slist_remove+0x16>
  114ab8:	3b 48 04             	cmp    0x4(%eax),%ecx
	list->head = node;
  114abb:	89 18                	mov    %ebx,(%eax)
Z_GENLIST_REMOVE(slist, snode)
  114abd:	75 0f                	jne    114ace <sys_slist_remove+0x20>
	list->tail = node;
  114abf:	89 58 04             	mov    %ebx,0x4(%eax)
}
  114ac2:	eb 0a                	jmp    114ace <sys_slist_remove+0x20>
	parent->next = child;
  114ac4:	89 1a                	mov    %ebx,(%edx)
Z_GENLIST_REMOVE(slist, snode)
  114ac6:	3b 48 04             	cmp    0x4(%eax),%ecx
  114ac9:	75 03                	jne    114ace <sys_slist_remove+0x20>
	list->tail = node;
  114acb:	89 50 04             	mov    %edx,0x4(%eax)
Z_GENLIST_REMOVE(slist, snode)
  114ace:	5b                   	pop    %ebx
	parent->next = child;
  114acf:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
Z_GENLIST_REMOVE(slist, snode)
  114ad5:	5d                   	pop    %ebp
  114ad6:	c3                   	ret    

00114ad7 <sys_slist_find_and_remove>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  114ad7:	55                   	push   %ebp
  114ad8:	89 e5                	mov    %esp,%ebp
  114ada:	53                   	push   %ebx
  114adb:	8b 08                	mov    (%eax),%ecx
  114add:	31 db                	xor    %ebx,%ebx
  114adf:	85 c9                	test   %ecx,%ecx
  114ae1:	74 15                	je     114af8 <sys_slist_find_and_remove+0x21>
  114ae3:	39 d1                	cmp    %edx,%ecx
  114ae5:	75 0b                	jne    114af2 <sys_slist_find_and_remove+0x1b>
  114ae7:	89 da                	mov    %ebx,%edx
  114ae9:	e8 c0 ff ff ff       	call   114aae <sys_slist_remove>
  114aee:	b0 01                	mov    $0x1,%al
  114af0:	eb 08                	jmp    114afa <sys_slist_find_and_remove+0x23>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  114af2:	89 cb                	mov    %ecx,%ebx
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  114af4:	8b 09                	mov    (%ecx),%ecx
  114af6:	eb e7                	jmp    114adf <sys_slist_find_and_remove+0x8>
  114af8:	31 c0                	xor    %eax,%eax
  114afa:	5b                   	pop    %ebx
  114afb:	5d                   	pop    %ebp
  114afc:	c3                   	ret    

00114afd <engine_get_s32>:
	return out->writer->put_objlnk(out, path, value);
}

static inline size_t engine_get_s32(struct lwm2m_input_context *in,
				    int32_t *value)
{
  114afd:	55                   	push   %ebp
  114afe:	89 e5                	mov    %esp,%ebp
	return in->reader->get_s32(in, value);
  114b00:	8b 08                	mov    (%eax),%ecx
  114b02:	52                   	push   %edx
  114b03:	50                   	push   %eax
  114b04:	ff 11                	call   *(%ecx)
  114b06:	5a                   	pop    %edx
  114b07:	59                   	pop    %ecx
}
  114b08:	c9                   	leave  
  114b09:	c3                   	ret    

00114b0a <get_engine_obj>:
	engine_remove_observer_by_id(obj->obj_id, -1);
	sys_slist_find_and_remove(&engine_obj_list, &obj->node);
}

static struct lwm2m_engine_obj *get_engine_obj(int obj_id)
{
  114b0a:	89 c2                	mov    %eax,%edx
  114b0c:	a1 b4 ec 12 00       	mov    0x12ecb4,%eax
	struct lwm2m_engine_obj *obj;

	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
  114b11:	85 c0                	test   %eax,%eax
  114b13:	74 0c                	je     114b21 <get_engine_obj+0x17>
		if (obj->obj_id == obj_id) {
  114b15:	0f b7 48 18          	movzwl 0x18(%eax),%ecx
  114b19:	39 d1                	cmp    %edx,%ecx
  114b1b:	74 04                	je     114b21 <get_engine_obj+0x17>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  114b1d:	8b 00                	mov    (%eax),%eax
	return node->next;
  114b1f:	eb f0                	jmp    114b11 <get_engine_obj+0x7>
			return obj;
		}
	}

	return NULL;
}
  114b21:	c3                   	ret    

00114b22 <get_engine_obj_inst>:
	sys_slist_find_and_remove(&engine_obj_inst_list, &obj_inst->node);
}

static struct lwm2m_engine_obj_inst *get_engine_obj_inst(int obj_id,
							 int obj_inst_id)
{
  114b22:	89 c1                	mov    %eax,%ecx
  114b24:	a1 ac ec 12 00       	mov    0x12ecac,%eax
	struct lwm2m_engine_obj_inst *obj_inst;

	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
  114b29:	85 c0                	test   %eax,%eax
  114b2b:	75 01                	jne    114b2e <get_engine_obj_inst+0xc>
			return obj_inst;
		}
	}

	return NULL;
}
  114b2d:	c3                   	ret    
{
  114b2e:	55                   	push   %ebp
  114b2f:	89 e5                	mov    %esp,%ebp
  114b31:	53                   	push   %ebx
		if (obj_inst->obj->obj_id == obj_id &&
  114b32:	8b 58 04             	mov    0x4(%eax),%ebx
  114b35:	0f b7 5b 18          	movzwl 0x18(%ebx),%ebx
  114b39:	39 cb                	cmp    %ecx,%ebx
  114b3b:	75 08                	jne    114b45 <get_engine_obj_inst+0x23>
		    obj_inst->obj_inst_id == obj_inst_id) {
  114b3d:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
		if (obj_inst->obj->obj_id == obj_id &&
  114b41:	39 d3                	cmp    %edx,%ebx
  114b43:	74 06                	je     114b4b <get_engine_obj_inst+0x29>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  114b45:	8b 00                	mov    (%eax),%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
  114b47:	85 c0                	test   %eax,%eax
  114b49:	75 e7                	jne    114b32 <get_engine_obj_inst+0x10>
}
  114b4b:	5b                   	pop    %ebx
  114b4c:	5d                   	pop    %ebp
  114b4d:	c3                   	ret    

00114b4e <next_engine_obj_inst>:

static struct lwm2m_engine_obj_inst *
next_engine_obj_inst(int obj_id, int obj_inst_id)
{
  114b4e:	55                   	push   %ebp
  114b4f:	8b 0d ac ec 12 00    	mov    0x12ecac,%ecx
  114b55:	89 e5                	mov    %esp,%ebp
  114b57:	57                   	push   %edi
  114b58:	56                   	push   %esi
  114b59:	53                   	push   %ebx
  114b5a:	89 c3                	mov    %eax,%ebx
	struct lwm2m_engine_obj_inst *obj_inst, *next = NULL;

	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst,
  114b5c:	31 c0                	xor    %eax,%eax
  114b5e:	85 c9                	test   %ecx,%ecx
  114b60:	74 23                	je     114b85 <next_engine_obj_inst+0x37>
				     node) {
		if (obj_inst->obj->obj_id == obj_id &&
  114b62:	8b 71 04             	mov    0x4(%ecx),%esi
  114b65:	0f b7 76 18          	movzwl 0x18(%esi),%esi
  114b69:	39 de                	cmp    %ebx,%esi
  114b6b:	75 14                	jne    114b81 <next_engine_obj_inst+0x33>
		    obj_inst->obj_inst_id > obj_inst_id &&
  114b6d:	0f b7 79 0c          	movzwl 0xc(%ecx),%edi
		if (obj_inst->obj->obj_id == obj_id &&
  114b71:	39 d7                	cmp    %edx,%edi
  114b73:	7e 0c                	jle    114b81 <next_engine_obj_inst+0x33>
		    obj_inst->obj_inst_id > obj_inst_id &&
  114b75:	85 c0                	test   %eax,%eax
  114b77:	74 06                	je     114b7f <next_engine_obj_inst+0x31>
		    (!next || next->obj_inst_id > obj_inst->obj_inst_id)) {
  114b79:	66 3b 78 0c          	cmp    0xc(%eax),%di
  114b7d:	73 02                	jae    114b81 <next_engine_obj_inst+0x33>
  114b7f:	89 c8                	mov    %ecx,%eax
  114b81:	8b 09                	mov    (%ecx),%ecx
	return node->next;
  114b83:	eb d9                	jmp    114b5e <next_engine_obj_inst+0x10>
			next = obj_inst;
		}
	}

	return next;
}
  114b85:	5b                   	pop    %ebx
  114b86:	5e                   	pop    %esi
  114b87:	5f                   	pop    %edi
  114b88:	5d                   	pop    %ebp
  114b89:	c3                   	ret    

00114b8a <update_attrs>:
{
  114b8a:	55                   	push   %ebp
  114b8b:	89 e5                	mov    %esp,%ebp
  114b8d:	57                   	push   %edi
  114b8e:	56                   	push   %esi
  114b8f:	53                   	push   %ebx
  114b90:	bb 40 ce 12 00       	mov    $0x12ce40,%ebx
		if (ref != write_attr_pool[i].ref) {
  114b95:	39 03                	cmp    %eax,(%ebx)
  114b97:	0f 85 89 00 00 00    	jne    114c26 <update_attrs+0x9c>
		switch (write_attr_pool[i].type) {
  114b9d:	0f b6 7b 0c          	movzbl 0xc(%ebx),%edi
  114ba1:	89 f9                	mov    %edi,%ecx
  114ba3:	80 f9 04             	cmp    $0x4,%cl
  114ba6:	77 40                	ja     114be8 <update_attrs+0x5e>
  114ba8:	ff 24 bd 58 44 12 00 	jmp    *0x124458(,%edi,4)
			out->pmin = write_attr_pool[i].int_val;
  114baf:	8b 7b 04             	mov    0x4(%ebx),%edi
  114bb2:	89 7a 18             	mov    %edi,0x18(%edx)
			break;
  114bb5:	eb 63                	jmp    114c1a <update_attrs+0x90>
			out->pmax = write_attr_pool[i].int_val;
  114bb7:	8b 7b 04             	mov    0x4(%ebx),%edi
  114bba:	89 7a 1c             	mov    %edi,0x1c(%edx)
			break;
  114bbd:	eb 5b                	jmp    114c1a <update_attrs+0x90>
			out->lt = write_attr_pool[i].float_val;
  114bbf:	8b 73 04             	mov    0x4(%ebx),%esi
  114bc2:	8b 7b 08             	mov    0x8(%ebx),%edi
  114bc5:	89 7a 0c             	mov    %edi,0xc(%edx)
  114bc8:	89 72 08             	mov    %esi,0x8(%edx)
			break;
  114bcb:	eb 4d                	jmp    114c1a <update_attrs+0x90>
			out->gt = write_attr_pool[i].float_val;
  114bcd:	8b 73 04             	mov    0x4(%ebx),%esi
  114bd0:	8b 7b 08             	mov    0x8(%ebx),%edi
  114bd3:	89 7a 04             	mov    %edi,0x4(%edx)
  114bd6:	89 32                	mov    %esi,(%edx)
			break;
  114bd8:	eb 40                	jmp    114c1a <update_attrs+0x90>
			out->st = write_attr_pool[i].float_val;
  114bda:	8b 73 04             	mov    0x4(%ebx),%esi
  114bdd:	8b 7b 08             	mov    0x8(%ebx),%edi
  114be0:	89 7a 14             	mov    %edi,0x14(%edx)
  114be3:	89 72 10             	mov    %esi,0x10(%edx)
			break;
  114be6:	eb 32                	jmp    114c1a <update_attrs+0x90>
			LOG_ERR("Unrecognize attr: %d",
  114be8:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
			return -EINVAL;
  114bef:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
			LOG_ERR("Unrecognize attr: %d",
  114bf4:	74 42                	je     114c38 <update_attrs+0xae>
  114bf6:	b8 20 31 12 00       	mov    $0x123120,%eax
  114bfb:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  114c00:	c1 e8 03             	shr    $0x3,%eax
  114c03:	c1 e0 06             	shl    $0x6,%eax
  114c06:	83 c8 01             	or     $0x1,%eax
  114c09:	50                   	push   %eax
  114c0a:	57                   	push   %edi
  114c0b:	68 a2 74 12 00       	push   $0x1274a2
  114c10:	e8 61 e9 fe ff       	call   103576 <log_1>
  114c15:	83 c4 0c             	add    $0xc,%esp
  114c18:	eb 1e                	jmp    114c38 <update_attrs+0xae>
		out->flags |= BIT(write_attr_pool[i].type);
  114c1a:	be 01 00 00 00       	mov    $0x1,%esi
  114c1f:	d3 e6                	shl    %cl,%esi
  114c21:	89 f1                	mov    %esi,%ecx
  114c23:	08 4a 20             	or     %cl,0x20(%edx)
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
  114c26:	83 c3 10             	add    $0x10,%ebx
  114c29:	b9 80 cf 12 00       	mov    $0x12cf80,%ecx
  114c2e:	39 d9                	cmp    %ebx,%ecx
  114c30:	0f 85 5f ff ff ff    	jne    114b95 <update_attrs+0xb>
	return 0;
  114c36:	31 db                	xor    %ebx,%ebx
}
  114c38:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114c3b:	89 d8                	mov    %ebx,%eax
  114c3d:	5b                   	pop    %ebx
  114c3e:	5e                   	pop    %esi
  114c3f:	5f                   	pop    %edi
  114c40:	5d                   	pop    %ebp
  114c41:	c3                   	ret    

00114c42 <k_uptime_get>:
{
  114c42:	55                   	push   %ebp
  114c43:	89 e5                	mov    %esp,%ebp
	return z_impl_k_uptime_ticks();
  114c45:	e8 3d d7 00 00       	call   122387 <z_impl_k_uptime_ticks>
}
  114c4a:	5d                   	pop    %ebp
			return t * (to_hz / from_hz);
  114c4b:	6b ca 0a             	imul   $0xa,%edx,%ecx
  114c4e:	ba 0a 00 00 00       	mov    $0xa,%edx
  114c53:	f7 e2                	mul    %edx
  114c55:	01 ca                	add    %ecx,%edx
  114c57:	c3                   	ret    

00114c58 <engine_remove_observer_by_id>:
{
  114c58:	55                   	push   %ebp
  114c59:	89 e5                	mov    %esp,%ebp
  114c5b:	57                   	push   %edi
  114c5c:	56                   	push   %esi
  114c5d:	89 c6                	mov    %eax,%esi
  114c5f:	53                   	push   %ebx
  114c60:	51                   	push   %ecx
  114c61:	89 55 f0             	mov    %edx,-0x10(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(
  114c64:	a1 a4 ec 12 00       	mov    0x12eca4,%eax
  114c69:	85 c0                	test   %eax,%eax
  114c6b:	74 3c                	je     114ca9 <engine_remove_observer_by_id+0x51>
  114c6d:	8b 18                	mov    (%eax),%ebx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  114c6f:	31 ff                	xor    %edi,%edi
		if (!(obj_id == obs->path.obj_id &&
  114c71:	66 39 70 08          	cmp    %si,0x8(%eax)
  114c75:	89 c1                	mov    %eax,%ecx
  114c77:	75 24                	jne    114c9d <engine_remove_observer_by_id+0x45>
		      obj_inst_id == obs->path.obj_inst_id)) {
  114c79:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
		if (!(obj_id == obs->path.obj_id &&
  114c7d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  114c80:	75 1b                	jne    114c9d <engine_remove_observer_by_id+0x45>
		sys_slist_remove(&engine_observer_list, prev_node, &obs->node);
  114c82:	89 fa                	mov    %edi,%edx
  114c84:	b8 a4 ec 12 00       	mov    $0x12eca4,%eax
  114c89:	e8 20 fe ff ff       	call   114aae <sys_slist_remove>
		(void)memset(obs, 0, sizeof(*obs));
  114c8e:	6a 3c                	push   $0x3c
  114c90:	6a 00                	push   $0x0
  114c92:	51                   	push   %ecx
  114c93:	e8 c3 71 ff ff       	call   10be5b <memset>
  114c98:	83 c4 0c             	add    $0xc,%esp
  114c9b:	89 f9                	mov    %edi,%ecx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(
  114c9d:	85 db                	test   %ebx,%ebx
  114c9f:	74 08                	je     114ca9 <engine_remove_observer_by_id+0x51>
  114ca1:	89 d8                	mov    %ebx,%eax
  114ca3:	89 cf                	mov    %ecx,%edi
  114ca5:	8b 1b                	mov    (%ebx),%ebx
  114ca7:	eb c8                	jmp    114c71 <engine_remove_observer_by_id+0x19>
}
  114ca9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114cac:	5b                   	pop    %ebx
  114cad:	5e                   	pop    %esi
  114cae:	5f                   	pop    %edi
  114caf:	5d                   	pop    %ebp
  114cb0:	c3                   	ret    

00114cb1 <clear_attrs>:
{
  114cb1:	55                   	push   %ebp
  114cb2:	89 e5                	mov    %esp,%ebp
  114cb4:	56                   	push   %esi
  114cb5:	53                   	push   %ebx
  114cb6:	89 c6                	mov    %eax,%esi
  114cb8:	31 db                	xor    %ebx,%ebx
		if (ref == write_attr_pool[i].ref) {
  114cba:	39 b3 40 ce 12 00    	cmp    %esi,0x12ce40(%ebx)
  114cc0:	75 13                	jne    114cd5 <clear_attrs+0x24>
			(void)memset(&write_attr_pool[i], 0,
  114cc2:	6a 10                	push   $0x10
  114cc4:	8d 83 40 ce 12 00    	lea    0x12ce40(%ebx),%eax
  114cca:	6a 00                	push   $0x0
  114ccc:	50                   	push   %eax
  114ccd:	e8 89 71 ff ff       	call   10be5b <memset>
  114cd2:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
  114cd5:	83 c3 10             	add    $0x10,%ebx
  114cd8:	81 fb 40 01 00 00    	cmp    $0x140,%ebx
  114cde:	75 da                	jne    114cba <clear_attrs+0x9>
}
  114ce0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  114ce3:	5b                   	pop    %ebx
  114ce4:	5e                   	pop    %esi
  114ce5:	5d                   	pop    %ebp
  114ce6:	c3                   	ret    

00114ce7 <sys_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
  114ce7:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  114ceb:	74 1e                	je     114d0b <sys_mutex_unlock+0x24>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
  114ced:	8b 0d c8 e9 12 00    	mov    0x12e9c8,%ecx
		return -EPERM;
  114cf3:	83 ca ff             	or     $0xffffffff,%edx
	if (mutex->kernel_mutex.owner != _current) {
  114cf6:	39 48 10             	cmp    %ecx,0x10(%eax)
  114cf9:	75 15                	jne    114d10 <sys_mutex_unlock+0x29>
{
  114cfb:	55                   	push   %ebp
  114cfc:	89 e5                	mov    %esp,%ebp
	return z_impl_k_mutex_unlock(mutex);
  114cfe:	50                   	push   %eax
  114cff:	e8 ca bf 00 00       	call   120cce <z_impl_k_mutex_unlock>
	}

	k_mutex_unlock(&mutex->kernel_mutex);
	return 0;
  114d04:	31 d2                	xor    %edx,%edx
  114d06:	58                   	pop    %eax
}
  114d07:	89 d0                	mov    %edx,%eax
  114d09:	c9                   	leave  
  114d0a:	c3                   	ret    
		return -EINVAL;
  114d0b:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  114d10:	89 d0                	mov    %edx,%eax
  114d12:	c3                   	ret    

00114d13 <z_errno>:
  114d13:	e9 4d b7 00 00       	jmp    120465 <z_impl_z_errno>

00114d18 <buf_append>:
#endif

/* append */
static inline int buf_append(uint8_t *dst, uint16_t *dst_len, uint16_t dst_size,
			     uint8_t *src, uint16_t src_len)
{
  114d18:	55                   	push   %ebp
  114d19:	89 e5                	mov    %esp,%ebp
  114d1b:	57                   	push   %edi
  114d1c:	56                   	push   %esi
  114d1d:	53                   	push   %ebx
  114d1e:	83 ec 08             	sub    $0x8,%esp
	if (!dst || !src) {
  114d21:	85 c0                	test   %eax,%eax
{
  114d23:	8b 75 0c             	mov    0xc(%ebp),%esi
  114d26:	89 75 f0             	mov    %esi,-0x10(%ebp)
	if (!dst || !src) {
  114d29:	74 35                	je     114d60 <buf_append+0x48>
		return -EINVAL;
	}

	if (*dst_len + src_len > dst_size) {
  114d2b:	0f b7 32             	movzwl (%edx),%esi
  114d2e:	0f b7 7d f0          	movzwl -0x10(%ebp),%edi
  114d32:	89 d3                	mov    %edx,%ebx
  114d34:	8d 14 3e             	lea    (%esi,%edi,1),%edx
  114d37:	89 55 ec             	mov    %edx,-0x14(%ebp)
		return -ENOMEM;
  114d3a:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (*dst_len + src_len > dst_size) {
  114d3f:	0f b7 c9             	movzwl %cx,%ecx
  114d42:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
  114d45:	7f 1e                	jg     114d65 <buf_append+0x4d>
	}

	memcpy(dst + *dst_len, src, src_len);
  114d47:	57                   	push   %edi
  114d48:	01 f0                	add    %esi,%eax
  114d4a:	ff 75 08             	pushl  0x8(%ebp)
  114d4d:	50                   	push   %eax
  114d4e:	e8 99 70 ff ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  114d53:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memcpy(dst + *dst_len, src, src_len);
  114d56:	83 c4 0c             	add    $0xc,%esp
	*dst_len += src_len;
  114d59:	66 01 03             	add    %ax,(%ebx)
	return 0;
  114d5c:	31 d2                	xor    %edx,%edx
  114d5e:	eb 05                	jmp    114d65 <buf_append+0x4d>
		return -EINVAL;
  114d60:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  114d65:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114d68:	89 d0                	mov    %edx,%eax
  114d6a:	5b                   	pop    %ebx
  114d6b:	5e                   	pop    %esi
  114d6c:	5f                   	pop    %edi
  114d6d:	5d                   	pop    %ebp
  114d6e:	c3                   	ret    

00114d6f <find_msg>:
	return options_count == path->level ? 0 : -EINVAL;
}

static struct lwm2m_message *find_msg(struct coap_pending *pending,
				      struct coap_reply *reply)
{
  114d6f:	89 c1                	mov    %eax,%ecx
	size_t i;

	if (!pending && !reply) {
  114d71:	09 d0                	or     %edx,%eax
  114d73:	74 37                	je     114dac <find_msg+0x3d>
{
  114d75:	55                   	push   %ebp
  114d76:	89 e5                	mov    %esp,%ebp
  114d78:	53                   	push   %ebx
		return NULL;
	}

	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
  114d79:	31 db                	xor    %ebx,%ebx
		if (messages[i].ctx && messages[i].pending == pending) {
  114d7b:	69 c3 8c 02 00 00    	imul   $0x28c,%ebx,%eax
  114d81:	83 b8 c0 b4 12 00 00 	cmpl   $0x0,0x12b4c0(%eax)
  114d88:	74 17                	je     114da1 <find_msg+0x32>
  114d8a:	3b 88 30 b7 12 00    	cmp    0x12b730(%eax),%ecx
  114d90:	74 08                	je     114d9a <find_msg+0x2b>
			return &messages[i];
		}

		if (messages[i].ctx && messages[i].reply == reply) {
  114d92:	3b 90 34 b7 12 00    	cmp    0x12b734(%eax),%edx
  114d98:	75 07                	jne    114da1 <find_msg+0x32>
			return &messages[i];
  114d9a:	05 c0 b4 12 00       	add    $0x12b4c0,%eax
  114d9f:	eb 08                	jmp    114da9 <find_msg+0x3a>
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
  114da1:	43                   	inc    %ebx
  114da2:	83 fb 0a             	cmp    $0xa,%ebx
  114da5:	75 d4                	jne    114d7b <find_msg+0xc>
		return NULL;
  114da7:	31 c0                	xor    %eax,%eax
		}
	}

	return NULL;
}
  114da9:	5b                   	pop    %ebx
  114daa:	5d                   	pop    %ebp
  114dab:	c3                   	ret    
  114dac:	c3                   	ret    

00114dad <select_writer>:

/* input / output selection */

static int select_writer(struct lwm2m_output_context *out, uint16_t accept)
{
	switch (accept) {
  114dad:	66 81 fa 06 06       	cmp    $0x606,%dx
{
  114db2:	55                   	push   %ebp
  114db3:	89 e5                	mov    %esp,%ebp
  114db5:	53                   	push   %ebx
	switch (accept) {
  114db6:	74 37                	je     114def <select_writer+0x42>
  114db8:	77 16                	ja     114dd0 <select_writer+0x23>
  114dba:	31 db                	xor    %ebx,%ebx
  114dbc:	66 83 fa 28          	cmp    $0x28,%dx
  114dc0:	74 72                	je     114e34 <select_writer+0x87>
  114dc2:	66 81 fa 05 06       	cmp    $0x605,%dx
  114dc7:	74 1e                	je     114de7 <select_writer+0x3a>
  114dc9:	66 85 d2             	test   %dx,%dx
  114dcc:	74 19                	je     114de7 <select_writer+0x3a>
  114dce:	eb 31                	jmp    114e01 <select_writer+0x54>
  114dd0:	66 81 fa 16 2d       	cmp    $0x2d16,%dx
  114dd5:	74 18                	je     114def <select_writer+0x42>
  114dd7:	66 81 fa 17 2d       	cmp    $0x2d17,%dx
  114ddc:	74 1b                	je     114df9 <select_writer+0x4c>
  114dde:	66 81 fa 07 06       	cmp    $0x607,%dx
  114de3:	74 14                	je     114df9 <select_writer+0x4c>
  114de5:	eb 1a                	jmp    114e01 <select_writer+0x54>
		/* TODO: rewrite do_discover as content formatter */
		break;

	case LWM2M_FORMAT_PLAIN_TEXT:
	case LWM2M_FORMAT_OMA_PLAIN_TEXT:
		out->writer = &plain_text_writer;
  114de7:	c7 00 80 3c 12 00    	movl   $0x123c80,(%eax)
		break;
  114ded:	eb 06                	jmp    114df5 <select_writer+0x48>

	case LWM2M_FORMAT_OMA_TLV:
	case LWM2M_FORMAT_OMA_OLD_TLV:
		out->writer = &oma_tlv_writer;
  114def:	c7 00 00 3d 12 00    	movl   $0x123d00,(%eax)
		LOG_WRN("Unknown content type %u", accept);
		return -ENOMSG;

	}

	return 0;
  114df5:	31 db                	xor    %ebx,%ebx
		break;
  114df7:	eb 3b                	jmp    114e34 <select_writer+0x87>
		out->writer = &json_writer;
  114df9:	c7 00 80 3d 12 00    	movl   $0x123d80,(%eax)
		break;
  114dff:	eb f4                	jmp    114df5 <select_writer+0x48>
		LOG_WRN("Unknown content type %u", accept);
  114e01:	f6 05 d0 5b 14 00 06 	testb  $0x6,0x145bd0
		return -ENOMSG;
  114e08:	bb b0 ff ff ff       	mov    $0xffffffb0,%ebx
		LOG_WRN("Unknown content type %u", accept);
  114e0d:	74 25                	je     114e34 <select_writer+0x87>
  114e0f:	b8 20 31 12 00       	mov    $0x123120,%eax
  114e14:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  114e19:	c1 e8 03             	shr    $0x3,%eax
  114e1c:	c1 e0 06             	shl    $0x6,%eax
  114e1f:	83 c8 02             	or     $0x2,%eax
  114e22:	50                   	push   %eax
  114e23:	0f b7 d2             	movzwl %dx,%edx
  114e26:	52                   	push   %edx
  114e27:	68 b7 74 12 00       	push   $0x1274b7
  114e2c:	e8 45 e7 fe ff       	call   103576 <log_1>
  114e31:	83 c4 0c             	add    $0xc,%esp
}
  114e34:	89 d8                	mov    %ebx,%eax
  114e36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  114e39:	c9                   	leave  
  114e3a:	c3                   	ret    

00114e3b <engine_remove_observer>:
{
  114e3b:	55                   	push   %ebp
  114e3c:	89 e5                	mov    %esp,%ebp
  114e3e:	57                   	push   %edi
  114e3f:	56                   	push   %esi
  114e40:	89 c7                	mov    %eax,%edi
  114e42:	53                   	push   %ebx
  114e43:	89 d0                	mov    %edx,%eax
  114e45:	83 ec 08             	sub    $0x8,%esp
  114e48:	88 55 f3             	mov    %dl,-0xd(%ebp)
	if (!token || (tkl == 0U || tkl > MAX_TOKEN_LEN)) {
  114e4b:	85 ff                	test   %edi,%edi
  114e4d:	74 10                	je     114e5f <engine_remove_observer+0x24>
  114e4f:	8d 4a ff             	lea    -0x1(%edx),%ecx
  114e52:	8b 1d a4 ec 12 00    	mov    0x12eca4,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  114e58:	31 d2                	xor    %edx,%edx
	if (!token || (tkl == 0U || tkl > MAX_TOKEN_LEN)) {
  114e5a:	80 f9 07             	cmp    $0x7,%cl
  114e5d:	76 5b                	jbe    114eba <engine_remove_observer+0x7f>
		LOG_ERR("token(%p) and token length(%u) must be valid.",
  114e5f:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  114e66:	be ea ff ff ff       	mov    $0xffffffea,%esi
  114e6b:	74 71                	je     114ede <engine_remove_observer+0xa3>
  114e6d:	ba 20 31 12 00       	mov    $0x123120,%edx
  114e72:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  114e78:	c1 ea 03             	shr    $0x3,%edx
  114e7b:	c1 e2 06             	shl    $0x6,%edx
  114e7e:	83 ca 01             	or     $0x1,%edx
  114e81:	52                   	push   %edx
  114e82:	0f b6 c0             	movzbl %al,%eax
  114e85:	50                   	push   %eax
  114e86:	57                   	push   %edi
  114e87:	68 cf 74 12 00       	push   $0x1274cf
  114e8c:	e8 1f e7 fe ff       	call   1035b0 <log_2>
  114e91:	83 c4 10             	add    $0x10,%esp
  114e94:	eb 48                	jmp    114ede <engine_remove_observer+0xa3>
		if (memcmp(obs->token, token, tkl) == 0) {
  114e96:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  114e9a:	50                   	push   %eax
  114e9b:	8d 43 12             	lea    0x12(%ebx),%eax
  114e9e:	57                   	push   %edi
  114e9f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  114ea2:	50                   	push   %eax
  114ea3:	e8 d7 6e ff ff       	call   10bd7f <memcmp>
  114ea8:	89 c6                	mov    %eax,%esi
  114eaa:	83 c4 0c             	add    $0xc,%esp
  114ead:	89 d8                	mov    %ebx,%eax
  114eaf:	85 f6                	test   %esi,%esi
  114eb1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  114eb4:	74 0f                	je     114ec5 <engine_remove_observer+0x8a>
  114eb6:	8b 1b                	mov    (%ebx),%ebx
  114eb8:	89 c2                	mov    %eax,%edx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  114eba:	85 db                	test   %ebx,%ebx
  114ebc:	75 d8                	jne    114e96 <engine_remove_observer+0x5b>
		return -ENOENT;
  114ebe:	be fe ff ff ff       	mov    $0xfffffffe,%esi
  114ec3:	eb 19                	jmp    114ede <engine_remove_observer+0xa3>
	sys_slist_remove(&engine_observer_list, prev_node, &found_obj->node);
  114ec5:	89 d9                	mov    %ebx,%ecx
  114ec7:	b8 a4 ec 12 00       	mov    $0x12eca4,%eax
  114ecc:	e8 dd fb ff ff       	call   114aae <sys_slist_remove>
	(void)memset(found_obj, 0, sizeof(*found_obj));
  114ed1:	6a 3c                	push   $0x3c
  114ed3:	6a 00                	push   $0x0
  114ed5:	53                   	push   %ebx
  114ed6:	e8 80 6f ff ff       	call   10be5b <memset>
  114edb:	83 c4 0c             	add    $0xc,%esp
}
  114ede:	8d 65 f4             	lea    -0xc(%ebp),%esp
  114ee1:	89 f0                	mov    %esi,%eax
  114ee3:	5b                   	pop    %ebx
  114ee4:	5e                   	pop    %esi
  114ee5:	5f                   	pop    %edi
  114ee6:	5d                   	pop    %ebp
  114ee7:	c3                   	ret    

00114ee8 <do_read_op>:
	return ret;
}

static int do_read_op(struct lwm2m_message *msg, uint16_t content_format)
{
	switch (content_format) {
  114ee8:	66 81 fa 06 06       	cmp    $0x606,%dx
{
  114eed:	55                   	push   %ebp
  114eee:	89 e5                	mov    %esp,%ebp
  114ef0:	51                   	push   %ecx
	switch (content_format) {
  114ef1:	0f b7 ca             	movzwl %dx,%ecx
  114ef4:	74 36                	je     114f2c <do_read_op+0x44>
  114ef6:	77 14                	ja     114f0c <do_read_op+0x24>
  114ef8:	66 83 fa 2a          	cmp    $0x2a,%dx
  114efc:	74 25                	je     114f23 <do_read_op+0x3b>
  114efe:	66 81 fa 05 06       	cmp    $0x605,%dx
  114f03:	74 1e                	je     114f23 <do_read_op+0x3b>
  114f05:	66 85 d2             	test   %dx,%dx
  114f08:	74 19                	je     114f23 <do_read_op+0x3b>
  114f0a:	eb 34                	jmp    114f40 <do_read_op+0x58>
  114f0c:	66 81 fa 16 2d       	cmp    $0x2d16,%dx
  114f11:	74 19                	je     114f2c <do_read_op+0x44>
  114f13:	66 81 fa 17 2d       	cmp    $0x2d17,%dx
  114f18:	74 1d                	je     114f37 <do_read_op+0x4f>
  114f1a:	66 81 fa 07 06       	cmp    $0x607,%dx
  114f1f:	74 16                	je     114f37 <do_read_op+0x4f>
  114f21:	eb 1d                	jmp    114f40 <do_read_op+0x58>

	case LWM2M_FORMAT_APP_OCTET_STREAM:
	case LWM2M_FORMAT_PLAIN_TEXT:
	case LWM2M_FORMAT_OMA_PLAIN_TEXT:
		return do_read_op_plain_text(msg, content_format);
  114f23:	51                   	push   %ecx
  114f24:	50                   	push   %eax
  114f25:	e8 3f 61 00 00       	call   11b069 <do_read_op_plain_text>
  114f2a:	eb 07                	jmp    114f33 <do_read_op+0x4b>

	case LWM2M_FORMAT_OMA_TLV:
	case LWM2M_FORMAT_OMA_OLD_TLV:
		return do_read_op_tlv(msg, content_format);
  114f2c:	51                   	push   %ecx
  114f2d:	50                   	push   %eax
  114f2e:	e8 b4 6f 00 00       	call   11bee7 <do_read_op_tlv>
  114f33:	5a                   	pop    %edx
  114f34:	59                   	pop    %ecx
  114f35:	eb 40                	jmp    114f77 <do_read_op+0x8f>

#if defined(CONFIG_LWM2M_RW_JSON_SUPPORT)
	case LWM2M_FORMAT_OMA_JSON:
	case LWM2M_FORMAT_OMA_OLD_JSON:
		return do_read_op_json(msg, content_format);
  114f37:	51                   	push   %ecx
  114f38:	50                   	push   %eax
  114f39:	e8 4d a1 00 00       	call   11f08b <do_read_op_json>
  114f3e:	eb f3                	jmp    114f33 <do_read_op+0x4b>
#endif

	default:
		LOG_ERR("Unsupported content-format: %u", content_format);
  114f40:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOMSG;
  114f47:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
		LOG_ERR("Unsupported content-format: %u", content_format);
  114f4c:	74 29                	je     114f77 <do_read_op+0x8f>
  114f4e:	ba 20 31 12 00       	mov    $0x123120,%edx
  114f53:	89 45 fc             	mov    %eax,-0x4(%ebp)
  114f56:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  114f5c:	c1 ea 03             	shr    $0x3,%edx
  114f5f:	c1 e2 06             	shl    $0x6,%edx
  114f62:	83 ca 01             	or     $0x1,%edx
  114f65:	52                   	push   %edx
  114f66:	51                   	push   %ecx
  114f67:	68 fd 74 12 00       	push   $0x1274fd
  114f6c:	e8 05 e6 fe ff       	call   103576 <log_1>
  114f71:	83 c4 0c             	add    $0xc,%esp
  114f74:	8b 45 fc             	mov    -0x4(%ebp),%eax

	}
}
  114f77:	c9                   	leave  
  114f78:	c3                   	ret    

00114f79 <notify_message_reply_cb>:
}

static int notify_message_reply_cb(const struct coap_packet *response,
				   struct coap_reply *reply,
				   const struct sockaddr *from)
{
  114f79:	55                   	push   %ebp
  114f7a:	89 e5                	mov    %esp,%ebp
  114f7c:	57                   	push   %edi
  114f7d:	56                   	push   %esi
  114f7e:	53                   	push   %ebx
  114f7f:	8b 7d 08             	mov    0x8(%ebp),%edi
	int ret = 0;
	uint8_t type, code;

	type = coap_header_get_type(response);
  114f82:	57                   	push   %edi
{
  114f83:	8b 75 0c             	mov    0xc(%ebp),%esi
	type = coap_header_get_type(response);
  114f86:	e8 98 3b ff ff       	call   108b23 <coap_header_get_type>
	code = coap_header_get_code(response);
  114f8b:	89 3c 24             	mov    %edi,(%esp)
	type = coap_header_get_type(response);
  114f8e:	88 c3                	mov    %al,%bl
	code = coap_header_get_code(response);
  114f90:	e8 df 3b ff ff       	call   108b74 <coap_header_get_code>
  114f95:	59                   	pop    %ecx
		COAP_RESPONSE_CODE_CLASS(code),
		COAP_RESPONSE_CODE_DETAIL(code),
		log_strdup(sprint_token(reply->token, reply->tkl)));

	/* remove observer on COAP_TYPE_RESET */
	if (type == COAP_TYPE_RESET) {
  114f96:	80 fb 03             	cmp    $0x3,%bl
  114f99:	75 6b                	jne    115006 <notify_message_reply_cb+0x8d>
		if (reply->tkl > 0) {
  114f9b:	0f b6 56 16          	movzbl 0x16(%esi),%edx
  114f9f:	84 d2                	test   %dl,%dl
  114fa1:	74 3a                	je     114fdd <notify_message_reply_cb+0x64>
			ret = engine_remove_observer(reply->token, reply->tkl);
  114fa3:	8d 46 0e             	lea    0xe(%esi),%eax
  114fa6:	e8 90 fe ff ff       	call   114e3b <engine_remove_observer>
			if (ret) {
  114fab:	85 c0                	test   %eax,%eax
  114fad:	74 57                	je     115006 <notify_message_reply_cb+0x8d>
				LOG_ERR("remove observe error: %d", ret);
  114faf:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  114fb6:	74 4e                	je     115006 <notify_message_reply_cb+0x8d>
  114fb8:	ba 20 31 12 00       	mov    $0x123120,%edx
  114fbd:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  114fc3:	c1 ea 03             	shr    $0x3,%edx
  114fc6:	c1 e2 06             	shl    $0x6,%edx
  114fc9:	83 ca 01             	or     $0x1,%edx
  114fcc:	52                   	push   %edx
  114fcd:	50                   	push   %eax
  114fce:	68 1c 75 12 00       	push   $0x12751c
  114fd3:	e8 9e e5 fe ff       	call   103576 <log_1>
  114fd8:	83 c4 0c             	add    $0xc,%esp
  114fdb:	eb 29                	jmp    115006 <notify_message_reply_cb+0x8d>
			}
		} else {
			LOG_ERR("notify reply missing token -- ignored.");
  114fdd:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  114fe4:	74 20                	je     115006 <notify_message_reply_cb+0x8d>
  114fe6:	b8 20 31 12 00       	mov    $0x123120,%eax
  114feb:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  114ff0:	c1 e8 03             	shr    $0x3,%eax
  114ff3:	c1 e0 06             	shl    $0x6,%eax
  114ff6:	83 c8 01             	or     $0x1,%eax
  114ff9:	50                   	push   %eax
  114ffa:	68 35 75 12 00       	push   $0x127535
  114fff:	e8 49 e5 fe ff       	call   10354d <log_0>
  115004:	58                   	pop    %eax
  115005:	5a                   	pop    %edx
		}
	}

	return 0;
}
  115006:	8d 65 f4             	lea    -0xc(%ebp),%esp
  115009:	31 c0                	xor    %eax,%eax
  11500b:	5b                   	pop    %ebx
  11500c:	5e                   	pop    %esi
  11500d:	5f                   	pop    %edi
  11500e:	5d                   	pop    %ebp
  11500f:	c3                   	ret    

00115010 <print_attr.constprop.0>:
static int print_attr(struct lwm2m_output_context *out,
  115010:	55                   	push   %ebp
  115011:	89 e5                	mov    %esp,%ebp
  115013:	57                   	push   %edi
  115014:	56                   	push   %esi
  115015:	53                   	push   %ebx
  115016:	bb 40 ce 12 00       	mov    $0x12ce40,%ebx
  11501b:	83 ec 08             	sub    $0x8,%esp
  11501e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  115021:	89 55 ec             	mov    %edx,-0x14(%ebp)
		if (ref != write_attr_pool[i].ref) {
  115024:	8b 45 ec             	mov    -0x14(%ebp),%eax
  115027:	39 03                	cmp    %eax,(%ebx)
  115029:	74 13                	je     11503e <print_attr.constprop.0+0x2e>
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
  11502b:	83 c3 10             	add    $0x10,%ebx
  11502e:	b8 80 cf 12 00       	mov    $0x12cf80,%eax
  115033:	39 d8                	cmp    %ebx,%eax
  115035:	75 ed                	jne    115024 <print_attr.constprop.0+0x14>
	return 0;
  115037:	31 c0                	xor    %eax,%eax
  115039:	e9 bd 00 00 00       	jmp    1150fb <print_attr.constprop.0+0xeb>
				attr->float_val.val2 != 0 ? "." : "");
  11503e:	8b 43 08             	mov    0x8(%ebx),%eax
		used = snprintk(buf, buflen, ";%s=%s%d%s",
  115041:	b9 70 49 12 00       	mov    $0x124970,%ecx
  115046:	85 c0                	test   %eax,%eax
  115048:	75 05                	jne    11504f <print_attr.constprop.0+0x3f>
  11504a:	b9 02 4e 12 00       	mov    $0x124e02,%ecx
  11504f:	8b 53 04             	mov    0x4(%ebx),%edx
				attr->float_val.val1 == 0 &&
  115052:	85 c0                	test   %eax,%eax
  115054:	79 09                	jns    11505f <print_attr.constprop.0+0x4f>
		used = snprintk(buf, buflen, ";%s=%s%d%s",
  115056:	b8 5c 75 12 00       	mov    $0x12755c,%eax
				attr->float_val.val1 == 0 &&
  11505b:	85 d2                	test   %edx,%edx
  11505d:	74 05                	je     115064 <print_attr.constprop.0+0x54>
		used = snprintk(buf, buflen, ";%s=%s%d%s",
  11505f:	b8 02 4e 12 00       	mov    $0x124e02,%eax
  115064:	51                   	push   %ecx
		base = 100000;
  115065:	be a0 86 01 00       	mov    $0x186a0,%esi
		used = snprintk(buf, buflen, ";%s=%s%d%s",
  11506a:	52                   	push   %edx
  11506b:	50                   	push   %eax
				LWM2M_ATTR_STR[attr->type],
  11506c:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
		used = snprintk(buf, buflen, ";%s=%s%d%s",
  115070:	ff 34 85 8c 45 12 00 	pushl  0x12458c(,%eax,4)
  115077:	68 5e 75 12 00       	push   $0x12755e
  11507c:	6a 18                	push   $0x18
  11507e:	68 54 ec 12 00       	push   $0x12ec54
  115083:	e8 77 c2 fe ff       	call   1012ff <snprintk>
  115088:	89 c1                	mov    %eax,%ecx
		fraction = attr->float_val.val2 < 0 ?
  11508a:	8b 43 08             	mov    0x8(%ebx),%eax
  11508d:	c1 f8 1f             	sar    $0x1f,%eax
  115090:	8b 7b 08             	mov    0x8(%ebx),%edi
  115093:	31 c7                	xor    %eax,%edi
		used = snprintk(buf, buflen, ";%s=%s%d%s",
  115095:	83 c4 1c             	add    $0x1c,%esp
		fraction = attr->float_val.val2 < 0 ?
  115098:	29 c7                	sub    %eax,%edi
		while (fraction && used < buflen && base > 0) {
  11509a:	85 ff                	test   %edi,%edi
  11509c:	0f 95 c2             	setne  %dl
  11509f:	83 f9 17             	cmp    $0x17,%ecx
  1150a2:	0f 9e c0             	setle  %al
  1150a5:	84 c2                	test   %al,%dl
  1150a7:	74 29                	je     1150d2 <print_attr.constprop.0+0xc2>
  1150a9:	85 f6                	test   %esi,%esi
  1150ab:	7e 25                	jle    1150d2 <print_attr.constprop.0+0xc2>
			digit = fraction / base;
  1150ad:	89 f8                	mov    %edi,%eax
			buf[used++] = '0' + digit;
  1150af:	41                   	inc    %ecx
			digit = fraction / base;
  1150b0:	99                   	cltd   
  1150b1:	f7 fe                	idiv   %esi
			buf[used++] = '0' + digit;
  1150b3:	8d 50 30             	lea    0x30(%eax),%edx
			fraction -= digit * base;
  1150b6:	0f b6 c0             	movzbl %al,%eax
  1150b9:	0f af c6             	imul   %esi,%eax
  1150bc:	29 c7                	sub    %eax,%edi
			base /= 10;
  1150be:	89 f0                	mov    %esi,%eax
			buf[used++] = '0' + digit;
  1150c0:	88 91 53 ec 12 00    	mov    %dl,0x12ec53(%ecx)
			base /= 10;
  1150c6:	be 0a 00 00 00       	mov    $0xa,%esi
  1150cb:	99                   	cltd   
  1150cc:	f7 fe                	idiv   %esi
  1150ce:	89 c6                	mov    %eax,%esi
  1150d0:	eb c8                	jmp    11509a <print_attr.constprop.0+0x8a>
		ret = buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, used);
  1150d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1150d5:	0f b7 c9             	movzwl %cx,%ecx
  1150d8:	8b 70 04             	mov    0x4(%eax),%esi
  1150db:	0f b7 7e 06          	movzwl 0x6(%esi),%edi
  1150df:	8d 56 04             	lea    0x4(%esi),%edx
  1150e2:	51                   	push   %ecx
  1150e3:	8b 06                	mov    (%esi),%eax
  1150e5:	89 f9                	mov    %edi,%ecx
  1150e7:	68 54 ec 12 00       	push   $0x12ec54
  1150ec:	e8 27 fc ff ff       	call   114d18 <buf_append>
  1150f1:	5a                   	pop    %edx
		if (ret < 0) {
  1150f2:	85 c0                	test   %eax,%eax
		ret = buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, used);
  1150f4:	59                   	pop    %ecx
		if (ret < 0) {
  1150f5:	0f 89 30 ff ff ff    	jns    11502b <print_attr.constprop.0+0x1b>
}
  1150fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1150fe:	5b                   	pop    %ebx
  1150ff:	5e                   	pop    %esi
  115100:	5f                   	pop    %edi
  115101:	5d                   	pop    %ebp
  115102:	c3                   	ret    

00115103 <string_to_path.constprop.0>:
static int string_to_path(char *pathstr, struct lwm2m_obj_path *path,
  115103:	55                   	push   %ebp
  115104:	89 e5                	mov    %esp,%ebp
  115106:	57                   	push   %edi
  115107:	56                   	push   %esi
	int i, tokstart = -1, toklen;
  115108:	83 cf ff             	or     $0xffffffff,%edi
static int string_to_path(char *pathstr, struct lwm2m_obj_path *path,
  11510b:	53                   	push   %ebx
  11510c:	89 d3                	mov    %edx,%ebx
  11510e:	83 ec 0c             	sub    $0xc,%esp
  115111:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int end_index = strlen(pathstr) - 1;
  115114:	50                   	push   %eax
  115115:	e8 02 6c ff ff       	call   10bd1c <strlen>
	(void)memset(path, 0, sizeof(*path));
  11511a:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  115121:	6a 00                	push   $0x0
	int end_index = strlen(pathstr) - 1;
  115123:	48                   	dec    %eax
	(void)memset(path, 0, sizeof(*path));
  115124:	53                   	push   %ebx
	int end_index = strlen(pathstr) - 1;
  115125:	89 45 ec             	mov    %eax,-0x14(%ebp)
	(void)memset(path, 0, sizeof(*path));
  115128:	e8 2e 6d ff ff       	call   10be5b <memset>
  11512d:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i <= end_index; i++) {
  115130:	31 c9                	xor    %ecx,%ecx
  115132:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
  115135:	0f 8c ce 00 00 00    	jl     115209 <string_to_path.constprop.0+0x106>
		if (tokstart == -1) {
  11513b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11513e:	83 ff ff             	cmp    $0xffffffff,%edi
  115141:	8a 04 08             	mov    (%eax,%ecx,1),%al
  115144:	75 11                	jne    115157 <string_to_path.constprop.0+0x54>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
  115146:	0f b6 d0             	movzbl %al,%edx
  115149:	83 ea 30             	sub    $0x30,%edx
			if (!isdigit((unsigned char)pathstr[i])) {
  11514c:	83 fa 09             	cmp    $0x9,%edx
  11514f:	0f 87 ae 00 00 00    	ja     115203 <string_to_path.constprop.0+0x100>
  115155:	89 cf                	mov    %ecx,%edi
		if (pathstr[i] == delim || i == end_index) {
  115157:	3c 2f                	cmp    $0x2f,%al
  115159:	74 09                	je     115164 <string_to_path.constprop.0+0x61>
  11515b:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
  11515e:	0f 85 9f 00 00 00    	jne    115203 <string_to_path.constprop.0+0x100>
			toklen = i - tokstart + 1;
  115164:	89 ca                	mov    %ecx,%edx
  115166:	29 fa                	sub    %edi,%edx
			if (pathstr[i] == delim) {
  115168:	3c 2f                	cmp    $0x2f,%al
  11516a:	74 01                	je     11516d <string_to_path.constprop.0+0x6a>
			toklen = i - tokstart + 1;
  11516c:	42                   	inc    %edx
			if (toklen <= 0) {
  11516d:	85 d2                	test   %edx,%edx
  11516f:	0f 8e 8e 00 00 00    	jle    115203 <string_to_path.constprop.0+0x100>
	while (pos < buflen && isdigit(buf[pos])) {
  115175:	03 7d f0             	add    -0x10(%ebp),%edi
  115178:	0f b7 d2             	movzwl %dx,%edx
  11517b:	8d 04 17             	lea    (%edi,%edx,1),%eax
	uint16_t val = 0U;
  11517e:	31 d2                	xor    %edx,%edx
  115180:	89 45 e8             	mov    %eax,-0x18(%ebp)
	while (pos < buflen && isdigit(buf[pos])) {
  115183:	3b 7d e8             	cmp    -0x18(%ebp),%edi
  115186:	74 18                	je     1151a0 <string_to_path.constprop.0+0x9d>
  115188:	0f b6 07             	movzbl (%edi),%eax
  11518b:	0f b6 f0             	movzbl %al,%esi
  11518e:	83 ee 30             	sub    $0x30,%esi
  115191:	47                   	inc    %edi
  115192:	83 fe 09             	cmp    $0x9,%esi
  115195:	77 09                	ja     1151a0 <string_to_path.constprop.0+0x9d>
		val = val * 10U + (buf[pos] - '0');
  115197:	6b d2 0a             	imul   $0xa,%edx,%edx
  11519a:	8d 54 02 d0          	lea    -0x30(%edx,%eax,1),%edx
		pos++;
  11519e:	eb e3                	jmp    115183 <string_to_path.constprop.0+0x80>
			switch (path->level) {
  1151a0:	0f b6 43 08          	movzbl 0x8(%ebx),%eax
  1151a4:	3c 02                	cmp    $0x2,%al
  1151a6:	74 1b                	je     1151c3 <string_to_path.constprop.0+0xc0>
  1151a8:	77 09                	ja     1151b3 <string_to_path.constprop.0+0xb0>
  1151aa:	84 c0                	test   %al,%al
  1151ac:	75 0f                	jne    1151bd <string_to_path.constprop.0+0xba>
				path->obj_id = value;
  1151ae:	66 89 13             	mov    %dx,(%ebx)
				break;
  1151b1:	eb 49                	jmp    1151fc <string_to_path.constprop.0+0xf9>
			switch (path->level) {
  1151b3:	3c 03                	cmp    $0x3,%al
  1151b5:	75 12                	jne    1151c9 <string_to_path.constprop.0+0xc6>
				path->res_inst_id = value;
  1151b7:	66 89 53 06          	mov    %dx,0x6(%ebx)
				break;
  1151bb:	eb 3f                	jmp    1151fc <string_to_path.constprop.0+0xf9>
				path->obj_inst_id = value;
  1151bd:	66 89 53 02          	mov    %dx,0x2(%ebx)
				break;
  1151c1:	eb 39                	jmp    1151fc <string_to_path.constprop.0+0xf9>
				path->res_id = value;
  1151c3:	66 89 53 04          	mov    %dx,0x4(%ebx)
				break;
  1151c7:	eb 33                	jmp    1151fc <string_to_path.constprop.0+0xf9>
				LOG_ERR("invalid level (%d)", path->level);
  1151c9:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
				return -EINVAL;
  1151d0:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
				LOG_ERR("invalid level (%d)", path->level);
  1151d5:	74 34                	je     11520b <string_to_path.constprop.0+0x108>
  1151d7:	ba 20 31 12 00       	mov    $0x123120,%edx
  1151dc:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  1151e2:	c1 ea 03             	shr    $0x3,%edx
  1151e5:	c1 e2 06             	shl    $0x6,%edx
  1151e8:	83 ca 01             	or     $0x1,%edx
  1151eb:	52                   	push   %edx
  1151ec:	50                   	push   %eax
  1151ed:	68 69 75 12 00       	push   $0x127569
  1151f2:	e8 7f e3 fe ff       	call   103576 <log_1>
  1151f7:	83 c4 0c             	add    $0xc,%esp
  1151fa:	eb 0f                	jmp    11520b <string_to_path.constprop.0+0x108>
			path->level++;
  1151fc:	40                   	inc    %eax
			tokstart = -1;
  1151fd:	83 cf ff             	or     $0xffffffff,%edi
			path->level++;
  115200:	88 43 08             	mov    %al,0x8(%ebx)
	for (i = 0; i <= end_index; i++) {
  115203:	41                   	inc    %ecx
  115204:	e9 29 ff ff ff       	jmp    115132 <string_to_path.constprop.0+0x2f>
	return 0;
  115209:	31 db                	xor    %ebx,%ebx
}
  11520b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11520e:	89 d8                	mov    %ebx,%eax
  115210:	5b                   	pop    %ebx
  115211:	5e                   	pop    %esi
  115212:	5f                   	pop    %edi
  115213:	5d                   	pop    %ebp
  115214:	c3                   	ret    

00115215 <lwm2m_engine_init>:
	lwm2m_engine_context_init(client_ctx);
	return lwm2m_socket_start(client_ctx);
}

static int lwm2m_engine_init(const struct device *dev)
{
  115215:	55                   	push   %ebp
  115216:	89 e5                	mov    %esp,%ebp
	int ret = 0;

	(void)memset(block1_contexts, 0, sizeof(block1_contexts));
  115218:	68 84 00 00 00       	push   $0x84
  11521d:	6a 00                	push   $0x0
  11521f:	68 80 cf 12 00       	push   $0x12cf80
  115224:	e8 32 6c ff ff       	call   10be5b <memset>
  115229:	83 c4 0c             	add    $0xc,%esp
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  11522c:	6a 00                	push   $0x0
  11522e:	6a 00                	push   $0x0
  115230:	6a 00                	push   $0x0
  115232:	6a ff                	push   $0xffffffff
  115234:	6a 00                	push   $0x0
  115236:	6a 00                	push   $0x0
  115238:	6a 00                	push   $0x0
  11523a:	68 e7 8d 11 00       	push   $0x118de7
  11523f:	68 00 0a 00 00       	push   $0xa00
  115244:	68 ec 3c 14 00       	push   $0x143cec
  115249:	68 20 d0 12 00       	push   $0x12d020
  11524e:	e8 83 c9 00 00       	call   121bd6 <z_impl_k_thread_create>
  115253:	83 c4 2c             	add    $0x2c,%esp
	return z_impl_k_thread_name_set(thread_id, value);
  115256:	68 7c 75 12 00       	push   $0x12757c
  11525b:	68 20 d0 12 00       	push   $0x12d020
  115260:	e8 c8 c7 00 00       	call   121a2d <z_impl_k_thread_name_set>
  115265:	58                   	pop    %eax
			0, K_NO_WAIT);
	k_thread_name_set(&engine_thread_data, "lwm2m-sock-recv");
	LOG_DBG("LWM2M engine socket receive thread started");

	return ret;
}
  115266:	31 c0                	xor    %eax,%eax
  115268:	5a                   	pop    %edx
  115269:	c9                   	leave  
  11526a:	c3                   	ret    

0011526b <lwm2m_default_block_size>:
}
  11526b:	b8 05 00 00 00       	mov    $0x5,%eax
  115270:	c3                   	ret    

00115271 <lwm2m_notify_observer>:
{
  115271:	55                   	push   %ebp
  115272:	89 e5                	mov    %esp,%ebp
  115274:	57                   	push   %edi
  115275:	56                   	push   %esi
  115276:	53                   	push   %ebx
  115277:	83 ec 08             	sub    $0x8,%esp
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  11527a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
{
  115281:	8b 75 08             	mov    0x8(%ebp),%esi
  115284:	8b 7d 0c             	mov    0xc(%ebp),%edi
  115287:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11528a:	8b 1d a4 ec 12 00    	mov    0x12eca4,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  115290:	85 db                	test   %ebx,%ebx
  115292:	74 30                	je     1152c4 <lwm2m_notify_observer+0x53>
		if (obs->path.obj_id == obj_id &&
  115294:	66 39 73 08          	cmp    %si,0x8(%ebx)
  115298:	75 26                	jne    1152c0 <lwm2m_notify_observer+0x4f>
  11529a:	66 39 7b 0a          	cmp    %di,0xa(%ebx)
  11529e:	75 20                	jne    1152c0 <lwm2m_notify_observer+0x4f>
		    obs->path.obj_inst_id == obj_inst_id &&
  1152a0:	80 7b 10 02          	cmpb   $0x2,0x10(%ebx)
  1152a4:	76 06                	jbe    1152ac <lwm2m_notify_observer+0x3b>
		    (obs->path.level < 3 ||
  1152a6:	66 39 4b 0c          	cmp    %cx,0xc(%ebx)
  1152aa:	75 14                	jne    1152c0 <lwm2m_notify_observer+0x4f>
  1152ac:	89 4d ec             	mov    %ecx,-0x14(%ebp)
			obs->event_timestamp = k_uptime_get();
  1152af:	e8 8e f9 ff ff       	call   114c42 <k_uptime_get>
			ret++;
  1152b4:	ff 45 f0             	incl   -0x10(%ebp)
			obs->event_timestamp = k_uptime_get();
  1152b7:	89 43 1c             	mov    %eax,0x1c(%ebx)
  1152ba:	89 53 20             	mov    %edx,0x20(%ebx)
			ret++;
  1152bd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1152c0:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  1152c2:	eb cc                	jmp    115290 <lwm2m_notify_observer+0x1f>
}
  1152c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1152c7:	5a                   	pop    %edx
  1152c8:	59                   	pop    %ecx
  1152c9:	5b                   	pop    %ebx
  1152ca:	5e                   	pop    %esi
  1152cb:	5f                   	pop    %edi
  1152cc:	5d                   	pop    %ebp
  1152cd:	c3                   	ret    

001152ce <lwm2m_notify_observer_path>:
{
  1152ce:	55                   	push   %ebp
  1152cf:	89 e5                	mov    %esp,%ebp
  1152d1:	8b 45 08             	mov    0x8(%ebp),%eax
	return lwm2m_notify_observer(path->obj_id, path->obj_inst_id,
  1152d4:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  1152d8:	52                   	push   %edx
  1152d9:	0f b7 50 02          	movzwl 0x2(%eax),%edx
  1152dd:	52                   	push   %edx
  1152de:	0f b7 00             	movzwl (%eax),%eax
  1152e1:	50                   	push   %eax
  1152e2:	e8 8a ff ff ff       	call   115271 <lwm2m_notify_observer>
  1152e7:	83 c4 0c             	add    $0xc,%esp
}
  1152ea:	c9                   	leave  
  1152eb:	c3                   	ret    

001152ec <lwm2m_register_obj>:
{
  1152ec:	55                   	push   %ebp
	sys_slist_append(&engine_obj_list, &obj->node);
  1152ed:	b8 b4 ec 12 00       	mov    $0x12ecb4,%eax
{
  1152f2:	89 e5                	mov    %esp,%ebp
	sys_slist_append(&engine_obj_list, &obj->node);
  1152f4:	8b 55 08             	mov    0x8(%ebp),%edx
}
  1152f7:	5d                   	pop    %ebp
	sys_slist_append(&engine_obj_list, &obj->node);
  1152f8:	e9 98 f7 ff ff       	jmp    114a95 <sys_slist_append>

001152fd <lwm2m_get_engine_obj_field>:
{
  1152fd:	55                   	push   %ebp
	return NULL;
  1152fe:	31 c0                	xor    %eax,%eax
{
  115300:	89 e5                	mov    %esp,%ebp
  115302:	53                   	push   %ebx
  115303:	8b 55 08             	mov    0x8(%ebp),%edx
	if (obj && obj->fields && obj->field_count > 0) {
  115306:	85 d2                	test   %edx,%edx
  115308:	74 24                	je     11532e <lwm2m_get_engine_obj_field+0x31>
  11530a:	8b 42 04             	mov    0x4(%edx),%eax
  11530d:	85 c0                	test   %eax,%eax
  11530f:	74 1d                	je     11532e <lwm2m_get_engine_obj_field+0x31>
  115311:	0f b7 52 1a          	movzwl 0x1a(%edx),%edx
  115315:	66 85 d2             	test   %dx,%dx
  115318:	74 12                	je     11532c <lwm2m_get_engine_obj_field+0x2f>
		for (i = 0; i < obj->field_count; i++) {
  11531a:	31 c9                	xor    %ecx,%ecx
			if (obj->fields[i].res_id == res_id) {
  11531c:	0f b7 18             	movzwl (%eax),%ebx
  11531f:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  115322:	74 0a                	je     11532e <lwm2m_get_engine_obj_field+0x31>
		for (i = 0; i < obj->field_count; i++) {
  115324:	41                   	inc    %ecx
  115325:	83 c0 04             	add    $0x4,%eax
  115328:	39 ca                	cmp    %ecx,%edx
  11532a:	7f f0                	jg     11531c <lwm2m_get_engine_obj_field+0x1f>
	return NULL;
  11532c:	31 c0                	xor    %eax,%eax
}
  11532e:	5b                   	pop    %ebx
  11532f:	5d                   	pop    %ebp
  115330:	c3                   	ret    

00115331 <path_to_objs>:
{
  115331:	55                   	push   %ebp
  115332:	89 e5                	mov    %esp,%ebp
  115334:	57                   	push   %edi
  115335:	56                   	push   %esi
  115336:	53                   	push   %ebx
		return -EINVAL;
  115337:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
{
  11533c:	83 ec 18             	sub    $0x18,%esp
  11533f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  115342:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	if (!path) {
  115345:	85 c0                	test   %eax,%eax
  115347:	0f 84 9a 01 00 00    	je     1154e7 <path_to_objs+0x1b6>
	oi = get_engine_obj_inst(path->obj_id, path->obj_inst_id);
  11534d:	0f b7 30             	movzwl (%eax),%esi
  115350:	0f b7 50 02          	movzwl 0x2(%eax),%edx
  115354:	89 c3                	mov    %eax,%ebx
  115356:	89 f0                	mov    %esi,%eax
  115358:	e8 c5 f7 ff ff       	call   114b22 <get_engine_obj_inst>
  11535d:	89 c7                	mov    %eax,%edi
	if (!oi) {
  11535f:	85 c0                	test   %eax,%eax
  115361:	75 3a                	jne    11539d <path_to_objs+0x6c>
		LOG_ERR("obj instance %d/%d not found",
  115363:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  11536a:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
		LOG_ERR("obj instance %d/%d not found",
  11536f:	0f 84 72 01 00 00    	je     1154e7 <path_to_objs+0x1b6>
  115375:	b8 20 31 12 00       	mov    $0x123120,%eax
  11537a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11537f:	c1 e8 03             	shr    $0x3,%eax
  115382:	c1 e0 06             	shl    $0x6,%eax
  115385:	83 c8 01             	or     $0x1,%eax
  115388:	50                   	push   %eax
  115389:	52                   	push   %edx
  11538a:	56                   	push   %esi
  11538b:	68 8c 75 12 00       	push   $0x12758c
  115390:	e8 1b e2 fe ff       	call   1035b0 <log_2>
  115395:	83 c4 10             	add    $0x10,%esp
  115398:	e9 4a 01 00 00       	jmp    1154e7 <path_to_objs+0x1b6>
	if (!oi->resources || oi->resource_count == 0U) {
  11539d:	8b 48 08             	mov    0x8(%eax),%ecx
  1153a0:	85 c9                	test   %ecx,%ecx
  1153a2:	74 09                	je     1153ad <path_to_objs+0x7c>
  1153a4:	66 8b 50 0e          	mov    0xe(%eax),%dx
  1153a8:	66 85 d2             	test   %dx,%dx
  1153ab:	75 37                	jne    1153e4 <path_to_objs+0xb3>
		LOG_ERR("obj instance has no resources");
  1153ad:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  1153b4:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("obj instance has no resources");
  1153b9:	0f 84 28 01 00 00    	je     1154e7 <path_to_objs+0x1b6>
  1153bf:	b8 20 31 12 00       	mov    $0x123120,%eax
  1153c4:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1153c9:	c1 e8 03             	shr    $0x3,%eax
  1153cc:	c1 e0 06             	shl    $0x6,%eax
  1153cf:	83 c8 01             	or     $0x1,%eax
  1153d2:	50                   	push   %eax
  1153d3:	68 a9 75 12 00       	push   $0x1275a9
  1153d8:	e8 70 e1 fe ff       	call   10354d <log_0>
  1153dd:	5e                   	pop    %esi
  1153de:	5f                   	pop    %edi
  1153df:	e9 03 01 00 00       	jmp    1154e7 <path_to_objs+0x1b6>
	of = lwm2m_get_engine_obj_field(oi->obj, path->res_id);
  1153e4:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  1153e8:	50                   	push   %eax
  1153e9:	89 55 dc             	mov    %edx,-0x24(%ebp)
  1153ec:	ff 77 04             	pushl  0x4(%edi)
  1153ef:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1153f2:	89 c6                	mov    %eax,%esi
  1153f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1153f7:	e8 01 ff ff ff       	call   1152fd <lwm2m_get_engine_obj_field>
  1153fc:	5a                   	pop    %edx
  1153fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  115400:	59                   	pop    %ecx
	for (i = 0; i < oi->resource_count; i++) {
  115401:	8b 55 dc             	mov    -0x24(%ebp),%edx
  115404:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  115407:	89 c8                	mov    %ecx,%eax
  115409:	31 c9                	xor    %ecx,%ecx
  11540b:	0f b7 d2             	movzwl %dx,%edx
	if (!of) {
  11540e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  115412:	75 43                	jne    115457 <path_to_objs+0x126>
		LOG_ERR("obj field %d not found", path->res_id);
  115414:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  11541b:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
		LOG_ERR("obj field %d not found", path->res_id);
  115420:	0f 84 c1 00 00 00    	je     1154e7 <path_to_objs+0x1b6>
  115426:	b8 20 31 12 00       	mov    $0x123120,%eax
  11542b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115430:	c1 e8 03             	shr    $0x3,%eax
  115433:	c1 e0 06             	shl    $0x6,%eax
  115436:	83 c8 01             	or     $0x1,%eax
  115439:	50                   	push   %eax
  11543a:	ff 75 e4             	pushl  -0x1c(%ebp)
  11543d:	68 c7 75 12 00       	push   $0x1275c7
  115442:	e8 2f e1 fe ff       	call   103576 <log_1>
  115447:	83 c4 0c             	add    $0xc,%esp
  11544a:	e9 98 00 00 00       	jmp    1154e7 <path_to_objs+0x1b6>
	for (i = 0; i < oi->resource_count; i++) {
  11544f:	41                   	inc    %ecx
  115450:	83 c0 18             	add    $0x18,%eax
  115453:	39 d1                	cmp    %edx,%ecx
  115455:	7d 60                	jge    1154b7 <path_to_objs+0x186>
		if (oi->resources[i].res_id == path->res_id) {
  115457:	66 3b 70 14          	cmp    0x14(%eax),%si
  11545b:	75 f2                	jne    11544f <path_to_objs+0x11e>
	for (i = 0; i < r->res_inst_count; i++) {
  11545d:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  115461:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  115464:	31 c9                	xor    %ecx,%ecx
  115466:	eb 11                	jmp    115479 <path_to_objs+0x148>
		if (r->res_instances[i].res_inst_id == path->res_inst_id) {
  115468:	6b d1 0c             	imul   $0xc,%ecx,%edx
  11546b:	03 50 10             	add    0x10(%eax),%edx
  11546e:	66 8b 73 06          	mov    0x6(%ebx),%si
  115472:	66 39 72 08          	cmp    %si,0x8(%edx)
  115476:	74 08                	je     115480 <path_to_objs+0x14f>
	for (i = 0; i < r->res_inst_count; i++) {
  115478:	41                   	inc    %ecx
  115479:	3b 4d e4             	cmp    -0x1c(%ebp),%ecx
  11547c:	7c ea                	jl     115468 <path_to_objs+0x137>
	struct lwm2m_engine_res_inst *ri = NULL;
  11547e:	31 d2                	xor    %edx,%edx
	if (obj_inst) {
  115480:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  115484:	74 05                	je     11548b <path_to_objs+0x15a>
		*obj_inst = oi;
  115486:	8b 75 ec             	mov    -0x14(%ebp),%esi
  115489:	89 3e                	mov    %edi,(%esi)
	if (obj_field) {
  11548b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  11548f:	74 08                	je     115499 <path_to_objs+0x168>
		*obj_field = of;
  115491:	8b 7d e8             	mov    -0x18(%ebp),%edi
  115494:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  115497:	89 0f                	mov    %ecx,(%edi)
	if (res) {
  115499:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  11549d:	74 05                	je     1154a4 <path_to_objs+0x173>
		*res = r;
  11549f:	8b 7d 08             	mov    0x8(%ebp),%edi
  1154a2:	89 07                	mov    %eax,(%edi)
	if (ri && res_inst) {
  1154a4:	85 d2                	test   %edx,%edx
  1154a6:	74 0b                	je     1154b3 <path_to_objs+0x182>
  1154a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1154ac:	74 05                	je     1154b3 <path_to_objs+0x182>
		*res_inst = ri;
  1154ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  1154b1:	89 10                	mov    %edx,(%eax)
	return 0;
  1154b3:	31 db                	xor    %ebx,%ebx
  1154b5:	eb 30                	jmp    1154e7 <path_to_objs+0x1b6>
		LOG_ERR("resource %d not found", path->res_id);
  1154b7:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1154be:	74 22                	je     1154e2 <path_to_objs+0x1b1>
  1154c0:	b8 20 31 12 00       	mov    $0x123120,%eax
  1154c5:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1154ca:	c1 e8 03             	shr    $0x3,%eax
  1154cd:	c1 e0 06             	shl    $0x6,%eax
  1154d0:	83 c8 01             	or     $0x1,%eax
  1154d3:	50                   	push   %eax
  1154d4:	56                   	push   %esi
  1154d5:	68 de 75 12 00       	push   $0x1275de
  1154da:	e8 97 e0 fe ff       	call   103576 <log_1>
  1154df:	83 c4 0c             	add    $0xc,%esp
		return -ENOENT;
  1154e2:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
}
  1154e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1154ea:	89 d8                	mov    %ebx,%eax
  1154ec:	5b                   	pop    %ebx
  1154ed:	5e                   	pop    %esi
  1154ee:	5f                   	pop    %edi
  1154ef:	5d                   	pop    %ebp
  1154f0:	c3                   	ret    

001154f1 <lwm2m_engine_set>:
{
  1154f1:	55                   	push   %ebp
  1154f2:	89 e5                	mov    %esp,%ebp
  1154f4:	57                   	push   %edi
  1154f5:	56                   	push   %esi
  1154f6:	89 d6                	mov    %edx,%esi
  1154f8:	53                   	push   %ebx
	ret = string_to_path(pathstr, &path, '/');
  1154f9:	8d 55 d6             	lea    -0x2a(%ebp),%edx
{
  1154fc:	83 ec 40             	sub    $0x40,%esp
  1154ff:	89 4d b8             	mov    %ecx,-0x48(%ebp)
	struct lwm2m_engine_res *res = NULL;
  115502:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	struct lwm2m_engine_res_inst *res_inst = NULL;
  115509:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	size_t max_data_len = 0;
  115510:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	ret = string_to_path(pathstr, &path, '/');
  115517:	e8 e7 fb ff ff       	call   115103 <string_to_path.constprop.0>
  11551c:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
  11551e:	85 c0                	test   %eax,%eax
  115520:	0f 88 04 03 00 00    	js     11582a <lwm2m_engine_set+0x339>
	if (path.level < 3) {
  115526:	80 7d de 02          	cmpb   $0x2,-0x22(%ebp)
  11552a:	77 33                	ja     11555f <lwm2m_engine_set+0x6e>
		LOG_ERR("path must have at least 3 parts");
  11552c:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115533:	74 20                	je     115555 <lwm2m_engine_set+0x64>
  115535:	b8 20 31 12 00       	mov    $0x123120,%eax
  11553a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11553f:	c1 e8 03             	shr    $0x3,%eax
  115542:	c1 e0 06             	shl    $0x6,%eax
  115545:	83 c8 01             	or     $0x1,%eax
  115548:	50                   	push   %eax
  115549:	68 f4 75 12 00       	push   $0x1275f4
  11554e:	e8 fa df fe ff       	call   10354d <log_0>
  115553:	5b                   	pop    %ebx
  115554:	5e                   	pop    %esi
		return -EINVAL;
  115555:	bf ea ff ff ff       	mov    $0xffffffea,%edi
  11555a:	e9 cb 02 00 00       	jmp    11582a <lwm2m_engine_set+0x339>
	ret = path_to_objs(&path, &obj_inst, &obj_field, &res, &res_inst);
  11555f:	8d 45 cc             	lea    -0x34(%ebp),%eax
  115562:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  115565:	50                   	push   %eax
  115566:	8d 45 c8             	lea    -0x38(%ebp),%eax
  115569:	50                   	push   %eax
  11556a:	8d 55 c0             	lea    -0x40(%ebp),%edx
  11556d:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  115570:	e8 bc fd ff ff       	call   115331 <path_to_objs>
  115575:	5a                   	pop    %edx
  115576:	59                   	pop    %ecx
  115577:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
  115579:	85 c0                	test   %eax,%eax
  11557b:	0f 88 a9 02 00 00    	js     11582a <lwm2m_engine_set+0x339>
	if (!res_inst) {
  115581:	8b 45 cc             	mov    -0x34(%ebp),%eax
  115584:	85 c0                	test   %eax,%eax
  115586:	75 3d                	jne    1155c5 <lwm2m_engine_set+0xd4>
		LOG_ERR("res instance %d not found", path.res_inst_id);
  115588:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  11558f:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
		LOG_ERR("res instance %d not found", path.res_inst_id);
  115594:	0f 84 90 02 00 00    	je     11582a <lwm2m_engine_set+0x339>
  11559a:	b8 20 31 12 00       	mov    $0x123120,%eax
  11559f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1155a4:	c1 e8 03             	shr    $0x3,%eax
  1155a7:	c1 e0 06             	shl    $0x6,%eax
  1155aa:	83 c8 01             	or     $0x1,%eax
  1155ad:	50                   	push   %eax
  1155ae:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  1155b2:	50                   	push   %eax
  1155b3:	68 14 76 12 00       	push   $0x127614
  1155b8:	e8 b9 df fe ff       	call   103576 <log_1>
  1155bd:	83 c4 0c             	add    $0xc,%esp
  1155c0:	e9 65 02 00 00       	jmp    11582a <lwm2m_engine_set+0x339>
	if (LWM2M_HAS_RES_FLAG(res_inst, LWM2M_RES_DATA_FLAG_RO)) {
  1155c5:	f6 40 0a 01          	testb  $0x1,0xa(%eax)
  1155c9:	74 5e                	je     115629 <lwm2m_engine_set+0x138>
		LOG_ERR("res instance data pointer is read-only "
  1155cb:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EACCES;
  1155d2:	bf f3 ff ff ff       	mov    $0xfffffff3,%edi
		LOG_ERR("res instance data pointer is read-only "
  1155d7:	0f 84 4d 02 00 00    	je     11582a <lwm2m_engine_set+0x339>
  1155dd:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  1155e1:	b8 20 31 12 00       	mov    $0x123120,%eax
  1155e6:	89 55 e0             	mov    %edx,-0x20(%ebp)
  1155e9:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  1155ed:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1155f2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1155f5:	c1 e8 03             	shr    $0x3,%eax
  1155f8:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  1155fc:	c1 e0 06             	shl    $0x6,%eax
  1155ff:	89 55 e8             	mov    %edx,-0x18(%ebp)
  115602:	83 c8 01             	or     $0x1,%eax
  115605:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  115609:	50                   	push   %eax
  11560a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  11560d:	6a 05                	push   $0x5
  11560f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  115612:	0f b6 55 de          	movzbl -0x22(%ebp),%edx
  115616:	50                   	push   %eax
  115617:	89 55 f0             	mov    %edx,-0x10(%ebp)
  11561a:	68 2e 76 12 00       	push   $0x12762e
  11561f:	e8 2e e0 fe ff       	call   103652 <log_n>
  115624:	e9 ea 00 00 00       	jmp    115713 <lwm2m_engine_set+0x222>
	max_data_len = res_inst->max_data_len;
  115629:	0f b7 50 04          	movzwl 0x4(%eax),%edx
	if (res->pre_write_cb) {
  11562d:	8b 4d c8             	mov    -0x38(%ebp),%ecx
	data_ptr = res_inst->data_ptr;
  115630:	8b 18                	mov    (%eax),%ebx
	max_data_len = res_inst->max_data_len;
  115632:	89 55 d0             	mov    %edx,-0x30(%ebp)
	if (res->pre_write_cb) {
  115635:	8b 51 04             	mov    0x4(%ecx),%edx
  115638:	85 d2                	test   %edx,%edx
  11563a:	74 1d                	je     115659 <lwm2m_engine_set+0x168>
		data_ptr = res->pre_write_cb(obj_inst->obj_inst_id,
  11563c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  115640:	8d 5d d0             	lea    -0x30(%ebp),%ebx
  115643:	53                   	push   %ebx
  115644:	50                   	push   %eax
  115645:	0f b7 41 14          	movzwl 0x14(%ecx),%eax
  115649:	50                   	push   %eax
  11564a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  11564d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  115651:	50                   	push   %eax
  115652:	ff d2                	call   *%edx
  115654:	83 c4 10             	add    $0x10,%esp
  115657:	89 c3                	mov    %eax,%ebx
	if (!data_ptr) {
  115659:	85 db                	test   %ebx,%ebx
  11565b:	75 5c                	jne    1156b9 <lwm2m_engine_set+0x1c8>
		LOG_ERR("res instance data pointer is NULL [%u/%u/%u/%u:%u]",
  11565d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115664:	0f 84 eb fe ff ff    	je     115555 <lwm2m_engine_set+0x64>
  11566a:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  11566e:	b8 20 31 12 00       	mov    $0x123120,%eax
  115673:	89 55 e0             	mov    %edx,-0x20(%ebp)
  115676:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11567b:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  11567f:	c1 e8 03             	shr    $0x3,%eax
  115682:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  115685:	c1 e0 06             	shl    $0x6,%eax
  115688:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
  11568c:	83 c8 01             	or     $0x1,%eax
  11568f:	89 55 e8             	mov    %edx,-0x18(%ebp)
  115692:	50                   	push   %eax
  115693:	8d 45 e0             	lea    -0x20(%ebp),%eax
  115696:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  11569a:	6a 05                	push   $0x5
  11569c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  11569f:	50                   	push   %eax
  1156a0:	0f b6 55 de          	movzbl -0x22(%ebp),%edx
  1156a4:	68 66 76 12 00       	push   $0x127666
  1156a9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1156ac:	e8 a1 df fe ff       	call   103652 <log_n>
  1156b1:	83 c4 10             	add    $0x10,%esp
  1156b4:	e9 9c fe ff ff       	jmp    115555 <lwm2m_engine_set+0x64>
	if (len > res_inst->max_data_len -
  1156b9:	0f b7 45 b8          	movzwl -0x48(%ebp),%eax
		(obj_field->data_type == LWM2M_RES_TYPE_STRING ? 1 : 0)) {
  1156bd:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
	if (len > res_inst->max_data_len -
  1156c0:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1156c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
		(obj_field->data_type == LWM2M_RES_TYPE_STRING ? 1 : 0)) {
  1156c6:	80 79 03 02          	cmpb   $0x2,0x3(%ecx)
	if (len > res_inst->max_data_len -
  1156ca:	0f b7 40 04          	movzwl 0x4(%eax),%eax
		(obj_field->data_type == LWM2M_RES_TYPE_STRING ? 1 : 0)) {
  1156ce:	0f 94 c1             	sete   %cl
  1156d1:	0f b6 c9             	movzbl %cl,%ecx
	if (len > res_inst->max_data_len -
  1156d4:	29 c8                	sub    %ecx,%eax
  1156d6:	39 45 bc             	cmp    %eax,-0x44(%ebp)
  1156d9:	7e 40                	jle    11571b <lwm2m_engine_set+0x22a>
		LOG_ERR("length %u is too long for res instance %d data",
  1156db:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOMEM;
  1156e2:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("length %u is too long for res instance %d data",
  1156e7:	0f 84 3d 01 00 00    	je     11582a <lwm2m_engine_set+0x339>
  1156ed:	b8 20 31 12 00       	mov    $0x123120,%eax
  1156f2:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1156f7:	c1 e8 03             	shr    $0x3,%eax
  1156fa:	c1 e0 06             	shl    $0x6,%eax
  1156fd:	83 c8 01             	or     $0x1,%eax
  115700:	50                   	push   %eax
  115701:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  115705:	50                   	push   %eax
  115706:	ff 75 bc             	pushl  -0x44(%ebp)
  115709:	68 99 76 12 00       	push   $0x127699
  11570e:	e8 9d de fe ff       	call   1035b0 <log_2>
  115713:	83 c4 10             	add    $0x10,%esp
  115716:	e9 0f 01 00 00       	jmp    11582a <lwm2m_engine_set+0x339>
	if (memcmp(data_ptr, value, len) !=  0) {
  11571b:	ff 75 bc             	pushl  -0x44(%ebp)
  11571e:	56                   	push   %esi
  11571f:	53                   	push   %ebx
  115720:	e8 5a 66 ff ff       	call   10bd7f <memcmp>
  115725:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	switch (obj_field->data_type) {
  115728:	8b 45 c4             	mov    -0x3c(%ebp),%eax
	if (memcmp(data_ptr, value, len) !=  0) {
  11572b:	83 c4 0c             	add    $0xc,%esp
	switch (obj_field->data_type) {
  11572e:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  115732:	8d 48 ff             	lea    -0x1(%eax),%ecx
  115735:	80 f9 0e             	cmp    $0xe,%cl
  115738:	77 76                	ja     1157b0 <lwm2m_engine_set+0x2bf>
  11573a:	0f b6 c9             	movzbl %cl,%ecx
  11573d:	ff 24 8d 6c 44 12 00 	jmp    *0x12446c(,%ecx,4)
		memcpy((uint8_t *)data_ptr, value, len);
  115744:	ff 75 bc             	pushl  -0x44(%ebp)
  115747:	56                   	push   %esi
  115748:	53                   	push   %ebx
  115749:	e8 9e 66 ff ff       	call   10bdec <memcpy>
  11574e:	83 c4 0c             	add    $0xc,%esp
		break;
  115751:	e9 8f 00 00 00       	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		memcpy((uint8_t *)data_ptr, value, len);
  115756:	ff 75 bc             	pushl  -0x44(%ebp)
  115759:	56                   	push   %esi
  11575a:	53                   	push   %ebx
  11575b:	e8 8c 66 ff ff       	call   10bdec <memcpy>
		((uint8_t *)data_ptr)[len] = '\0';
  115760:	8b 45 bc             	mov    -0x44(%ebp),%eax
		memcpy((uint8_t *)data_ptr, value, len);
  115763:	83 c4 0c             	add    $0xc,%esp
		((uint8_t *)data_ptr)[len] = '\0';
  115766:	c6 04 03 00          	movb   $0x0,(%ebx,%eax,1)
		break;
  11576a:	eb 79                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		*((int64_t *)data_ptr) = *(int64_t *)value;
  11576c:	8b 06                	mov    (%esi),%eax
  11576e:	8b 56 04             	mov    0x4(%esi),%edx
  115771:	89 53 04             	mov    %edx,0x4(%ebx)
  115774:	89 03                	mov    %eax,(%ebx)
		break;
  115776:	eb 6d                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		*((int16_t *)data_ptr) = *(int16_t *)value;
  115778:	66 8b 06             	mov    (%esi),%ax
  11577b:	66 89 03             	mov    %ax,(%ebx)
		break;
  11577e:	eb 65                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		*((bool *)data_ptr) = *(bool *)value;
  115780:	8a 06                	mov    (%esi),%al
  115782:	88 03                	mov    %al,(%ebx)
		break;
  115784:	eb 5f                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
				((float32_value_t *)value)->val1;
  115786:	8b 06                	mov    (%esi),%eax
		((float32_value_t *)data_ptr)->val1 =
  115788:	89 03                	mov    %eax,(%ebx)
				((float32_value_t *)value)->val2;
  11578a:	8b 46 04             	mov    0x4(%esi),%eax
		((float32_value_t *)data_ptr)->val2 =
  11578d:	89 43 04             	mov    %eax,0x4(%ebx)
		break;
  115790:	eb 53                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		((float64_value_t *)data_ptr)->val1 =
  115792:	8b 56 04             	mov    0x4(%esi),%edx
  115795:	8b 06                	mov    (%esi),%eax
  115797:	89 53 04             	mov    %edx,0x4(%ebx)
  11579a:	89 03                	mov    %eax,(%ebx)
				((float64_value_t *)value)->val2;
  11579c:	8b 56 0c             	mov    0xc(%esi),%edx
  11579f:	8b 46 08             	mov    0x8(%esi),%eax
  1157a2:	89 43 08             	mov    %eax,0x8(%ebx)
  1157a5:	89 53 0c             	mov    %edx,0xc(%ebx)
		break;
  1157a8:	eb 3b                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		*((struct lwm2m_objlnk *)data_ptr) =
  1157aa:	8b 06                	mov    (%esi),%eax
  1157ac:	89 03                	mov    %eax,(%ebx)
		break;
  1157ae:	eb 35                	jmp    1157e5 <lwm2m_engine_set+0x2f4>
		LOG_ERR("unknown obj data_type %d", obj_field->data_type);
  1157b0:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1157b7:	0f 84 98 fd ff ff    	je     115555 <lwm2m_engine_set+0x64>
  1157bd:	ba 20 31 12 00       	mov    $0x123120,%edx
  1157c2:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  1157c8:	c1 ea 03             	shr    $0x3,%edx
  1157cb:	c1 e2 06             	shl    $0x6,%edx
  1157ce:	83 ca 01             	or     $0x1,%edx
  1157d1:	52                   	push   %edx
  1157d2:	50                   	push   %eax
  1157d3:	68 c8 76 12 00       	push   $0x1276c8
  1157d8:	e8 99 dd fe ff       	call   103576 <log_1>
  1157dd:	83 c4 0c             	add    $0xc,%esp
  1157e0:	e9 70 fd ff ff       	jmp    115555 <lwm2m_engine_set+0x64>
	res_inst->data_len = len;
  1157e5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
	if (res->post_write_cb) {
  1157e8:	8b 75 c8             	mov    -0x38(%ebp),%esi
	res_inst->data_len = len;
  1157eb:	8b 45 b8             	mov    -0x48(%ebp),%eax
  1157ee:	66 89 41 06          	mov    %ax,0x6(%ecx)
	if (res->post_write_cb) {
  1157f2:	8b 46 08             	mov    0x8(%esi),%eax
  1157f5:	85 c0                	test   %eax,%eax
  1157f7:	74 21                	je     11581a <lwm2m_engine_set+0x329>
		ret = res->post_write_cb(obj_inst->obj_inst_id,
  1157f9:	6a 00                	push   $0x0
  1157fb:	6a 00                	push   $0x0
  1157fd:	ff 75 bc             	pushl  -0x44(%ebp)
  115800:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  115804:	53                   	push   %ebx
  115805:	52                   	push   %edx
  115806:	0f b7 56 14          	movzwl 0x14(%esi),%edx
  11580a:	52                   	push   %edx
  11580b:	8b 55 c0             	mov    -0x40(%ebp),%edx
  11580e:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  115812:	52                   	push   %edx
  115813:	ff d0                	call   *%eax
  115815:	83 c4 1c             	add    $0x1c,%esp
  115818:	89 c7                	mov    %eax,%edi
	if (changed) {
  11581a:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  11581e:	74 0a                	je     11582a <lwm2m_engine_set+0x339>
		NOTIFY_OBSERVER_PATH(&path);
  115820:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  115823:	50                   	push   %eax
  115824:	e8 a5 fa ff ff       	call   1152ce <lwm2m_notify_observer_path>
  115829:	58                   	pop    %eax
}
  11582a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11582d:	89 f8                	mov    %edi,%eax
  11582f:	5b                   	pop    %ebx
  115830:	5e                   	pop    %esi
  115831:	5f                   	pop    %edi
  115832:	5d                   	pop    %ebp
  115833:	c3                   	ret    

00115834 <lwm2m_engine_get>:
{
  115834:	55                   	push   %ebp
  115835:	89 e5                	mov    %esp,%ebp
  115837:	57                   	push   %edi
  115838:	56                   	push   %esi
  115839:	89 ce                	mov    %ecx,%esi
  11583b:	53                   	push   %ebx
  11583c:	89 d3                	mov    %edx,%ebx
  11583e:	83 ec 24             	sub    $0x24,%esp
	ret = string_to_path(pathstr, &path, '/');
  115841:	8d 55 ea             	lea    -0x16(%ebp),%edx
	struct lwm2m_engine_res *res = NULL;
  115844:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	struct lwm2m_engine_res_inst *res_inst = NULL;
  11584b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	size_t data_len = 0;
  115852:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	ret = string_to_path(pathstr, &path, '/');
  115859:	e8 a5 f8 ff ff       	call   115103 <string_to_path.constprop.0>
	if (ret < 0) {
  11585e:	85 c0                	test   %eax,%eax
  115860:	0f 88 9f 01 00 00    	js     115a05 <lwm2m_engine_get+0x1d1>
	if (path.level < 3) {
  115866:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  11586a:	77 32                	ja     11589e <lwm2m_engine_get+0x6a>
		LOG_ERR("path must have at least 3 parts");
  11586c:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115873:	0f 84 87 01 00 00    	je     115a00 <lwm2m_engine_get+0x1cc>
  115879:	b8 20 31 12 00       	mov    $0x123120,%eax
  11587e:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115883:	c1 e8 03             	shr    $0x3,%eax
  115886:	c1 e0 06             	shl    $0x6,%eax
  115889:	83 c8 01             	or     $0x1,%eax
  11588c:	50                   	push   %eax
  11588d:	68 f4 75 12 00       	push   $0x1275f4
  115892:	e8 b6 dc fe ff       	call   10354d <log_0>
  115897:	5b                   	pop    %ebx
  115898:	5e                   	pop    %esi
  115899:	e9 62 01 00 00       	jmp    115a00 <lwm2m_engine_get+0x1cc>
	ret = path_to_objs(&path, &obj_inst, &obj_field, &res, &res_inst);
  11589e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  1158a1:	8d 4d d8             	lea    -0x28(%ebp),%ecx
  1158a4:	50                   	push   %eax
  1158a5:	8d 45 dc             	lea    -0x24(%ebp),%eax
  1158a8:	50                   	push   %eax
  1158a9:	8d 55 d4             	lea    -0x2c(%ebp),%edx
  1158ac:	8d 45 ea             	lea    -0x16(%ebp),%eax
  1158af:	e8 7d fa ff ff       	call   115331 <path_to_objs>
  1158b4:	5a                   	pop    %edx
  1158b5:	59                   	pop    %ecx
	if (ret < 0) {
  1158b6:	85 c0                	test   %eax,%eax
  1158b8:	0f 88 47 01 00 00    	js     115a05 <lwm2m_engine_get+0x1d1>
	if (!res_inst) {
  1158be:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1158c1:	85 c0                	test   %eax,%eax
  1158c3:	75 44                	jne    115909 <lwm2m_engine_get+0xd5>
		LOG_ERR("res instance %d not found", path.res_inst_id);
  1158c5:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  1158cc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		LOG_ERR("res instance %d not found", path.res_inst_id);
  1158d1:	0f 84 2e 01 00 00    	je     115a05 <lwm2m_engine_get+0x1d1>
  1158d7:	ba 20 31 12 00       	mov    $0x123120,%edx
  1158dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1158df:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  1158e5:	c1 ea 03             	shr    $0x3,%edx
  1158e8:	c1 e2 06             	shl    $0x6,%edx
  1158eb:	83 ca 01             	or     $0x1,%edx
  1158ee:	52                   	push   %edx
  1158ef:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  1158f3:	52                   	push   %edx
  1158f4:	68 14 76 12 00       	push   $0x127614
  1158f9:	e8 78 dc fe ff       	call   103576 <log_1>
  1158fe:	83 c4 0c             	add    $0xc,%esp
  115901:	8b 45 d0             	mov    -0x30(%ebp),%eax
  115904:	e9 fc 00 00 00       	jmp    115a05 <lwm2m_engine_get+0x1d1>
	data_len = res_inst->data_len;
  115909:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
	if (res->read_cb) {
  11590d:	8b 7d dc             	mov    -0x24(%ebp),%edi
	data_ptr = res_inst->data_ptr;
  115910:	8b 10                	mov    (%eax),%edx
	data_len = res_inst->data_len;
  115912:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if (res->read_cb) {
  115915:	8b 0f                	mov    (%edi),%ecx
  115917:	85 c9                	test   %ecx,%ecx
  115919:	74 1d                	je     115938 <lwm2m_engine_get+0x104>
		data_ptr = res->read_cb(obj_inst->obj_inst_id,
  11591b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11591f:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  115922:	52                   	push   %edx
  115923:	50                   	push   %eax
  115924:	0f b7 47 14          	movzwl 0x14(%edi),%eax
  115928:	50                   	push   %eax
  115929:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  11592c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  115930:	50                   	push   %eax
  115931:	ff d1                	call   *%ecx
  115933:	83 c4 10             	add    $0x10,%esp
  115936:	89 c2                	mov    %eax,%edx
	return 0;
  115938:	31 c0                	xor    %eax,%eax
	if (data_ptr && data_len > 0) {
  11593a:	85 d2                	test   %edx,%edx
  11593c:	0f 84 c3 00 00 00    	je     115a05 <lwm2m_engine_get+0x1d1>
  115942:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  115945:	85 ff                	test   %edi,%edi
  115947:	0f 84 b8 00 00 00    	je     115a05 <lwm2m_engine_get+0x1d1>
		switch (obj_field->data_type) {
  11594d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  115950:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  115954:	8d 41 ff             	lea    -0x1(%ecx),%eax
  115957:	3c 0e                	cmp    $0xe,%al
  115959:	77 7a                	ja     1159d5 <lwm2m_engine_get+0x1a1>
  11595b:	0f b6 c0             	movzbl %al,%eax
  11595e:	ff 24 85 a8 44 12 00 	jmp    *0x1244a8(,%eax,4)
			if (data_len > buflen) {
  115965:	0f b7 f6             	movzwl %si,%esi
				return -ENOMEM;
  115968:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			if (data_len > buflen) {
  11596d:	39 f7                	cmp    %esi,%edi
  11596f:	0f 87 90 00 00 00    	ja     115a05 <lwm2m_engine_get+0x1d1>
			memcpy(buf, data_ptr, data_len);
  115975:	57                   	push   %edi
  115976:	52                   	push   %edx
  115977:	53                   	push   %ebx
  115978:	e8 6f 64 ff ff       	call   10bdec <memcpy>
  11597d:	eb 0b                	jmp    11598a <lwm2m_engine_get+0x156>
			strncpy((uint8_t *)buf, (uint8_t *)data_ptr, buflen);
  11597f:	0f b7 f6             	movzwl %si,%esi
  115982:	56                   	push   %esi
  115983:	52                   	push   %edx
  115984:	53                   	push   %ebx
  115985:	e8 1b 63 ff ff       	call   10bca5 <strncpy>
  11598a:	83 c4 0c             	add    $0xc,%esp
			break;
  11598d:	eb 42                	jmp    1159d1 <lwm2m_engine_get+0x19d>
			*(int64_t *)buf = *(int64_t *)data_ptr;
  11598f:	8b 02                	mov    (%edx),%eax
  115991:	8b 52 04             	mov    0x4(%edx),%edx
  115994:	89 53 04             	mov    %edx,0x4(%ebx)
  115997:	89 03                	mov    %eax,(%ebx)
  115999:	eb 36                	jmp    1159d1 <lwm2m_engine_get+0x19d>
			*(int16_t *)buf = *(int16_t *)data_ptr;
  11599b:	66 8b 02             	mov    (%edx),%ax
  11599e:	66 89 03             	mov    %ax,(%ebx)
			break;
  1159a1:	eb 2e                	jmp    1159d1 <lwm2m_engine_get+0x19d>
			*(bool *)buf = *(bool *)data_ptr;
  1159a3:	8a 02                	mov    (%edx),%al
  1159a5:	88 03                	mov    %al,(%ebx)
			break;
  1159a7:	eb 28                	jmp    1159d1 <lwm2m_engine_get+0x19d>
				((float32_value_t *)data_ptr)->val1;
  1159a9:	8b 02                	mov    (%edx),%eax
			((float32_value_t *)buf)->val1 =
  1159ab:	89 03                	mov    %eax,(%ebx)
				((float32_value_t *)data_ptr)->val2;
  1159ad:	8b 42 04             	mov    0x4(%edx),%eax
			((float32_value_t *)buf)->val2 =
  1159b0:	89 43 04             	mov    %eax,0x4(%ebx)
			break;
  1159b3:	eb 1c                	jmp    1159d1 <lwm2m_engine_get+0x19d>
			((float64_value_t *)buf)->val1 =
  1159b5:	8b 7a 04             	mov    0x4(%edx),%edi
  1159b8:	8b 32                	mov    (%edx),%esi
  1159ba:	89 7b 04             	mov    %edi,0x4(%ebx)
  1159bd:	89 33                	mov    %esi,(%ebx)
				((float64_value_t *)data_ptr)->val2;
  1159bf:	8b 42 08             	mov    0x8(%edx),%eax
  1159c2:	8b 52 0c             	mov    0xc(%edx),%edx
			((float64_value_t *)buf)->val2 =
  1159c5:	89 53 0c             	mov    %edx,0xc(%ebx)
  1159c8:	89 43 08             	mov    %eax,0x8(%ebx)
  1159cb:	eb 04                	jmp    1159d1 <lwm2m_engine_get+0x19d>
			*(struct lwm2m_objlnk *)buf =
  1159cd:	8b 02                	mov    (%edx),%eax
  1159cf:	89 03                	mov    %eax,(%ebx)
	return 0;
  1159d1:	31 c0                	xor    %eax,%eax
			break;
  1159d3:	eb 30                	jmp    115a05 <lwm2m_engine_get+0x1d1>
			LOG_ERR("unknown obj data_type %d",
  1159d5:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1159dc:	74 22                	je     115a00 <lwm2m_engine_get+0x1cc>
  1159de:	b8 20 31 12 00       	mov    $0x123120,%eax
  1159e3:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1159e8:	c1 e8 03             	shr    $0x3,%eax
  1159eb:	c1 e0 06             	shl    $0x6,%eax
  1159ee:	83 c8 01             	or     $0x1,%eax
  1159f1:	50                   	push   %eax
  1159f2:	51                   	push   %ecx
  1159f3:	68 c8 76 12 00       	push   $0x1276c8
  1159f8:	e8 79 db fe ff       	call   103576 <log_1>
  1159fd:	83 c4 0c             	add    $0xc,%esp
			return -EINVAL;
  115a00:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  115a05:	8d 65 f4             	lea    -0xc(%ebp),%esp
  115a08:	5b                   	pop    %ebx
  115a09:	5e                   	pop    %esi
  115a0a:	5f                   	pop    %edi
  115a0b:	5d                   	pop    %ebp
  115a0c:	c3                   	ret    

00115a0d <lwm2m_delete_obj_inst>:
{
  115a0d:	55                   	push   %ebp
  115a0e:	89 e5                	mov    %esp,%ebp
  115a10:	57                   	push   %edi
  115a11:	56                   	push   %esi
  115a12:	53                   	push   %ebx
		return -ENOENT;
  115a13:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
{
  115a18:	83 ec 08             	sub    $0x8,%esp
	obj = get_engine_obj(obj_id);
  115a1b:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  115a1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  115a22:	e8 e3 f0 ff ff       	call   114b0a <get_engine_obj>
{
  115a27:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!obj) {
  115a2a:	85 c0                	test   %eax,%eax
  115a2c:	0f 84 d5 00 00 00    	je     115b07 <lwm2m_delete_obj_inst+0xfa>
  115a32:	89 c7                	mov    %eax,%edi
	obj_inst = get_engine_obj_inst(obj_id, obj_inst_id);
  115a34:	0f b7 c6             	movzwl %si,%eax
  115a37:	89 45 f0             	mov    %eax,-0x10(%ebp)
  115a3a:	89 c2                	mov    %eax,%edx
  115a3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  115a3f:	e8 de f0 ff ff       	call   114b22 <get_engine_obj_inst>
  115a44:	89 c6                	mov    %eax,%esi
	if (!obj_inst) {
  115a46:	85 c0                	test   %eax,%eax
  115a48:	0f 84 b9 00 00 00    	je     115b07 <lwm2m_delete_obj_inst+0xfa>
	if (obj->user_delete_cb) {
  115a4e:	8b 47 14             	mov    0x14(%edi),%eax
	int i, ret = 0;
  115a51:	31 db                	xor    %ebx,%ebx
	if (obj->user_delete_cb) {
  115a53:	85 c0                	test   %eax,%eax
  115a55:	74 3d                	je     115a94 <lwm2m_delete_obj_inst+0x87>
		ret = obj->user_delete_cb(obj_inst_id);
  115a57:	ff 75 f0             	pushl  -0x10(%ebp)
  115a5a:	ff d0                	call   *%eax
  115a5c:	59                   	pop    %ecx
  115a5d:	89 c3                	mov    %eax,%ebx
		if (ret < 0) {
  115a5f:	85 c0                	test   %eax,%eax
  115a61:	79 31                	jns    115a94 <lwm2m_delete_obj_inst+0x87>
			LOG_ERR("Error in user obj delete %u/%u: %d",
  115a63:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115a6a:	74 28                	je     115a94 <lwm2m_delete_obj_inst+0x87>
  115a6c:	b8 20 31 12 00       	mov    $0x123120,%eax
  115a71:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115a76:	c1 e8 03             	shr    $0x3,%eax
  115a79:	c1 e0 06             	shl    $0x6,%eax
  115a7c:	83 c8 01             	or     $0x1,%eax
  115a7f:	50                   	push   %eax
  115a80:	53                   	push   %ebx
  115a81:	ff 75 f0             	pushl  -0x10(%ebp)
  115a84:	ff 75 ec             	pushl  -0x14(%ebp)
  115a87:	68 e1 76 12 00       	push   $0x1276e1
  115a8c:	e8 68 db fe ff       	call   1035f9 <log_3>
  115a91:	83 c4 14             	add    $0x14,%esp
			obj_inst->obj->obj_id, obj_inst->obj_inst_id);
  115a94:	8b 46 04             	mov    0x4(%esi),%eax
	engine_remove_observer_by_id(
  115a97:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  115a9b:	0f b7 40 18          	movzwl 0x18(%eax),%eax
  115a9f:	e8 b4 f1 ff ff       	call   114c58 <engine_remove_observer_by_id>
	sys_slist_find_and_remove(&engine_obj_inst_list, &obj_inst->node);
  115aa4:	89 f2                	mov    %esi,%edx
  115aa6:	b8 ac ec 12 00       	mov    $0x12ecac,%eax
  115aab:	e8 27 f0 ff ff       	call   114ad7 <sys_slist_find_and_remove>
	if (obj->delete_cb) {
  115ab0:	8b 47 0c             	mov    0xc(%edi),%eax
	obj->instance_count--;
  115ab3:	66 ff 4f 1c          	decw   0x1c(%edi)
	if (obj->delete_cb) {
  115ab7:	85 c0                	test   %eax,%eax
  115ab9:	74 08                	je     115ac3 <lwm2m_delete_obj_inst+0xb6>
		ret = obj->delete_cb(obj_inst_id);
  115abb:	ff 75 f0             	pushl  -0x10(%ebp)
  115abe:	ff d0                	call   *%eax
  115ac0:	5a                   	pop    %edx
  115ac1:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < obj_inst->resource_count; i++) {
  115ac3:	31 ff                	xor    %edi,%edi
  115ac5:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
  115ac9:	39 c7                	cmp    %eax,%edi
  115acb:	7d 26                	jge    115af3 <lwm2m_delete_obj_inst+0xe6>
		clear_attrs(&obj_inst->resources[i]);
  115acd:	6b d7 18             	imul   $0x18,%edi,%edx
  115ad0:	89 d0                	mov    %edx,%eax
  115ad2:	89 55 f0             	mov    %edx,-0x10(%ebp)
  115ad5:	03 46 08             	add    0x8(%esi),%eax
	for (i = 0; i < obj_inst->resource_count; i++) {
  115ad8:	47                   	inc    %edi
		clear_attrs(&obj_inst->resources[i]);
  115ad9:	e8 d3 f1 ff ff       	call   114cb1 <clear_attrs>
		(void)memset(obj_inst->resources + i, 0,
  115ade:	8b 55 f0             	mov    -0x10(%ebp),%edx
  115ae1:	6a 18                	push   $0x18
  115ae3:	03 56 08             	add    0x8(%esi),%edx
  115ae6:	6a 00                	push   $0x0
  115ae8:	52                   	push   %edx
  115ae9:	e8 6d 63 ff ff       	call   10be5b <memset>
  115aee:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < obj_inst->resource_count; i++) {
  115af1:	eb d2                	jmp    115ac5 <lwm2m_delete_obj_inst+0xb8>
	clear_attrs(obj_inst);
  115af3:	89 f0                	mov    %esi,%eax
  115af5:	e8 b7 f1 ff ff       	call   114cb1 <clear_attrs>
	(void)memset(obj_inst, 0, sizeof(struct lwm2m_engine_obj_inst));
  115afa:	6a 10                	push   $0x10
  115afc:	6a 00                	push   $0x0
  115afe:	56                   	push   %esi
  115aff:	e8 57 63 ff ff       	call   10be5b <memset>
  115b04:	83 c4 0c             	add    $0xc,%esp
}
  115b07:	8d 65 f4             	lea    -0xc(%ebp),%esp
  115b0a:	89 d8                	mov    %ebx,%eax
  115b0c:	5b                   	pop    %ebx
  115b0d:	5e                   	pop    %esi
  115b0e:	5f                   	pop    %edi
  115b0f:	5d                   	pop    %ebp
  115b10:	c3                   	ret    

00115b11 <lwm2m_create_obj_inst>:
{
  115b11:	55                   	push   %ebp
  115b12:	89 e5                	mov    %esp,%ebp
  115b14:	57                   	push   %edi
  115b15:	56                   	push   %esi
  115b16:	53                   	push   %ebx
  115b17:	51                   	push   %ecx
  115b18:	8b 45 0c             	mov    0xc(%ebp),%eax
  115b1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*obj_inst = NULL;
  115b1e:	8b 45 10             	mov    0x10(%ebp),%eax
	obj = get_engine_obj(obj_id);
  115b21:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
	*obj_inst = NULL;
  115b25:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	obj = get_engine_obj(obj_id);
  115b2b:	89 d8                	mov    %ebx,%eax
  115b2d:	e8 d8 ef ff ff       	call   114b0a <get_engine_obj>
	if (!obj) {
  115b32:	85 c0                	test   %eax,%eax
  115b34:	75 2e                	jne    115b64 <lwm2m_create_obj_inst+0x53>
		LOG_ERR("unable to find obj: %u", obj_id);
  115b36:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  115b3d:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
		LOG_ERR("unable to find obj: %u", obj_id);
  115b42:	0f 84 46 01 00 00    	je     115c8e <lwm2m_create_obj_inst+0x17d>
  115b48:	b8 20 31 12 00       	mov    $0x123120,%eax
  115b4d:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115b52:	c1 e8 03             	shr    $0x3,%eax
  115b55:	c1 e0 06             	shl    $0x6,%eax
  115b58:	83 c8 01             	or     $0x1,%eax
  115b5b:	50                   	push   %eax
  115b5c:	53                   	push   %ebx
  115b5d:	68 04 77 12 00       	push   $0x127704
  115b62:	eb 35                	jmp    115b99 <lwm2m_create_obj_inst+0x88>
	if (!obj->create_cb) {
  115b64:	8b 50 08             	mov    0x8(%eax),%edx
  115b67:	89 c7                	mov    %eax,%edi
  115b69:	85 d2                	test   %edx,%edx
  115b6b:	75 39                	jne    115ba6 <lwm2m_create_obj_inst+0x95>
		LOG_ERR("obj %u has no create_cb", obj_id);
  115b6d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  115b74:	bf ea ff ff ff       	mov    $0xffffffea,%edi
		LOG_ERR("obj %u has no create_cb", obj_id);
  115b79:	0f 84 0f 01 00 00    	je     115c8e <lwm2m_create_obj_inst+0x17d>
  115b7f:	b8 20 31 12 00       	mov    $0x123120,%eax
  115b84:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115b89:	c1 e8 03             	shr    $0x3,%eax
  115b8c:	c1 e0 06             	shl    $0x6,%eax
  115b8f:	83 c8 01             	or     $0x1,%eax
  115b92:	50                   	push   %eax
  115b93:	53                   	push   %ebx
  115b94:	68 1b 77 12 00       	push   $0x12771b
  115b99:	e8 d8 d9 fe ff       	call   103576 <log_1>
  115b9e:	83 c4 0c             	add    $0xc,%esp
  115ba1:	e9 e8 00 00 00       	jmp    115c8e <lwm2m_create_obj_inst+0x17d>
	if (obj->instance_count + 1 > obj->max_instance_count) {
  115ba6:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  115baa:	0f b7 77 1e          	movzwl 0x1e(%edi),%esi
  115bae:	40                   	inc    %eax
  115baf:	39 f0                	cmp    %esi,%eax
  115bb1:	7e 2e                	jle    115be1 <lwm2m_create_obj_inst+0xd0>
		LOG_ERR("no more instances available for obj %u", obj_id);
  115bb3:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOMEM;
  115bba:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("no more instances available for obj %u", obj_id);
  115bbf:	0f 84 c9 00 00 00    	je     115c8e <lwm2m_create_obj_inst+0x17d>
  115bc5:	b8 20 31 12 00       	mov    $0x123120,%eax
  115bca:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115bcf:	c1 e8 03             	shr    $0x3,%eax
  115bd2:	c1 e0 06             	shl    $0x6,%eax
  115bd5:	83 c8 01             	or     $0x1,%eax
  115bd8:	50                   	push   %eax
  115bd9:	53                   	push   %ebx
  115bda:	68 33 77 12 00       	push   $0x127733
  115bdf:	eb b8                	jmp    115b99 <lwm2m_create_obj_inst+0x88>
	*obj_inst = obj->create_cb(obj_inst_id);
  115be1:	0f b7 75 f0          	movzwl -0x10(%ebp),%esi
  115be5:	56                   	push   %esi
  115be6:	ff d2                	call   *%edx
  115be8:	5a                   	pop    %edx
  115be9:	89 c2                	mov    %eax,%edx
  115beb:	8b 45 10             	mov    0x10(%ebp),%eax
	if (!*obj_inst) {
  115bee:	85 d2                	test   %edx,%edx
	*obj_inst = obj->create_cb(obj_inst_id);
  115bf0:	89 10                	mov    %edx,(%eax)
	if (!*obj_inst) {
  115bf2:	75 37                	jne    115c2b <lwm2m_create_obj_inst+0x11a>
		LOG_ERR("unable to create obj %u instance %u",
  115bf4:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EEXIST;
  115bfb:	bf ef ff ff ff       	mov    $0xffffffef,%edi
		LOG_ERR("unable to create obj %u instance %u",
  115c00:	0f 84 88 00 00 00    	je     115c8e <lwm2m_create_obj_inst+0x17d>
  115c06:	b8 20 31 12 00       	mov    $0x123120,%eax
  115c0b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115c10:	c1 e8 03             	shr    $0x3,%eax
  115c13:	c1 e0 06             	shl    $0x6,%eax
  115c16:	83 c8 01             	or     $0x1,%eax
  115c19:	50                   	push   %eax
  115c1a:	56                   	push   %esi
  115c1b:	53                   	push   %ebx
  115c1c:	68 5a 77 12 00       	push   $0x12775a
  115c21:	e8 8a d9 fe ff       	call   1035b0 <log_2>
  115c26:	83 c4 10             	add    $0x10,%esp
  115c29:	eb 63                	jmp    115c8e <lwm2m_create_obj_inst+0x17d>
	obj->instance_count++;
  115c2b:	66 ff 47 1c          	incw   0x1c(%edi)
	(*obj_inst)->obj_inst_id = obj_inst_id;
  115c2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  115c32:	66 89 42 0c          	mov    %ax,0xc(%edx)
	(*obj_inst)->obj = obj;
  115c36:	89 7a 04             	mov    %edi,0x4(%edx)
	sys_slist_append(&engine_obj_inst_list, &obj_inst->node);
  115c39:	b8 ac ec 12 00       	mov    $0x12ecac,%eax
  115c3e:	e8 52 ee ff ff       	call   114a95 <sys_slist_append>
	if (obj->user_create_cb) {
  115c43:	8b 47 10             	mov    0x10(%edi),%eax
  115c46:	85 c0                	test   %eax,%eax
  115c48:	75 04                	jne    115c4e <lwm2m_create_obj_inst+0x13d>
	return 0;
  115c4a:	31 ff                	xor    %edi,%edi
  115c4c:	eb 40                	jmp    115c8e <lwm2m_create_obj_inst+0x17d>
		ret = obj->user_create_cb(obj_inst_id);
  115c4e:	56                   	push   %esi
  115c4f:	ff d0                	call   *%eax
  115c51:	59                   	pop    %ecx
  115c52:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
  115c54:	85 c0                	test   %eax,%eax
  115c56:	79 f2                	jns    115c4a <lwm2m_create_obj_inst+0x139>
			LOG_ERR("Error in user obj create %u/%u: %d",
  115c58:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115c5f:	74 24                	je     115c85 <lwm2m_create_obj_inst+0x174>
  115c61:	b8 20 31 12 00       	mov    $0x123120,%eax
  115c66:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115c6b:	c1 e8 03             	shr    $0x3,%eax
  115c6e:	c1 e0 06             	shl    $0x6,%eax
  115c71:	83 c8 01             	or     $0x1,%eax
  115c74:	50                   	push   %eax
  115c75:	57                   	push   %edi
  115c76:	56                   	push   %esi
  115c77:	53                   	push   %ebx
  115c78:	68 7e 77 12 00       	push   $0x12777e
  115c7d:	e8 77 d9 fe ff       	call   1035f9 <log_3>
  115c82:	83 c4 14             	add    $0x14,%esp
			lwm2m_delete_obj_inst(obj_id, obj_inst_id);
  115c85:	56                   	push   %esi
  115c86:	53                   	push   %ebx
  115c87:	e8 81 fd ff ff       	call   115a0d <lwm2m_delete_obj_inst>
  115c8c:	58                   	pop    %eax
  115c8d:	5a                   	pop    %edx
}
  115c8e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  115c91:	89 f8                	mov    %edi,%eax
  115c93:	5b                   	pop    %ebx
  115c94:	5e                   	pop    %esi
  115c95:	5f                   	pop    %edi
  115c96:	5d                   	pop    %ebp
  115c97:	c3                   	ret    

00115c98 <lwm2m_get_message>:
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
  115c98:	31 c0                	xor    %eax,%eax
		if (!messages[i].ctx) {
  115c9a:	69 d0 8c 02 00 00    	imul   $0x28c,%eax,%edx
  115ca0:	83 ba c0 b4 12 00 00 	cmpl   $0x0,0x12b4c0(%edx)
  115ca7:	75 14                	jne    115cbd <lwm2m_get_message+0x25>
{
  115ca9:	55                   	push   %ebp
  115caa:	89 e5                	mov    %esp,%ebp
			messages[i].ctx = client_ctx;
  115cac:	8b 45 08             	mov    0x8(%ebp),%eax
}
  115caf:	5d                   	pop    %ebp
			messages[i].ctx = client_ctx;
  115cb0:	89 82 c0 b4 12 00    	mov    %eax,0x12b4c0(%edx)
			return &messages[i];
  115cb6:	8d 82 c0 b4 12 00    	lea    0x12b4c0(%edx),%eax
}
  115cbc:	c3                   	ret    
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_MESSAGES; i++) {
  115cbd:	40                   	inc    %eax
  115cbe:	83 f8 0a             	cmp    $0xa,%eax
  115cc1:	75 d7                	jne    115c9a <lwm2m_get_message+0x2>
	return NULL;
  115cc3:	31 c0                	xor    %eax,%eax
}
  115cc5:	c3                   	ret    

00115cc6 <lwm2m_reset_message>:
{
  115cc6:	55                   	push   %ebp
  115cc7:	89 e5                	mov    %esp,%ebp
  115cc9:	56                   	push   %esi
  115cca:	53                   	push   %ebx
  115ccb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  115cce:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (!msg) {
  115cd1:	85 db                	test   %ebx,%ebx
  115cd3:	74 4b                	je     115d20 <lwm2m_reset_message+0x5a>
	if (msg->pending) {
  115cd5:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
  115cdb:	85 c0                	test   %eax,%eax
  115cdd:	74 07                	je     115ce6 <lwm2m_reset_message+0x20>
		coap_pending_clear(msg->pending);
  115cdf:	50                   	push   %eax
  115ce0:	e8 e7 32 ff ff       	call   108fcc <coap_pending_clear>
  115ce5:	5a                   	pop    %edx
	if (msg->reply) {
  115ce6:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
  115cec:	85 c0                	test   %eax,%eax
  115cee:	74 07                	je     115cf7 <lwm2m_reset_message+0x31>
		coap_reply_clear(msg->reply);
  115cf0:	50                   	push   %eax
  115cf1:	e8 1d 34 ff ff       	call   109113 <coap_reply_clear>
  115cf6:	58                   	pop    %eax
	if (release) {
  115cf7:	89 f0                	mov    %esi,%eax
  115cf9:	84 c0                	test   %al,%al
  115cfb:	74 09                	je     115d06 <lwm2m_reset_message+0x40>
		(void)memset(msg, 0, sizeof(*msg));
  115cfd:	68 8c 02 00 00       	push   $0x28c
  115d02:	6a 00                	push   $0x0
  115d04:	eb 11                	jmp    115d17 <lwm2m_reset_message+0x51>
		msg->message_timeout_cb = NULL;
  115d06:	c7 83 80 02 00 00 00 	movl   $0x0,0x280(%ebx)
  115d0d:	00 00 00 
		(void)memset(&msg->cpkt, 0, sizeof(msg->cpkt));
  115d10:	6a 10                	push   $0x10
  115d12:	6a 00                	push   $0x0
  115d14:	83 c3 30             	add    $0x30,%ebx
  115d17:	53                   	push   %ebx
  115d18:	e8 3e 61 ff ff       	call   10be5b <memset>
  115d1d:	83 c4 0c             	add    $0xc,%esp
}
  115d20:	8d 65 f8             	lea    -0x8(%ebp),%esp
  115d23:	5b                   	pop    %ebx
  115d24:	5e                   	pop    %esi
  115d25:	5d                   	pop    %ebp
  115d26:	c3                   	ret    

00115d27 <retransmit_request>:
{
  115d27:	55                   	push   %ebp
  115d28:	89 e5                	mov    %esp,%ebp
  115d2a:	57                   	push   %edi
  115d2b:	56                   	push   %esi
	pending = coap_pending_next_to_expire(client_ctx->pendings,
  115d2c:	8b 45 08             	mov    0x8(%ebp),%eax
{
  115d2f:	53                   	push   %ebx
	pending = coap_pending_next_to_expire(client_ctx->pendings,
  115d30:	6a 05                	push   $0x5
  115d32:	8d b0 fc fe ff ff    	lea    -0x104(%eax),%esi
  115d38:	56                   	push   %esi
  115d39:	e8 10 32 ff ff       	call   108f4e <coap_pending_next_to_expire>
  115d3e:	5a                   	pop    %edx
	if (!pending) {
  115d3f:	85 c0                	test   %eax,%eax
	pending = coap_pending_next_to_expire(client_ctx->pendings,
  115d41:	59                   	pop    %ecx
	if (!pending) {
  115d42:	0f 84 a0 01 00 00    	je     115ee8 <retransmit_request+0x1c1>
	remaining = pending->t0 + pending->timeout - k_uptime_get_32();
  115d48:	8b 58 0c             	mov    0xc(%eax),%ebx
  115d4b:	89 c7                	mov    %eax,%edi
  115d4d:	03 58 08             	add    0x8(%eax),%ebx
	return (uint32_t)k_uptime_get();
  115d50:	e8 ed ee ff ff       	call   114c42 <k_uptime_get>
  115d55:	29 c3                	sub    %eax,%ebx
	if (remaining > 0) {
  115d57:	85 db                	test   %ebx,%ebx
  115d59:	0f 8f 41 01 00 00    	jg     115ea0 <retransmit_request+0x179>
	msg = find_msg(pending, NULL);
  115d5f:	31 d2                	xor    %edx,%edx
  115d61:	89 f8                	mov    %edi,%eax
  115d63:	e8 07 f0 ff ff       	call   114d6f <find_msg>
  115d68:	89 c3                	mov    %eax,%ebx
	if (!msg) {
  115d6a:	85 c0                	test   %eax,%eax
  115d6c:	75 35                	jne    115da3 <retransmit_request+0x7c>
		LOG_ERR("pending has no valid LwM2M message!");
  115d6e:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115d75:	74 20                	je     115d97 <retransmit_request+0x70>
  115d77:	b8 20 31 12 00       	mov    $0x123120,%eax
  115d7c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115d81:	c1 e8 03             	shr    $0x3,%eax
  115d84:	c1 e0 06             	shl    $0x6,%eax
  115d87:	83 c8 01             	or     $0x1,%eax
  115d8a:	50                   	push   %eax
  115d8b:	68 a1 77 12 00       	push   $0x1277a1
  115d90:	e8 b8 d7 fe ff       	call   10354d <log_0>
  115d95:	5b                   	pop    %ebx
  115d96:	58                   	pop    %eax
		coap_pending_clear(pending);
  115d97:	57                   	push   %edi
  115d98:	e8 2f 32 ff ff       	call   108fcc <coap_pending_clear>
  115d9d:	59                   	pop    %ecx
		goto next;
  115d9e:	e9 fd 00 00 00       	jmp    115ea0 <retransmit_request+0x179>
	if (!coap_pending_cycle(pending)) {
  115da3:	57                   	push   %edi
  115da4:	e8 e2 31 ff ff       	call   108f8b <coap_pending_cycle>
  115da9:	5a                   	pop    %edx
  115daa:	84 c0                	test   %al,%al
  115dac:	75 1d                	jne    115dcb <retransmit_request+0xa4>
		if (msg->message_timeout_cb) {
  115dae:	8b 83 80 02 00 00    	mov    0x280(%ebx),%eax
  115db4:	85 c0                	test   %eax,%eax
  115db6:	74 04                	je     115dbc <retransmit_request+0x95>
			msg->message_timeout_cb(msg);
  115db8:	53                   	push   %ebx
  115db9:	ff d0                	call   *%eax
  115dbb:	58                   	pop    %eax
		lwm2m_reset_message(msg, true);
  115dbc:	6a 01                	push   $0x1
  115dbe:	53                   	push   %ebx
  115dbf:	e8 02 ff ff ff       	call   115cc6 <lwm2m_reset_message>
  115dc4:	5b                   	pop    %ebx
  115dc5:	5f                   	pop    %edi
		goto next;
  115dc6:	e9 d5 00 00 00       	jmp    115ea0 <retransmit_request+0x179>
	LOG_INF("Resending message: %p", msg);
  115dcb:	a1 d0 5b 14 00       	mov    0x145bd0,%eax
  115dd0:	83 e0 07             	and    $0x7,%eax
  115dd3:	83 f8 02             	cmp    $0x2,%eax
  115dd6:	76 22                	jbe    115dfa <retransmit_request+0xd3>
  115dd8:	b8 20 31 12 00       	mov    $0x123120,%eax
  115ddd:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115de2:	c1 e8 03             	shr    $0x3,%eax
  115de5:	c1 e0 06             	shl    $0x6,%eax
  115de8:	83 c8 03             	or     $0x3,%eax
  115deb:	50                   	push   %eax
  115dec:	53                   	push   %ebx
  115ded:	68 c5 77 12 00       	push   $0x1277c5
  115df2:	e8 7f d7 fe ff       	call   103576 <log_1>
  115df7:	83 c4 0c             	add    $0xc,%esp
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
  115dfa:	8b 45 08             	mov    0x8(%ebp),%eax
	msg->send_attempts++;
  115dfd:	fe 83 8a 02 00 00    	incb   0x28a(%ebx)
  115e03:	8d 78 24             	lea    0x24(%eax),%edi
	return z_impl_k_mutex_lock(mutex, timeout);
  115e06:	6a ff                	push   $0xffffffff
  115e08:	6a ff                	push   $0xffffffff
  115e0a:	57                   	push   %edi
  115e0b:	e8 c0 ad 00 00       	call   120bd0 <z_impl_k_mutex_lock>
	if (msg->ctx == NULL) {
  115e10:	8b 03                	mov    (%ebx),%eax
  115e12:	83 c4 0c             	add    $0xc,%esp
  115e15:	85 c0                	test   %eax,%eax
  115e17:	75 29                	jne    115e42 <retransmit_request+0x11b>
		LOG_INF("Response for %p already handled", msg);
  115e19:	a1 d0 5b 14 00       	mov    0x145bd0,%eax
  115e1e:	83 e0 07             	and    $0x7,%eax
  115e21:	83 f8 02             	cmp    $0x2,%eax
  115e24:	76 73                	jbe    115e99 <retransmit_request+0x172>
  115e26:	b8 20 31 12 00       	mov    $0x123120,%eax
  115e2b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115e30:	c1 e8 03             	shr    $0x3,%eax
  115e33:	c1 e0 06             	shl    $0x6,%eax
  115e36:	83 c8 03             	or     $0x3,%eax
  115e39:	50                   	push   %eax
  115e3a:	53                   	push   %ebx
  115e3b:	68 db 77 12 00       	push   $0x1277db
  115e40:	eb 4f                	jmp    115e91 <retransmit_request+0x16a>
	if (send(msg->ctx->sock_fd, msg->cpkt.data, msg->cpkt.offset, 0) < 0) {
  115e42:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  115e46:	8b 4b 30             	mov    0x30(%ebx),%ecx
  115e49:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
	if (z_syscall_trap()) {
		return (ssize_t) arch_syscall_invoke6(*(uintptr_t *)&sock, *(uintptr_t *)&buf, *(uintptr_t *)&len, *(uintptr_t *)&flags, *(uintptr_t *)&dest_addr, *(uintptr_t *)&addrlen, K_SYSCALL_ZSOCK_SENDTO);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
  115e4f:	6a 00                	push   $0x0
  115e51:	6a 00                	push   $0x0
  115e53:	6a 00                	push   $0x0
  115e55:	52                   	push   %edx
  115e56:	51                   	push   %ecx
  115e57:	50                   	push   %eax
  115e58:	e8 6a 3b ff ff       	call   1099c7 <z_impl_zsock_sendto>
  115e5d:	83 c4 18             	add    $0x18,%esp
  115e60:	85 c0                	test   %eax,%eax
  115e62:	79 35                	jns    115e99 <retransmit_request+0x172>
		LOG_ERR("Error sending lwm2m message: %d", -errno);
  115e64:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115e6b:	74 2c                	je     115e99 <retransmit_request+0x172>
  115e6d:	e8 a1 ee ff ff       	call   114d13 <z_errno>
  115e72:	bb 20 31 12 00       	mov    $0x123120,%ebx
  115e77:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  115e7d:	c1 eb 03             	shr    $0x3,%ebx
  115e80:	c1 e3 06             	shl    $0x6,%ebx
  115e83:	83 cb 01             	or     $0x1,%ebx
  115e86:	53                   	push   %ebx
  115e87:	8b 00                	mov    (%eax),%eax
  115e89:	f7 d8                	neg    %eax
  115e8b:	50                   	push   %eax
  115e8c:	68 fb 77 12 00       	push   $0x1277fb
  115e91:	e8 e0 d6 fe ff       	call   103576 <log_1>
  115e96:	83 c4 0c             	add    $0xc,%esp
	ret = sys_mutex_unlock(&client_ctx->send_lock);
  115e99:	89 f8                	mov    %edi,%eax
  115e9b:	e8 47 ee ff ff       	call   114ce7 <sys_mutex_unlock>
	pending = coap_pending_next_to_expire(client_ctx->pendings,
  115ea0:	6a 05                	push   $0x5
  115ea2:	56                   	push   %esi
  115ea3:	e8 a6 30 ff ff       	call   108f4e <coap_pending_next_to_expire>
  115ea8:	5a                   	pop    %edx
	if (!pending) {
  115ea9:	85 c0                	test   %eax,%eax
	pending = coap_pending_next_to_expire(client_ctx->pendings,
  115eab:	59                   	pop    %ecx
	if (!pending) {
  115eac:	74 3a                	je     115ee8 <retransmit_request+0x1c1>
	remaining = pending->t0 + pending->timeout - k_uptime_get_32();
  115eae:	8b 58 0c             	mov    0xc(%eax),%ebx
  115eb1:	03 58 08             	add    0x8(%eax),%ebx
  115eb4:	e8 89 ed ff ff       	call   114c42 <k_uptime_get>
	k_delayed_work_submit(&client_ctx->retransmit_work, K_MSEC(remaining));
  115eb9:	29 c3                	sub    %eax,%ebx
  115ebb:	79 02                	jns    115ebf <retransmit_request+0x198>
  115ebd:	31 db                	xor    %ebx,%ebx
  115ebf:	89 d8                	mov    %ebx,%eax
			return t / (from_hz / to_hz);
  115ec1:	6a 00                	push   $0x0
  115ec3:	99                   	cltd   
		t += off;
  115ec4:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  115ec7:	6a 0a                	push   $0xa
		t += off;
  115ec9:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  115ecc:	52                   	push   %edx
  115ecd:	50                   	push   %eax
  115ece:	e8 4d a3 fe ff       	call   100220 <__udivdi3>
  115ed3:	83 c4 10             	add    $0x10,%esp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
  115ed6:	52                   	push   %edx
  115ed7:	50                   	push   %eax
  115ed8:	ff 75 08             	pushl  0x8(%ebp)
  115edb:	68 00 ea 12 00       	push   $0x12ea00
  115ee0:	e8 f2 bf 00 00       	call   121ed7 <k_delayed_work_submit_to_queue>
  115ee5:	83 c4 10             	add    $0x10,%esp
}
  115ee8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  115eeb:	5b                   	pop    %ebx
  115eec:	5e                   	pop    %esi
  115eed:	5f                   	pop    %edi
  115eee:	5d                   	pop    %ebp
  115eef:	c3                   	ret    

00115ef0 <lwm2m_init_message>:
{
  115ef0:	55                   	push   %ebp
  115ef1:	89 e5                	mov    %esp,%ebp
  115ef3:	57                   	push   %edi
  115ef4:	56                   	push   %esi
  115ef5:	53                   	push   %ebx
  115ef6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!msg || !msg->ctx) {
  115ef9:	85 db                	test   %ebx,%ebx
  115efb:	74 05                	je     115f02 <lwm2m_init_message+0x12>
  115efd:	83 3b 00             	cmpl   $0x0,(%ebx)
  115f00:	75 35                	jne    115f37 <lwm2m_init_message+0x47>
		LOG_ERR("LwM2M message is invalid.");
  115f02:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  115f09:	be ea ff ff ff       	mov    $0xffffffea,%esi
		LOG_ERR("LwM2M message is invalid.");
  115f0e:	0f 84 c9 01 00 00    	je     1160dd <lwm2m_init_message+0x1ed>
  115f14:	b8 20 31 12 00       	mov    $0x123120,%eax
  115f19:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115f1e:	c1 e8 03             	shr    $0x3,%eax
  115f21:	c1 e0 06             	shl    $0x6,%eax
  115f24:	83 c8 01             	or     $0x1,%eax
  115f27:	50                   	push   %eax
  115f28:	68 1b 78 12 00       	push   $0x12781b
  115f2d:	e8 1b d6 fe ff       	call   10354d <log_0>
  115f32:	e9 a4 01 00 00       	jmp    1160db <lwm2m_init_message+0x1eb>
	if (msg->tkl == LWM2M_MSG_TOKEN_GENERATE_NEW) {
  115f37:	0f b6 93 88 02 00 00 	movzbl 0x288(%ebx),%edx
  115f3e:	80 fa ff             	cmp    $0xff,%dl
  115f41:	75 0c                	jne    115f4f <lwm2m_init_message+0x5f>
		token = coap_next_token();
  115f43:	e8 40 2a ff ff       	call   108988 <coap_next_token>
		tokenlen = 8U;
  115f48:	ba 08 00 00 00       	mov    $0x8,%edx
  115f4d:	eb 12                	jmp    115f61 <lwm2m_init_message+0x71>
	} else if (msg->token && msg->tkl != 0) {
  115f4f:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
  115f55:	85 c0                	test   %eax,%eax
  115f57:	74 04                	je     115f5d <lwm2m_init_message+0x6d>
  115f59:	84 d2                	test   %dl,%dl
  115f5b:	75 04                	jne    115f61 <lwm2m_init_message+0x71>
	uint8_t *token = NULL;
  115f5d:	31 c0                	xor    %eax,%eax
	uint8_t tokenlen = 0U;
  115f5f:	31 d2                	xor    %edx,%edx
	r = coap_packet_init(&msg->cpkt, msg->msg_data, sizeof(msg->msg_data),
  115f61:	0f b7 8b 84 02 00 00 	movzwl 0x284(%ebx),%ecx
  115f68:	51                   	push   %ecx
  115f69:	8d 7b 30             	lea    0x30(%ebx),%edi
  115f6c:	0f b6 8b 87 02 00 00 	movzbl 0x287(%ebx),%ecx
  115f73:	51                   	push   %ecx
  115f74:	50                   	push   %eax
  115f75:	52                   	push   %edx
  115f76:	0f b6 83 86 02 00 00 	movzbl 0x286(%ebx),%eax
  115f7d:	50                   	push   %eax
  115f7e:	8d 43 40             	lea    0x40(%ebx),%eax
  115f81:	6a 01                	push   $0x1
  115f83:	68 30 02 00 00       	push   $0x230
  115f88:	50                   	push   %eax
  115f89:	57                   	push   %edi
  115f8a:	e8 9e 26 ff ff       	call   10862d <coap_packet_init>
  115f8f:	83 c4 24             	add    $0x24,%esp
  115f92:	89 c6                	mov    %eax,%esi
	if (r < 0) {
  115f94:	85 c0                	test   %eax,%eax
  115f96:	79 2c                	jns    115fc4 <lwm2m_init_message+0xd4>
		LOG_ERR("coap packet init error (err:%d)", r);
  115f98:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115f9f:	0f 84 2e 01 00 00    	je     1160d3 <lwm2m_init_message+0x1e3>
  115fa5:	b8 20 31 12 00       	mov    $0x123120,%eax
  115faa:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115faf:	c1 e8 03             	shr    $0x3,%eax
  115fb2:	c1 e0 06             	shl    $0x6,%eax
  115fb5:	83 c8 01             	or     $0x1,%eax
  115fb8:	50                   	push   %eax
  115fb9:	56                   	push   %esi
  115fba:	68 35 78 12 00       	push   $0x127835
  115fbf:	e9 92 00 00 00       	jmp    116056 <lwm2m_init_message+0x166>
	if (msg->type != COAP_TYPE_CON) {
  115fc4:	80 bb 86 02 00 00 00 	cmpb   $0x0,0x286(%ebx)
  115fcb:	0f 85 fe 00 00 00    	jne    1160cf <lwm2m_init_message+0x1df>
				msg->ctx->pendings,
  115fd1:	8b 03                	mov    (%ebx),%eax
	msg->pending = coap_pending_next_unused(
  115fd3:	6a 05                	push   $0x5
				msg->ctx->pendings,
  115fd5:	83 c0 08             	add    $0x8,%eax
	msg->pending = coap_pending_next_unused(
  115fd8:	50                   	push   %eax
  115fd9:	e8 09 2f ff ff       	call   108ee7 <coap_pending_next_unused>
  115fde:	5a                   	pop    %edx
	if (!msg->pending) {
  115fdf:	85 c0                	test   %eax,%eax
	msg->pending = coap_pending_next_unused(
  115fe1:	59                   	pop    %ecx
  115fe2:	89 83 70 02 00 00    	mov    %eax,0x270(%ebx)
	if (!msg->pending) {
  115fe8:	75 33                	jne    11601d <lwm2m_init_message+0x12d>
		LOG_ERR("Unable to find a free pending to track "
  115fea:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  115ff1:	74 20                	je     116013 <lwm2m_init_message+0x123>
  115ff3:	b8 20 31 12 00       	mov    $0x123120,%eax
  115ff8:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  115ffd:	c1 e8 03             	shr    $0x3,%eax
  116000:	c1 e0 06             	shl    $0x6,%eax
  116003:	83 c8 01             	or     $0x1,%eax
  116006:	50                   	push   %eax
  116007:	68 55 78 12 00       	push   $0x127855
  11600c:	e8 3c d5 fe ff       	call   10354d <log_0>
  116011:	5e                   	pop    %esi
  116012:	5f                   	pop    %edi
		r = -ENOMEM;
  116013:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
  116018:	e9 b6 00 00 00       	jmp    1160d3 <lwm2m_init_message+0x1e3>
	r = coap_pending_init(msg->pending, &msg->cpkt, &msg->ctx->remote_addr);
  11601d:	ff 33                	pushl  (%ebx)
  11601f:	57                   	push   %edi
  116020:	50                   	push   %eax
  116021:	e8 68 2e ff ff       	call   108e8e <coap_pending_init>
  116026:	83 c4 0c             	add    $0xc,%esp
  116029:	89 c6                	mov    %eax,%esi
	if (r < 0) {
  11602b:	85 c0                	test   %eax,%eax
  11602d:	79 31                	jns    116060 <lwm2m_init_message+0x170>
		LOG_ERR("Unable to initialize a pending "
  11602f:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116036:	0f 84 97 00 00 00    	je     1160d3 <lwm2m_init_message+0x1e3>
  11603c:	b8 20 31 12 00       	mov    $0x123120,%eax
  116041:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  116046:	c1 e8 03             	shr    $0x3,%eax
  116049:	c1 e0 06             	shl    $0x6,%eax
  11604c:	83 c8 01             	or     $0x1,%eax
  11604f:	50                   	push   %eax
  116050:	56                   	push   %esi
  116051:	68 8d 78 12 00       	push   $0x12788d
  116056:	e8 1b d5 fe ff       	call   103576 <log_1>
  11605b:	83 c4 0c             	add    $0xc,%esp
  11605e:	eb 73                	jmp    1160d3 <lwm2m_init_message+0x1e3>
	if (msg->reply_cb) {
  116060:	83 bb 7c 02 00 00 00 	cmpl   $0x0,0x27c(%ebx)
  116067:	74 66                	je     1160cf <lwm2m_init_message+0x1df>
				msg->ctx->replies,
  116069:	8b 03                	mov    (%ebx),%eax
		msg->reply = coap_reply_next_unused(
  11606b:	6a 05                	push   $0x5
				msg->ctx->replies,
  11606d:	05 94 00 00 00       	add    $0x94,%eax
		msg->reply = coap_reply_next_unused(
  116072:	50                   	push   %eax
  116073:	e8 8c 2e ff ff       	call   108f04 <coap_reply_next_unused>
  116078:	5a                   	pop    %edx
		if (!msg->reply) {
  116079:	85 c0                	test   %eax,%eax
		msg->reply = coap_reply_next_unused(
  11607b:	59                   	pop    %ecx
  11607c:	89 83 74 02 00 00    	mov    %eax,0x274(%ebx)
		if (!msg->reply) {
  116082:	75 27                	jne    1160ab <lwm2m_init_message+0x1bb>
			LOG_ERR("No resources for waiting for replies.");
  116084:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  11608b:	74 86                	je     116013 <lwm2m_init_message+0x123>
  11608d:	b8 20 31 12 00       	mov    $0x123120,%eax
  116092:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  116097:	c1 e8 03             	shr    $0x3,%eax
  11609a:	c1 e0 06             	shl    $0x6,%eax
  11609d:	83 c8 01             	or     $0x1,%eax
  1160a0:	50                   	push   %eax
  1160a1:	68 c5 78 12 00       	push   $0x1278c5
  1160a6:	e9 61 ff ff ff       	jmp    11600c <lwm2m_init_message+0x11c>
		coap_reply_clear(msg->reply);
  1160ab:	50                   	push   %eax
  1160ac:	e8 62 30 ff ff       	call   109113 <coap_reply_clear>
		coap_reply_init(msg->reply, &msg->cpkt);
  1160b1:	89 3c 24             	mov    %edi,(%esp)
  1160b4:	ff b3 74 02 00 00    	pushl  0x274(%ebx)
  1160ba:	e8 f3 2f ff ff       	call   1090b2 <coap_reply_init>
		msg->reply->reply = msg->reply_cb;
  1160bf:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
		coap_reply_init(msg->reply, &msg->cpkt);
  1160c5:	59                   	pop    %ecx
		msg->reply->reply = msg->reply_cb;
  1160c6:	8b 93 7c 02 00 00    	mov    0x27c(%ebx),%edx
		coap_reply_init(msg->reply, &msg->cpkt);
  1160cc:	5e                   	pop    %esi
		msg->reply->reply = msg->reply_cb;
  1160cd:	89 10                	mov    %edx,(%eax)
	return 0;
  1160cf:	31 f6                	xor    %esi,%esi
  1160d1:	eb 0a                	jmp    1160dd <lwm2m_init_message+0x1ed>
	lwm2m_reset_message(msg, true);
  1160d3:	6a 01                	push   $0x1
  1160d5:	53                   	push   %ebx
  1160d6:	e8 eb fb ff ff       	call   115cc6 <lwm2m_reset_message>
  1160db:	58                   	pop    %eax
  1160dc:	5a                   	pop    %edx
}
  1160dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1160e0:	89 f0                	mov    %esi,%eax
  1160e2:	5b                   	pop    %ebx
  1160e3:	5e                   	pop    %esi
  1160e4:	5f                   	pop    %edi
  1160e5:	5d                   	pop    %ebp
  1160e6:	c3                   	ret    

001160e7 <handle_request>:
{
  1160e7:	55                   	push   %ebp
  1160e8:	89 e5                	mov    %esp,%ebp
  1160ea:	57                   	push   %edi
  1160eb:	56                   	push   %esi
  1160ec:	53                   	push   %ebx
	tkl = coap_header_get_token(msg->in.in_cpkt, token);
  1160ed:	8d 9d ff fe ff ff    	lea    -0x101(%ebp),%ebx
{
  1160f3:	81 ec 44 01 00 00    	sub    $0x144,%esp
	uint16_t payload_len = 0U;
  1160f9:	66 c7 85 ea fe ff ff 	movw   $0x0,-0x116(%ebp)
  116100:	00 00 
{
  116102:	8b 75 0c             	mov    0xc(%ebp),%esi
  116105:	8b 45 08             	mov    0x8(%ebp),%eax
	msg->out.out_cpkt = &msg->cpkt;
  116108:	8d 56 30             	lea    0x30(%esi),%edx
	msg->in.in_cpkt = request;
  11610b:	89 46 08             	mov    %eax,0x8(%esi)
	msg->out.out_cpkt = &msg->cpkt;
  11610e:	89 56 1c             	mov    %edx,0x1c(%esi)
	msg->in.reader = &plain_text_reader;
  116111:	c7 46 04 60 3c 12 00 	movl   $0x123c60,0x4(%esi)
	msg->out.writer = &plain_text_writer;
  116118:	c7 46 18 80 3c 12 00 	movl   $0x123c80,0x18(%esi)
	code = coap_header_get_code(msg->in.in_cpkt);
  11611f:	50                   	push   %eax
  116120:	e8 4f 2a ff ff       	call   108b74 <coap_header_get_code>
	tkl = coap_header_get_token(msg->in.in_cpkt, token);
  116125:	89 1c 24             	mov    %ebx,(%esp)
  116128:	ff 76 08             	pushl  0x8(%esi)
	code = coap_header_get_code(msg->in.in_cpkt);
  11612b:	88 85 e0 fe ff ff    	mov    %al,-0x120(%ebp)
	tkl = coap_header_get_token(msg->in.in_cpkt, token);
  116131:	e8 0a 2a ff ff       	call   108b40 <coap_header_get_token>
  116136:	5f                   	pop    %edi
  116137:	88 85 dc fe ff ff    	mov    %al,-0x124(%ebp)
  11613d:	5a                   	pop    %edx
	if (tkl) {
  11613e:	84 c0                	test   %al,%al
  116140:	74 0c                	je     11614e <handle_request+0x67>
		msg->tkl = tkl;
  116142:	88 86 88 02 00 00    	mov    %al,0x288(%esi)
		msg->token = token;
  116148:	89 9e 78 02 00 00    	mov    %ebx,0x278(%esi)
	r = coap_find_options(msg->in.in_cpkt, COAP_OPTION_URI_PATH, options,
  11614e:	6a 04                	push   $0x4
  116150:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
  116156:	50                   	push   %eax
  116157:	6a 0b                	push   $0xb
  116159:	ff 76 08             	pushl  0x8(%esi)
  11615c:	e8 39 29 ff ff       	call   108a9a <coap_find_options>
  116161:	83 c4 10             	add    $0x10,%esp
  116164:	89 c3                	mov    %eax,%ebx
	if (r <= 0) {
  116166:	85 c0                	test   %eax,%eax
  116168:	7f 63                	jg     1161cd <handle_request+0xe6>
		switch (code & COAP_REQUEST_MASK) {
  11616a:	8a 85 e0 fe ff ff    	mov    -0x120(%ebp),%al
  116170:	83 e0 07             	and    $0x7,%eax
  116173:	3c 04                	cmp    $0x4,%al
  116175:	0f 85 95 15 00 00    	jne    117710 <handle_request+0x1629>
			if (msg->ctx->bootstrap_mode) {
  11617b:	8b 06                	mov    (%esi),%eax
  11617d:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  116184:	0f 84 86 15 00 00    	je     117710 <handle_request+0x1629>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_obj_inst_list,
  11618a:	a1 ac ec 12 00       	mov    0x12ecac,%eax
  11618f:	85 c0                	test   %eax,%eax
  116191:	0f 84 bd 15 00 00    	je     117754 <handle_request+0x166d>
  116197:	8b 18                	mov    (%eax),%ebx
		if (obj_inst->obj->obj_id == LWM2M_OBJECT_SECURITY_ID &&
  116199:	8b 50 04             	mov    0x4(%eax),%edx
  11619c:	66 83 7a 18 00       	cmpw   $0x0,0x18(%edx)
  1161a1:	74 0e                	je     1161b1 <handle_request+0xca>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_obj_inst_list,
  1161a3:	85 db                	test   %ebx,%ebx
  1161a5:	0f 84 a9 15 00 00    	je     117754 <handle_request+0x166d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1161ab:	89 d8                	mov    %ebx,%eax
  1161ad:	8b 1b                	mov    (%ebx),%ebx
  1161af:	eb e8                	jmp    116199 <handle_request+0xb2>
		    obj_inst->obj_inst_id > 0) {
  1161b1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
		if (obj_inst->obj->obj_id == LWM2M_OBJECT_SECURITY_ID &&
  1161b5:	66 85 c0             	test   %ax,%ax
  1161b8:	74 e9                	je     1161a3 <handle_request+0xbc>
			ret = lwm2m_delete_obj_inst(obj_inst->obj->obj_id,
  1161ba:	50                   	push   %eax
  1161bb:	6a 00                	push   $0x0
  1161bd:	e8 4b f8 ff ff       	call   115a0d <lwm2m_delete_obj_inst>
  1161c2:	5a                   	pop    %edx
			if (ret < 0) {
  1161c3:	85 c0                	test   %eax,%eax
			ret = lwm2m_delete_obj_inst(obj_inst->obj->obj_id,
  1161c5:	59                   	pop    %ecx
			if (ret < 0) {
  1161c6:	79 db                	jns    1161a3 <handle_request+0xbc>
  1161c8:	e9 9d 15 00 00       	jmp    11776a <handle_request+0x1683>
	if (r == 2 &&
  1161cd:	0f b6 85 66 ff ff ff 	movzbl -0x9a(%ebp),%eax
  1161d4:	83 fb 02             	cmp    $0x2,%ebx
  1161d7:	75 6e                	jne    116247 <handle_request+0x160>
  1161d9:	3c 0b                	cmp    $0xb,%al
  1161db:	0f 85 e3 19 00 00    	jne    117bc4 <handle_request+0x1add>
	     strncmp(options[0].value, ".well-known", 11) == 0) &&
  1161e1:	6a 0b                	push   $0xb
  1161e3:	8d 85 67 ff ff ff    	lea    -0x99(%ebp),%eax
  1161e9:	68 ed 78 12 00       	push   $0x1278ed
  1161ee:	50                   	push   %eax
  1161ef:	e8 5b 5b ff ff       	call   10bd4f <strncmp>
  1161f4:	83 c4 0c             	add    $0xc,%esp
	    (options[0].len == 11U &&
  1161f7:	85 c0                	test   %eax,%eax
  1161f9:	0f 85 c5 19 00 00    	jne    117bc4 <handle_request+0x1add>
	     strncmp(options[0].value, ".well-known", 11) == 0) &&
  1161ff:	80 bd 76 ff ff ff 04 	cmpb   $0x4,-0x8a(%ebp)
  116206:	0f 85 b8 19 00 00    	jne    117bc4 <handle_request+0x1add>
	     strncmp(options[1].value, "core", 4) == 0)) {
  11620c:	6a 04                	push   $0x4
  11620e:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
  116214:	68 67 5d 12 00       	push   $0x125d67
  116219:	50                   	push   %eax
  11621a:	e8 30 5b ff ff       	call   10bd4f <strncmp>
  11621f:	83 c4 0c             	add    $0xc,%esp
	    (options[1].len == 4U &&
  116222:	85 c0                	test   %eax,%eax
  116224:	0f 85 9a 19 00 00    	jne    117bc4 <handle_request+0x1add>
		if ((code & COAP_REQUEST_MASK) != COAP_METHOD_GET) {
  11622a:	8a 85 e0 fe ff ff    	mov    -0x120(%ebp),%al
  116230:	83 e0 07             	and    $0x7,%eax
  116233:	fe c8                	dec    %al
  116235:	0f 85 d5 14 00 00    	jne    117710 <handle_request+0x1629>
		well_known = true;
  11623b:	c6 85 d8 fe ff ff 01 	movb   $0x1,-0x128(%ebp)
  116242:	e9 cc 00 00 00       	jmp    116313 <handle_request+0x22c>
	} else if ((code & COAP_REQUEST_MASK) == COAP_METHOD_POST && r == 1 && \
  116247:	8a 95 e0 fe ff ff    	mov    -0x120(%ebp),%dl
  11624d:	83 e2 07             	and    $0x7,%edx
  116250:	80 fa 02             	cmp    $0x2,%dl
  116253:	0f 85 6b 19 00 00    	jne    117bc4 <handle_request+0x1add>
  116259:	83 fb 01             	cmp    $0x1,%ebx
  11625c:	0f 85 62 19 00 00    	jne    117bc4 <handle_request+0x1add>
		   strncmp(options[0].value, "bs", options[0].len) == 0) {
  116262:	50                   	push   %eax
  116263:	8d 85 67 ff ff ff    	lea    -0x99(%ebp),%eax
  116269:	68 f9 78 12 00       	push   $0x1278f9
  11626e:	50                   	push   %eax
  11626f:	e8 db 5a ff ff       	call   10bd4f <strncmp>
  116274:	83 c4 0c             	add    $0xc,%esp
	} else if ((code & COAP_REQUEST_MASK) == COAP_METHOD_POST && r == 1 && \
  116277:	85 c0                	test   %eax,%eax
  116279:	0f 85 45 19 00 00    	jne    117bc4 <handle_request+0x1add>
		engine_bootstrap_finish();
  11627f:	e8 a0 74 00 00       	call   11d724 <engine_bootstrap_finish>
		msg->code = COAP_RESPONSE_CODE_CHANGED;
  116284:	c6 86 87 02 00 00 44 	movb   $0x44,0x287(%esi)
		r = lwm2m_init_message(msg);
  11628b:	e9 cb 14 00 00       	jmp    11775b <handle_request+0x1674>
		if (len == 0U || opt[i].len != len) {
  116290:	66 85 d2             	test   %dx,%dx
  116293:	74 68                	je     1162fd <handle_request+0x216>
	for (int i = 0; i < options_count; i++) {
  116295:	40                   	inc    %eax
  116296:	83 c7 10             	add    $0x10,%edi
  116299:	39 c3                	cmp    %eax,%ebx
  11629b:	74 63                	je     116300 <handle_request+0x219>
		*id[i] = atou16(opt[i].value, opt[i].len, &len);
  11629d:	8b 4c 85 a4          	mov    -0x5c(%ebp,%eax,4),%ecx
	while (pos < buflen && isdigit(buf[pos])) {
  1162a1:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  1162a8:	00 00 00 
		*id[i] = atou16(opt[i].value, opt[i].len, &len);
  1162ab:	89 8d c8 fe ff ff    	mov    %ecx,-0x138(%ebp)
	uint16_t val = 0U;
  1162b1:	66 c7 85 d8 fe ff ff 	movw   $0x0,-0x128(%ebp)
  1162b8:	00 00 
  1162ba:	0f b6 4f 02          	movzbl 0x2(%edi),%ecx
  1162be:	66 89 8d d4 fe ff ff 	mov    %cx,-0x12c(%ebp)
	while (pos < buflen && isdigit(buf[pos])) {
  1162c5:	8b 8d e4 fe ff ff    	mov    -0x11c(%ebp),%ecx
  1162cb:	66 39 8d d4 fe ff ff 	cmp    %cx,-0x12c(%ebp)
  1162d2:	66 89 8d cc fe ff ff 	mov    %cx,-0x134(%ebp)
  1162d9:	0f 87 0d 19 00 00    	ja     117bec <handle_request+0x1b05>
		*id[i] = atou16(opt[i].value, opt[i].len, &len);
  1162df:	8b 8d c8 fe ff ff    	mov    -0x138(%ebp),%ecx
  1162e5:	8b 95 d8 fe ff ff    	mov    -0x128(%ebp),%edx
  1162eb:	66 89 11             	mov    %dx,(%ecx)
		if (len == 0U || opt[i].len != len) {
  1162ee:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
  1162f4:	66 39 95 d4 fe ff ff 	cmp    %dx,-0x12c(%ebp)
  1162fb:	74 93                	je     116290 <handle_request+0x1a9>
			path->level = i;
  1162fd:	88 46 2c             	mov    %al,0x2c(%esi)
	return options_count == path->level ? 0 : -EINVAL;
  116300:	0f b6 46 2c          	movzbl 0x2c(%esi),%eax
  116304:	39 c3                	cmp    %eax,%ebx
  116306:	0f 85 21 14 00 00    	jne    11772d <handle_request+0x1646>
	bool well_known = false;
  11630c:	c6 85 d8 fe ff ff 00 	movb   $0x0,-0x128(%ebp)
	r = coap_find_options(msg->in.in_cpkt, COAP_OPTION_CONTENT_FORMAT,
  116313:	6a 01                	push   $0x1
  116315:	8d 9d 64 ff ff ff    	lea    -0x9c(%ebp),%ebx
  11631b:	53                   	push   %ebx
  11631c:	6a 0c                	push   $0xc
  11631e:	ff 76 08             	pushl  0x8(%esi)
  116321:	e8 74 27 ff ff       	call   108a9a <coap_find_options>
  116326:	83 c4 10             	add    $0x10,%esp
	if (r > 0) {
  116329:	85 c0                	test   %eax,%eax
  11632b:	0f 8e 8b 00 00 00    	jle    1163bc <handle_request+0x2d5>
		format = coap_option_value_to_int(&options[0]);
  116331:	53                   	push   %ebx
  116332:	e8 e7 25 ff ff       	call   10891e <coap_option_value_to_int>
	switch (format) {
  116337:	66 3d 06 06          	cmp    $0x606,%ax
		format = coap_option_value_to_int(&options[0]);
  11633b:	5f                   	pop    %edi
  11633c:	89 c7                	mov    %eax,%edi
	switch (format) {
  11633e:	74 32                	je     116372 <handle_request+0x28b>
  116340:	77 13                	ja     116355 <handle_request+0x26e>
  116342:	66 83 f8 2a          	cmp    $0x2a,%ax
  116346:	74 21                	je     116369 <handle_request+0x282>
  116348:	66 3d 05 06          	cmp    $0x605,%ax
  11634c:	74 1b                	je     116369 <handle_request+0x282>
  11634e:	66 85 c0             	test   %ax,%ax
  116351:	74 16                	je     116369 <handle_request+0x282>
  116353:	eb 2f                	jmp    116384 <handle_request+0x29d>
  116355:	66 3d 16 2d          	cmp    $0x2d16,%ax
  116359:	74 17                	je     116372 <handle_request+0x28b>
  11635b:	66 3d 17 2d          	cmp    $0x2d17,%ax
  11635f:	74 1a                	je     11637b <handle_request+0x294>
  116361:	66 3d 07 06          	cmp    $0x607,%ax
  116365:	74 14                	je     11637b <handle_request+0x294>
  116367:	eb 1b                	jmp    116384 <handle_request+0x29d>
		in->reader = &plain_text_reader;
  116369:	c7 46 04 60 3c 12 00 	movl   $0x123c60,0x4(%esi)
		if (r < 0) {
  116370:	eb 4d                	jmp    1163bf <handle_request+0x2d8>
		in->reader = &oma_tlv_reader;
  116372:	c7 46 04 e0 3c 12 00 	movl   $0x123ce0,0x4(%esi)
		if (r < 0) {
  116379:	eb 44                	jmp    1163bf <handle_request+0x2d8>
		in->reader = &json_reader;
  11637b:	c7 46 04 60 3d 12 00 	movl   $0x123d60,0x4(%esi)
		if (r < 0) {
  116382:	eb 3b                	jmp    1163bf <handle_request+0x2d8>
		LOG_WRN("Unknown content type %u", format);
  116384:	f6 05 d0 5b 14 00 06 	testb  $0x6,0x145bd0
  11638b:	0f 84 8b 13 00 00    	je     11771c <handle_request+0x1635>
  116391:	ba 20 31 12 00       	mov    $0x123120,%edx
  116396:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11639c:	c1 ea 03             	shr    $0x3,%edx
  11639f:	c1 e2 06             	shl    $0x6,%edx
  1163a2:	83 ca 02             	or     $0x2,%edx
  1163a5:	52                   	push   %edx
  1163a6:	0f b7 c0             	movzwl %ax,%eax
  1163a9:	50                   	push   %eax
  1163aa:	68 b7 74 12 00       	push   $0x1274b7
  1163af:	e8 c2 d1 fe ff       	call   103576 <log_1>
  1163b4:	83 c4 0c             	add    $0xc,%esp
		if (r < 0) {
  1163b7:	e9 60 13 00 00       	jmp    11771c <handle_request+0x1635>
	uint16_t format = LWM2M_FORMAT_NONE, accept;
  1163bc:	83 cf ff             	or     $0xffffffff,%edi
	r = coap_find_options(msg->in.in_cpkt, COAP_OPTION_ACCEPT, options, 1);
  1163bf:	6a 01                	push   $0x1
  1163c1:	8d 9d 64 ff ff ff    	lea    -0x9c(%ebp),%ebx
  1163c7:	53                   	push   %ebx
  1163c8:	6a 11                	push   $0x11
  1163ca:	ff 76 08             	pushl  0x8(%esi)
  1163cd:	e8 c8 26 ff ff       	call   108a9a <coap_find_options>
  1163d2:	83 c4 10             	add    $0x10,%esp
		accept = LWM2M_FORMAT_OMA_TLV;
  1163d5:	66 c7 85 d0 fe ff ff 	movw   $0x2d16,-0x130(%ebp)
  1163dc:	16 2d 
	if (r > 0) {
  1163de:	85 c0                	test   %eax,%eax
  1163e0:	7e 0e                	jle    1163f0 <handle_request+0x309>
		accept = coap_option_value_to_int(&options[0]);
  1163e2:	53                   	push   %ebx
  1163e3:	e8 36 25 ff ff       	call   10891e <coap_option_value_to_int>
  1163e8:	5b                   	pop    %ebx
  1163e9:	66 89 85 d0 fe ff ff 	mov    %ax,-0x130(%ebp)
	r = select_writer(&msg->out, accept);
  1163f0:	0f b7 95 d0 fe ff ff 	movzwl -0x130(%ebp),%edx
  1163f7:	8d 46 18             	lea    0x18(%esi),%eax
  1163fa:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  116400:	e8 a8 e9 ff ff       	call   114dad <select_writer>
	if (r < 0) {
  116405:	85 c0                	test   %eax,%eax
  116407:	0f 88 5d 13 00 00    	js     11776a <handle_request+0x1683>
	if (!well_known) {
  11640d:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
	struct lwm2m_engine_obj *obj = NULL;
  116414:	c7 85 cc fe ff ff 00 	movl   $0x0,-0x134(%ebp)
  11641b:	00 00 00 
	if (!well_known) {
  11641e:	75 1d                	jne    11643d <handle_request+0x356>
		obj = get_engine_obj(msg->path.obj_id);
  116420:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  116424:	e8 e1 e6 ff ff       	call   114b0a <get_engine_obj>
  116429:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if (!obj) {
  11642f:	85 c0                	test   %eax,%eax
  116431:	0f 84 00 13 00 00    	je     117737 <handle_request+0x1650>
  116437:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
	switch (code & COAP_REQUEST_MASK) {
  11643d:	8a 95 e0 fe ff ff    	mov    -0x120(%ebp),%dl
  116443:	83 e2 07             	and    $0x7,%edx
  116446:	80 fa 03             	cmp    $0x3,%dl
  116449:	0f 84 a1 00 00 00    	je     1164f0 <handle_request+0x409>
  11644f:	8a 85 e0 fe ff ff    	mov    -0x120(%ebp),%al
  116455:	24 04                	and    $0x4,%al
  116457:	75 0f                	jne    116468 <handle_request+0x381>
  116459:	80 fa 01             	cmp    $0x1,%dl
  11645c:	74 26                	je     116484 <handle_request+0x39d>
  11645e:	80 fa 02             	cmp    $0x2,%dl
  116461:	74 60                	je     1164c3 <handle_request+0x3dc>
  116463:	e9 a3 00 00 00       	jmp    11650b <handle_request+0x424>
  116468:	80 fa 04             	cmp    $0x4,%dl
  11646b:	0f 85 9a 00 00 00    	jne    11650b <handle_request+0x424>
		msg->operation = LWM2M_OP_DELETE;
  116471:	c6 86 89 02 00 00 03 	movb   $0x3,0x289(%esi)
		msg->code = COAP_RESPONSE_CODE_DELETED;
  116478:	c6 86 87 02 00 00 42 	movb   $0x42,0x287(%esi)
  11647f:	e9 87 00 00 00       	jmp    11650b <handle_request+0x424>
		if (well_known || accept == LWM2M_FORMAT_APP_LINK_FORMAT) {
  116484:	66 83 bd d0 fe ff ff 	cmpw   $0x28,-0x130(%ebp)
  11648b:	28 
  11648c:	74 09                	je     116497 <handle_request+0x3b0>
  11648e:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116495:	74 0b                	je     1164a2 <handle_request+0x3bb>
			msg->operation = LWM2M_OP_DISCOVER;
  116497:	b0 08                	mov    $0x8,%al
			accept = LWM2M_FORMAT_APP_LINK_FORMAT;
  116499:	66 c7 85 d0 fe ff ff 	movw   $0x28,-0x130(%ebp)
  1164a0:	28 00 
  1164a2:	88 86 89 02 00 00    	mov    %al,0x289(%esi)
		observe = coap_get_option_int(msg->in.in_cpkt,
  1164a8:	6a 06                	push   $0x6
  1164aa:	ff 76 08             	pushl  0x8(%esi)
  1164ad:	e8 6d 28 ff ff       	call   108d1f <coap_get_option_int>
  1164b2:	5a                   	pop    %edx
  1164b3:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  1164b9:	59                   	pop    %ecx
		msg->code = COAP_RESPONSE_CODE_CONTENT;
  1164ba:	c6 86 87 02 00 00 45 	movb   $0x45,0x287(%esi)
		break;
  1164c1:	eb 52                	jmp    116515 <handle_request+0x42e>
		if (msg->path.level == 1U) {
  1164c3:	8a 46 2c             	mov    0x2c(%esi),%al
  1164c6:	3c 01                	cmp    $0x1,%al
  1164c8:	75 10                	jne    1164da <handle_request+0x3f3>
			msg->operation = LWM2M_OP_CREATE;
  1164ca:	c6 86 89 02 00 00 02 	movb   $0x2,0x289(%esi)
			msg->code = COAP_RESPONSE_CODE_CREATED;
  1164d1:	c6 86 87 02 00 00 41 	movb   $0x41,0x287(%esi)
  1164d8:	eb 31                	jmp    11650b <handle_request+0x424>
		} else if (msg->path.level == 2U) {
  1164da:	3c 02                	cmp    $0x2,%al
  1164dc:	75 09                	jne    1164e7 <handle_request+0x400>
			msg->operation = LWM2M_OP_WRITE;
  1164de:	c6 86 89 02 00 00 01 	movb   $0x1,0x289(%esi)
			msg->code = COAP_RESPONSE_CODE_CHANGED;
  1164e5:	eb 1d                	jmp    116504 <handle_request+0x41d>
			msg->operation = LWM2M_OP_EXECUTE;
  1164e7:	c6 86 89 02 00 00 04 	movb   $0x4,0x289(%esi)
			msg->code = COAP_RESPONSE_CODE_CHANGED;
  1164ee:	eb 14                	jmp    116504 <handle_request+0x41d>
			msg->operation = LWM2M_OP_WRITE_ATTR;
  1164f0:	66 83 ff ff          	cmp    $0xffff,%di
  1164f4:	0f 94 c0             	sete   %al
  1164f7:	8d 04 c5 01 00 00 00 	lea    0x1(,%eax,8),%eax
  1164fe:	88 86 89 02 00 00    	mov    %al,0x289(%esi)
		msg->code = COAP_RESPONSE_CODE_CHANGED;
  116504:	c6 86 87 02 00 00 44 	movb   $0x44,0x287(%esi)
	int observe = -1; /* default to -1, 0 = ENABLE, 1 = DISABLE */
  11650b:	c7 85 e0 fe ff ff ff 	movl   $0xffffffff,-0x120(%ebp)
  116512:	ff ff ff 
	msg->in.offset = msg->in.in_cpkt->hdr_len + msg->in.in_cpkt->opt_len;
  116515:	8b 46 08             	mov    0x8(%esi),%eax
  116518:	0f b6 50 08          	movzbl 0x8(%eax),%edx
  11651c:	66 03 50 0a          	add    0xa(%eax),%dx
  116520:	66 89 56 0c          	mov    %dx,0xc(%esi)
	coap_packet_get_payload(msg->in.in_cpkt, &payload_len);
  116524:	8d 95 ea fe ff ff    	lea    -0x116(%ebp),%edx
  11652a:	52                   	push   %edx
  11652b:	50                   	push   %eax
  11652c:	e8 c6 26 ff ff       	call   108bf7 <coap_packet_get_payload>
  116531:	58                   	pop    %eax
  116532:	5a                   	pop    %edx
	block_opt = coap_get_option_int(msg->in.in_cpkt, COAP_OPTION_BLOCK1);
  116533:	6a 1b                	push   $0x1b
  116535:	ff 76 08             	pushl  0x8(%esi)
  116538:	e8 e2 27 ff ff       	call   108d1f <coap_get_option_int>
  11653d:	59                   	pop    %ecx
  11653e:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
  116544:	5b                   	pop    %ebx
	if (block_opt > 0) {
  116545:	85 c0                	test   %eax,%eax
  116547:	0f 8e b9 02 00 00    	jle    116806 <handle_request+0x71f>
		if (!last_block &&
  11654d:	83 e0 08             	and    $0x8,%eax
  116550:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
  116556:	74 20                	je     116578 <handle_request+0x491>
		block_size = GET_BLOCK_SIZE(block_opt);
  116558:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
  11655e:	b8 01 00 00 00       	mov    $0x1,%eax
  116563:	83 e1 07             	and    $0x7,%ecx
  116566:	83 c1 04             	add    $0x4,%ecx
  116569:	d3 e0                	shl    %cl,%eax
		if (!last_block &&
  11656b:	66 39 85 ea fe ff ff 	cmp    %ax,-0x116(%ebp)
  116572:	0f 82 c6 11 00 00    	jb     11773e <handle_request+0x1657>
		block_num = GET_BLOCK_NUM(block_opt);
  116578:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
  11657e:	c7 85 e4 fe ff ff 80 	movl   $0x12cf80,-0x11c(%ebp)
  116585:	cf 12 00 
  116588:	c1 f8 04             	sar    $0x4,%eax
  11658b:	ba 80 cf 12 00       	mov    $0x12cf80,%edx
  116590:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
  116596:	31 db                	xor    %ebx,%ebx
		if (block1_contexts[i].tkl == tkl &&
  116598:	8a 85 dc fe ff ff    	mov    -0x124(%ebp),%al
  11659e:	3a 42 28             	cmp    0x28(%edx),%al
  1165a1:	75 62                	jne    116605 <handle_request+0x51e>
  1165a3:	89 d0                	mov    %edx,%eax
		    memcmp(token, block1_contexts[i].token, tkl) == 0) {
  1165a5:	89 95 b4 fe ff ff    	mov    %edx,-0x14c(%ebp)
  1165ab:	2d 80 cf 12 00       	sub    $0x12cf80,%eax
  1165b0:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
  1165b6:	0f b6 85 dc fe ff ff 	movzbl -0x124(%ebp),%eax
  1165bd:	50                   	push   %eax
  1165be:	8d 42 20             	lea    0x20(%edx),%eax
  1165c1:	50                   	push   %eax
  1165c2:	8d 85 ff fe ff ff    	lea    -0x101(%ebp),%eax
  1165c8:	50                   	push   %eax
  1165c9:	e8 b1 57 ff ff       	call   10bd7f <memcmp>
  1165ce:	83 c4 0c             	add    $0xc,%esp
		if (block1_contexts[i].tkl == tkl &&
  1165d1:	8b 95 b4 fe ff ff    	mov    -0x14c(%ebp),%edx
  1165d7:	85 c0                	test   %eax,%eax
  1165d9:	75 2a                	jne    116605 <handle_request+0x51e>
			(*ctx)->timestamp = k_uptime_get();
  1165db:	6b db 2c             	imul   $0x2c,%ebx,%ebx
			*ctx = &block1_contexts[i];
  1165de:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
  1165e4:	05 80 cf 12 00       	add    $0x12cf80,%eax
  1165e9:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
			(*ctx)->timestamp = k_uptime_get();
  1165ef:	e8 4e e6 ff ff       	call   114c42 <k_uptime_get>
  1165f4:	89 83 94 cf 12 00    	mov    %eax,0x12cf94(%ebx)
  1165fa:	89 93 98 cf 12 00    	mov    %edx,0x12cf98(%ebx)
		if (r < 0) {
  116600:	e9 b9 00 00 00       	jmp    1166be <handle_request+0x5d7>
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
  116605:	43                   	inc    %ebx
  116606:	83 c2 2c             	add    $0x2c,%edx
  116609:	83 fb 03             	cmp    $0x3,%ebx
  11660c:	75 8a                	jne    116598 <handle_request+0x4b1>
		if (r < 0 && block_num == 0) {
  11660e:	83 bd c8 fe ff ff 00 	cmpl   $0x0,-0x138(%ebp)
		return -ENOENT;
  116615:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (r < 0 && block_num == 0) {
  11661a:	0f 85 68 15 00 00    	jne    117b88 <handle_request+0x1aa1>
	timestamp = k_uptime_get();
  116620:	e8 1d e6 ff ff       	call   114c42 <k_uptime_get>
  116625:	89 85 bc fe ff ff    	mov    %eax,-0x144(%ebp)
  11662b:	89 95 c0 fe ff ff    	mov    %edx,-0x140(%ebp)
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
  116631:	31 c0                	xor    %eax,%eax
		if (block1_contexts[i].tkl == 0U) {
  116633:	8b 8d e4 fe ff ff    	mov    -0x11c(%ebp),%ecx
  116639:	80 79 28 00          	cmpb   $0x0,0x28(%ecx)
  11663d:	0f 85 da 14 00 00    	jne    117b1d <handle_request+0x1a36>
			*ctx = &block1_contexts[i];
  116643:	6b c0 2c             	imul   $0x2c,%eax,%eax
  116646:	05 80 cf 12 00       	add    $0x12cf80,%eax
  11664b:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
	(*ctx)->tkl = tkl;
  116651:	8b 9d e4 fe ff ff    	mov    -0x11c(%ebp),%ebx
  116657:	0f b6 85 dc fe ff ff 	movzbl -0x124(%ebp),%eax
  11665e:	88 43 28             	mov    %al,0x28(%ebx)
	memcpy((*ctx)->token, token, tkl);
  116661:	50                   	push   %eax
  116662:	8d 85 ff fe ff ff    	lea    -0x101(%ebp),%eax
  116668:	50                   	push   %eax
  116669:	89 d8                	mov    %ebx,%eax
  11666b:	83 c0 20             	add    $0x20,%eax
  11666e:	50                   	push   %eax
  11666f:	e8 78 57 ff ff       	call   10bdec <memcpy>
  116674:	83 c4 0c             	add    $0xc,%esp
	coap_block_transfer_init(&(*ctx)->ctx, lwm2m_default_block_size(), 0);
  116677:	6a 00                	push   $0x0
  116679:	6a 05                	push   $0x5
  11667b:	ff b5 e4 fe ff ff    	pushl  -0x11c(%ebp)
  116681:	e8 b5 25 ff ff       	call   108c3b <coap_block_transfer_init>
	(*ctx)->timestamp = timestamp;
  116686:	8b 9d e4 fe ff ff    	mov    -0x11c(%ebp),%ebx
	coap_block_transfer_init(&(*ctx)->ctx, lwm2m_default_block_size(), 0);
  11668c:	83 c4 0c             	add    $0xc,%esp
	(*ctx)->timestamp = timestamp;
  11668f:	8b 85 bc fe ff ff    	mov    -0x144(%ebp),%eax
  116695:	8b 95 c0 fe ff ff    	mov    -0x140(%ebp),%edx
  11669b:	89 43 14             	mov    %eax,0x14(%ebx)
	(*ctx)->last_block = false;
  11669e:	80 63 29 fe          	andb   $0xfe,0x29(%ebx)
	(*ctx)->timestamp = timestamp;
  1166a2:	89 53 18             	mov    %edx,0x18(%ebx)
	(*ctx)->expected = 0;
  1166a5:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  1166ac:	89 d8                	mov    %ebx,%eax
	memset(&(*ctx)->opaque, 0, sizeof((*ctx)->opaque));
  1166ae:	6a 08                	push   $0x8
  1166b0:	6a 00                	push   $0x0
  1166b2:	83 c0 0c             	add    $0xc,%eax
  1166b5:	50                   	push   %eax
  1166b6:	e8 a0 57 ff ff       	call   10be5b <memset>
  1166bb:	83 c4 0c             	add    $0xc,%esp
		msg->in.block_ctx = block_ctx;
  1166be:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
		last_block = !GET_MORE(block_opt);
  1166c4:	83 bd b8 fe ff ff 00 	cmpl   $0x0,-0x148(%ebp)
  1166cb:	0f 94 85 bc fe ff ff 	sete   -0x144(%ebp)
		if (block_num < block_ctx->expected) {
  1166d2:	8b 48 1c             	mov    0x1c(%eax),%ecx
		msg->in.block_ctx = block_ctx;
  1166d5:	89 46 10             	mov    %eax,0x10(%esi)
		if (block_num < block_ctx->expected) {
  1166d8:	3b 8d c8 fe ff ff    	cmp    -0x138(%ebp),%ecx
  1166de:	76 41                	jbe    116721 <handle_request+0x63a>
			LOG_WRN("Block already handled %d, expected %d",
  1166e0:	f6 05 d0 5b 14 00 06 	testb  $0x6,0x145bd0
			ignore = true;
  1166e7:	c6 85 d4 fe ff ff 01 	movb   $0x1,-0x12c(%ebp)
			LOG_WRN("Block already handled %d, expected %d",
  1166ee:	0f 84 00 01 00 00    	je     1167f4 <handle_request+0x70d>
  1166f4:	b8 20 31 12 00       	mov    $0x123120,%eax
  1166f9:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1166fe:	c1 e8 03             	shr    $0x3,%eax
  116701:	c1 e0 06             	shl    $0x6,%eax
  116704:	83 c8 02             	or     $0x2,%eax
  116707:	50                   	push   %eax
  116708:	51                   	push   %ecx
  116709:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
  11670f:	68 35 79 12 00       	push   $0x127935
  116714:	e8 97 ce fe ff       	call   1035b0 <log_2>
  116719:	83 c4 10             	add    $0x10,%esp
  11671c:	e9 d3 00 00 00       	jmp    1167f4 <handle_request+0x70d>
		} else if (block_num > block_ctx->expected) {
  116721:	73 4c                	jae    11676f <handle_request+0x688>
			LOG_WRN("Block out of order %d, expected %d",
  116723:	f6 05 d0 5b 14 00 06 	testb  $0x6,0x145bd0
			r = -EFAULT;
  11672a:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
			LOG_WRN("Block out of order %d, expected %d",
  11672f:	0f 84 3f 10 00 00    	je     117774 <handle_request+0x168d>
  116735:	ba 20 31 12 00       	mov    $0x123120,%edx
  11673a:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  116740:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  116746:	c1 ea 03             	shr    $0x3,%edx
  116749:	c1 e2 06             	shl    $0x6,%edx
  11674c:	83 ca 02             	or     $0x2,%edx
  11674f:	52                   	push   %edx
  116750:	51                   	push   %ecx
  116751:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
  116757:	68 5b 79 12 00       	push   $0x12795b
  11675c:	e8 4f ce fe ff       	call   1035b0 <log_2>
  116761:	83 c4 10             	add    $0x10,%esp
  116764:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
  11676a:	e9 05 10 00 00       	jmp    117774 <handle_request+0x168d>
			r = coap_update_from_block(msg->in.in_cpkt, &block_ctx->ctx);
  11676f:	ff b5 e4 fe ff ff    	pushl  -0x11c(%ebp)
  116775:	ff 76 08             	pushl  0x8(%esi)
  116778:	e8 e2 25 ff ff       	call   108d5f <coap_update_from_block>
  11677d:	59                   	pop    %ecx
			if (r < 0) {
  11677e:	85 c0                	test   %eax,%eax
			r = coap_update_from_block(msg->in.in_cpkt, &block_ctx->ctx);
  116780:	5b                   	pop    %ebx
			if (r < 0) {
  116781:	79 33                	jns    1167b6 <handle_request+0x6cf>
				LOG_ERR("Error from block update: %d", r);
  116783:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  11678a:	0f 84 e4 0f 00 00    	je     117774 <handle_request+0x168d>
  116790:	ba 20 31 12 00       	mov    $0x123120,%edx
  116795:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  11679b:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  1167a1:	c1 ea 03             	shr    $0x3,%edx
  1167a4:	c1 e2 06             	shl    $0x6,%edx
  1167a7:	83 ca 01             	or     $0x1,%edx
  1167aa:	52                   	push   %edx
  1167ab:	50                   	push   %eax
  1167ac:	68 7e 79 12 00       	push   $0x12797e
  1167b1:	e9 f9 00 00 00       	jmp    1168af <handle_request+0x7c8>
			block_ctx->last_block = last_block;
  1167b6:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
  1167bc:	8b 8d e4 fe ff ff    	mov    -0x11c(%ebp),%ecx
  1167c2:	8a 40 29             	mov    0x29(%eax),%al
			block_ctx->expected += GET_BLOCK_SIZE(block_opt) -
  1167c5:	8b 51 1c             	mov    0x1c(%ecx),%edx
			block_ctx->last_block = last_block;
  1167c8:	88 85 c8 fe ff ff    	mov    %al,-0x138(%ebp)
  1167ce:	83 e0 fe             	and    $0xfffffffe,%eax
  1167d1:	0b 85 bc fe ff ff    	or     -0x144(%ebp),%eax
  1167d7:	88 41 29             	mov    %al,0x29(%ecx)
			block_ctx->expected += GET_BLOCK_SIZE(block_opt) -
  1167da:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
  1167e0:	83 e0 07             	and    $0x7,%eax
	bool ignore = false;
  1167e3:	c6 85 d4 fe ff ff 00 	movb   $0x0,-0x12c(%ebp)
			block_ctx->expected += GET_BLOCK_SIZE(block_opt) -
  1167ea:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  1167ee:	2b 41 08             	sub    0x8(%ecx),%eax
  1167f1:	89 41 1c             	mov    %eax,0x1c(%ecx)
		if (!last_block) {
  1167f4:	83 bd b8 fe ff ff 00 	cmpl   $0x0,-0x148(%ebp)
  1167fb:	74 21                	je     11681e <handle_request+0x737>
			msg->code = COAP_RESPONSE_CODE_CONTINUE;
  1167fd:	c6 86 87 02 00 00 5f 	movb   $0x5f,0x287(%esi)
  116804:	eb 18                	jmp    11681e <handle_request+0x737>
	struct lwm2m_block_context *block_ctx = NULL;
  116806:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  11680d:	00 00 00 
	bool ignore = false;
  116810:	c6 85 d4 fe ff ff 00 	movb   $0x0,-0x12c(%ebp)
	bool last_block = false;
  116817:	c6 85 bc fe ff ff 00 	movb   $0x0,-0x144(%ebp)
	r = lwm2m_init_message(msg);
  11681e:	56                   	push   %esi
  11681f:	e8 cc f6 ff ff       	call   115ef0 <lwm2m_init_message>
  116824:	5a                   	pop    %edx
	if (r < 0) {
  116825:	85 c0                	test   %eax,%eax
  116827:	0f 88 47 0f 00 00    	js     117774 <handle_request+0x168d>
	if (!ignore) {
  11682d:	80 bd d4 fe ff ff 00 	cmpb   $0x0,-0x12c(%ebp)
  116834:	0f 85 6a 0e 00 00    	jne    1176a4 <handle_request+0x15bd>
		switch (msg->operation) {
  11683a:	0f b6 8e 89 02 00 00 	movzbl 0x289(%esi),%ecx
  116841:	80 f9 09             	cmp    $0x9,%cl
  116844:	0f 87 1a 0e 00 00    	ja     117664 <handle_request+0x157d>
  11684a:	0f b6 c1             	movzbl %cl,%eax
  11684d:	ff 24 85 e4 44 12 00 	jmp    *0x1244e4(,%eax,4)
			if (observe == 0) {
  116854:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
  11685b:	0f 85 9d 03 00 00    	jne    116bfe <handle_request+0xb17>
				if (msg->token) {
  116861:	83 be 78 02 00 00 00 	cmpl   $0x0,0x278(%esi)
  116868:	0f 84 52 03 00 00    	je     116bc0 <handle_request+0xad9>
					r = coap_append_option_int(
  11686e:	6a 00                	push   $0x0
  116870:	6a 06                	push   $0x6
  116872:	ff 76 1c             	pushl  0x1c(%esi)
  116875:	e8 38 20 ff ff       	call   1088b2 <coap_append_option_int>
  11687a:	83 c4 0c             	add    $0xc,%esp
					if (r < 0) {
  11687d:	85 c0                	test   %eax,%eax
  11687f:	79 3b                	jns    1168bc <handle_request+0x7d5>
						LOG_ERR("OBSERVE option error: %d", r);
  116881:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116888:	0f 84 e6 0e 00 00    	je     117774 <handle_request+0x168d>
  11688e:	ba 20 31 12 00       	mov    $0x123120,%edx
  116893:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  116899:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11689f:	c1 ea 03             	shr    $0x3,%edx
  1168a2:	c1 e2 06             	shl    $0x6,%edx
  1168a5:	83 ca 01             	or     $0x1,%edx
  1168a8:	52                   	push   %edx
  1168a9:	50                   	push   %eax
  1168aa:	68 9a 79 12 00       	push   $0x12799a
  1168af:	e8 c2 cc fe ff       	call   103576 <log_1>
  1168b4:	83 c4 0c             	add    $0xc,%esp
  1168b7:	e9 a8 fe ff ff       	jmp    116764 <handle_request+0x67d>
	struct notification_attrs attrs = {
  1168bc:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
  1168c2:	8d 7d a4             	lea    -0x5c(%ebp),%edi
  1168c5:	b9 09 00 00 00       	mov    $0x9,%ecx
  1168ca:	f3 ab                	rep stos %eax,%es:(%edi)
	if (!msg || !msg->ctx) {
  1168cc:	8b 06                	mov    (%esi),%eax
	struct notification_attrs attrs = {
  1168ce:	c6 45 c4 03          	movb   $0x3,-0x3c(%ebp)
	if (!msg || !msg->ctx) {
  1168d2:	85 c0                	test   %eax,%eax
  1168d4:	75 2b                	jne    116901 <handle_request+0x81a>
		LOG_ERR("valid lwm2m message is required");
  1168d6:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1168dd:	74 69                	je     116948 <handle_request+0x861>
  1168df:	b8 20 31 12 00       	mov    $0x123120,%eax
  1168e4:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1168e9:	c1 e8 03             	shr    $0x3,%eax
  1168ec:	c1 e0 06             	shl    $0x6,%eax
  1168ef:	83 c8 01             	or     $0x1,%eax
  1168f2:	50                   	push   %eax
  1168f3:	68 b3 79 12 00       	push   $0x1279b3
  1168f8:	e8 50 cc fe ff       	call   10354d <log_0>
  1168fd:	5f                   	pop    %edi
  1168fe:	58                   	pop    %eax
					if (r < 0) {
  1168ff:	eb 47                	jmp    116948 <handle_request+0x861>
	if (!token || (tkl == 0U || tkl > MAX_TOKEN_LEN)) {
  116901:	8b bd dc fe ff ff    	mov    -0x124(%ebp),%edi
  116907:	8d 57 ff             	lea    -0x1(%edi),%edx
  11690a:	80 fa 07             	cmp    $0x7,%dl
  11690d:	76 43                	jbe    116952 <handle_request+0x86b>
		LOG_ERR("token(%p) and token length(%u) must be valid.",
  11690f:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116916:	74 30                	je     116948 <handle_request+0x861>
  116918:	b8 20 31 12 00       	mov    $0x123120,%eax
  11691d:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  116922:	c1 e8 03             	shr    $0x3,%eax
  116925:	c1 e0 06             	shl    $0x6,%eax
  116928:	83 c8 01             	or     $0x1,%eax
  11692b:	50                   	push   %eax
  11692c:	0f b6 85 dc fe ff ff 	movzbl -0x124(%ebp),%eax
  116933:	50                   	push   %eax
  116934:	8d 85 ff fe ff ff    	lea    -0x101(%ebp),%eax
  11693a:	50                   	push   %eax
  11693b:	68 cf 74 12 00       	push   $0x1274cf
  116940:	e8 6b cc fe ff       	call   1035b0 <log_2>
  116945:	83 c4 10             	add    $0x10,%esp
		return -EINVAL;
  116948:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  11694d:	e9 3b 02 00 00       	jmp    116b8d <handle_request+0xaa6>
	attrs.pmin = lwm2m_server_get_pmin(msg->ctx->srv_obj_inst);
  116952:	0f b7 80 54 01 00 00 	movzwl 0x154(%eax),%eax
  116959:	50                   	push   %eax
  11695a:	e8 e9 35 00 00       	call   119f48 <lwm2m_server_get_pmin>
  11695f:	89 45 bc             	mov    %eax,-0x44(%ebp)
	attrs.pmax = lwm2m_server_get_pmax(msg->ctx->srv_obj_inst);
  116962:	8b 06                	mov    (%esi),%eax
  116964:	0f b7 80 54 01 00 00 	movzwl 0x154(%eax),%eax
  11696b:	89 04 24             	mov    %eax,(%esp)
  11696e:	e8 16 36 00 00       	call   119f89 <lwm2m_server_get_pmax>
  116973:	5b                   	pop    %ebx
  116974:	89 45 c0             	mov    %eax,-0x40(%ebp)
	return list->head;
  116977:	8b 1d a4 ec 12 00    	mov    0x12eca4,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  11697d:	85 db                	test   %ebx,%ebx
  11697f:	74 4a                	je     1169cb <handle_request+0x8e4>
		if (obs->ctx == msg->ctx &&
  116981:	8b 06                	mov    (%esi),%eax
  116983:	39 43 04             	cmp    %eax,0x4(%ebx)
  116986:	75 3f                	jne    1169c7 <handle_request+0x8e0>
		    memcmp(&obs->path, &msg->path, sizeof(msg->path)) == 0) {
  116988:	6a 0a                	push   $0xa
  11698a:	8d 46 24             	lea    0x24(%esi),%eax
  11698d:	50                   	push   %eax
  11698e:	8d 43 08             	lea    0x8(%ebx),%eax
  116991:	50                   	push   %eax
  116992:	e8 e8 53 ff ff       	call   10bd7f <memcmp>
  116997:	83 c4 0c             	add    $0xc,%esp
		if (obs->ctx == msg->ctx &&
  11699a:	85 c0                	test   %eax,%eax
  11699c:	75 29                	jne    1169c7 <handle_request+0x8e0>
			memcpy(obs->token, token, tkl);
  11699e:	0f b6 85 dc fe ff ff 	movzbl -0x124(%ebp),%eax
  1169a5:	50                   	push   %eax
  1169a6:	8d 85 ff fe ff ff    	lea    -0x101(%ebp),%eax
  1169ac:	50                   	push   %eax
  1169ad:	8d 43 12             	lea    0x12(%ebx),%eax
  1169b0:	50                   	push   %eax
  1169b1:	e8 36 54 ff ff       	call   10bdec <memcpy>
			obs->tkl = tkl;
  1169b6:	8a 85 dc fe ff ff    	mov    -0x124(%ebp),%al
			memcpy(obs->token, token, tkl);
  1169bc:	83 c4 0c             	add    $0xc,%esp
			obs->tkl = tkl;
  1169bf:	88 43 3a             	mov    %al,0x3a(%ebx)
					if (r < 0) {
  1169c2:	e9 82 02 00 00       	jmp    116c49 <handle_request+0xb62>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1169c7:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  1169c9:	eb b2                	jmp    11697d <handle_request+0x896>
	obj = get_engine_obj(msg->path.obj_id);
  1169cb:	0f b7 7e 24          	movzwl 0x24(%esi),%edi
  1169cf:	89 f8                	mov    %edi,%eax
  1169d1:	e8 34 e1 ff ff       	call   114b0a <get_engine_obj>
  1169d6:	89 c3                	mov    %eax,%ebx
	if (!obj) {
  1169d8:	85 c0                	test   %eax,%eax
  1169da:	75 35                	jne    116a11 <handle_request+0x92a>
		LOG_ERR("unable to find obj: %u", msg->path.obj_id);
  1169dc:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1169e3:	74 22                	je     116a07 <handle_request+0x920>
  1169e5:	b8 20 31 12 00       	mov    $0x123120,%eax
  1169ea:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1169ef:	c1 e8 03             	shr    $0x3,%eax
  1169f2:	c1 e0 06             	shl    $0x6,%eax
  1169f5:	83 c8 01             	or     $0x1,%eax
  1169f8:	50                   	push   %eax
  1169f9:	57                   	push   %edi
  1169fa:	68 04 77 12 00       	push   $0x127704
  1169ff:	e8 72 cb fe ff       	call   103576 <log_1>
  116a04:	83 c4 0c             	add    $0xc,%esp
		return -ENOENT;
  116a07:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  116a0c:	e9 7c 01 00 00       	jmp    116b8d <handle_request+0xaa6>
	ret = update_attrs(obj, &attrs);
  116a11:	8d 55 a4             	lea    -0x5c(%ebp),%edx
  116a14:	e8 71 e1 ff ff       	call   114b8a <update_attrs>
	if (ret < 0) {
  116a19:	85 c0                	test   %eax,%eax
  116a1b:	0f 88 6c 01 00 00    	js     116b8d <handle_request+0xaa6>
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  116a21:	31 ff                	xor    %edi,%edi
	if (msg->path.level >= 2U) {
  116a23:	80 7e 2c 01          	cmpb   $0x1,0x2c(%esi)
  116a27:	76 5f                	jbe    116a88 <handle_request+0x9a1>
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
  116a29:	0f b7 4e 24          	movzwl 0x24(%esi),%ecx
  116a2d:	0f b7 56 26          	movzwl 0x26(%esi),%edx
  116a31:	89 c8                	mov    %ecx,%eax
  116a33:	89 8d d8 fe ff ff    	mov    %ecx,-0x128(%ebp)
  116a39:	e8 e4 e0 ff ff       	call   114b22 <get_engine_obj_inst>
		if (!obj_inst) {
  116a3e:	8b 8d d8 fe ff ff    	mov    -0x128(%ebp),%ecx
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
  116a44:	89 c7                	mov    %eax,%edi
		if (!obj_inst) {
  116a46:	85 c0                	test   %eax,%eax
  116a48:	75 2e                	jne    116a78 <handle_request+0x991>
			LOG_ERR("unable to find obj_inst: %u/%u",
  116a4a:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116a51:	74 b4                	je     116a07 <handle_request+0x920>
  116a53:	b8 20 31 12 00       	mov    $0x123120,%eax
  116a58:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  116a5d:	c1 e8 03             	shr    $0x3,%eax
  116a60:	c1 e0 06             	shl    $0x6,%eax
  116a63:	83 c8 01             	or     $0x1,%eax
  116a66:	50                   	push   %eax
  116a67:	52                   	push   %edx
  116a68:	51                   	push   %ecx
  116a69:	68 d3 79 12 00       	push   $0x1279d3
  116a6e:	e8 3d cb fe ff       	call   1035b0 <log_2>
  116a73:	83 c4 10             	add    $0x10,%esp
					if (r < 0) {
  116a76:	eb 8f                	jmp    116a07 <handle_request+0x920>
		ret = update_attrs(obj_inst, &attrs);
  116a78:	8d 55 a4             	lea    -0x5c(%ebp),%edx
  116a7b:	e8 0a e1 ff ff       	call   114b8a <update_attrs>
		if (ret < 0) {
  116a80:	85 c0                	test   %eax,%eax
  116a82:	0f 88 05 01 00 00    	js     116b8d <handle_request+0xaa6>
	if (msg->path.level >= 3U) {
  116a88:	80 7e 2c 02          	cmpb   $0x2,0x2c(%esi)
  116a8c:	0f 86 ce 00 00 00    	jbe    116b60 <handle_request+0xa79>
		for (i = 0; i < obj_inst->resource_count; i++) {
  116a92:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  116a96:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
  116a9c:	31 c0                	xor    %eax,%eax
  116a9e:	3b 85 d8 fe ff ff    	cmp    -0x128(%ebp),%eax
  116aa4:	7d 12                	jge    116ab8 <handle_request+0x9d1>
			if (obj_inst->resources[i].res_id == msg->path.res_id) {
  116aa6:	6b d0 18             	imul   $0x18,%eax,%edx
  116aa9:	03 57 08             	add    0x8(%edi),%edx
  116aac:	8b 4e 28             	mov    0x28(%esi),%ecx
  116aaf:	66 39 4a 14          	cmp    %cx,0x14(%edx)
  116ab3:	74 3c                	je     116af1 <handle_request+0xa0a>
		for (i = 0; i < obj_inst->resource_count; i++) {
  116ab5:	40                   	inc    %eax
  116ab6:	eb e6                	jmp    116a9e <handle_request+0x9b7>
		if (i == obj_inst->resource_count) {
  116ab8:	75 37                	jne    116af1 <handle_request+0xa0a>
			LOG_ERR("unable to find res_id: %u/%u/%u",
  116aba:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116ac1:	0f 84 40 ff ff ff    	je     116a07 <handle_request+0x920>
  116ac7:	b8 20 31 12 00       	mov    $0x123120,%eax
  116acc:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  116ad1:	c1 e8 03             	shr    $0x3,%eax
  116ad4:	c1 e0 06             	shl    $0x6,%eax
  116ad7:	83 c8 01             	or     $0x1,%eax
  116ada:	50                   	push   %eax
  116adb:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  116adf:	50                   	push   %eax
  116ae0:	0f b7 46 26          	movzwl 0x26(%esi),%eax
  116ae4:	50                   	push   %eax
  116ae5:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  116ae9:	50                   	push   %eax
  116aea:	68 f2 79 12 00       	push   $0x1279f2
  116aef:	eb 4e                	jmp    116b3f <handle_request+0xa58>
				obj_inst->resources[i].res_id);
  116af1:	6b c0 18             	imul   $0x18,%eax,%eax
  116af4:	03 47 08             	add    0x8(%edi),%eax
  116af7:	89 c7                	mov    %eax,%edi
		obj_field = lwm2m_get_engine_obj_field(obj,
  116af9:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  116afd:	50                   	push   %eax
  116afe:	53                   	push   %ebx
  116aff:	e8 f9 e7 ff ff       	call   1152fd <lwm2m_get_engine_obj_field>
  116b04:	5a                   	pop    %edx
		if (!obj_field) {
  116b05:	85 c0                	test   %eax,%eax
		obj_field = lwm2m_get_engine_obj_field(obj,
  116b07:	59                   	pop    %ecx
		if (!obj_field) {
  116b08:	75 42                	jne    116b4c <handle_request+0xa65>
			LOG_ERR("unable to find obj_field: %u/%u/%u",
  116b0a:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116b11:	0f 84 f0 fe ff ff    	je     116a07 <handle_request+0x920>
  116b17:	b8 20 31 12 00       	mov    $0x123120,%eax
  116b1c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  116b21:	c1 e8 03             	shr    $0x3,%eax
  116b24:	c1 e0 06             	shl    $0x6,%eax
  116b27:	83 c8 01             	or     $0x1,%eax
  116b2a:	50                   	push   %eax
  116b2b:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  116b2f:	50                   	push   %eax
  116b30:	0f b7 46 26          	movzwl 0x26(%esi),%eax
  116b34:	50                   	push   %eax
  116b35:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  116b39:	50                   	push   %eax
  116b3a:	68 12 7a 12 00       	push   $0x127a12
  116b3f:	e8 b5 ca fe ff       	call   1035f9 <log_3>
  116b44:	83 c4 14             	add    $0x14,%esp
					if (r < 0) {
  116b47:	e9 bb fe ff ff       	jmp    116a07 <handle_request+0x920>
		if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_R)) {
  116b4c:	f6 40 02 01          	testb  $0x1,0x2(%eax)
  116b50:	74 38                	je     116b8a <handle_request+0xaa3>
		ret = update_attrs(&obj_inst->resources[i], &attrs);
  116b52:	8d 55 a4             	lea    -0x5c(%ebp),%edx
  116b55:	89 f8                	mov    %edi,%eax
  116b57:	e8 2e e0 ff ff       	call   114b8a <update_attrs>
		if (ret < 0) {
  116b5c:	85 c0                	test   %eax,%eax
  116b5e:	78 2d                	js     116b8d <handle_request+0xaa6>
		if (!observe_node_data[i].ctx) {
  116b60:	6b bd e0 fe ff ff 3c 	imul   $0x3c,-0x120(%ebp),%edi
  116b67:	83 bf a4 d1 12 00 00 	cmpl   $0x0,0x12d1a4(%edi)
  116b6e:	0f 84 d2 0c 00 00    	je     117846 <handle_request+0x175f>
	for (i = 0; i < CONFIG_LWM2M_ENGINE_MAX_OBSERVER; i++) {
  116b74:	ff 85 e0 fe ff ff    	incl   -0x120(%ebp)
  116b7a:	83 bd e0 fe ff ff 0a 	cmpl   $0xa,-0x120(%ebp)
  116b81:	75 dd                	jne    116b60 <handle_request+0xa79>
		return -ENOMEM;
  116b83:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  116b88:	eb 03                	jmp    116b8d <handle_request+0xaa6>
			return -EPERM;
  116b8a:	83 c8 ff             	or     $0xffffffff,%eax
						LOG_ERR("add OBSERVE error: %d", r);
  116b8d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116b94:	0f 84 da 0b 00 00    	je     117774 <handle_request+0x168d>
  116b9a:	ba 20 31 12 00       	mov    $0x123120,%edx
  116b9f:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  116ba5:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  116bab:	c1 ea 03             	shr    $0x3,%edx
  116bae:	c1 e2 06             	shl    $0x6,%edx
  116bb1:	83 ca 01             	or     $0x1,%edx
  116bb4:	52                   	push   %edx
  116bb5:	50                   	push   %eax
  116bb6:	68 35 7a 12 00       	push   $0x127a35
  116bbb:	e9 ef fc ff ff       	jmp    1168af <handle_request+0x7c8>
					LOG_ERR("OBSERVE request missing token");
  116bc0:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
					r = -EINVAL;
  116bc7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
					LOG_ERR("OBSERVE request missing token");
  116bcc:	0f 84 a2 0b 00 00    	je     117774 <handle_request+0x168d>
  116bd2:	ba 20 31 12 00       	mov    $0x123120,%edx
  116bd7:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  116bdd:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  116be3:	c1 ea 03             	shr    $0x3,%edx
  116be6:	c1 e2 06             	shl    $0x6,%edx
  116be9:	83 ca 01             	or     $0x1,%edx
  116bec:	52                   	push   %edx
  116bed:	68 4b 7a 12 00       	push   $0x127a4b
  116bf2:	e8 56 c9 fe ff       	call   10354d <log_0>
  116bf7:	59                   	pop    %ecx
  116bf8:	5b                   	pop    %ebx
  116bf9:	e9 66 fb ff ff       	jmp    116764 <handle_request+0x67d>
			} else if (observe == 1) {
  116bfe:	83 bd e0 fe ff ff 01 	cmpl   $0x1,-0x120(%ebp)
  116c05:	75 42                	jne    116c49 <handle_request+0xb62>
				r = engine_remove_observer(token, tkl);
  116c07:	0f b6 95 dc fe ff ff 	movzbl -0x124(%ebp),%edx
  116c0e:	8d 85 ff fe ff ff    	lea    -0x101(%ebp),%eax
  116c14:	e8 22 e2 ff ff       	call   114e3b <engine_remove_observer>
				if (r < 0) {
  116c19:	85 c0                	test   %eax,%eax
  116c1b:	79 2c                	jns    116c49 <handle_request+0xb62>
					LOG_ERR("remove observe error: %d", r);
  116c1d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116c24:	74 23                	je     116c49 <handle_request+0xb62>
  116c26:	ba 20 31 12 00       	mov    $0x123120,%edx
  116c2b:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  116c31:	c1 ea 03             	shr    $0x3,%edx
  116c34:	c1 e2 06             	shl    $0x6,%edx
  116c37:	83 ca 01             	or     $0x1,%edx
  116c3a:	52                   	push   %edx
  116c3b:	50                   	push   %eax
  116c3c:	68 1c 75 12 00       	push   $0x12751c
  116c41:	e8 30 c9 fe ff       	call   103576 <log_1>
  116c46:	83 c4 0c             	add    $0xc,%esp
			r = do_read_op(msg, accept);
  116c49:	0f b7 95 d0 fe ff ff 	movzwl -0x130(%ebp),%edx
  116c50:	89 f0                	mov    %esi,%eax
  116c52:	e8 91 e2 ff ff       	call   114ee8 <do_read_op>
			break;
  116c57:	e9 40 0a 00 00       	jmp    11769c <handle_request+0x15b5>
	if (!msg->ctx->bootstrap_mode && !well_known &&
  116c5c:	8b 06                	mov    (%esi),%eax
  116c5e:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  116c65:	75 1e                	jne    116c85 <handle_request+0xb9e>
  116c67:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116c6e:	75 15                	jne    116c85 <handle_request+0xb9e>
  116c70:	80 7e 2c 00          	cmpb   $0x0,0x2c(%esi)
  116c74:	0f 84 d5 0a 00 00    	je     11774f <handle_request+0x1668>
	    (msg->path.level == 0U ||
  116c7a:	66 83 7e 24 00       	cmpw   $0x0,0x24(%esi)
  116c7f:	0f 84 ca 0a 00 00    	je     11774f <handle_request+0x1668>
	ret = coap_append_option_int(msg->out.out_cpkt,
  116c85:	6a 28                	push   $0x28
  116c87:	6a 0c                	push   $0xc
  116c89:	ff 76 1c             	pushl  0x1c(%esi)
  116c8c:	e8 21 1c ff ff       	call   1088b2 <coap_append_option_int>
  116c91:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  116c94:	85 c0                	test   %eax,%eax
  116c96:	79 33                	jns    116ccb <handle_request+0xbe4>
		LOG_ERR("Error setting response content-format: %d", ret);
  116c98:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  116c9f:	0f 84 cf 0a 00 00    	je     117774 <handle_request+0x168d>
  116ca5:	ba 20 31 12 00       	mov    $0x123120,%edx
  116caa:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  116cb0:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  116cb6:	c1 ea 03             	shr    $0x3,%edx
  116cb9:	c1 e2 06             	shl    $0x6,%edx
  116cbc:	83 ca 01             	or     $0x1,%edx
  116cbf:	52                   	push   %edx
  116cc0:	50                   	push   %eax
  116cc1:	68 69 7a 12 00       	push   $0x127a69
  116cc6:	e9 e4 fb ff ff       	jmp    1168af <handle_request+0x7c8>
	ret = coap_packet_append_payload_marker(msg->out.out_cpkt);
  116ccb:	ff 76 1c             	pushl  0x1c(%esi)
  116cce:	e8 9c 1c ff ff       	call   10896f <coap_packet_append_payload_marker>
  116cd3:	5a                   	pop    %edx
	if (ret < 0) {
  116cd4:	85 c0                	test   %eax,%eax
  116cd6:	0f 88 98 0a 00 00    	js     117774 <handle_request+0x168d>
	if (well_known) {
  116cdc:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116ce3:	8b 1d ac ec 12 00    	mov    0x12ecac,%ebx
  116ce9:	0f 84 a4 00 00 00    	je     116d93 <handle_request+0xcac>
				 strlen(WELL_KNOWN_CORE_PATH));
  116cef:	68 93 7a 12 00       	push   $0x127a93
  116cf4:	e8 23 50 ff ff       	call   10bd1c <strlen>
		ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
  116cf9:	8b 5e 1c             	mov    0x1c(%esi),%ebx
  116cfc:	0f b7 c0             	movzwl %ax,%eax
  116cff:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
  116d03:	8d 53 04             	lea    0x4(%ebx),%edx
  116d06:	89 04 24             	mov    %eax,(%esp)
  116d09:	8b 03                	mov    (%ebx),%eax
  116d0b:	68 93 7a 12 00       	push   $0x127a93
  116d10:	e8 03 e0 ff ff       	call   114d18 <buf_append>
  116d15:	5b                   	pop    %ebx
  116d16:	5f                   	pop    %edi
		if (ret < 0) {
  116d17:	85 c0                	test   %eax,%eax
  116d19:	0f 88 55 0a 00 00    	js     117774 <handle_request+0x168d>
	return list->head;
  116d1f:	8b 1d b4 ec 12 00    	mov    0x12ecb4,%ebx
		SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
  116d25:	85 db                	test   %ebx,%ebx
  116d27:	0f 84 77 09 00 00    	je     1176a4 <handle_request+0x15bd>
			snprintk(disc_buf, sizeof(disc_buf), ",</%u>",
  116d2d:	0f b7 43 18          	movzwl 0x18(%ebx),%eax
  116d31:	50                   	push   %eax
  116d32:	68 a7 7a 12 00       	push   $0x127aa7
  116d37:	6a 18                	push   $0x18
  116d39:	68 54 ec 12 00       	push   $0x12ec54
  116d3e:	e8 bc a5 fe ff       	call   1012ff <snprintk>
  116d43:	83 c4 10             	add    $0x10,%esp
					 disc_buf, strlen(disc_buf));
  116d46:	68 54 ec 12 00       	push   $0x12ec54
  116d4b:	e8 cc 4f ff ff       	call   10bd1c <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
  116d50:	8b 7e 1c             	mov    0x1c(%esi),%edi
  116d53:	0f b7 c0             	movzwl %ax,%eax
  116d56:	0f b7 4f 06          	movzwl 0x6(%edi),%ecx
  116d5a:	8d 57 04             	lea    0x4(%edi),%edx
  116d5d:	89 04 24             	mov    %eax,(%esp)
  116d60:	8b 07                	mov    (%edi),%eax
  116d62:	68 54 ec 12 00       	push   $0x12ec54
  116d67:	e8 ac df ff ff       	call   114d18 <buf_append>
  116d6c:	5a                   	pop    %edx
  116d6d:	59                   	pop    %ecx
			if (ret < 0) {
  116d6e:	85 c0                	test   %eax,%eax
  116d70:	0f 88 fe 09 00 00    	js     117774 <handle_request+0x168d>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  116d76:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  116d78:	eb ab                	jmp    116d25 <handle_request+0xc3e>
		if ((!msg->ctx->bootstrap_mode &&
  116d7a:	8b 43 04             	mov    0x4(%ebx),%eax
  116d7d:	8b 16                	mov    (%esi),%edx
  116d7f:	0f b7 40 18          	movzwl 0x18(%eax),%eax
  116d83:	80 ba 58 01 00 00 00 	cmpb   $0x0,0x158(%edx)
  116d8a:	75 10                	jne    116d9c <handle_request+0xcb5>
  116d8c:	66 85 c0             	test   %ax,%ax
  116d8f:	75 0b                	jne    116d9c <handle_request+0xcb5>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  116d91:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list, obj_inst, node) {
  116d93:	85 db                	test   %ebx,%ebx
  116d95:	75 e3                	jne    116d7a <handle_request+0xc93>
  116d97:	e9 16 02 00 00       	jmp    116fb2 <handle_request+0xecb>
		     obj_inst->obj->obj_id == LWM2M_OBJECT_SECURITY_ID) ||
  116d9c:	66 39 46 24          	cmp    %ax,0x24(%esi)
  116da0:	75 ef                	jne    116d91 <handle_request+0xcaa>
		if (msg->path.level == 1U) {
  116da2:	80 7e 2c 01          	cmpb   $0x1,0x2c(%esi)
  116da6:	75 76                	jne    116e1e <handle_request+0xd37>
			snprintk(disc_buf, sizeof(disc_buf), "%s</%u>",
  116da8:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116daf:	ba eb 78 12 00       	mov    $0x1278eb,%edx
  116db4:	75 05                	jne    116dbb <handle_request+0xcd4>
  116db6:	ba 02 4e 12 00       	mov    $0x124e02,%edx
  116dbb:	50                   	push   %eax
  116dbc:	52                   	push   %edx
  116dbd:	68 ae 7a 12 00       	push   $0x127aae
  116dc2:	6a 18                	push   $0x18
  116dc4:	68 54 ec 12 00       	push   $0x12ec54
  116dc9:	e8 31 a5 fe ff       	call   1012ff <snprintk>
  116dce:	83 c4 14             	add    $0x14,%esp
					 disc_buf, strlen(disc_buf));
  116dd1:	68 54 ec 12 00       	push   $0x12ec54
  116dd6:	e8 41 4f ff ff       	call   10bd1c <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
  116ddb:	8b 7e 1c             	mov    0x1c(%esi),%edi
  116dde:	0f b7 c0             	movzwl %ax,%eax
  116de1:	0f b7 4f 06          	movzwl 0x6(%edi),%ecx
  116de5:	8d 57 04             	lea    0x4(%edi),%edx
  116de8:	89 04 24             	mov    %eax,(%esp)
  116deb:	8b 07                	mov    (%edi),%eax
  116ded:	68 54 ec 12 00       	push   $0x12ec54
  116df2:	e8 21 df ff ff       	call   114d18 <buf_append>
  116df7:	59                   	pop    %ecx
  116df8:	5f                   	pop    %edi
			if (ret < 0) {
  116df9:	85 c0                	test   %eax,%eax
  116dfb:	0f 88 73 09 00 00    	js     117774 <handle_request+0x168d>
			ret = print_attr(&msg->out, disc_buf, sizeof(disc_buf),
  116e01:	8b 53 04             	mov    0x4(%ebx),%edx
  116e04:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
  116e0a:	e8 01 e2 ff ff       	call   115010 <print_attr.constprop.0>
			if (ret < 0) {
  116e0f:	85 c0                	test   %eax,%eax
  116e11:	0f 88 5d 09 00 00    	js     117774 <handle_request+0x168d>
			reported = true;
  116e17:	c6 85 d8 fe ff ff 01 	movb   $0x1,-0x128(%ebp)
		if (msg->path.level > 1 &&
  116e1e:	8a 56 2c             	mov    0x2c(%esi),%dl
  116e21:	80 fa 01             	cmp    $0x1,%dl
  116e24:	0f 86 96 00 00 00    	jbe    116ec0 <handle_request+0xdd9>
		    msg->path.obj_inst_id != obj_inst->obj_inst_id) {
  116e2a:	8b 43 0c             	mov    0xc(%ebx),%eax
		if (msg->path.level > 1 &&
  116e2d:	66 39 46 26          	cmp    %ax,0x26(%esi)
  116e31:	0f 85 5a ff ff ff    	jne    116d91 <handle_request+0xcaa>
		if (msg->path.level == 2U) {
  116e37:	80 fa 02             	cmp    $0x2,%dl
  116e3a:	0f 85 80 00 00 00    	jne    116ec0 <handle_request+0xdd9>
			snprintk(disc_buf, sizeof(disc_buf), "%s</%u/%u>",
  116e40:	0f b7 d0             	movzwl %ax,%edx
				 obj_inst->obj->obj_id, obj_inst->obj_inst_id);
  116e43:	8b 43 04             	mov    0x4(%ebx),%eax
			snprintk(disc_buf, sizeof(disc_buf), "%s</%u/%u>",
  116e46:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116e4d:	0f b7 48 18          	movzwl 0x18(%eax),%ecx
  116e51:	b8 eb 78 12 00       	mov    $0x1278eb,%eax
  116e56:	75 05                	jne    116e5d <handle_request+0xd76>
  116e58:	b8 02 4e 12 00       	mov    $0x124e02,%eax
  116e5d:	52                   	push   %edx
  116e5e:	51                   	push   %ecx
  116e5f:	50                   	push   %eax
  116e60:	68 b6 7a 12 00       	push   $0x127ab6
  116e65:	6a 18                	push   $0x18
  116e67:	68 54 ec 12 00       	push   $0x12ec54
  116e6c:	e8 8e a4 fe ff       	call   1012ff <snprintk>
  116e71:	83 c4 18             	add    $0x18,%esp
					 disc_buf, strlen(disc_buf));
  116e74:	68 54 ec 12 00       	push   $0x12ec54
  116e79:	e8 9e 4e ff ff       	call   10bd1c <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
  116e7e:	8b 7e 1c             	mov    0x1c(%esi),%edi
  116e81:	0f b7 c0             	movzwl %ax,%eax
  116e84:	0f b7 4f 06          	movzwl 0x6(%edi),%ecx
  116e88:	8d 57 04             	lea    0x4(%edi),%edx
  116e8b:	89 04 24             	mov    %eax,(%esp)
  116e8e:	8b 07                	mov    (%edi),%eax
  116e90:	68 54 ec 12 00       	push   $0x12ec54
  116e95:	e8 7e de ff ff       	call   114d18 <buf_append>
  116e9a:	5f                   	pop    %edi
  116e9b:	5a                   	pop    %edx
			if (ret < 0) {
  116e9c:	85 c0                	test   %eax,%eax
  116e9e:	0f 88 d0 08 00 00    	js     117774 <handle_request+0x168d>
			ret = print_attr(&msg->out, disc_buf, sizeof(disc_buf),
  116ea4:	89 da                	mov    %ebx,%edx
  116ea6:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
  116eac:	e8 5f e1 ff ff       	call   115010 <print_attr.constprop.0>
			if (ret < 0) {
  116eb1:	85 c0                	test   %eax,%eax
  116eb3:	0f 88 bb 08 00 00    	js     117774 <handle_request+0x168d>
			reported = true;
  116eb9:	c6 85 d8 fe ff ff 01 	movb   $0x1,-0x128(%ebp)
		if (msg->ctx->bootstrap_mode) {
  116ec0:	8b 06                	mov    (%esi),%eax
  116ec2:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  116ec9:	0f 85 c2 fe ff ff    	jne    116d91 <handle_request+0xcaa>
		for (int i = 0; i < obj_inst->resource_count; i++) {
  116ecf:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
  116ed6:	00 00 00 
  116ed9:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  116edd:	39 85 e0 fe ff ff    	cmp    %eax,-0x120(%ebp)
  116ee3:	0f 8d a8 fe ff ff    	jge    116d91 <handle_request+0xcaa>
			if (msg->path.level == 3U &&
  116ee9:	6b bd e0 fe ff ff 18 	imul   $0x18,-0x120(%ebp),%edi
  116ef0:	8b 43 08             	mov    0x8(%ebx),%eax
  116ef3:	80 7e 2c 03          	cmpb   $0x3,0x2c(%esi)
  116ef7:	0f b7 44 38 14       	movzwl 0x14(%eax,%edi,1),%eax
  116efc:	75 0a                	jne    116f08 <handle_request+0xe21>
  116efe:	66 39 46 28          	cmp    %ax,0x28(%esi)
  116f02:	0f 85 9f 00 00 00    	jne    116fa7 <handle_request+0xec0>
			snprintk(disc_buf, sizeof(disc_buf),
  116f08:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
				 obj_inst->obj->obj_id,
  116f0c:	8b 53 04             	mov    0x4(%ebx),%edx
			snprintk(disc_buf, sizeof(disc_buf),
  116f0f:	89 8d dc fe ff ff    	mov    %ecx,-0x124(%ebp)
  116f15:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116f1c:	0f b7 4a 18          	movzwl 0x18(%edx),%ecx
  116f20:	ba eb 78 12 00       	mov    $0x1278eb,%edx
  116f25:	75 05                	jne    116f2c <handle_request+0xe45>
  116f27:	ba 02 4e 12 00       	mov    $0x124e02,%edx
  116f2c:	50                   	push   %eax
  116f2d:	ff b5 dc fe ff ff    	pushl  -0x124(%ebp)
  116f33:	51                   	push   %ecx
  116f34:	52                   	push   %edx
  116f35:	68 c1 7a 12 00       	push   $0x127ac1
  116f3a:	6a 18                	push   $0x18
  116f3c:	68 54 ec 12 00       	push   $0x12ec54
  116f41:	e8 b9 a3 fe ff       	call   1012ff <snprintk>
  116f46:	83 c4 1c             	add    $0x1c,%esp
					 disc_buf, strlen(disc_buf));
  116f49:	68 54 ec 12 00       	push   $0x12ec54
  116f4e:	e8 c9 4d ff ff       	call   10bd1c <strlen>
			ret = buf_append(CPKT_BUF_WRITE(msg->out.out_cpkt),
  116f53:	8b 4e 1c             	mov    0x1c(%esi),%ecx
  116f56:	8b 56 1c             	mov    0x1c(%esi),%edx
  116f59:	0f b7 c0             	movzwl %ax,%eax
  116f5c:	0f b7 49 06          	movzwl 0x6(%ecx),%ecx
  116f60:	89 04 24             	mov    %eax,(%esp)
  116f63:	8b 46 1c             	mov    0x1c(%esi),%eax
  116f66:	83 c2 04             	add    $0x4,%edx
  116f69:	68 54 ec 12 00       	push   $0x12ec54
  116f6e:	8b 00                	mov    (%eax),%eax
  116f70:	e8 a3 dd ff ff       	call   114d18 <buf_append>
  116f75:	5a                   	pop    %edx
  116f76:	59                   	pop    %ecx
			if (ret < 0) {
  116f77:	85 c0                	test   %eax,%eax
  116f79:	0f 88 f5 07 00 00    	js     117774 <handle_request+0x168d>
			if (msg->path.level > 1) {
  116f7f:	80 7e 2c 01          	cmpb   $0x1,0x2c(%esi)
  116f83:	77 09                	ja     116f8e <handle_request+0xea7>
			reported = true;
  116f85:	c6 85 d8 fe ff ff 01 	movb   $0x1,-0x128(%ebp)
  116f8c:	eb 19                	jmp    116fa7 <handle_request+0xec0>
						 &obj_inst->resources[i]);
  116f8e:	03 7b 08             	add    0x8(%ebx),%edi
				ret = print_attr(&msg->out,
  116f91:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
						 &obj_inst->resources[i]);
  116f97:	89 fa                	mov    %edi,%edx
				ret = print_attr(&msg->out,
  116f99:	e8 72 e0 ff ff       	call   115010 <print_attr.constprop.0>
				if (ret < 0) {
  116f9e:	85 c0                	test   %eax,%eax
  116fa0:	79 e3                	jns    116f85 <handle_request+0xe9e>
  116fa2:	e9 cd 07 00 00       	jmp    117774 <handle_request+0x168d>
		for (int i = 0; i < obj_inst->resource_count; i++) {
  116fa7:	ff 85 e0 fe ff ff    	incl   -0x120(%ebp)
  116fad:	e9 27 ff ff ff       	jmp    116ed9 <handle_request+0xdf2>
	return reported ? 0 : -ENOENT;
  116fb2:	80 bd d8 fe ff ff 00 	cmpb   $0x0,-0x128(%ebp)
  116fb9:	0f 85 e5 06 00 00    	jne    1176a4 <handle_request+0x15bd>
  116fbf:	e9 73 07 00 00       	jmp    117737 <handle_request+0x1650>
	switch (format) {
  116fc4:	66 81 ff 06 06       	cmp    $0x606,%di
  116fc9:	74 35                	je     117000 <handle_request+0xf19>
  116fcb:	77 14                	ja     116fe1 <handle_request+0xefa>
  116fcd:	66 83 ff 2a          	cmp    $0x2a,%di
  116fd1:	74 25                	je     116ff8 <handle_request+0xf11>
  116fd3:	66 81 ff 05 06       	cmp    $0x605,%di
  116fd8:	74 1e                	je     116ff8 <handle_request+0xf11>
  116fda:	66 85 ff             	test   %di,%di
  116fdd:	74 19                	je     116ff8 <handle_request+0xf11>
  116fdf:	eb 33                	jmp    117014 <handle_request+0xf2d>
  116fe1:	66 81 ff 16 2d       	cmp    $0x2d16,%di
  116fe6:	74 18                	je     117000 <handle_request+0xf19>
  116fe8:	66 81 ff 17 2d       	cmp    $0x2d17,%di
  116fed:	74 19                	je     117008 <handle_request+0xf21>
  116fef:	66 81 ff 07 06       	cmp    $0x607,%di
  116ff4:	74 12                	je     117008 <handle_request+0xf21>
  116ff6:	eb 1c                	jmp    117014 <handle_request+0xf2d>
		return do_write_op_plain_text(msg);
  116ff8:	56                   	push   %esi
  116ff9:	e8 8b 40 00 00       	call   11b089 <do_write_op_plain_text>
  116ffe:	eb 0e                	jmp    11700e <handle_request+0xf27>
		return do_write_op_tlv(msg);
  117000:	56                   	push   %esi
  117001:	e8 1a 4f 00 00       	call   11bf20 <do_write_op_tlv>
  117006:	eb 06                	jmp    11700e <handle_request+0xf27>
		return do_write_op_json(msg);
  117008:	56                   	push   %esi
  117009:	e8 ba 80 00 00       	call   11f0c8 <do_write_op_json>
  11700e:	5f                   	pop    %edi
  11700f:	e9 88 06 00 00       	jmp    11769c <handle_request+0x15b5>
		LOG_ERR("Unsupported format: %u", format);
  117014:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOMSG;
  11701b:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
		LOG_ERR("Unsupported format: %u", format);
  117020:	0f 84 4e 07 00 00    	je     117774 <handle_request+0x168d>
  117026:	ba 20 31 12 00       	mov    $0x123120,%edx
  11702b:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  117031:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  117037:	c1 ea 03             	shr    $0x3,%edx
  11703a:	c1 e2 06             	shl    $0x6,%edx
  11703d:	83 ca 01             	or     $0x1,%edx
  117040:	52                   	push   %edx
  117041:	0f b7 d7             	movzwl %di,%edx
  117044:	52                   	push   %edx
  117045:	68 cf 7a 12 00       	push   $0x127acf
  11704a:	e9 60 f8 ff ff       	jmp    1168af <handle_request+0x7c8>
	struct notification_attrs nattrs = { 0 };
  11704f:	31 c0                	xor    %eax,%eax
  117051:	8d bd 40 ff ff ff    	lea    -0xc0(%ebp),%edi
  117057:	b9 09 00 00 00       	mov    $0x9,%ecx
	void *nattr_ptrs[NR_LWM2M_ATTR] = {
  11705c:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
	struct notification_attrs nattrs = { 0 };
  117062:	f3 ab                	rep stos %eax,%es:(%edi)
	void *nattr_ptrs[NR_LWM2M_ATTR] = {
  117064:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
  11706a:	89 95 14 ff ff ff    	mov    %edx,-0xec(%ebp)
  117070:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  117076:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
  11707c:	8d 95 5c ff ff ff    	lea    -0xa4(%ebp),%edx
  117082:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
  117088:	8d 85 50 ff ff ff    	lea    -0xb0(%ebp),%eax
	struct lwm2m_engine_res *res = NULL;
  11708e:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
  117095:	00 00 00 
	void *nattr_ptrs[NR_LWM2M_ATTR] = {
  117098:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  11709e:	89 95 18 ff ff ff    	mov    %edx,-0xe8(%ebp)
	if (!obj || !msg) {
  1170a4:	83 bd cc fe ff ff 00 	cmpl   $0x0,-0x134(%ebp)
		return -EINVAL;
  1170ab:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (!obj || !msg) {
  1170b0:	0f 84 be 06 00 00    	je     117774 <handle_request+0x168d>
	if (obj->obj_id == LWM2M_OBJECT_SECURITY_ID) {
  1170b6:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
  1170bc:	66 83 78 18 00       	cmpw   $0x0,0x18(%eax)
  1170c1:	0f 84 70 06 00 00    	je     117737 <handle_request+0x1650>
	nr_opt = coap_find_options(msg->in.in_cpkt, COAP_OPTION_URI_QUERY,
  1170c7:	6a 05                	push   $0x5
  1170c9:	8d 45 a4             	lea    -0x5c(%ebp),%eax
  1170cc:	50                   	push   %eax
  1170cd:	6a 0f                	push   $0xf
  1170cf:	ff 76 08             	pushl  0x8(%esi)
  1170d2:	e8 c3 19 ff ff       	call   108a9a <coap_find_options>
  1170d7:	83 c4 10             	add    $0x10,%esp
  1170da:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
	if (nr_opt <= 0) {
  1170e0:	85 c0                	test   %eax,%eax
  1170e2:	7f 32                	jg     117116 <handle_request+0x102f>
		LOG_ERR("No attribute found!");
  1170e4:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1170eb:	0f 84 42 02 00 00    	je     117333 <handle_request+0x124c>
  1170f1:	b8 20 31 12 00       	mov    $0x123120,%eax
  1170f6:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1170fb:	c1 e8 03             	shr    $0x3,%eax
  1170fe:	c1 e0 06             	shl    $0x6,%eax
  117101:	83 c8 01             	or     $0x1,%eax
  117104:	50                   	push   %eax
  117105:	68 e6 7a 12 00       	push   $0x127ae6
  11710a:	e8 3e c4 fe ff       	call   10354d <log_0>
  11710f:	59                   	pop    %ecx
  117110:	5b                   	pop    %ebx
		if (r < 0) {
  117111:	e9 1d 02 00 00       	jmp    117333 <handle_request+0x124c>
	if (msg->path.level == 3U) {
  117116:	8a 46 2c             	mov    0x2c(%esi),%al
  117119:	3c 03                	cmp    $0x3,%al
  11711b:	75 27                	jne    117144 <handle_request+0x105d>
		ret = path_to_objs(&msg->path, NULL, NULL, &res, NULL);
  11711d:	6a 00                	push   $0x0
  11711f:	8d 95 ec fe ff ff    	lea    -0x114(%ebp),%edx
  117125:	52                   	push   %edx
  117126:	31 c9                	xor    %ecx,%ecx
  117128:	31 d2                	xor    %edx,%edx
  11712a:	8d 46 24             	lea    0x24(%esi),%eax
  11712d:	e8 ff e1 ff ff       	call   115331 <path_to_objs>
  117132:	5f                   	pop    %edi
  117133:	5a                   	pop    %edx
		if (ret < 0) {
  117134:	85 c0                	test   %eax,%eax
  117136:	0f 88 38 06 00 00    	js     117774 <handle_request+0x168d>
		ref = res;
  11713c:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
  117142:	eb 34                	jmp    117178 <handle_request+0x1091>
	} else if (msg->path.level == 1U) {
  117144:	3c 01                	cmp    $0x1,%al
  117146:	74 2a                	je     117172 <handle_request+0x108b>
	} else if (msg->path.level == 2U) {
  117148:	3c 02                	cmp    $0x2,%al
  11714a:	0f 85 e3 01 00 00    	jne    117333 <handle_request+0x124c>
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
  117150:	0f b7 56 26          	movzwl 0x26(%esi),%edx
  117154:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  117158:	e8 c5 d9 ff ff       	call   114b22 <get_engine_obj_inst>
  11715d:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
		if (!obj_inst) {
  117163:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
  117169:	85 c0                	test   %eax,%eax
  11716b:	75 1b                	jne    117188 <handle_request+0x10a1>
  11716d:	e9 c5 05 00 00       	jmp    117737 <handle_request+0x1650>
  117172:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
  117178:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11717e:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%ebp)
  117185:	00 00 00 
	ret = update_attrs(ref, &nattrs);
  117188:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
  11718e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
  117194:	e8 f1 d9 ff ff       	call   114b8a <update_attrs>
	if (ret < 0) {
  117199:	85 c0                	test   %eax,%eax
  11719b:	0f 88 d3 05 00 00    	js     117774 <handle_request+0x168d>
  1171a1:	8d 45 a4             	lea    -0x5c(%ebp),%eax
	for (i = 0; i < nr_opt; i++) {
  1171a4:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
  1171ab:	00 00 00 
  1171ae:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
		int limit = MIN(options[i].len, 5), plen = 0, vlen;
  1171b4:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
  1171ba:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  1171be:	3c 05                	cmp    $0x5,%al
  1171c0:	76 05                	jbe    1171c7 <handle_request+0x10e0>
  1171c2:	b8 05 00 00 00       	mov    $0x5,%eax
		float32_value_t val = { 0 };
  1171c7:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  1171ce:	00 00 00 
  1171d1:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%ebp)
  1171d8:	00 00 00 
		int limit = MIN(options[i].len, 5), plen = 0, vlen;
  1171db:	31 db                	xor    %ebx,%ebx
		while (plen < limit && options[i].value[plen] != '=') {
  1171dd:	39 d8                	cmp    %ebx,%eax
  1171df:	7e 10                	jle    1171f1 <handle_request+0x110a>
  1171e1:	8b bd d0 fe ff ff    	mov    -0x130(%ebp),%edi
  1171e7:	80 7c 1f 03 3d       	cmpb   $0x3d,0x3(%edi,%ebx,1)
  1171ec:	74 03                	je     1171f1 <handle_request+0x110a>
			plen += 1;
  1171ee:	43                   	inc    %ebx
  1171ef:	eb ec                	jmp    1171dd <handle_request+0x10f6>
		if (plen != 2 && plen != 4) {
  1171f1:	8d 43 fe             	lea    -0x2(%ebx),%eax
  1171f4:	83 e0 fd             	and    $0xfffffffd,%eax
  1171f7:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
  1171fd:	0f 85 a5 00 00 00    	jne    1172a8 <handle_request+0x11c1>
  117203:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
  117209:	8d 78 03             	lea    0x3(%eax),%edi
  11720c:	8a 85 dc fe ff ff    	mov    -0x124(%ebp),%al
  117212:	88 85 b3 fe ff ff    	mov    %al,-0x14d(%ebp)
			if (LWM2M_ATTR_LEN[type] == plen &&
  117218:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
  11721e:	0f b6 80 84 45 12 00 	movzbl 0x124584(%eax),%eax
  117225:	39 c3                	cmp    %eax,%ebx
  117227:	74 11                	je     11723a <handle_request+0x1153>
		for (type = 0U; type < NR_LWM2M_ATTR; type++) {
  117229:	ff 85 dc fe ff ff    	incl   -0x124(%ebp)
  11722f:	83 bd dc fe ff ff 05 	cmpl   $0x5,-0x124(%ebp)
  117236:	75 d4                	jne    11720c <handle_request+0x1125>
  117238:	eb 6e                	jmp    1172a8 <handle_request+0x11c1>
			    !memcmp(options[i].value, LWM2M_ATTR_STR[type],
  11723a:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
  117240:	53                   	push   %ebx
  117241:	8b 04 85 8c 45 12 00 	mov    0x12458c(,%eax,4),%eax
  117248:	50                   	push   %eax
  117249:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  11724f:	57                   	push   %edi
  117250:	e8 2a 4b ff ff       	call   10bd7f <memcmp>
  117255:	83 c4 0c             	add    $0xc,%esp
			if (LWM2M_ATTR_LEN[type] == plen &&
  117258:	85 c0                	test   %eax,%eax
  11725a:	75 cd                	jne    117229 <handle_request+0x1142>
		if (options[i].len == plen) {
  11725c:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
  117262:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  117266:	39 c3                	cmp    %eax,%ebx
  117268:	0f 85 71 06 00 00    	jne    1178df <handle_request+0x17f8>
			nattrs.flags &= ~BIT(type);
  11726e:	8a 8d dc fe ff ff    	mov    -0x124(%ebp),%cl
  117274:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  117279:	d3 c0                	rol    %cl,%eax
  11727b:	20 85 60 ff ff ff    	and    %al,-0xa0(%ebp)
			(void)memset(nattr_ptrs[type], 0,
  117281:	80 bd b3 fe ff ff 02 	cmpb   $0x2,-0x14d(%ebp)
  117288:	19 c0                	sbb    %eax,%eax
  11728a:	83 e0 fc             	and    $0xfffffffc,%eax
  11728d:	83 c0 08             	add    $0x8,%eax
  117290:	50                   	push   %eax
  117291:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
  117297:	6a 00                	push   $0x0
  117299:	ff b4 85 14 ff ff ff 	pushl  -0xec(%ebp,%eax,4)
  1172a0:	e8 b6 4b ff ff       	call   10be5b <memset>
  1172a5:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < nr_opt; i++) {
  1172a8:	ff 85 b8 fe ff ff    	incl   -0x148(%ebp)
  1172ae:	8b bd b8 fe ff ff    	mov    -0x148(%ebp),%edi
  1172b4:	83 85 d0 fe ff ff 10 	addl   $0x10,-0x130(%ebp)
  1172bb:	39 bd c8 fe ff ff    	cmp    %edi,-0x138(%ebp)
  1172c1:	0f 85 ed fe ff ff    	jne    1171b4 <handle_request+0x10cd>
	if ((nattrs.flags & (BIT(LWM2M_ATTR_PMIN) | BIT(LWM2M_ATTR_PMAX))) &&
  1172c7:	8a 85 60 ff ff ff    	mov    -0xa0(%ebp),%al
  1172cd:	a8 03                	test   $0x3,%al
  1172cf:	74 0e                	je     1172df <handle_request+0x11f8>
  1172d1:	8b bd 5c ff ff ff    	mov    -0xa4(%ebp),%edi
  1172d7:	39 bd 58 ff ff ff    	cmp    %edi,-0xa8(%ebp)
  1172dd:	7f 54                	jg     117333 <handle_request+0x124c>
	if (nattrs.flags & (BIT(LWM2M_ATTR_LT) | BIT(LWM2M_ATTR_GT))) {
  1172df:	a8 0c                	test   $0xc,%al
  1172e1:	74 5a                	je     11733d <handle_request+0x1256>
		if (!((nattrs.lt.val1 < nattrs.gt.val1) ||
  1172e3:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
  1172e9:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
  1172ef:	39 da                	cmp    %ebx,%edx
  1172f1:	7c 0e                	jl     117301 <handle_request+0x121a>
  1172f3:	8b bd 44 ff ff ff    	mov    -0xbc(%ebp),%edi
  1172f9:	39 bd 4c ff ff ff    	cmp    %edi,-0xb4(%ebp)
  1172ff:	7d 32                	jge    117333 <handle_request+0x124c>
		if (nattrs.flags & BIT(LWM2M_ATTR_STEP)) {
  117301:	a8 10                	test   $0x10,%al
  117303:	74 38                	je     11733d <handle_request+0x1256>
				    nattrs.st.val2 * 2 / 1000000;
  117305:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
			int32_t st1 = nattrs.st.val1 * 2 +
  11730b:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
				    nattrs.st.val2 * 2 / 1000000;
  117311:	01 c0                	add    %eax,%eax
			int32_t st1 = nattrs.st.val1 * 2 +
  117313:	01 c9                	add    %ecx,%ecx
			if (!(((nattrs.lt.val1 + st1) < nattrs.gt.val1) ||
  117315:	01 d1                	add    %edx,%ecx
				    nattrs.st.val2 * 2 / 1000000;
  117317:	bf 40 42 0f 00       	mov    $0xf4240,%edi
  11731c:	99                   	cltd   
  11731d:	f7 ff                	idiv   %edi
			if (!(((nattrs.lt.val1 + st1) < nattrs.gt.val1) ||
  11731f:	01 c8                	add    %ecx,%eax
  117321:	39 c3                	cmp    %eax,%ebx
  117323:	7f 18                	jg     11733d <handle_request+0x1256>
			      ((nattrs.lt.val2 + st2) < nattrs.gt.val2))) {
  117325:	03 95 4c ff ff ff    	add    -0xb4(%ebp),%edx
			if (!(((nattrs.lt.val1 + st1) < nattrs.gt.val1) ||
  11732b:	3b 95 44 ff ff ff    	cmp    -0xbc(%ebp),%edx
  117331:	7c 0a                	jl     11733d <handle_request+0x1256>
				return -EEXIST;
  117333:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  117338:	e9 37 04 00 00       	jmp    117774 <handle_request+0x168d>
  11733d:	bb 40 ce 12 00       	mov    $0x12ce40,%ebx
		if (ref != write_attr_pool[i].ref) {
  117342:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
  117348:	3b 03                	cmp    (%ebx),%eax
  11734a:	0f 85 8d 00 00 00    	jne    1173dd <handle_request+0x12f6>
  117350:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
		type = attr->type;
  117357:	0f b6 7b 0c          	movzbl 0xc(%ebx),%edi
  11735b:	89 c2                	mov    %eax,%edx
  11735d:	89 f9                	mov    %edi,%ecx
		if (!(BIT(type) & nattrs.flags)) {
  11735f:	0f a3 f8             	bt     %edi,%eax
  117362:	72 20                	jb     117384 <handle_request+0x129d>
			(void)memset(attr, 0, sizeof(*attr));
  117364:	6a 10                	push   $0x10
  117366:	88 8d dc fe ff ff    	mov    %cl,-0x124(%ebp)
  11736c:	6a 00                	push   $0x0
  11736e:	53                   	push   %ebx
  11736f:	e8 e7 4a ff ff       	call   10be5b <memset>
			if (type <= LWM2M_ATTR_PMAX) {
  117374:	8a 8d dc fe ff ff    	mov    -0x124(%ebp),%cl
			(void)memset(attr, 0, sizeof(*attr));
  11737a:	83 c4 0c             	add    $0xc,%esp
			if (type <= LWM2M_ATTR_PMAX) {
  11737d:	80 f9 01             	cmp    $0x1,%cl
  117380:	77 5b                	ja     1173dd <handle_request+0x12f6>
  117382:	eb 25                	jmp    1173a9 <handle_request+0x12c2>
		nattrs.flags &= ~BIT(type);
  117384:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  117389:	d3 c0                	rol    %cl,%eax
  11738b:	21 d0                	and    %edx,%eax
  11738d:	8b 94 bd 14 ff ff ff 	mov    -0xec(%ebp,%edi,4),%edx
  117394:	88 85 60 ff ff ff    	mov    %al,-0xa0(%ebp)
		if (type <= LWM2M_ATTR_PMAX) {
  11739a:	80 f9 01             	cmp    $0x1,%cl
  11739d:	77 13                	ja     1173b2 <handle_request+0x12cb>
			if (attr->int_val == *(int32_t *)nattr_ptrs[type]) {
  11739f:	8b 02                	mov    (%edx),%eax
  1173a1:	39 43 04             	cmp    %eax,0x4(%ebx)
  1173a4:	74 37                	je     1173dd <handle_request+0x12f6>
			attr->int_val = *(int32_t *)nattr_ptrs[type];
  1173a6:	89 43 04             	mov    %eax,0x4(%ebx)
			update_observe_node = true;
  1173a9:	c6 85 d4 fe ff ff 01 	movb   $0x1,-0x12c(%ebp)
  1173b0:	eb 2b                	jmp    1173dd <handle_request+0x12f6>
			if (!memcmp(&attr->float_val, nattr_ptrs[type],
  1173b2:	6a 08                	push   $0x8
  1173b4:	8d 7b 04             	lea    0x4(%ebx),%edi
  1173b7:	52                   	push   %edx
  1173b8:	89 95 dc fe ff ff    	mov    %edx,-0x124(%ebp)
  1173be:	57                   	push   %edi
  1173bf:	e8 bb 49 ff ff       	call   10bd7f <memcmp>
  1173c4:	83 c4 0c             	add    $0xc,%esp
  1173c7:	85 c0                	test   %eax,%eax
  1173c9:	74 12                	je     1173dd <handle_request+0x12f6>
			memcpy(&attr->float_val, nattr_ptrs[type],
  1173cb:	6a 08                	push   $0x8
  1173cd:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
  1173d3:	52                   	push   %edx
  1173d4:	57                   	push   %edi
  1173d5:	e8 12 4a ff ff       	call   10bdec <memcpy>
  1173da:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
  1173dd:	83 c3 10             	add    $0x10,%ebx
  1173e0:	b8 80 cf 12 00       	mov    $0x12cf80,%eax
  1173e5:	39 d8                	cmp    %ebx,%eax
  1173e7:	0f 85 55 ff ff ff    	jne    117342 <handle_request+0x125b>
  1173ed:	31 c9                	xor    %ecx,%ecx
	for (type = 0U; nattrs.flags && type < NR_LWM2M_ATTR; type++) {
  1173ef:	0f b6 95 60 ff ff ff 	movzbl -0xa0(%ebp),%edx
  1173f6:	80 f9 05             	cmp    $0x5,%cl
  1173f9:	88 8d d0 fe ff ff    	mov    %cl,-0x130(%ebp)
  1173ff:	0f 95 c3             	setne  %bl
  117402:	84 d2                	test   %dl,%dl
  117404:	89 cf                	mov    %ecx,%edi
  117406:	0f 95 c0             	setne  %al
  117409:	20 d8                	and    %bl,%al
  11740b:	88 85 dc fe ff ff    	mov    %al,-0x124(%ebp)
  117411:	74 74                	je     117487 <handle_request+0x13a0>
		if (!(BIT(type) & nattrs.flags)) {
  117413:	0f a3 ca             	bt     %ecx,%edx
  117416:	73 69                	jae    117481 <handle_request+0x139a>
		for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
  117418:	31 d2                	xor    %edx,%edx
			if (!write_attr_pool[i].ref) {
  11741a:	89 d3                	mov    %edx,%ebx
  11741c:	c1 e3 04             	shl    $0x4,%ebx
  11741f:	83 bb 40 ce 12 00 00 	cmpl   $0x0,0x12ce40(%ebx)
  117426:	74 10                	je     117438 <handle_request+0x1351>
		for (i = 0; i < CONFIG_LWM2M_NUM_ATTR; i++) {
  117428:	42                   	inc    %edx
  117429:	83 fa 14             	cmp    $0x14,%edx
  11742c:	75 ec                	jne    11741a <handle_request+0x1333>
			return -ENOMEM;
  11742e:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  117433:	e9 3c 03 00 00       	jmp    117774 <handle_request+0x168d>
		attr = write_attr_pool + i;
  117438:	8d 93 40 ce 12 00    	lea    0x12ce40(%ebx),%edx
		attr->type = type;
  11743e:	89 f8                	mov    %edi,%eax
		if (type <= LWM2M_ATTR_PMAX) {
  117440:	80 bd d0 fe ff ff 01 	cmpb   $0x1,-0x130(%ebp)
		attr->type = type;
  117447:	88 42 0c             	mov    %al,0xc(%edx)
		attr->ref = ref;
  11744a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
  117450:	89 83 40 ce 12 00    	mov    %eax,0x12ce40(%ebx)
		if (type <= LWM2M_ATTR_PMAX) {
  117456:	8b 9c 8d 14 ff ff ff 	mov    -0xec(%ebp,%ecx,4),%ebx
  11745d:	0f 87 8e 06 00 00    	ja     117af1 <handle_request+0x1a0a>
			attr->int_val = *(int32_t *)nattr_ptrs[type];
  117463:	8b 1b                	mov    (%ebx),%ebx
  117465:	89 5a 04             	mov    %ebx,0x4(%edx)
		nattrs.flags &= ~BIT(type);
  117468:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  11746d:	8a 85 dc fe ff ff    	mov    -0x124(%ebp),%al
  117473:	d3 c2                	rol    %cl,%edx
  117475:	20 95 60 ff ff ff    	and    %dl,-0xa0(%ebp)
		LOG_DBG("Add %s to %d.%06d", log_strdup(LWM2M_ATTR_STR[type]),
  11747b:	88 85 d4 fe ff ff    	mov    %al,-0x12c(%ebp)
	for (type = 0U; nattrs.flags && type < NR_LWM2M_ATTR; type++) {
  117481:	41                   	inc    %ecx
  117482:	e9 68 ff ff ff       	jmp    1173ef <handle_request+0x1308>
	if (!update_observe_node) {
  117487:	80 bd d4 fe ff ff 00 	cmpb   $0x0,-0x12c(%ebp)
  11748e:	8b 1d a4 ec 12 00    	mov    0x12eca4,%ebx
  117494:	0f 84 0a 02 00 00    	je     1176a4 <handle_request+0x15bd>
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  11749a:	85 db                	test   %ebx,%ebx
  11749c:	0f 84 02 02 00 00    	je     1176a4 <handle_request+0x15bd>
		if (msg->path.level > obs->path.level) {
  1174a2:	8a 43 10             	mov    0x10(%ebx),%al
  1174a5:	38 46 2c             	cmp    %al,0x2c(%esi)
  1174a8:	0f 87 41 01 00 00    	ja     1175ef <handle_request+0x1508>
		if (msg->path.obj_id != obs->path.obj_id) {
  1174ae:	8b 43 08             	mov    0x8(%ebx),%eax
  1174b1:	66 39 46 24          	cmp    %ax,0x24(%esi)
  1174b5:	0f 85 34 01 00 00    	jne    1175ef <handle_request+0x1508>
		nattrs.pmin = lwm2m_server_get_pmin(msg->ctx->srv_obj_inst);
  1174bb:	8b 06                	mov    (%esi),%eax
  1174bd:	0f b7 80 54 01 00 00 	movzwl 0x154(%eax),%eax
  1174c4:	50                   	push   %eax
  1174c5:	e8 7e 2a 00 00       	call   119f48 <lwm2m_server_get_pmin>
  1174ca:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		nattrs.pmax = lwm2m_server_get_pmax(msg->ctx->srv_obj_inst);
  1174d0:	8b 06                	mov    (%esi),%eax
  1174d2:	0f b7 80 54 01 00 00 	movzwl 0x154(%eax),%eax
  1174d9:	89 04 24             	mov    %eax,(%esp)
  1174dc:	e8 a8 2a 00 00       	call   119f89 <lwm2m_server_get_pmax>
		ret = update_attrs(obj, &nattrs);
  1174e1:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
		nattrs.pmax = lwm2m_server_get_pmax(msg->ctx->srv_obj_inst);
  1174e7:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
		ret = update_attrs(obj, &nattrs);
  1174ed:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
		nattrs.pmax = lwm2m_server_get_pmax(msg->ctx->srv_obj_inst);
  1174f3:	59                   	pop    %ecx
		ret = update_attrs(obj, &nattrs);
  1174f4:	e8 91 d6 ff ff       	call   114b8a <update_attrs>
		if (ret < 0) {
  1174f9:	85 c0                	test   %eax,%eax
  1174fb:	0f 88 73 02 00 00    	js     117774 <handle_request+0x168d>
		if (obs->path.level > 1) {
  117501:	80 7b 10 01          	cmpb   $0x1,0x10(%ebx)
  117505:	76 59                	jbe    117560 <handle_request+0x1479>
			if (msg->path.level > 1 &&
  117507:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  11750b:	80 7e 2c 01          	cmpb   $0x1,0x2c(%esi)
  11750f:	76 0a                	jbe    11751b <handle_request+0x1434>
  117511:	66 39 56 26          	cmp    %dx,0x26(%esi)
  117515:	0f 85 d4 00 00 00    	jne    1175ef <handle_request+0x1508>
			if (!obj_inst || obj_inst->obj_inst_id !=
  11751b:	83 bd e0 fe ff ff 00 	cmpl   $0x0,-0x120(%ebp)
  117522:	74 0c                	je     117530 <handle_request+0x1449>
  117524:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
  11752a:	66 39 50 0c          	cmp    %dx,0xc(%eax)
  11752e:	74 17                	je     117547 <handle_request+0x1460>
				obj_inst = get_engine_obj_inst(
  117530:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  117534:	e8 e9 d5 ff ff       	call   114b22 <get_engine_obj_inst>
  117539:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
				if (!obj_inst) {
  11753f:	85 c0                	test   %eax,%eax
  117541:	0f 84 f0 01 00 00    	je     117737 <handle_request+0x1650>
			ret = update_attrs(obj_inst, &nattrs);
  117547:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
  11754d:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
  117553:	e8 32 d6 ff ff       	call   114b8a <update_attrs>
			if (ret < 0) {
  117558:	85 c0                	test   %eax,%eax
  11755a:	0f 88 14 02 00 00    	js     117774 <handle_request+0x168d>
		if (obs->path.level > 2) {
  117560:	80 7b 10 02          	cmpb   $0x2,0x10(%ebx)
  117564:	77 2d                	ja     117593 <handle_request+0x14ac>
		obs->min_period_sec = (uint32_t)nattrs.pmin;
  117566:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
		obs->max_period_sec = (uint32_t)MAX(nattrs.pmin, nattrs.pmax);
  11756c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
		obs->min_period_sec = (uint32_t)nattrs.pmin;
  117572:	89 53 2c             	mov    %edx,0x2c(%ebx)
		obs->max_period_sec = (uint32_t)MAX(nattrs.pmin, nattrs.pmax);
  117575:	39 d0                	cmp    %edx,%eax
  117577:	7d 02                	jge    11757b <handle_request+0x1494>
  117579:	89 d0                	mov    %edx,%eax
  11757b:	89 43 30             	mov    %eax,0x30(%ebx)
		(void)memset(&nattrs, 0, sizeof(nattrs));
  11757e:	6a 24                	push   $0x24
  117580:	6a 00                	push   $0x0
  117582:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
  117588:	50                   	push   %eax
  117589:	e8 cd 48 ff ff       	call   10be5b <memset>
  11758e:	83 c4 0c             	add    $0xc,%esp
  117591:	eb 5c                	jmp    1175ef <handle_request+0x1508>
			if (msg->path.level > 2 &&
  117593:	80 7e 2c 02          	cmpb   $0x2,0x2c(%esi)
  117597:	76 09                	jbe    1175a2 <handle_request+0x14bb>
  117599:	8b 43 0c             	mov    0xc(%ebx),%eax
  11759c:	66 39 46 28          	cmp    %ax,0x28(%esi)
  1175a0:	75 4d                	jne    1175ef <handle_request+0x1508>
			if (!res || res->res_id != obs->path.res_id) {
  1175a2:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
  1175a8:	85 c0                	test   %eax,%eax
  1175aa:	74 23                	je     1175cf <handle_request+0x14e8>
  1175ac:	8b 7b 0c             	mov    0xc(%ebx),%edi
  1175af:	66 39 78 14          	cmp    %di,0x14(%eax)
  1175b3:	75 1a                	jne    1175cf <handle_request+0x14e8>
			ret = update_attrs(res, &nattrs);
  1175b5:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
  1175bb:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
  1175c1:	e8 c4 d5 ff ff       	call   114b8a <update_attrs>
			if (ret < 0) {
  1175c6:	85 c0                	test   %eax,%eax
  1175c8:	79 9c                	jns    117566 <handle_request+0x147f>
  1175ca:	e9 a5 01 00 00       	jmp    117774 <handle_request+0x168d>
				ret = path_to_objs(&obs->path, NULL, NULL,
  1175cf:	6a 00                	push   $0x0
  1175d1:	8d 95 ec fe ff ff    	lea    -0x114(%ebp),%edx
  1175d7:	52                   	push   %edx
  1175d8:	31 c9                	xor    %ecx,%ecx
  1175da:	31 d2                	xor    %edx,%edx
  1175dc:	8d 43 08             	lea    0x8(%ebx),%eax
  1175df:	e8 4d dd ff ff       	call   115331 <path_to_objs>
  1175e4:	5f                   	pop    %edi
  1175e5:	5a                   	pop    %edx
				if (ret < 0) {
  1175e6:	85 c0                	test   %eax,%eax
  1175e8:	79 cb                	jns    1175b5 <handle_request+0x14ce>
  1175ea:	e9 85 01 00 00       	jmp    117774 <handle_request+0x168d>
  1175ef:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  1175f1:	e9 a4 fe ff ff       	jmp    11749a <handle_request+0x13b3>
	ret = path_to_objs(&msg->path, &obj_inst, NULL, &res, NULL);
  1175f6:	6a 00                	push   $0x0
  1175f8:	8d 55 a4             	lea    -0x5c(%ebp),%edx
  1175fb:	52                   	push   %edx
  1175fc:	31 c9                	xor    %ecx,%ecx
  1175fe:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
  117604:	8d 46 24             	lea    0x24(%esi),%eax
	struct lwm2m_engine_res *res = NULL;
  117607:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
	ret = path_to_objs(&msg->path, &obj_inst, NULL, &res, NULL);
  11760e:	e8 1e dd ff ff       	call   115331 <path_to_objs>
  117613:	5a                   	pop    %edx
	if (ret < 0) {
  117614:	85 c0                	test   %eax,%eax
	ret = path_to_objs(&msg->path, &obj_inst, NULL, &res, NULL);
  117616:	59                   	pop    %ecx
	if (ret < 0) {
  117617:	0f 88 57 01 00 00    	js     117774 <handle_request+0x168d>
	if (res->execute_cb) {
  11761d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  117620:	8b 40 0c             	mov    0xc(%eax),%eax
  117623:	85 c0                	test   %eax,%eax
  117625:	0f 84 0c 01 00 00    	je     117737 <handle_request+0x1650>
		return res->execute_cb(obj_inst->obj_inst_id);
  11762b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
  117631:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  117635:	52                   	push   %edx
  117636:	ff d0                	call   *%eax
  117638:	e9 d1 f9 ff ff       	jmp    11700e <handle_request+0xf27>
	ret = lwm2m_delete_obj_inst(msg->path.obj_id, msg->path.obj_inst_id);
  11763d:	0f b7 46 26          	movzwl 0x26(%esi),%eax
  117641:	50                   	push   %eax
  117642:	0f b7 46 24          	movzwl 0x24(%esi),%eax
  117646:	50                   	push   %eax
  117647:	e8 c1 e3 ff ff       	call   115a0d <lwm2m_delete_obj_inst>
  11764c:	5b                   	pop    %ebx
	if (!ret && !msg->ctx->bootstrap_mode) {
  11764d:	85 c0                	test   %eax,%eax
	ret = lwm2m_delete_obj_inst(msg->path.obj_id, msg->path.obj_inst_id);
  11764f:	5f                   	pop    %edi
	if (!ret && !msg->ctx->bootstrap_mode) {
  117650:	75 4a                	jne    11769c <handle_request+0x15b5>
  117652:	8b 06                	mov    (%esi),%eax
  117654:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  11765b:	75 47                	jne    1176a4 <handle_request+0x15bd>
		engine_trigger_update();
  11765d:	e8 ba 60 00 00       	call   11d71c <engine_trigger_update>
  117662:	eb 40                	jmp    1176a4 <handle_request+0x15bd>
			LOG_ERR("Unknown operation: %u", msg->operation);
  117664:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
			r = -EINVAL;
  11766b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			LOG_ERR("Unknown operation: %u", msg->operation);
  117670:	0f 84 fe 00 00 00    	je     117774 <handle_request+0x168d>
  117676:	ba 20 31 12 00       	mov    $0x123120,%edx
  11767b:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  117681:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  117687:	c1 ea 03             	shr    $0x3,%edx
  11768a:	c1 e2 06             	shl    $0x6,%edx
  11768d:	83 ca 01             	or     $0x1,%edx
  117690:	52                   	push   %edx
  117691:	51                   	push   %ecx
  117692:	68 11 7b 12 00       	push   $0x127b11
  117697:	e9 13 f2 ff ff       	jmp    1168af <handle_request+0x7c8>
		if (r < 0) {
  11769c:	85 c0                	test   %eax,%eax
  11769e:	0f 88 d0 00 00 00    	js     117774 <handle_request+0x168d>
	if (block_ctx) {
  1176a4:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
  1176ab:	0f 84 7d 05 00 00    	je     117c2e <handle_request+0x1b47>
		if (!last_block) {
  1176b1:	80 bd bc fe ff ff 00 	cmpb   $0x0,-0x144(%ebp)
  1176b8:	0f 85 79 01 00 00    	jne    117837 <handle_request+0x1750>
			r = coap_append_block1_option(msg->out.out_cpkt,
  1176be:	ff b5 e4 fe ff ff    	pushl  -0x11c(%ebp)
  1176c4:	ff 76 1c             	pushl  0x1c(%esi)
  1176c7:	e8 8b 15 ff ff       	call   108c57 <coap_append_block1_option>
  1176cc:	5a                   	pop    %edx
			if (r < 0) {
  1176cd:	85 c0                	test   %eax,%eax
			r = coap_append_block1_option(msg->out.out_cpkt,
  1176cf:	59                   	pop    %ecx
  1176d0:	89 c1                	mov    %eax,%ecx
			if (r < 0) {
  1176d2:	0f 89 56 05 00 00    	jns    117c2e <handle_request+0x1b47>
				LOG_ERR("Fail adding block1 option: %d", r);
  1176d8:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
				r = -EINVAL;
  1176df:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
				LOG_ERR("Fail adding block1 option: %d", r);
  1176e4:	0f 84 8a 00 00 00    	je     117774 <handle_request+0x168d>
  1176ea:	ba 20 31 12 00       	mov    $0x123120,%edx
  1176ef:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  1176f5:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  1176fb:	c1 ea 03             	shr    $0x3,%edx
  1176fe:	c1 e2 06             	shl    $0x6,%edx
  117701:	83 ca 01             	or     $0x1,%edx
  117704:	52                   	push   %edx
  117705:	51                   	push   %ecx
  117706:	68 27 7b 12 00       	push   $0x127b27
  11770b:	e9 9f f1 ff ff       	jmp    1168af <handle_request+0x7c8>
	struct lwm2m_block_context *block_ctx = NULL;
  117710:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  117717:	00 00 00 
  11771a:	eb 33                	jmp    11774f <handle_request+0x1668>
  11771c:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  117723:	00 00 00 
		return -ENOMSG;
  117726:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
  11772b:	eb 47                	jmp    117774 <handle_request+0x168d>
	struct lwm2m_block_context *block_ctx = NULL;
  11772d:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  117734:	00 00 00 
			r = -ENOENT;
  117737:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  11773c:	eb 36                	jmp    117774 <handle_request+0x168d>
	struct lwm2m_block_context *block_ctx = NULL;
  11773e:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  117745:	00 00 00 
			r = -EFBIG;
  117748:	b8 e5 ff ff ff       	mov    $0xffffffe5,%eax
  11774d:	eb 25                	jmp    117774 <handle_request+0x168d>
		return -EPERM;
  11774f:	83 c8 ff             	or     $0xffffffff,%eax
  117752:	eb 20                	jmp    117774 <handle_request+0x168d>
				msg->code = COAP_RESPONSE_CODE_DELETED;
  117754:	c6 86 87 02 00 00 42 	movb   $0x42,0x287(%esi)
				r = lwm2m_init_message(msg);
  11775b:	56                   	push   %esi
  11775c:	e8 8f e7 ff ff       	call   115ef0 <lwm2m_init_message>
  117761:	5a                   	pop    %edx
			if (r < 0) {
  117762:	85 c0                	test   %eax,%eax
  117764:	0f 89 c4 04 00 00    	jns    117c2e <handle_request+0x1b47>
	struct lwm2m_block_context *block_ctx = NULL;
  11776a:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  117771:	00 00 00 
	lwm2m_reset_message(msg, false);
  117774:	6a 00                	push   $0x0
  117776:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  11777c:	56                   	push   %esi
  11777d:	e8 44 e5 ff ff       	call   115cc6 <lwm2m_reset_message>
  117782:	5b                   	pop    %ebx
	if (r == -ENOENT) {
  117783:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
	lwm2m_reset_message(msg, false);
  117789:	5f                   	pop    %edi
	if (r == -ENOENT) {
  11778a:	83 f8 fe             	cmp    $0xfffffffe,%eax
  11778d:	75 09                	jne    117798 <handle_request+0x16b1>
		msg->code = COAP_RESPONSE_CODE_NOT_FOUND;
  11778f:	c6 86 87 02 00 00 84 	movb   $0x84,0x287(%esi)
  117796:	eb 5b                	jmp    1177f3 <handle_request+0x170c>
	} else if (r == -EPERM) {
  117798:	83 f8 ff             	cmp    $0xffffffff,%eax
  11779b:	75 09                	jne    1177a6 <handle_request+0x16bf>
		msg->code = COAP_RESPONSE_CODE_NOT_ALLOWED;
  11779d:	c6 86 87 02 00 00 85 	movb   $0x85,0x287(%esi)
  1177a4:	eb 4d                	jmp    1177f3 <handle_request+0x170c>
	} else if (r == -EEXIST) {
  1177a6:	83 f8 ef             	cmp    $0xffffffef,%eax
  1177a9:	75 09                	jne    1177b4 <handle_request+0x16cd>
		msg->code = COAP_RESPONSE_CODE_BAD_REQUEST;
  1177ab:	c6 86 87 02 00 00 80 	movb   $0x80,0x287(%esi)
  1177b2:	eb 3f                	jmp    1177f3 <handle_request+0x170c>
	} else if (r == -EFAULT) {
  1177b4:	83 f8 f2             	cmp    $0xfffffff2,%eax
  1177b7:	75 09                	jne    1177c2 <handle_request+0x16db>
		msg->code = COAP_RESPONSE_CODE_INCOMPLETE;
  1177b9:	c6 86 87 02 00 00 88 	movb   $0x88,0x287(%esi)
  1177c0:	eb 31                	jmp    1177f3 <handle_request+0x170c>
	} else if (r == -EFBIG) {
  1177c2:	83 f8 e5             	cmp    $0xffffffe5,%eax
  1177c5:	75 09                	jne    1177d0 <handle_request+0x16e9>
		msg->code = COAP_RESPONSE_CODE_REQUEST_TOO_LARGE;
  1177c7:	c6 86 87 02 00 00 8d 	movb   $0x8d,0x287(%esi)
  1177ce:	eb 23                	jmp    1177f3 <handle_request+0x170c>
	} else if (r == -ENOTSUP) {
  1177d0:	83 f8 dd             	cmp    $0xffffffdd,%eax
  1177d3:	75 09                	jne    1177de <handle_request+0x16f7>
		msg->code = COAP_RESPONSE_CODE_NOT_IMPLEMENTED;
  1177d5:	c6 86 87 02 00 00 a1 	movb   $0xa1,0x287(%esi)
  1177dc:	eb 15                	jmp    1177f3 <handle_request+0x170c>
	} else if (r == -ENOMSG) {
  1177de:	83 f8 b0             	cmp    $0xffffffb0,%eax
  1177e1:	75 09                	jne    1177ec <handle_request+0x1705>
		msg->code = COAP_RESPONSE_CODE_UNSUPPORTED_CONTENT_FORMAT;
  1177e3:	c6 86 87 02 00 00 8f 	movb   $0x8f,0x287(%esi)
  1177ea:	eb 07                	jmp    1177f3 <handle_request+0x170c>
		msg->code = COAP_RESPONSE_CODE_INTERNAL_ERROR;
  1177ec:	c6 86 87 02 00 00 a0 	movb   $0xa0,0x287(%esi)
	r = lwm2m_init_message(msg);
  1177f3:	56                   	push   %esi
  1177f4:	e8 f7 e6 ff ff       	call   115ef0 <lwm2m_init_message>
  1177f9:	59                   	pop    %ecx
	if (r < 0) {
  1177fa:	85 c0                	test   %eax,%eax
  1177fc:	79 2c                	jns    11782a <handle_request+0x1743>
		LOG_ERR("Error recreating message: %d", r);
  1177fe:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117805:	74 23                	je     11782a <handle_request+0x1743>
  117807:	ba 20 31 12 00       	mov    $0x123120,%edx
  11780c:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  117812:	c1 ea 03             	shr    $0x3,%edx
  117815:	c1 e2 06             	shl    $0x6,%edx
  117818:	83 ca 01             	or     $0x1,%edx
  11781b:	52                   	push   %edx
  11781c:	50                   	push   %eax
  11781d:	68 45 7b 12 00       	push   $0x127b45
  117822:	e8 4f bd fe ff       	call   103576 <log_1>
  117827:	83 c4 0c             	add    $0xc,%esp
	if (ctx == NULL) {
  11782a:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
  117831:	0f 84 f7 03 00 00    	je     117c2e <handle_request+0x1b47>
	ctx->tkl = 0U;
  117837:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
  11783d:	c6 40 28 00          	movb   $0x0,0x28(%eax)
  117841:	e9 e8 03 00 00       	jmp    117c2e <handle_request+0x1b47>
	observe_node_data[i].ctx = msg->ctx;
  117846:	8d 9f a0 d1 12 00    	lea    0x12d1a0(%edi),%ebx
  11784c:	8b 06                	mov    (%esi),%eax
  11784e:	89 43 04             	mov    %eax,0x4(%ebx)
	memcpy(&observe_node_data[i].path, &msg->path, sizeof(msg->path));
  117851:	6a 0a                	push   $0xa
  117853:	8d 46 24             	lea    0x24(%esi),%eax
  117856:	50                   	push   %eax
  117857:	8d 87 a8 d1 12 00    	lea    0x12d1a8(%edi),%eax
  11785d:	50                   	push   %eax
  11785e:	e8 89 45 ff ff       	call   10bdec <memcpy>
  117863:	83 c4 0c             	add    $0xc,%esp
	memcpy(observe_node_data[i].token, token, tkl);
  117866:	0f b6 85 dc fe ff ff 	movzbl -0x124(%ebp),%eax
  11786d:	50                   	push   %eax
  11786e:	8d 85 ff fe ff ff    	lea    -0x101(%ebp),%eax
  117874:	50                   	push   %eax
  117875:	8d 87 b2 d1 12 00    	lea    0x12d1b2(%edi),%eax
  11787b:	50                   	push   %eax
  11787c:	e8 6b 45 ff ff       	call   10bdec <memcpy>
	observe_node_data[i].tkl = tkl;
  117881:	8a 85 dc fe ff ff    	mov    -0x124(%ebp),%al
	memcpy(observe_node_data[i].token, token, tkl);
  117887:	83 c4 0c             	add    $0xc,%esp
	observe_node_data[i].tkl = tkl;
  11788a:	88 43 3a             	mov    %al,0x3a(%ebx)
	observe_node_data[i].last_timestamp = k_uptime_get();
  11788d:	e8 b0 d3 ff ff       	call   114c42 <k_uptime_get>
  117892:	89 43 24             	mov    %eax,0x24(%ebx)
  117895:	89 53 28             	mov    %edx,0x28(%ebx)
	observe_node_data[i].event_timestamp =
  117898:	89 43 1c             	mov    %eax,0x1c(%ebx)
  11789b:	89 53 20             	mov    %edx,0x20(%ebx)
	observe_node_data[i].max_period_sec = MAX(attrs.pmax, attrs.pmin);
  11789e:	8b 45 c0             	mov    -0x40(%ebp),%eax
	observe_node_data[i].min_period_sec = attrs.pmin;
  1178a1:	8b 55 bc             	mov    -0x44(%ebp),%edx
  1178a4:	89 53 2c             	mov    %edx,0x2c(%ebx)
	observe_node_data[i].max_period_sec = MAX(attrs.pmax, attrs.pmin);
  1178a7:	39 d0                	cmp    %edx,%eax
  1178a9:	7d 02                	jge    1178ad <handle_request+0x17c6>
  1178ab:	89 d0                	mov    %edx,%eax
  1178ad:	89 43 30             	mov    %eax,0x30(%ebx)
	observe_node_data[i].format = format;
  1178b0:	8b bd d0 fe ff ff    	mov    -0x130(%ebp),%edi
  1178b6:	6b 85 e0 fe ff ff 3c 	imul   $0x3c,-0x120(%ebp),%eax
	sys_slist_append(&engine_observer_list,
  1178bd:	89 da                	mov    %ebx,%edx
	observe_node_data[i].format = format;
  1178bf:	66 89 b8 d8 d1 12 00 	mov    %di,0x12d1d8(%eax)
	observe_node_data[i].counter = OBSERVE_COUNTER_START;
  1178c6:	c7 80 d4 d1 12 00 00 	movl   $0x0,0x12d1d4(%eax)
  1178cd:	00 00 00 
	sys_slist_append(&engine_observer_list,
  1178d0:	b8 a4 ec 12 00       	mov    $0x12eca4,%eax
  1178d5:	e8 bb d1 ff ff       	call   114a95 <sys_slist_append>
					if (r < 0) {
  1178da:	e9 6a f3 ff ff       	jmp    116c49 <handle_request+0xb62>
		if (plen == 2 && msg->path.level <= 2U) {
  1178df:	83 fb 02             	cmp    $0x2,%ebx
  1178e2:	75 0a                	jne    1178ee <handle_request+0x1807>
  1178e4:	80 7e 2c 02          	cmpb   $0x2,0x2c(%esi)
  1178e8:	0f 86 45 fa ff ff    	jbe    117333 <handle_request+0x124c>
		vlen = options[i].len - plen - 1;
  1178ee:	48                   	dec    %eax
  1178ef:	29 d8                	sub    %ebx,%eax
		memcpy(opt_buf, options[i].value + plen + 1, vlen);
  1178f1:	50                   	push   %eax
  1178f2:	89 85 b4 fe ff ff    	mov    %eax,-0x14c(%ebp)
  1178f8:	8d 44 1f 01          	lea    0x1(%edi,%ebx,1),%eax
  1178fc:	8d bd 07 ff ff ff    	lea    -0xf9(%ebp),%edi
  117902:	50                   	push   %eax
  117903:	57                   	push   %edi
  117904:	e8 e3 44 ff ff       	call   10bdec <memcpy>
		opt_buf[vlen] = '\0';
  117909:	8b 95 b4 fe ff ff    	mov    -0x14c(%ebp),%edx
		memcpy(opt_buf, options[i].value + plen + 1, vlen);
  11790f:	83 c4 0c             	add    $0xc,%esp
		if (plen == 4) {
  117912:	83 fb 04             	cmp    $0x4,%ebx
		opt_buf[vlen] = '\0';
  117915:	c6 84 15 07 ff ff ff 	movb   $0x0,-0xf9(%ebp,%edx,1)
  11791c:	00 
		if (plen == 4) {
  11791d:	75 4e                	jne    11796d <handle_request+0x1886>
			errno = 0;
  11791f:	e8 ef d3 ff ff       	call   114d13 <z_errno>
  117924:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			v = strtol(opt_buf, &end, 10);
  11792a:	6a 0a                	push   $0xa
  11792c:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
  117932:	50                   	push   %eax
  117933:	57                   	push   %edi
  117934:	e8 5b 40 ff ff       	call   10b994 <strtol>
  117939:	83 c4 0c             	add    $0xc,%esp
  11793c:	89 c3                	mov    %eax,%ebx
			if (errno || *end || v < 0) {
  11793e:	e8 d0 d3 ff ff       	call   114d13 <z_errno>
  117943:	83 38 00             	cmpl   $0x0,(%eax)
  117946:	75 0f                	jne    117957 <handle_request+0x1870>
  117948:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
  11794e:	80 38 00             	cmpb   $0x0,(%eax)
  117951:	75 04                	jne    117957 <handle_request+0x1870>
  117953:	85 db                	test   %ebx,%ebx
  117955:	79 0b                	jns    117962 <handle_request+0x187b>
			val.val1 = v;
  117957:	89 9d f4 fe ff ff    	mov    %ebx,-0x10c(%ebp)
		if (ret < 0) {
  11795d:	e9 02 01 00 00       	jmp    117a64 <handle_request+0x197d>
			val.val1 = v;
  117962:	89 9d f4 fe ff ff    	mov    %ebx,-0x10c(%ebp)
		if (ret < 0) {
  117968:	e9 3a 01 00 00       	jmp    117aa7 <handle_request+0x19c0>
	strncpy(buf, input, sizeof(buf) - 1);
  11796d:	6a 17                	push   $0x17
  11796f:	8d 9d 28 ff ff ff    	lea    -0xd8(%ebp),%ebx
  117975:	57                   	push   %edi
  117976:	53                   	push   %ebx
  117977:	e8 29 43 ff ff       	call   10bca5 <strncpy>
  11797c:	83 c4 0c             	add    $0xc,%esp
	buf[sizeof(buf) - 1] = '\0';
  11797f:	c6 85 3f ff ff ff 00 	movb   $0x0,-0xc1(%ebp)
	if (strchr(buf, '-')) {
  117986:	6a 2d                	push   $0x2d
  117988:	53                   	push   %ebx
  117989:	e8 54 43 ff ff       	call   10bce2 <strchr>
  11798e:	5f                   	pop    %edi
		sign = -1;
  11798f:	83 f8 01             	cmp    $0x1,%eax
  117992:	19 ff                	sbb    %edi,%edi
	if (strchr(buf, '-')) {
  117994:	5a                   	pop    %edx
	pos = strchr(buf, '.');
  117995:	6a 2e                	push   $0x2e
		sign = -1;
  117997:	83 e7 02             	and    $0x2,%edi
	pos = strchr(buf, '.');
  11799a:	53                   	push   %ebx
  11799b:	e8 42 43 ff ff       	call   10bce2 <strchr>
  1179a0:	59                   	pop    %ecx
		sign = -1;
  1179a1:	4f                   	dec    %edi
	pos = strchr(buf, '.');
  1179a2:	5b                   	pop    %ebx
	if (pos) {
  1179a3:	85 c0                	test   %eax,%eax
	pos = strchr(buf, '.');
  1179a5:	89 c3                	mov    %eax,%ebx
	if (pos) {
  1179a7:	74 03                	je     1179ac <handle_request+0x18c5>
		*pos = '\0';
  1179a9:	c6 00 00             	movb   $0x0,(%eax)
	errno = 0;
  1179ac:	e8 62 d3 ff ff       	call   114d13 <z_errno>
  1179b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	val = strtol(buf, &end, 10);
  1179b7:	6a 0a                	push   $0xa
  1179b9:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  1179bf:	50                   	push   %eax
  1179c0:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
  1179c6:	50                   	push   %eax
  1179c7:	e8 c8 3f ff ff       	call   10b994 <strtol>
  1179cc:	83 c4 0c             	add    $0xc,%esp
  1179cf:	89 85 b4 fe ff ff    	mov    %eax,-0x14c(%ebp)
	if (errno || *end || val < INT_MIN) {
  1179d5:	e8 39 d3 ff ff       	call   114d13 <z_errno>
  1179da:	83 38 00             	cmpl   $0x0,(%eax)
  1179dd:	0f 85 81 00 00 00    	jne    117a64 <handle_request+0x197d>
  1179e3:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  1179e9:	80 38 00             	cmpb   $0x0,(%eax)
  1179ec:	75 76                	jne    117a64 <handle_request+0x197d>
	out->val1 = (int32_t) val;
  1179ee:	8b 95 b4 fe ff ff    	mov    -0x14c(%ebp),%edx
	out->val2 = 0;
  1179f4:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%ebp)
  1179fb:	00 00 00 
	out->val1 = (int32_t) val;
  1179fe:	89 95 f4 fe ff ff    	mov    %edx,-0x10c(%ebp)
	int32_t base = 1000000, sign = 1;
  117a04:	b8 40 42 0f 00       	mov    $0xf4240,%eax
	if (!pos) {
  117a09:	85 db                	test   %ebx,%ebx
  117a0b:	0f 84 96 00 00 00    	je     117aa7 <handle_request+0x19c0>
	while (*(++pos) && base > 1 && isdigit((unsigned char)*pos)) {
  117a11:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
  117a15:	8b 95 f8 fe ff ff    	mov    -0x108(%ebp),%edx
  117a1b:	43                   	inc    %ebx
  117a1c:	89 95 b4 fe ff ff    	mov    %edx,-0x14c(%ebp)
  117a22:	8d 51 d0             	lea    -0x30(%ecx),%edx
  117a25:	80 fa 09             	cmp    $0x9,%dl
  117a28:	77 20                	ja     117a4a <handle_request+0x1963>
  117a2a:	83 f8 01             	cmp    $0x1,%eax
  117a2d:	7e 1b                	jle    117a4a <handle_request+0x1963>
		out->val2 = out->val2 * 10 + (*pos - '0');
  117a2f:	6b 95 b4 fe ff ff 0a 	imul   $0xa,-0x14c(%ebp),%edx
  117a36:	8d 54 0a d0          	lea    -0x30(%edx,%ecx,1),%edx
		base /= 10;
  117a3a:	b9 0a 00 00 00       	mov    $0xa,%ecx
		out->val2 = out->val2 * 10 + (*pos - '0');
  117a3f:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
		base /= 10;
  117a45:	99                   	cltd   
  117a46:	f7 f9                	idiv   %ecx
  117a48:	eb c7                	jmp    117a11 <handle_request+0x192a>
	out->val2 *= sign * base;
  117a4a:	8b 95 b4 fe ff ff    	mov    -0x14c(%ebp),%edx
  117a50:	0f af d0             	imul   %eax,%edx
  117a53:	0f af d7             	imul   %edi,%edx
  117a56:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
	return !*pos || base == 1 ? 0 : -EINVAL;
  117a5c:	80 3b 00             	cmpb   $0x0,(%ebx)
  117a5f:	74 46                	je     117aa7 <handle_request+0x19c0>
  117a61:	48                   	dec    %eax
  117a62:	74 43                	je     117aa7 <handle_request+0x19c0>
			LOG_ERR("invalid attr[%s] value",
  117a64:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117a6b:	0f 84 c2 f8 ff ff    	je     117333 <handle_request+0x124c>
  117a71:	ff b5 c4 fe ff ff    	pushl  -0x13c(%ebp)
  117a77:	e8 db b7 fe ff       	call   103257 <log_strdup>
  117a7c:	bb 20 31 12 00       	mov    $0x123120,%ebx
  117a81:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  117a87:	c1 eb 03             	shr    $0x3,%ebx
  117a8a:	c1 e3 06             	shl    $0x6,%ebx
  117a8d:	83 cb 01             	or     $0x1,%ebx
  117a90:	66 89 1c 24          	mov    %bx,(%esp)
  117a94:	50                   	push   %eax
  117a95:	68 fa 7a 12 00       	push   $0x127afa
  117a9a:	e8 d7 ba fe ff       	call   103576 <log_1>
  117a9f:	83 c4 0c             	add    $0xc,%esp
  117aa2:	e9 8c f8 ff ff       	jmp    117333 <handle_request+0x124c>
		if (type <= LWM2M_ATTR_PMAX) {
  117aa7:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
  117aad:	80 bd b3 fe ff ff 01 	cmpb   $0x1,-0x14d(%ebp)
  117ab4:	8b 84 85 14 ff ff ff 	mov    -0xec(%ebp,%eax,4),%eax
  117abb:	77 0a                	ja     117ac7 <handle_request+0x19e0>
			*(int32_t *)nattr_ptrs[type] = val.val1;
  117abd:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
  117ac3:	89 10                	mov    %edx,(%eax)
  117ac5:	eb 12                	jmp    117ad9 <handle_request+0x19f2>
			memcpy(nattr_ptrs[type], &val, sizeof(float32_value_t));
  117ac7:	6a 08                	push   $0x8
  117ac9:	8d 95 f4 fe ff ff    	lea    -0x10c(%ebp),%edx
  117acf:	52                   	push   %edx
  117ad0:	50                   	push   %eax
  117ad1:	e8 16 43 ff ff       	call   10bdec <memcpy>
  117ad6:	83 c4 0c             	add    $0xc,%esp
		nattrs.flags |= BIT(type);
  117ad9:	b8 01 00 00 00       	mov    $0x1,%eax
  117ade:	8a 8d dc fe ff ff    	mov    -0x124(%ebp),%cl
  117ae4:	d3 e0                	shl    %cl,%eax
  117ae6:	08 85 60 ff ff ff    	or     %al,-0xa0(%ebp)
  117aec:	e9 b7 f7 ff ff       	jmp    1172a8 <handle_request+0x11c1>
			memcpy(&attr->float_val, nattr_ptrs[type],
  117af1:	6a 08                	push   $0x8
  117af3:	83 c2 04             	add    $0x4,%edx
  117af6:	53                   	push   %ebx
  117af7:	89 8d d0 fe ff ff    	mov    %ecx,-0x130(%ebp)
  117afd:	52                   	push   %edx
  117afe:	e8 e9 42 ff ff       	call   10bdec <memcpy>
  117b03:	8a 85 d4 fe ff ff    	mov    -0x12c(%ebp),%al
  117b09:	83 c4 0c             	add    $0xc,%esp
  117b0c:	88 85 dc fe ff ff    	mov    %al,-0x124(%ebp)
  117b12:	8b 8d d0 fe ff ff    	mov    -0x130(%ebp),%ecx
  117b18:	e9 4b f9 ff ff       	jmp    117468 <handle_request+0x1381>
		if (timestamp - block1_contexts[i].timestamp >
  117b1d:	8b 95 e4 fe ff ff    	mov    -0x11c(%ebp),%edx
  117b23:	8b 8d bc fe ff ff    	mov    -0x144(%ebp),%ecx
  117b29:	8b 9d c0 fe ff ff    	mov    -0x140(%ebp),%ebx
  117b2f:	2b 4a 14             	sub    0x14(%edx),%ecx
  117b32:	1b 5a 18             	sbb    0x18(%edx),%ebx
  117b35:	ba 30 75 00 00       	mov    $0x7530,%edx
  117b3a:	39 ca                	cmp    %ecx,%edx
  117b3c:	ba 00 00 00 00       	mov    $0x0,%edx
  117b41:	19 da                	sbb    %ebx,%edx
  117b43:	0f 8c fa ea ff ff    	jl     116643 <handle_request+0x55c>
	for (i = 0; i < NUM_BLOCK1_CONTEXT; i++) {
  117b49:	40                   	inc    %eax
  117b4a:	83 85 e4 fe ff ff 2c 	addl   $0x2c,-0x11c(%ebp)
  117b51:	83 f8 03             	cmp    $0x3,%eax
  117b54:	0f 85 d9 ea ff ff    	jne    116633 <handle_request+0x54c>
		LOG_ERR("Cannot find free block context");
  117b5a:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117b61:	74 20                	je     117b83 <handle_request+0x1a9c>
  117b63:	b8 20 31 12 00       	mov    $0x123120,%eax
  117b68:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117b6d:	c1 e8 03             	shr    $0x3,%eax
  117b70:	c1 e0 06             	shl    $0x6,%eax
  117b73:	83 c8 01             	or     $0x1,%eax
  117b76:	50                   	push   %eax
  117b77:	68 fc 78 12 00       	push   $0x1278fc
  117b7c:	e8 cc b9 fe ff       	call   10354d <log_0>
  117b81:	5f                   	pop    %edi
  117b82:	58                   	pop    %eax
		return -ENOMEM;
  117b83:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
			LOG_ERR("Cannot find block context");
  117b88:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117b8f:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
  117b96:	00 00 00 
  117b99:	0f 84 d5 fb ff ff    	je     117774 <handle_request+0x168d>
  117b9f:	ba 20 31 12 00       	mov    $0x123120,%edx
  117ba4:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
  117baa:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  117bb0:	c1 ea 03             	shr    $0x3,%edx
  117bb3:	c1 e2 06             	shl    $0x6,%edx
  117bb6:	83 ca 01             	or     $0x1,%edx
  117bb9:	52                   	push   %edx
  117bba:	68 1b 79 12 00       	push   $0x12791b
  117bbf:	e9 2e f0 ff ff       	jmp    116bf2 <handle_request+0xb0b>
		r = coap_options_to_path(options, r, &msg->path);
  117bc4:	8d 46 24             	lea    0x24(%esi),%eax
	path->level = options_count;
  117bc7:	88 5e 2c             	mov    %bl,0x2c(%esi)
		r = coap_options_to_path(options, r, &msg->path);
  117bca:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint16_t len, *id[4] = { &path->obj_id, &path->obj_inst_id,
  117bcd:	8d 46 26             	lea    0x26(%esi),%eax
  117bd0:	89 45 a8             	mov    %eax,-0x58(%ebp)
			      &path->res_id, &path->res_inst_id };
  117bd3:	8d 46 28             	lea    0x28(%esi),%eax
  117bd6:	89 45 ac             	mov    %eax,-0x54(%ebp)
  117bd9:	8d 46 2a             	lea    0x2a(%esi),%eax
  117bdc:	89 45 b0             	mov    %eax,-0x50(%ebp)
	for (int i = 0; i < options_count; i++) {
  117bdf:	8d bd 64 ff ff ff    	lea    -0x9c(%ebp),%edi
  117be5:	31 c0                	xor    %eax,%eax
  117be7:	e9 b1 e6 ff ff       	jmp    11629d <handle_request+0x1b6>
	while (pos < buflen && isdigit(buf[pos])) {
  117bec:	8b 8d e4 fe ff ff    	mov    -0x11c(%ebp),%ecx
  117bf2:	ff 85 e4 fe ff ff    	incl   -0x11c(%ebp)
  117bf8:	0f b6 4c 0f 03       	movzbl 0x3(%edi,%ecx,1),%ecx
  117bfd:	88 8d d0 fe ff ff    	mov    %cl,-0x130(%ebp)
  117c03:	83 e9 30             	sub    $0x30,%ecx
  117c06:	83 f9 09             	cmp    $0x9,%ecx
  117c09:	0f 87 d0 e6 ff ff    	ja     1162df <handle_request+0x1f8>
		val = val * 10U + (buf[pos] - '0');
  117c0f:	66 6b 95 d8 fe ff ff 	imul   $0xa,-0x128(%ebp),%dx
  117c16:	0a 
  117c17:	0f b6 8d d0 fe ff ff 	movzbl -0x130(%ebp),%ecx
  117c1e:	8d 4c 0a d0          	lea    -0x30(%edx,%ecx,1),%ecx
  117c22:	66 89 8d d8 fe ff ff 	mov    %cx,-0x128(%ebp)
		pos++;
  117c29:	e9 97 e6 ff ff       	jmp    1162c5 <handle_request+0x1de>
}
  117c2e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  117c31:	31 c0                	xor    %eax,%eax
  117c33:	5b                   	pop    %ebx
  117c34:	5e                   	pop    %esi
  117c35:	5f                   	pop    %edi
  117c36:	5d                   	pop    %ebp
  117c37:	c3                   	ret    

00117c38 <lwm2m_send_message>:
{
  117c38:	55                   	push   %ebp
  117c39:	89 e5                	mov    %esp,%ebp
  117c3b:	56                   	push   %esi
  117c3c:	53                   	push   %ebx
  117c3d:	51                   	push   %ecx
  117c3e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!msg || !msg->ctx) {
  117c41:	85 db                	test   %ebx,%ebx
  117c43:	74 05                	je     117c4a <lwm2m_send_message+0x12>
  117c45:	83 3b 00             	cmpl   $0x0,(%ebx)
  117c48:	75 3e                	jne    117c88 <lwm2m_send_message+0x50>
		LOG_ERR("LwM2M message is invalid.");
  117c4a:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  117c51:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		LOG_ERR("LwM2M message is invalid.");
  117c56:	0f 84 49 01 00 00    	je     117da5 <lwm2m_send_message+0x16d>
  117c5c:	ba 20 31 12 00       	mov    $0x123120,%edx
  117c61:	89 45 f4             	mov    %eax,-0xc(%ebp)
  117c64:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  117c6a:	c1 ea 03             	shr    $0x3,%edx
  117c6d:	c1 e2 06             	shl    $0x6,%edx
  117c70:	83 ca 01             	or     $0x1,%edx
  117c73:	52                   	push   %edx
  117c74:	68 1b 78 12 00       	push   $0x12781b
  117c79:	e8 cf b8 fe ff       	call   10354d <log_0>
  117c7e:	58                   	pop    %eax
  117c7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  117c82:	5a                   	pop    %edx
  117c83:	e9 1d 01 00 00       	jmp    117da5 <lwm2m_send_message+0x16d>
	if (msg->type == COAP_TYPE_CON) {
  117c88:	80 bb 86 02 00 00 00 	cmpb   $0x0,0x286(%ebx)
  117c8f:	75 0c                	jne    117c9d <lwm2m_send_message+0x65>
		coap_pending_cycle(msg->pending);
  117c91:	ff b3 70 02 00 00    	pushl  0x270(%ebx)
  117c97:	e8 ef 12 ff ff       	call   108f8b <coap_pending_cycle>
  117c9c:	5e                   	pop    %esi
  117c9d:	8b 03                	mov    (%ebx),%eax
	msg->send_attempts++;
  117c9f:	fe 83 8a 02 00 00    	incb   0x28a(%ebx)
  117ca5:	05 30 01 00 00       	add    $0x130,%eax
  117caa:	6a ff                	push   $0xffffffff
  117cac:	6a ff                	push   $0xffffffff
  117cae:	50                   	push   %eax
  117caf:	e8 1c 8f 00 00       	call   120bd0 <z_impl_k_mutex_lock>
	rc = send(msg->ctx->sock_fd, msg->cpkt.data, msg->cpkt.offset, 0);
  117cb4:	8b 03                	mov    (%ebx),%eax
  117cb6:	83 c4 0c             	add    $0xc,%esp
  117cb9:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  117cbd:	8b 53 30             	mov    0x30(%ebx),%edx
  117cc0:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
  117cc6:	6a 00                	push   $0x0
  117cc8:	6a 00                	push   $0x0
  117cca:	6a 00                	push   $0x0
  117ccc:	51                   	push   %ecx
  117ccd:	52                   	push   %edx
  117cce:	50                   	push   %eax
  117ccf:	e8 f3 1c ff ff       	call   1099c7 <z_impl_zsock_sendto>
  117cd4:	89 c6                	mov    %eax,%esi
	ret = sys_mutex_unlock(&msg->ctx->send_lock);
  117cd6:	8b 03                	mov    (%ebx),%eax
  117cd8:	83 c4 18             	add    $0x18,%esp
  117cdb:	05 30 01 00 00       	add    $0x130,%eax
  117ce0:	e8 02 d0 ff ff       	call   114ce7 <sys_mutex_unlock>
	if (rc < 0) {
  117ce5:	85 f6                	test   %esi,%esi
  117ce7:	79 52                	jns    117d3b <lwm2m_send_message+0x103>
		if (msg->type == COAP_TYPE_CON) {
  117ce9:	80 bb 86 02 00 00 00 	cmpb   $0x0,0x286(%ebx)
  117cf0:	75 0c                	jne    117cfe <lwm2m_send_message+0xc6>
			coap_pending_clear(msg->pending);
  117cf2:	ff b3 70 02 00 00    	pushl  0x270(%ebx)
  117cf8:	e8 cf 12 ff ff       	call   108fcc <coap_pending_clear>
  117cfd:	5b                   	pop    %ebx
		LOG_ERR("Failed to send packet, err %d", errno);
  117cfe:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117d05:	74 29                	je     117d30 <lwm2m_send_message+0xf8>
  117d07:	e8 07 d0 ff ff       	call   114d13 <z_errno>
  117d0c:	bb 20 31 12 00       	mov    $0x123120,%ebx
  117d11:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  117d17:	c1 eb 03             	shr    $0x3,%ebx
  117d1a:	c1 e3 06             	shl    $0x6,%ebx
  117d1d:	83 cb 01             	or     $0x1,%ebx
  117d20:	53                   	push   %ebx
  117d21:	ff 30                	pushl  (%eax)
  117d23:	68 62 7b 12 00       	push   $0x127b62
  117d28:	e8 49 b8 fe ff       	call   103576 <log_1>
  117d2d:	83 c4 0c             	add    $0xc,%esp
		return -errno;
  117d30:	e8 de cf ff ff       	call   114d13 <z_errno>
  117d35:	8b 00                	mov    (%eax),%eax
  117d37:	f7 d8                	neg    %eax
  117d39:	eb 6a                	jmp    117da5 <lwm2m_send_message+0x16d>
	if (msg->type == COAP_TYPE_CON) {
  117d3b:	80 bb 86 02 00 00 00 	cmpb   $0x0,0x286(%ebx)
  117d42:	75 55                	jne    117d99 <lwm2m_send_message+0x161>
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
  117d44:	8b 03                	mov    (%ebx),%eax
  117d46:	05 18 01 00 00       	add    $0x118,%eax
  117d4b:	50                   	push   %eax
  117d4c:	e8 a3 a4 00 00       	call   1221f4 <z_timeout_remaining>
			return ((uint32_t)t) * (to_hz / from_hz);
  117d51:	6b d0 0a             	imul   $0xa,%eax,%edx
  117d54:	59                   	pop    %ecx
		if (remaining == 0 || remaining > msg->pending->timeout) {
  117d55:	85 d2                	test   %edx,%edx
  117d57:	8b 8b 70 02 00 00    	mov    0x270(%ebx),%ecx
  117d5d:	74 07                	je     117d66 <lwm2m_send_message+0x12e>
	return 0;
  117d5f:	31 c0                	xor    %eax,%eax
		if (remaining == 0 || remaining > msg->pending->timeout) {
  117d61:	39 51 0c             	cmp    %edx,0xc(%ecx)
  117d64:	73 3f                	jae    117da5 <lwm2m_send_message+0x16d>
					      K_MSEC(msg->pending->timeout));
  117d66:	8b 41 0c             	mov    0xc(%ecx),%eax
			k_delayed_work_submit(&msg->ctx->retransmit_work,
  117d69:	8b 1b                	mov    (%ebx),%ebx
  117d6b:	81 c3 0c 01 00 00    	add    $0x10c,%ebx
			return t / (from_hz / to_hz);
  117d71:	6a 00                	push   $0x0
					      K_MSEC(msg->pending->timeout));
  117d73:	31 d2                	xor    %edx,%edx
		t += off;
  117d75:	83 c0 09             	add    $0x9,%eax
  117d78:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  117d7b:	6a 0a                	push   $0xa
  117d7d:	52                   	push   %edx
  117d7e:	50                   	push   %eax
  117d7f:	e8 9c 84 fe ff       	call   100220 <__udivdi3>
  117d84:	83 c4 10             	add    $0x10,%esp
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
  117d87:	52                   	push   %edx
  117d88:	50                   	push   %eax
  117d89:	53                   	push   %ebx
  117d8a:	68 00 ea 12 00       	push   $0x12ea00
  117d8f:	e8 43 a1 00 00       	call   121ed7 <k_delayed_work_submit_to_queue>
  117d94:	83 c4 10             	add    $0x10,%esp
  117d97:	eb 0a                	jmp    117da3 <lwm2m_send_message+0x16b>
		lwm2m_reset_message(msg, true);
  117d99:	6a 01                	push   $0x1
  117d9b:	53                   	push   %ebx
  117d9c:	e8 25 df ff ff       	call   115cc6 <lwm2m_reset_message>
  117da1:	58                   	pop    %eax
  117da2:	5a                   	pop    %edx
	return 0;
  117da3:	31 c0                	xor    %eax,%eax
}
  117da5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  117da8:	5b                   	pop    %ebx
  117da9:	5e                   	pop    %esi
  117daa:	5d                   	pop    %ebp
  117dab:	c3                   	ret    

00117dac <generate_notify_message.constprop.0>:
static int generate_notify_message(struct observe_node *obs,
  117dac:	55                   	push   %ebp
  117dad:	89 e5                	mov    %esp,%ebp
  117daf:	57                   	push   %edi
  117db0:	56                   	push   %esi
  117db1:	89 c7                	mov    %eax,%edi
  117db3:	53                   	push   %ebx
  117db4:	51                   	push   %ecx
	if (!obs->ctx) {
  117db5:	8b 40 04             	mov    0x4(%eax),%eax
  117db8:	85 c0                	test   %eax,%eax
  117dba:	75 2d                	jne    117de9 <generate_notify_message.constprop.0+0x3d>
		LOG_ERR("observer has no valid LwM2M ctx!");
  117dbc:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  117dc3:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("observer has no valid LwM2M ctx!");
  117dc8:	0f 84 0c 02 00 00    	je     117fda <generate_notify_message.constprop.0+0x22e>
  117dce:	b8 20 31 12 00       	mov    $0x123120,%eax
  117dd3:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117dd8:	c1 e8 03             	shr    $0x3,%eax
  117ddb:	c1 e0 06             	shl    $0x6,%eax
  117dde:	83 c8 01             	or     $0x1,%eax
  117de1:	50                   	push   %eax
  117de2:	68 80 7b 12 00       	push   $0x127b80
  117de7:	eb 38                	jmp    117e21 <generate_notify_message.constprop.0+0x75>
	msg = lwm2m_get_message(obs->ctx);
  117de9:	50                   	push   %eax
  117dea:	e8 a9 de ff ff       	call   115c98 <lwm2m_get_message>
  117def:	5a                   	pop    %edx
  117df0:	89 c6                	mov    %eax,%esi
	if (!msg) {
  117df2:	85 c0                	test   %eax,%eax
  117df4:	75 37                	jne    117e2d <generate_notify_message.constprop.0+0x81>
		LOG_ERR("Unable to get a lwm2m message!");
  117df6:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOMEM;
  117dfd:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
		LOG_ERR("Unable to get a lwm2m message!");
  117e02:	0f 84 d2 01 00 00    	je     117fda <generate_notify_message.constprop.0+0x22e>
  117e08:	b8 20 31 12 00       	mov    $0x123120,%eax
  117e0d:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117e12:	c1 e8 03             	shr    $0x3,%eax
  117e15:	c1 e0 06             	shl    $0x6,%eax
  117e18:	83 c8 01             	or     $0x1,%eax
  117e1b:	50                   	push   %eax
  117e1c:	68 a1 7b 12 00       	push   $0x127ba1
  117e21:	e8 27 b7 fe ff       	call   10354d <log_0>
  117e26:	5e                   	pop    %esi
  117e27:	5f                   	pop    %edi
  117e28:	e9 ad 01 00 00       	jmp    117fda <generate_notify_message.constprop.0+0x22e>
	memcpy(&msg->path, &obs->path, sizeof(struct lwm2m_obj_path));
  117e2d:	6a 0a                	push   $0xa
  117e2f:	8d 47 08             	lea    0x8(%edi),%eax
  117e32:	50                   	push   %eax
  117e33:	8d 46 24             	lea    0x24(%esi),%eax
  117e36:	50                   	push   %eax
  117e37:	e8 b0 3f ff ff       	call   10bdec <memcpy>
	msg->operation = LWM2M_OP_READ;
  117e3c:	c6 86 89 02 00 00 00 	movb   $0x0,0x289(%esi)
	memcpy(&msg->path, &obs->path, sizeof(struct lwm2m_obj_path));
  117e43:	83 c4 0c             	add    $0xc,%esp
	obj_inst = get_engine_obj_inst(obs->path.obj_id,
  117e46:	0f b7 4f 08          	movzwl 0x8(%edi),%ecx
  117e4a:	0f b7 57 0a          	movzwl 0xa(%edi),%edx
  117e4e:	89 c8                	mov    %ecx,%eax
  117e50:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  117e53:	e8 ca cc ff ff       	call   114b22 <get_engine_obj_inst>
	if (!obj_inst) {
  117e58:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  117e5b:	85 c0                	test   %eax,%eax
  117e5d:	75 3a                	jne    117e99 <generate_notify_message.constprop.0+0xed>
		LOG_ERR("unable to get engine obj for %u/%u",
  117e5f:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		ret = -EINVAL;
  117e66:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("unable to get engine obj for %u/%u",
  117e6b:	0f 84 5a 01 00 00    	je     117fcb <generate_notify_message.constprop.0+0x21f>
  117e71:	b8 20 31 12 00       	mov    $0x123120,%eax
  117e76:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117e7b:	c1 e8 03             	shr    $0x3,%eax
  117e7e:	c1 e0 06             	shl    $0x6,%eax
  117e81:	83 c8 01             	or     $0x1,%eax
  117e84:	50                   	push   %eax
  117e85:	52                   	push   %edx
  117e86:	51                   	push   %ecx
  117e87:	68 c0 7b 12 00       	push   $0x127bc0
  117e8c:	e8 1f b7 fe ff       	call   1035b0 <log_2>
  117e91:	83 c4 10             	add    $0x10,%esp
  117e94:	e9 32 01 00 00       	jmp    117fcb <generate_notify_message.constprop.0+0x21f>
	msg->type = COAP_TYPE_CON;
  117e99:	66 c7 86 86 02 00 00 	movw   $0x4500,0x286(%esi)
  117ea0:	00 45 
	msg->mid = coap_next_id();
  117ea2:	e8 b3 12 ff ff       	call   10915a <coap_next_id>
	msg->out.out_cpkt = &msg->cpkt;
  117ea7:	8d 56 30             	lea    0x30(%esi),%edx
	msg->mid = coap_next_id();
  117eaa:	66 89 86 84 02 00 00 	mov    %ax,0x284(%esi)
	msg->token = obs->token;
  117eb1:	8d 47 12             	lea    0x12(%edi),%eax
  117eb4:	89 86 78 02 00 00    	mov    %eax,0x278(%esi)
	msg->out.out_cpkt = &msg->cpkt;
  117eba:	89 55 f0             	mov    %edx,-0x10(%ebp)
	msg->tkl = obs->tkl;
  117ebd:	8a 47 3a             	mov    0x3a(%edi),%al
	msg->out.out_cpkt = &msg->cpkt;
  117ec0:	89 56 1c             	mov    %edx,0x1c(%esi)
	msg->tkl = obs->tkl;
  117ec3:	88 86 88 02 00 00    	mov    %al,0x288(%esi)
	msg->reply_cb = notify_message_reply_cb;
  117ec9:	c7 86 7c 02 00 00 79 	movl   $0x114f79,0x27c(%esi)
  117ed0:	4f 11 00 
	ret = lwm2m_init_message(msg);
  117ed3:	56                   	push   %esi
  117ed4:	e8 17 e0 ff ff       	call   115ef0 <lwm2m_init_message>
  117ed9:	59                   	pop    %ecx
  117eda:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  117edc:	85 c0                	test   %eax,%eax
  117ede:	8b 55 f0             	mov    -0x10(%ebp),%edx
  117ee1:	79 2c                	jns    117f0f <generate_notify_message.constprop.0+0x163>
		LOG_ERR("Unable to init lwm2m message! (err: %d)", ret);
  117ee3:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117eea:	0f 84 db 00 00 00    	je     117fcb <generate_notify_message.constprop.0+0x21f>
  117ef0:	b8 20 31 12 00       	mov    $0x123120,%eax
  117ef5:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117efa:	c1 e8 03             	shr    $0x3,%eax
  117efd:	c1 e0 06             	shl    $0x6,%eax
  117f00:	83 c8 01             	or     $0x1,%eax
  117f03:	50                   	push   %eax
  117f04:	53                   	push   %ebx
  117f05:	68 e3 7b 12 00       	push   $0x127be3
  117f0a:	e9 b4 00 00 00       	jmp    117fc3 <generate_notify_message.constprop.0+0x217>
	obs->counter++;
  117f0f:	8b 47 34             	mov    0x34(%edi),%eax
  117f12:	40                   	inc    %eax
  117f13:	89 47 34             	mov    %eax,0x34(%edi)
	ret = coap_append_option_int(&msg->cpkt, COAP_OPTION_OBSERVE,
  117f16:	50                   	push   %eax
  117f17:	6a 06                	push   $0x6
  117f19:	52                   	push   %edx
  117f1a:	e8 93 09 ff ff       	call   1088b2 <coap_append_option_int>
  117f1f:	83 c4 0c             	add    $0xc,%esp
  117f22:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  117f24:	85 c0                	test   %eax,%eax
  117f26:	79 29                	jns    117f51 <generate_notify_message.constprop.0+0x1a5>
		LOG_ERR("OBSERVE option error: %d", ret);
  117f28:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117f2f:	0f 84 96 00 00 00    	je     117fcb <generate_notify_message.constprop.0+0x21f>
  117f35:	b8 20 31 12 00       	mov    $0x123120,%eax
  117f3a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117f3f:	c1 e8 03             	shr    $0x3,%eax
  117f42:	c1 e0 06             	shl    $0x6,%eax
  117f45:	83 c8 01             	or     $0x1,%eax
  117f48:	50                   	push   %eax
  117f49:	53                   	push   %ebx
  117f4a:	68 9a 79 12 00       	push   $0x12799a
  117f4f:	eb 72                	jmp    117fc3 <generate_notify_message.constprop.0+0x217>
	select_writer(&msg->out, obs->format);
  117f51:	0f b7 57 38          	movzwl 0x38(%edi),%edx
  117f55:	8d 46 18             	lea    0x18(%esi),%eax
  117f58:	e8 50 ce ff ff       	call   114dad <select_writer>
	ret = do_read_op(msg, obs->format);
  117f5d:	89 f0                	mov    %esi,%eax
  117f5f:	0f b7 57 38          	movzwl 0x38(%edi),%edx
  117f63:	e8 80 cf ff ff       	call   114ee8 <do_read_op>
  117f68:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  117f6a:	85 c0                	test   %eax,%eax
  117f6c:	79 25                	jns    117f93 <generate_notify_message.constprop.0+0x1e7>
		LOG_ERR("error in multi-format read (err:%d)", ret);
  117f6e:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117f75:	74 54                	je     117fcb <generate_notify_message.constprop.0+0x21f>
  117f77:	b8 20 31 12 00       	mov    $0x123120,%eax
  117f7c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117f81:	c1 e8 03             	shr    $0x3,%eax
  117f84:	c1 e0 06             	shl    $0x6,%eax
  117f87:	83 c8 01             	or     $0x1,%eax
  117f8a:	50                   	push   %eax
  117f8b:	53                   	push   %ebx
  117f8c:	68 0b 7c 12 00       	push   $0x127c0b
  117f91:	eb 30                	jmp    117fc3 <generate_notify_message.constprop.0+0x217>
	ret = lwm2m_send_message(msg);
  117f93:	56                   	push   %esi
  117f94:	e8 9f fc ff ff       	call   117c38 <lwm2m_send_message>
  117f99:	5a                   	pop    %edx
  117f9a:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  117f9c:	85 c0                	test   %eax,%eax
  117f9e:	79 38                	jns    117fd8 <generate_notify_message.constprop.0+0x22c>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
  117fa0:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  117fa7:	74 22                	je     117fcb <generate_notify_message.constprop.0+0x21f>
  117fa9:	b8 20 31 12 00       	mov    $0x123120,%eax
  117fae:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  117fb3:	c1 e8 03             	shr    $0x3,%eax
  117fb6:	c1 e0 06             	shl    $0x6,%eax
  117fb9:	83 c8 01             	or     $0x1,%eax
  117fbc:	50                   	push   %eax
  117fbd:	53                   	push   %ebx
  117fbe:	68 2f 7c 12 00       	push   $0x127c2f
  117fc3:	e8 ae b5 fe ff       	call   103576 <log_1>
  117fc8:	83 c4 0c             	add    $0xc,%esp
	lwm2m_reset_message(msg, true);
  117fcb:	6a 01                	push   $0x1
  117fcd:	56                   	push   %esi
  117fce:	e8 f3 dc ff ff       	call   115cc6 <lwm2m_reset_message>
  117fd3:	e9 4e fe ff ff       	jmp    117e26 <generate_notify_message.constprop.0+0x7a>
	return 0;
  117fd8:	31 db                	xor    %ebx,%ebx
}
  117fda:	8d 65 f4             	lea    -0xc(%ebp),%esp
  117fdd:	89 d8                	mov    %ebx,%eax
  117fdf:	5b                   	pop    %ebx
  117fe0:	5e                   	pop    %esi
  117fe1:	5f                   	pop    %edi
  117fe2:	5d                   	pop    %ebp
  117fe3:	c3                   	ret    

00117fe4 <lwm2m_get_rd_data>:
{
  117fe4:	55                   	push   %ebp
  117fe5:	89 e5                	mov    %esp,%ebp
  117fe7:	57                   	push   %edi
  117fe8:	56                   	push   %esi
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
  117fe9:	bf 1b 00 00 00       	mov    $0x1b,%edi
{
  117fee:	53                   	push   %ebx
  117fef:	83 ec 28             	sub    $0x28,%esp
  117ff2:	8b 45 0c             	mov    0xc(%ebp),%eax
	memcpy(client_data, REG_PREFACE, sizeof(REG_PREFACE) - 1);
  117ff5:	6a 1b                	push   $0x1b
{
  117ff7:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
	memcpy(client_data, REG_PREFACE, sizeof(REG_PREFACE) - 1);
  117ffb:	68 54 7c 12 00       	push   $0x127c54
  118000:	ff 75 08             	pushl  0x8(%ebp)
  118003:	e8 e4 3d ff ff       	call   10bdec <memcpy>
  118008:	83 c4 0c             	add    $0xc,%esp
	return list->head;
  11800b:	8b 1d b4 ec 12 00    	mov    0x12ecb4,%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
  118011:	85 db                	test   %ebx,%ebx
  118013:	0f 84 d5 00 00 00    	je     1180ee <lwm2m_get_rd_data+0x10a>
		if (obj->obj_id == LWM2M_OBJECT_SECURITY_ID) {
  118019:	0f b7 43 18          	movzwl 0x18(%ebx),%eax
  11801d:	66 85 c0             	test   %ax,%ax
  118020:	0f 84 c1 00 00 00    	je     1180e7 <lwm2m_get_rd_data+0x103>
		if (obj->instance_count == 0U) {
  118026:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  11802b:	75 4d                	jne    11807a <lwm2m_get_rd_data+0x96>
			len = snprintk(temp, sizeof(temp), "%s</%u>",
  11802d:	66 85 ff             	test   %di,%di
  118030:	ba eb 78 12 00       	mov    $0x1278eb,%edx
  118035:	75 05                	jne    11803c <lwm2m_get_rd_data+0x58>
  118037:	ba 02 4e 12 00       	mov    $0x124e02,%edx
  11803c:	50                   	push   %eax
  11803d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  118040:	52                   	push   %edx
  118041:	68 ae 7a 12 00       	push   $0x127aae
  118046:	6a 20                	push   $0x20
  118048:	50                   	push   %eax
  118049:	e8 b1 92 fe ff       	call   1012ff <snprintk>
  11804e:	89 c6                	mov    %eax,%esi
  118050:	83 c4 14             	add    $0x14,%esp
			if (pos + len >= size) {
  118053:	0f b7 c7             	movzwl %di,%eax
  118056:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
  11805a:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  11805d:	39 d1                	cmp    %edx,%ecx
  11805f:	0f 8d 89 00 00 00    	jge    1180ee <lwm2m_get_rd_data+0x10a>
			memcpy(&client_data[pos], temp, len);
  118065:	56                   	push   %esi
  118066:	03 45 08             	add    0x8(%ebp),%eax
  118069:	8d 4d d4             	lea    -0x2c(%ebp),%ecx
			pos += len;
  11806c:	01 f7                	add    %esi,%edi
			memcpy(&client_data[pos], temp, len);
  11806e:	51                   	push   %ecx
  11806f:	50                   	push   %eax
  118070:	e8 77 3d ff ff       	call   10bdec <memcpy>
  118075:	83 c4 0c             	add    $0xc,%esp
			continue;
  118078:	eb 6d                	jmp    1180e7 <lwm2m_get_rd_data+0x103>
  11807a:	8b 35 ac ec 12 00    	mov    0x12ecac,%esi
		SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_inst_list,
  118080:	85 f6                	test   %esi,%esi
  118082:	74 63                	je     1180e7 <lwm2m_get_rd_data+0x103>
			if (obj_inst->obj->obj_id == obj->obj_id) {
  118084:	8b 46 04             	mov    0x4(%esi),%eax
  118087:	0f b7 40 18          	movzwl 0x18(%eax),%eax
  11808b:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  11808f:	75 52                	jne    1180e3 <lwm2m_get_rd_data+0xff>
				len = snprintk(temp, sizeof(temp),
  118091:	0f b7 4e 0c          	movzwl 0xc(%esi),%ecx
  118095:	66 85 ff             	test   %di,%di
  118098:	ba eb 78 12 00       	mov    $0x1278eb,%edx
  11809d:	75 05                	jne    1180a4 <lwm2m_get_rd_data+0xc0>
  11809f:	ba 02 4e 12 00       	mov    $0x124e02,%edx
  1180a4:	51                   	push   %ecx
  1180a5:	50                   	push   %eax
  1180a6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  1180a9:	52                   	push   %edx
  1180aa:	68 b6 7a 12 00       	push   $0x127ab6
  1180af:	6a 20                	push   $0x20
  1180b1:	50                   	push   %eax
  1180b2:	e8 48 92 fe ff       	call   1012ff <snprintk>
  1180b7:	8b 55 08             	mov    0x8(%ebp),%edx
  1180ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
				if (pos + len >= size) {
  1180bd:	0f b7 c7             	movzwl %di,%eax
  1180c0:	01 c2                	add    %eax,%edx
  1180c2:	03 45 d0             	add    -0x30(%ebp),%eax
  1180c5:	0f b7 4d ce          	movzwl -0x32(%ebp),%ecx
				len = snprintk(temp, sizeof(temp),
  1180c9:	83 c4 18             	add    $0x18,%esp
				if (pos + len >= size) {
  1180cc:	39 c8                	cmp    %ecx,%eax
  1180ce:	7d 17                	jge    1180e7 <lwm2m_get_rd_data+0x103>
				memcpy(&client_data[pos], temp, len);
  1180d0:	ff 75 d0             	pushl  -0x30(%ebp)
  1180d3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  1180d6:	50                   	push   %eax
  1180d7:	52                   	push   %edx
  1180d8:	e8 0f 3d ff ff       	call   10bdec <memcpy>
				pos += len;
  1180dd:	03 7d d0             	add    -0x30(%ebp),%edi
				memcpy(&client_data[pos], temp, len);
  1180e0:	83 c4 0c             	add    $0xc,%esp
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1180e3:	8b 36                	mov    (%esi),%esi
	return node->next;
  1180e5:	eb 99                	jmp    118080 <lwm2m_get_rd_data+0x9c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  1180e7:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  1180e9:	e9 23 ff ff ff       	jmp    118011 <lwm2m_get_rd_data+0x2d>
	client_data[pos] = '\0';
  1180ee:	0f b7 c7             	movzwl %di,%eax
  1180f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1180f4:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
}
  1180f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1180fb:	89 f8                	mov    %edi,%eax
  1180fd:	5b                   	pop    %ebx
  1180fe:	5e                   	pop    %esi
  1180ff:	5f                   	pop    %edi
  118100:	5d                   	pop    %ebp
  118101:	c3                   	ret    

00118102 <lwm2m_engine_set_res_data>:
{
  118102:	55                   	push   %ebp
  118103:	89 e5                	mov    %esp,%ebp
  118105:	57                   	push   %edi
  118106:	56                   	push   %esi
  118107:	53                   	push   %ebx
	ret = string_to_path(pathstr, &path, '/');
  118108:	8d 55 ea             	lea    -0x16(%ebp),%edx
{
  11810b:	83 ec 10             	sub    $0x10,%esp
	struct lwm2m_engine_res_inst *res_inst = NULL;
  11810e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	ret = string_to_path(pathstr, &path, '/');
  118115:	8b 45 08             	mov    0x8(%ebp),%eax
{
  118118:	8b 75 10             	mov    0x10(%ebp),%esi
  11811b:	8b 7d 14             	mov    0x14(%ebp),%edi
	ret = string_to_path(pathstr, &path, '/');
  11811e:	e8 e0 cf ff ff       	call   115103 <string_to_path.constprop.0>
  118123:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  118125:	85 c0                	test   %eax,%eax
  118127:	0f 88 a3 00 00 00    	js     1181d0 <lwm2m_engine_set_res_data+0xce>
	if (path.level < 3) {
  11812d:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  118131:	77 34                	ja     118167 <lwm2m_engine_set_res_data+0x65>
		LOG_ERR("path must have at least 3 parts");
  118133:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  11813a:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("path must have at least 3 parts");
  11813f:	0f 84 8b 00 00 00    	je     1181d0 <lwm2m_engine_set_res_data+0xce>
  118145:	b8 20 31 12 00       	mov    $0x123120,%eax
  11814a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11814f:	c1 e8 03             	shr    $0x3,%eax
  118152:	c1 e0 06             	shl    $0x6,%eax
  118155:	83 c8 01             	or     $0x1,%eax
  118158:	50                   	push   %eax
  118159:	68 f4 75 12 00       	push   $0x1275f4
  11815e:	e8 ea b3 fe ff       	call   10354d <log_0>
  118163:	5e                   	pop    %esi
  118164:	5f                   	pop    %edi
  118165:	eb 69                	jmp    1181d0 <lwm2m_engine_set_res_data+0xce>
	ret = path_to_objs(&path, NULL, NULL, NULL, &res_inst);
  118167:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  11816a:	31 c9                	xor    %ecx,%ecx
  11816c:	50                   	push   %eax
  11816d:	31 d2                	xor    %edx,%edx
  11816f:	8d 45 ea             	lea    -0x16(%ebp),%eax
  118172:	6a 00                	push   $0x0
  118174:	e8 b8 d1 ff ff       	call   115331 <path_to_objs>
  118179:	5a                   	pop    %edx
  11817a:	59                   	pop    %ecx
  11817b:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  11817d:	85 c0                	test   %eax,%eax
  11817f:	78 4f                	js     1181d0 <lwm2m_engine_set_res_data+0xce>
	if (!res_inst) {
  118181:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  118184:	85 c0                	test   %eax,%eax
  118186:	75 36                	jne    1181be <lwm2m_engine_set_res_data+0xbc>
		LOG_ERR("res instance %d not found", path.res_inst_id);
  118188:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  11818f:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
		LOG_ERR("res instance %d not found", path.res_inst_id);
  118194:	74 3a                	je     1181d0 <lwm2m_engine_set_res_data+0xce>
  118196:	b8 20 31 12 00       	mov    $0x123120,%eax
  11819b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1181a0:	c1 e8 03             	shr    $0x3,%eax
  1181a3:	c1 e0 06             	shl    $0x6,%eax
  1181a6:	83 c8 01             	or     $0x1,%eax
  1181a9:	50                   	push   %eax
  1181aa:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  1181ae:	50                   	push   %eax
  1181af:	68 14 76 12 00       	push   $0x127614
  1181b4:	e8 bd b3 fe ff       	call   103576 <log_1>
  1181b9:	83 c4 0c             	add    $0xc,%esp
  1181bc:	eb 12                	jmp    1181d0 <lwm2m_engine_set_res_data+0xce>
	res_inst->data_ptr = data_ptr;
  1181be:	8b 55 0c             	mov    0xc(%ebp),%edx
	res_inst->data_flags = data_flags;
  1181c1:	89 f9                	mov    %edi,%ecx
	res_inst->data_ptr = data_ptr;
  1181c3:	89 10                	mov    %edx,(%eax)
	res_inst->data_len = data_len;
  1181c5:	66 89 70 06          	mov    %si,0x6(%eax)
	res_inst->max_data_len = data_len;
  1181c9:	66 89 70 04          	mov    %si,0x4(%eax)
	res_inst->data_flags = data_flags;
  1181cd:	88 48 0a             	mov    %cl,0xa(%eax)
}
  1181d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1181d3:	89 d8                	mov    %ebx,%eax
  1181d5:	5b                   	pop    %ebx
  1181d6:	5e                   	pop    %esi
  1181d7:	5f                   	pop    %edi
  1181d8:	5d                   	pop    %ebp
  1181d9:	c3                   	ret    

001181da <lwm2m_engine_set_string>:
{
  1181da:	55                   	push   %ebp
  1181db:	89 e5                	mov    %esp,%ebp
  1181dd:	53                   	push   %ebx
  1181de:	50                   	push   %eax
  1181df:	8b 55 0c             	mov    0xc(%ebp),%edx
  1181e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return lwm2m_engine_set(pathstr, data_ptr, strlen(data_ptr));
  1181e5:	52                   	push   %edx
  1181e6:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1181e9:	e8 2e 3b ff ff       	call   10bd1c <strlen>
  1181ee:	5a                   	pop    %edx
  1181ef:	0f b7 c8             	movzwl %ax,%ecx
  1181f2:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1181f5:	89 d8                	mov    %ebx,%eax
}
  1181f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1181fa:	c9                   	leave  
	return lwm2m_engine_set(pathstr, data_ptr, strlen(data_ptr));
  1181fb:	e9 f1 d2 ff ff       	jmp    1154f1 <lwm2m_engine_set>

00118200 <lwm2m_engine_set_u16>:
{
  118200:	55                   	push   %ebp
	return lwm2m_engine_set(pathstr, &value, 2);
  118201:	b9 02 00 00 00       	mov    $0x2,%ecx
{
  118206:	89 e5                	mov    %esp,%ebp
  118208:	50                   	push   %eax
  118209:	8b 45 0c             	mov    0xc(%ebp),%eax
	return lwm2m_engine_set(pathstr, &value, 2);
  11820c:	8d 55 fc             	lea    -0x4(%ebp),%edx
{
  11820f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	return lwm2m_engine_set(pathstr, &value, 2);
  118213:	8b 45 08             	mov    0x8(%ebp),%eax
  118216:	e8 d6 d2 ff ff       	call   1154f1 <lwm2m_engine_set>
}
  11821b:	c9                   	leave  
  11821c:	c3                   	ret    

0011821d <lwm2m_engine_get_res_data>:
{
  11821d:	55                   	push   %ebp
  11821e:	89 e5                	mov    %esp,%ebp
  118220:	53                   	push   %ebx
  118221:	83 ec 10             	sub    $0x10,%esp
	ret = string_to_path(pathstr, &path, '/');
  118224:	8d 55 f2             	lea    -0xe(%ebp),%edx
  118227:	8b 45 08             	mov    0x8(%ebp),%eax
	struct lwm2m_engine_res_inst *res_inst = NULL;
  11822a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	ret = string_to_path(pathstr, &path, '/');
  118231:	e8 cd ce ff ff       	call   115103 <string_to_path.constprop.0>
  118236:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  118238:	85 c0                	test   %eax,%eax
  11823a:	0f 88 ac 00 00 00    	js     1182ec <lwm2m_engine_get_res_data+0xcf>
	if (path.level < 3) {
  118240:	80 7d fa 02          	cmpb   $0x2,-0x6(%ebp)
  118244:	77 34                	ja     11827a <lwm2m_engine_get_res_data+0x5d>
		LOG_ERR("path must have at least 3 parts");
  118246:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -EINVAL;
  11824d:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("path must have at least 3 parts");
  118252:	0f 84 94 00 00 00    	je     1182ec <lwm2m_engine_get_res_data+0xcf>
  118258:	b8 20 31 12 00       	mov    $0x123120,%eax
  11825d:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  118262:	c1 e8 03             	shr    $0x3,%eax
  118265:	c1 e0 06             	shl    $0x6,%eax
  118268:	83 c8 01             	or     $0x1,%eax
  11826b:	50                   	push   %eax
  11826c:	68 f4 75 12 00       	push   $0x1275f4
  118271:	e8 d7 b2 fe ff       	call   10354d <log_0>
  118276:	58                   	pop    %eax
  118277:	5a                   	pop    %edx
  118278:	eb 72                	jmp    1182ec <lwm2m_engine_get_res_data+0xcf>
	ret = path_to_objs(&path, NULL, NULL, NULL, &res_inst);
  11827a:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11827d:	31 c9                	xor    %ecx,%ecx
  11827f:	50                   	push   %eax
  118280:	31 d2                	xor    %edx,%edx
  118282:	8d 45 f2             	lea    -0xe(%ebp),%eax
  118285:	6a 00                	push   $0x0
  118287:	e8 a5 d0 ff ff       	call   115331 <path_to_objs>
  11828c:	5a                   	pop    %edx
  11828d:	59                   	pop    %ecx
  11828e:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  118290:	85 c0                	test   %eax,%eax
  118292:	78 58                	js     1182ec <lwm2m_engine_get_res_data+0xcf>
	if (!res_inst) {
  118294:	8b 45 ec             	mov    -0x14(%ebp),%eax
  118297:	85 c0                	test   %eax,%eax
  118299:	75 36                	jne    1182d1 <lwm2m_engine_get_res_data+0xb4>
		LOG_ERR("res instance %d not found", path.res_inst_id);
  11829b:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOENT;
  1182a2:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
		LOG_ERR("res instance %d not found", path.res_inst_id);
  1182a7:	74 43                	je     1182ec <lwm2m_engine_get_res_data+0xcf>
  1182a9:	b8 20 31 12 00       	mov    $0x123120,%eax
  1182ae:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1182b3:	c1 e8 03             	shr    $0x3,%eax
  1182b6:	c1 e0 06             	shl    $0x6,%eax
  1182b9:	83 c8 01             	or     $0x1,%eax
  1182bc:	50                   	push   %eax
  1182bd:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
  1182c1:	50                   	push   %eax
  1182c2:	68 14 76 12 00       	push   $0x127614
  1182c7:	e8 aa b2 fe ff       	call   103576 <log_1>
  1182cc:	83 c4 0c             	add    $0xc,%esp
  1182cf:	eb 1b                	jmp    1182ec <lwm2m_engine_get_res_data+0xcf>
	*data_ptr = res_inst->data_ptr;
  1182d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  1182d4:	8b 08                	mov    (%eax),%ecx
	return 0;
  1182d6:	31 db                	xor    %ebx,%ebx
	*data_ptr = res_inst->data_ptr;
  1182d8:	89 0a                	mov    %ecx,(%edx)
	*data_len = res_inst->data_len;
  1182da:	8b 55 10             	mov    0x10(%ebp),%edx
  1182dd:	66 8b 48 06          	mov    0x6(%eax),%cx
  1182e1:	66 89 0a             	mov    %cx,(%edx)
	*data_flags = res_inst->data_flags;
  1182e4:	8a 50 0a             	mov    0xa(%eax),%dl
  1182e7:	8b 45 14             	mov    0x14(%ebp),%eax
  1182ea:	88 10                	mov    %dl,(%eax)
}
  1182ec:	89 d8                	mov    %ebx,%eax
  1182ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1182f1:	c9                   	leave  
  1182f2:	c3                   	ret    

001182f3 <lwm2m_engine_get_string>:
  1182f3:	55                   	push   %ebp
  1182f4:	89 e5                	mov    %esp,%ebp
  1182f6:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  1182fa:	8b 55 0c             	mov    0xc(%ebp),%edx
  1182fd:	8b 45 08             	mov    0x8(%ebp),%eax
  118300:	5d                   	pop    %ebp
  118301:	e9 2e d5 ff ff       	jmp    115834 <lwm2m_engine_get>

00118306 <lwm2m_engine_get_u16>:
{
  118306:	55                   	push   %ebp
	return lwm2m_engine_get(pathstr, value, 2);
  118307:	b9 02 00 00 00       	mov    $0x2,%ecx
{
  11830c:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_get(pathstr, value, 2);
  11830e:	8b 55 0c             	mov    0xc(%ebp),%edx
  118311:	8b 45 08             	mov    0x8(%ebp),%eax
}
  118314:	5d                   	pop    %ebp
	return lwm2m_engine_get(pathstr, value, 2);
  118315:	e9 1a d5 ff ff       	jmp    115834 <lwm2m_engine_get>

0011831a <lwm2m_engine_get_u32>:
{
  11831a:	55                   	push   %ebp
	return lwm2m_engine_get(pathstr, value, 4);
  11831b:	b9 04 00 00 00       	mov    $0x4,%ecx
{
  118320:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_get(pathstr, value, 4);
  118322:	8b 55 0c             	mov    0xc(%ebp),%edx
  118325:	8b 45 08             	mov    0x8(%ebp),%eax
}
  118328:	5d                   	pop    %ebp
	return lwm2m_engine_get(pathstr, value, 4);
  118329:	e9 06 d5 ff ff       	jmp    115834 <lwm2m_engine_get>

0011832e <lwm2m_engine_get_s8>:
{
  11832e:	55                   	push   %ebp
	return lwm2m_engine_get(pathstr, value, 1);
  11832f:	b9 01 00 00 00       	mov    $0x1,%ecx
{
  118334:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_get(pathstr, value, 1);
  118336:	8b 55 0c             	mov    0xc(%ebp),%edx
  118339:	8b 45 08             	mov    0x8(%ebp),%eax
}
  11833c:	5d                   	pop    %ebp
	return lwm2m_engine_get(pathstr, value, 1);
  11833d:	e9 f2 d4 ff ff       	jmp    115834 <lwm2m_engine_get>

00118342 <lwm2m_engine_get_bool>:
{
  118342:	55                   	push   %ebp
  118343:	89 e5                	mov    %esp,%ebp
  118345:	50                   	push   %eax
	ret = lwm2m_engine_get_s8(pathstr, &temp);
  118346:	8d 45 ff             	lea    -0x1(%ebp),%eax
	int8_t temp = 0;
  118349:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
	ret = lwm2m_engine_get_s8(pathstr, &temp);
  11834d:	50                   	push   %eax
  11834e:	ff 75 08             	pushl  0x8(%ebp)
  118351:	e8 d8 ff ff ff       	call   11832e <lwm2m_engine_get_s8>
  118356:	5a                   	pop    %edx
	if (!ret) {
  118357:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_s8(pathstr, &temp);
  118359:	59                   	pop    %ecx
	if (!ret) {
  11835a:	75 0a                	jne    118366 <lwm2m_engine_get_bool+0x24>
		*value = temp != 0;
  11835c:	8b 55 0c             	mov    0xc(%ebp),%edx
  11835f:	80 7d ff 00          	cmpb   $0x0,-0x1(%ebp)
  118363:	0f 95 02             	setne  (%edx)
}
  118366:	c9                   	leave  
  118367:	c3                   	ret    

00118368 <lwm2m_engine_get_resource>:
{
  118368:	55                   	push   %ebp
  118369:	89 e5                	mov    %esp,%ebp
  11836b:	83 ec 10             	sub    $0x10,%esp
	ret = string_to_path(pathstr, &path, '/');
  11836e:	8d 55 f6             	lea    -0xa(%ebp),%edx
  118371:	8b 45 08             	mov    0x8(%ebp),%eax
  118374:	e8 8a cd ff ff       	call   115103 <string_to_path.constprop.0>
	if (ret < 0) {
  118379:	85 c0                	test   %eax,%eax
  11837b:	78 50                	js     1183cd <lwm2m_engine_get_resource+0x65>
	if (path.level < 3) {
  11837d:	80 7d fe 02          	cmpb   $0x2,-0x2(%ebp)
  118381:	77 37                	ja     1183ba <lwm2m_engine_get_resource+0x52>
		LOG_ERR("path must have 3 parts");
  118383:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  11838a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  11838f:	74 3c                	je     1183cd <lwm2m_engine_get_resource+0x65>
  118391:	ba 20 31 12 00       	mov    $0x123120,%edx
  118396:	89 45 f0             	mov    %eax,-0x10(%ebp)
  118399:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11839f:	c1 ea 03             	shr    $0x3,%edx
  1183a2:	c1 e2 06             	shl    $0x6,%edx
  1183a5:	83 ca 01             	or     $0x1,%edx
  1183a8:	52                   	push   %edx
  1183a9:	68 70 7c 12 00       	push   $0x127c70
  1183ae:	e8 9a b1 fe ff       	call   10354d <log_0>
  1183b3:	58                   	pop    %eax
  1183b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1183b7:	5a                   	pop    %edx
  1183b8:	eb 13                	jmp    1183cd <lwm2m_engine_get_resource+0x65>
	return path_to_objs(&path, NULL, NULL, res, NULL);
  1183ba:	6a 00                	push   $0x0
  1183bc:	31 c9                	xor    %ecx,%ecx
  1183be:	ff 75 0c             	pushl  0xc(%ebp)
  1183c1:	31 d2                	xor    %edx,%edx
  1183c3:	8d 45 f6             	lea    -0xa(%ebp),%eax
  1183c6:	e8 66 cf ff ff       	call   115331 <path_to_objs>
  1183cb:	5a                   	pop    %edx
  1183cc:	59                   	pop    %ecx
}
  1183cd:	c9                   	leave  
  1183ce:	c3                   	ret    

001183cf <lwm2m_engine_get_binding>:
{
  1183cf:	55                   	push   %ebp
  1183d0:	89 e5                	mov    %esp,%ebp
		strcpy(binding, "U");
  1183d2:	68 87 7c 12 00       	push   $0x127c87
  1183d7:	ff 75 08             	pushl  0x8(%ebp)
  1183da:	e8 a2 38 ff ff       	call   10bc81 <strcpy>
  1183df:	58                   	pop    %eax
  1183e0:	5a                   	pop    %edx
}
  1183e1:	c9                   	leave  
  1183e2:	c3                   	ret    

001183e3 <lwm2m_engine_register_pre_write_callback>:
{
  1183e3:	55                   	push   %ebp
  1183e4:	89 e5                	mov    %esp,%ebp
  1183e6:	50                   	push   %eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
  1183e7:	8d 45 fc             	lea    -0x4(%ebp),%eax
	struct lwm2m_engine_res *res = NULL;
  1183ea:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	ret = lwm2m_engine_get_resource(pathstr, &res);
  1183f1:	50                   	push   %eax
  1183f2:	ff 75 08             	pushl  0x8(%ebp)
  1183f5:	e8 6e ff ff ff       	call   118368 <lwm2m_engine_get_resource>
  1183fa:	5a                   	pop    %edx
	if (ret < 0) {
  1183fb:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_resource(pathstr, &res);
  1183fd:	59                   	pop    %ecx
	if (ret < 0) {
  1183fe:	78 0b                	js     11840b <lwm2m_engine_register_pre_write_callback+0x28>
	res->pre_write_cb = cb;
  118400:	8b 45 fc             	mov    -0x4(%ebp),%eax
  118403:	8b 55 0c             	mov    0xc(%ebp),%edx
  118406:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  118409:	31 c0                	xor    %eax,%eax
}
  11840b:	c9                   	leave  
  11840c:	c3                   	ret    

0011840d <lwm2m_engine_get_opaque_more>:
{
  11840d:	55                   	push   %ebp
  11840e:	89 e5                	mov    %esp,%ebp
  118410:	57                   	push   %edi
  118411:	56                   	push   %esi
  118412:	53                   	push   %ebx
  118413:	50                   	push   %eax
	uint16_t remaining = in->in_cpkt->max_len - in->offset;
  118414:	8b 7d 08             	mov    0x8(%ebp),%edi
  118417:	8b 75 08             	mov    0x8(%ebp),%esi
	uint32_t in_len = opaque->remaining;
  11841a:	8b 45 14             	mov    0x14(%ebp),%eax
{
  11841d:	8b 5d 10             	mov    0x10(%ebp),%ebx
	uint16_t remaining = in->in_cpkt->max_len - in->offset;
  118420:	8b 57 04             	mov    0x4(%edi),%edx
  118423:	8b 4e 08             	mov    0x8(%esi),%ecx
  118426:	66 89 4d f2          	mov    %cx,-0xe(%ebp)
	uint32_t in_len = opaque->remaining;
  11842a:	8b 40 04             	mov    0x4(%eax),%eax
	uint16_t remaining = in->in_cpkt->max_len - in->offset;
  11842d:	66 8b 7a 06          	mov    0x6(%edx),%di
  118431:	89 de                	mov    %ebx,%esi
  118433:	89 f9                	mov    %edi,%ecx
  118435:	66 2b 4d f2          	sub    -0xe(%ebp),%cx
	if (in_len > buflen) {
  118439:	39 d8                	cmp    %ebx,%eax
  11843b:	77 02                	ja     11843f <lwm2m_engine_get_opaque_more+0x32>
  11843d:	89 c6                	mov    %eax,%esi
	if (in_len > remaining) {
  11843f:	0f b7 d9             	movzwl %cx,%ebx
  118442:	39 f3                	cmp    %esi,%ebx
  118444:	76 02                	jbe    118448 <lwm2m_engine_get_opaque_more+0x3b>
  118446:	89 f3                	mov    %esi,%ebx
	opaque->remaining -= in_len;
  118448:	8b 75 14             	mov    0x14(%ebp),%esi
  11844b:	29 d8                	sub    %ebx,%eax
  11844d:	89 46 04             	mov    %eax,0x4(%esi)
	remaining -= in_len;
  118450:	89 de                	mov    %ebx,%esi
	if (opaque->remaining == 0U || remaining == 0) {
  118452:	74 05                	je     118459 <lwm2m_engine_get_opaque_more+0x4c>
  118454:	66 39 d9             	cmp    %bx,%cx
  118457:	75 06                	jne    11845f <lwm2m_engine_get_opaque_more+0x52>
		*last_block = true;
  118459:	8b 45 18             	mov    0x18(%ebp),%eax
  11845c:	c6 00 01             	movb   $0x1,(%eax)
	if (buf_read(buf, in_len, CPKT_BUF_READ(in->in_cpkt),
  11845f:	8b 12                	mov    (%edx),%edx
  118461:	0f b7 cf             	movzwl %di,%ecx

/* read */
static inline int buf_read(uint8_t *dst, uint16_t len, uint8_t *src, uint16_t src_len,
			   uint16_t *offset)
{
	if (!src) {
  118464:	85 d2                	test   %edx,%edx
  118466:	74 29                	je     118491 <lwm2m_engine_get_opaque_more+0x84>
		return -EINVAL;
	}

	if (*offset + len > src_len) {
  118468:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  11846c:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
  11846f:	39 f9                	cmp    %edi,%ecx
  118471:	7c 1e                	jl     118491 <lwm2m_engine_get_opaque_more+0x84>
		return -ENOMEM;
	}

	if (dst) {
  118473:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  118477:	74 0f                	je     118488 <lwm2m_engine_get_opaque_more+0x7b>
		/* copy data at offset into dst */
		memcpy(dst, src + *offset, len);
  118479:	53                   	push   %ebx
  11847a:	01 d0                	add    %edx,%eax
  11847c:	50                   	push   %eax
  11847d:	ff 75 0c             	pushl  0xc(%ebp)
  118480:	e8 67 39 ff ff       	call   10bdec <memcpy>
  118485:	83 c4 0c             	add    $0xc,%esp
	}

	*offset += len;
  118488:	8b 45 08             	mov    0x8(%ebp),%eax
  11848b:	66 01 70 08          	add    %si,0x8(%eax)
	return 0;
  11848f:	eb 08                	jmp    118499 <lwm2m_engine_get_opaque_more+0x8c>
		*last_block = true;
  118491:	8b 45 18             	mov    0x18(%ebp),%eax
		return 0;
  118494:	31 db                	xor    %ebx,%ebx
		*last_block = true;
  118496:	c6 00 01             	movb   $0x1,(%eax)
}
  118499:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11849c:	89 d8                	mov    %ebx,%eax
  11849e:	5b                   	pop    %ebx
  11849f:	5e                   	pop    %esi
  1184a0:	5f                   	pop    %edi
  1184a1:	5d                   	pop    %ebp
  1184a2:	c3                   	ret    

001184a3 <lwm2m_write_handler>:
{
  1184a3:	55                   	push   %ebp
  1184a4:	89 e5                	mov    %esp,%ebp
  1184a6:	57                   	push   %edi
  1184a7:	56                   	push   %esi
  1184a8:	53                   	push   %ebx
  1184a9:	83 ec 28             	sub    $0x28,%esp
	int64_t temp64 = 0;
  1184ac:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	if (!obj_inst || !res || !res_inst || !obj_field || !msg) {
  1184b3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
{
  1184b7:	8b 75 18             	mov    0x18(%ebp),%esi
	int64_t temp64 = 0;
  1184ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int32_t temp32 = 0;
  1184c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	if (!obj_inst || !res || !res_inst || !obj_field || !msg) {
  1184c8:	0f 84 96 02 00 00    	je     118764 <lwm2m_write_handler+0x2c1>
  1184ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1184d2:	0f 84 8c 02 00 00    	je     118764 <lwm2m_write_handler+0x2c1>
  1184d8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1184dc:	0f 94 c2             	sete   %dl
  1184df:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1184e3:	0f 94 c0             	sete   %al
  1184e6:	08 c2                	or     %al,%dl
  1184e8:	0f 85 76 02 00 00    	jne    118764 <lwm2m_write_handler+0x2c1>
  1184ee:	85 f6                	test   %esi,%esi
  1184f0:	0f 84 6e 02 00 00    	je     118764 <lwm2m_write_handler+0x2c1>
	if (LWM2M_HAS_RES_FLAG(res_inst, LWM2M_RES_DATA_FLAG_RO)) {
  1184f6:	8b 45 10             	mov    0x10(%ebp),%eax
		return -EACCES;
  1184f9:	ba f3 ff ff ff       	mov    $0xfffffff3,%edx
	if (LWM2M_HAS_RES_FLAG(res_inst, LWM2M_RES_DATA_FLAG_RO)) {
  1184fe:	f6 40 0a 01          	testb  $0x1,0xa(%eax)
  118502:	0f 85 bf 02 00 00    	jne    1187c7 <lwm2m_write_handler+0x324>
	data_ptr = res_inst->data_ptr;
  118508:	8b 18                	mov    (%eax),%ebx
	data_len = res_inst->max_data_len;
  11850a:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  11850e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (res->pre_write_cb) {
  118511:	8b 45 0c             	mov    0xc(%ebp),%eax
  118514:	8b 40 04             	mov    0x4(%eax),%eax
  118517:	85 c0                	test   %eax,%eax
  118519:	74 23                	je     11853e <lwm2m_write_handler+0x9b>
		data_ptr = res->pre_write_cb(obj_inst->obj_inst_id,
  11851b:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11851e:	8d 55 dc             	lea    -0x24(%ebp),%edx
  118521:	52                   	push   %edx
  118522:	8b 7d 08             	mov    0x8(%ebp),%edi
  118525:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  118529:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11852c:	52                   	push   %edx
  11852d:	0f b7 51 14          	movzwl 0x14(%ecx),%edx
  118531:	52                   	push   %edx
  118532:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
  118536:	52                   	push   %edx
  118537:	ff d0                	call   *%eax
  118539:	83 c4 10             	add    $0x10,%esp
  11853c:	89 c3                	mov    %eax,%ebx
	if (res->post_write_cb) {
  11853e:	8b 45 0c             	mov    0xc(%ebp),%eax
	size_t total_size = 0;
  118541:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	if (res->post_write_cb) {
  118548:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  11854c:	74 0c                	je     11855a <lwm2m_write_handler+0xb7>
		if (msg->in.block_ctx != NULL) {
  11854e:	8b 46 10             	mov    0x10(%esi),%eax
  118551:	85 c0                	test   %eax,%eax
  118553:	74 05                	je     11855a <lwm2m_write_handler+0xb7>
			total_size = msg->in.block_ctx->ctx.total_size;
  118555:	8b 00                	mov    (%eax),%eax
  118557:	89 45 d0             	mov    %eax,-0x30(%ebp)
		return -ENOENT;
  11855a:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
	if (data_ptr && data_len > 0) {
  11855f:	85 db                	test   %ebx,%ebx
  118561:	0f 84 60 02 00 00    	je     1187c7 <lwm2m_write_handler+0x324>
  118567:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11856a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  11856d:	85 c0                	test   %eax,%eax
  11856f:	0f 84 52 02 00 00    	je     1187c7 <lwm2m_write_handler+0x324>
		switch (obj_field->data_type) {
  118575:	8b 45 14             	mov    0x14(%ebp),%eax
  118578:	0f b6 50 03          	movzbl 0x3(%eax),%edx
  11857c:	8d 42 ff             	lea    -0x1(%edx),%eax
  11857f:	3c 0e                	cmp    $0xe,%al
  118581:	0f 87 b2 01 00 00    	ja     118739 <lwm2m_write_handler+0x296>
  118587:	0f b6 c0             	movzbl %al,%eax
  11858a:	8d 7e 04             	lea    0x4(%esi),%edi
  11858d:	ff 24 85 0c 45 12 00 	jmp    *0x12450c(,%eax,4)
	if (in->block_ctx != NULL) {
  118594:	8b 46 10             	mov    0x10(%esi),%eax
	bool last_pkt_block = false;
  118597:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
	struct lwm2m_opaque_context opaque_ctx = { 0 };
  11859b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1185a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool last_block = true;
  1185a9:	c6 45 cf 01          	movb   $0x1,-0x31(%ebp)
	if (in->block_ctx != NULL) {
  1185ad:	85 c0                	test   %eax,%eax
  1185af:	74 49                	je     1185fa <lwm2m_write_handler+0x157>
		last_block = in->block_ctx->last_block;
  1185b1:	8a 48 29             	mov    0x29(%eax),%cl
		opaque_ctx = in->block_ctx->opaque;
  1185b4:	8b 50 10             	mov    0x10(%eax),%edx
		last_block = in->block_ctx->last_block;
  1185b7:	83 e1 01             	and    $0x1,%ecx
		opaque_ctx = in->block_ctx->opaque;
  1185ba:	8b 40 0c             	mov    0xc(%eax),%eax
		last_block = in->block_ctx->last_block;
  1185bd:	88 4d cf             	mov    %cl,-0x31(%ebp)
		opaque_ctx = in->block_ctx->opaque;
  1185c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1185c3:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1185c6:	eb 32                	jmp    1185fa <lwm2m_write_handler+0x157>
static inline size_t engine_get_opaque(struct lwm2m_input_context *in,
				       uint8_t *buf, size_t buflen,
				       struct lwm2m_opaque_context *opaque,
				       bool *last_block)
{
	if (in->reader->get_opaque) {
  1185c8:	8b 46 04             	mov    0x4(%esi),%eax
  1185cb:	8b 40 18             	mov    0x18(%eax),%eax
  1185ce:	85 c0                	test   %eax,%eax
  1185d0:	0f 84 ea 01 00 00    	je     1187c0 <lwm2m_write_handler+0x31d>
		return in->reader->get_opaque(in, buf, buflen,
  1185d6:	8d 55 db             	lea    -0x25(%ebp),%edx
  1185d9:	52                   	push   %edx
  1185da:	8d 55 ec             	lea    -0x14(%ebp),%edx
  1185dd:	52                   	push   %edx
  1185de:	ff 75 d4             	pushl  -0x2c(%ebp)
  1185e1:	53                   	push   %ebx
  1185e2:	57                   	push   %edi
  1185e3:	ff d0                	call   *%eax
  1185e5:	83 c4 14             	add    $0x14,%esp
		if (len == 0) {
  1185e8:	85 c0                	test   %eax,%eax
  1185ea:	0f 84 d0 01 00 00    	je     1187c0 <lwm2m_write_handler+0x31d>
		if (res->post_write_cb) {
  1185f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1185f3:	8b 49 08             	mov    0x8(%ecx),%ecx
  1185f6:	85 c9                	test   %ecx,%ecx
  1185f8:	75 08                	jne    118602 <lwm2m_write_handler+0x15f>
	while (!last_pkt_block && len > 0) {
  1185fa:	80 7d db 00          	cmpb   $0x0,-0x25(%ebp)
  1185fe:	74 c8                	je     1185c8 <lwm2m_write_handler+0x125>
  118600:	eb 3a                	jmp    11863c <lwm2m_write_handler+0x199>
			ret = res->post_write_cb(
  118602:	ff 75 ec             	pushl  -0x14(%ebp)
				last_pkt_block && last_block, opaque_ctx.len);
  118605:	8a 55 cf             	mov    -0x31(%ebp),%dl
  118608:	22 55 db             	and    -0x25(%ebp),%dl
  11860b:	0f b6 d2             	movzbl %dl,%edx
			ret = res->post_write_cb(
  11860e:	52                   	push   %edx
  11860f:	0f b7 c0             	movzwl %ax,%eax
  118612:	50                   	push   %eax
  118613:	8b 45 10             	mov    0x10(%ebp),%eax
  118616:	53                   	push   %ebx
  118617:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  11861b:	50                   	push   %eax
  11861c:	8b 45 0c             	mov    0xc(%ebp),%eax
  11861f:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  118623:	50                   	push   %eax
  118624:	8b 45 08             	mov    0x8(%ebp),%eax
  118627:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  11862b:	50                   	push   %eax
  11862c:	ff d1                	call   *%ecx
  11862e:	83 c4 1c             	add    $0x1c,%esp
  118631:	89 c2                	mov    %eax,%edx
			if (ret < 0) {
  118633:	85 c0                	test   %eax,%eax
  118635:	79 c3                	jns    1185fa <lwm2m_write_handler+0x157>
  118637:	e9 8b 01 00 00       	jmp    1187c7 <lwm2m_write_handler+0x324>
	if (in->block_ctx != NULL) {
  11863c:	8b 4e 10             	mov    0x10(%esi),%ecx
  11863f:	85 c9                	test   %ecx,%ecx
  118641:	74 0c                	je     11864f <lwm2m_write_handler+0x1ac>
		in->block_ctx->opaque = opaque_ctx;
  118643:	8b 45 ec             	mov    -0x14(%ebp),%eax
  118646:	8b 55 f0             	mov    -0x10(%ebp),%edx
  118649:	89 41 0c             	mov    %eax,0xc(%ecx)
  11864c:	89 51 10             	mov    %edx,0x10(%ecx)
	return opaque_ctx.len;
  11864f:	8b 55 ec             	mov    -0x14(%ebp),%edx
			if (ret < 0) {
  118652:	85 d2                	test   %edx,%edx
  118654:	0f 88 6d 01 00 00    	js     1187c7 <lwm2m_write_handler+0x324>
			len = ret;
  11865a:	89 d0                	mov    %edx,%eax
			break;
  11865c:	e9 0a 01 00 00       	jmp    11876b <lwm2m_write_handler+0x2c8>
	return in->reader->get_string(in, buf, buflen);
  118661:	8b 46 04             	mov    0x4(%esi),%eax
  118664:	ff 75 d4             	pushl  -0x2c(%ebp)
  118667:	53                   	push   %ebx
  118668:	57                   	push   %edi
  118669:	ff 50 08             	call   *0x8(%eax)
  11866c:	83 c4 0c             	add    $0xc,%esp
			len = strlen((char *)data_ptr);
  11866f:	53                   	push   %ebx
  118670:	e8 a7 36 ff ff       	call   10bd1c <strlen>
  118675:	59                   	pop    %ecx
	int ret = 0;
  118676:	31 d2                	xor    %edx,%edx
			break;
  118678:	e9 ee 00 00 00       	jmp    11876b <lwm2m_write_handler+0x2c8>
	return in->reader->get_s64(in, value);
  11867d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  118680:	8b 46 04             	mov    0x4(%esi),%eax
  118683:	52                   	push   %edx
  118684:	57                   	push   %edi
  118685:	ff 50 04             	call   *0x4(%eax)
  118688:	58                   	pop    %eax
			*(uint64_t *)data_ptr = temp64;
  118689:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11868c:	5a                   	pop    %edx
  11868d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  118690:	89 53 04             	mov    %edx,0x4(%ebx)
  118693:	89 03                	mov    %eax,(%ebx)
  118695:	eb 73                	jmp    11870a <lwm2m_write_handler+0x267>
			engine_get_s32(&msg->in, &temp32);
  118697:	8d 55 e0             	lea    -0x20(%ebp),%edx
  11869a:	89 f8                	mov    %edi,%eax
  11869c:	e8 5c c4 ff ff       	call   114afd <engine_get_s32>
			*(uint32_t *)data_ptr = temp32;
  1186a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1186a4:	89 03                	mov    %eax,(%ebx)
			break;
  1186a6:	e9 85 00 00 00       	jmp    118730 <lwm2m_write_handler+0x28d>
  1186ab:	8b 46 04             	mov    0x4(%esi),%eax
  1186ae:	53                   	push   %ebx
  1186af:	57                   	push   %edi
  1186b0:	ff 50 04             	call   *0x4(%eax)
  1186b3:	eb 53                	jmp    118708 <lwm2m_write_handler+0x265>
			engine_get_s32(&msg->in, (int32_t *)data_ptr);
  1186b5:	89 da                	mov    %ebx,%edx
  1186b7:	89 f8                	mov    %edi,%eax
  1186b9:	e8 3f c4 ff ff       	call   114afd <engine_get_s32>
			break;
  1186be:	eb 70                	jmp    118730 <lwm2m_write_handler+0x28d>
			engine_get_s32(&msg->in, &temp32);
  1186c0:	8d 55 e0             	lea    -0x20(%ebp),%edx
  1186c3:	89 f8                	mov    %edi,%eax
  1186c5:	e8 33 c4 ff ff       	call   114afd <engine_get_s32>
			*(int16_t *)data_ptr = temp32;
  1186ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1186cd:	66 89 03             	mov    %ax,(%ebx)
	int ret = 0;
  1186d0:	31 d2                	xor    %edx,%edx
			len = 2;
  1186d2:	b8 02 00 00 00       	mov    $0x2,%eax
			break;
  1186d7:	e9 8f 00 00 00       	jmp    11876b <lwm2m_write_handler+0x2c8>
			engine_get_s32(&msg->in, &temp32);
  1186dc:	8d 55 e0             	lea    -0x20(%ebp),%edx
  1186df:	89 f8                	mov    %edi,%eax
  1186e1:	e8 17 c4 ff ff       	call   114afd <engine_get_s32>
			*(int8_t *)data_ptr = temp32;
  1186e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1186e9:	88 03                	mov    %al,(%ebx)
			break;
  1186eb:	eb 0a                	jmp    1186f7 <lwm2m_write_handler+0x254>
	return in->reader->get_bool(in, value);
  1186ed:	8b 46 04             	mov    0x4(%esi),%eax
  1186f0:	53                   	push   %ebx
  1186f1:	57                   	push   %edi
  1186f2:	ff 50 14             	call   *0x14(%eax)
  1186f5:	59                   	pop    %ecx
  1186f6:	5f                   	pop    %edi
	int ret = 0;
  1186f7:	31 d2                	xor    %edx,%edx
			len = 1;
  1186f9:	b8 01 00 00 00       	mov    $0x1,%eax
  1186fe:	eb 6b                	jmp    11876b <lwm2m_write_handler+0x2c8>
	return in->reader->get_float32fix(in, value);
  118700:	8b 46 04             	mov    0x4(%esi),%eax
  118703:	53                   	push   %ebx
  118704:	57                   	push   %edi
  118705:	ff 50 0c             	call   *0xc(%eax)
  118708:	58                   	pop    %eax
  118709:	5a                   	pop    %edx
	int ret = 0;
  11870a:	31 d2                	xor    %edx,%edx
			len = sizeof(float32_value_t);
  11870c:	b8 08 00 00 00       	mov    $0x8,%eax
  118711:	eb 58                	jmp    11876b <lwm2m_write_handler+0x2c8>
	return in->reader->get_float64fix(in, value);
  118713:	8b 46 04             	mov    0x4(%esi),%eax
  118716:	53                   	push   %ebx
  118717:	57                   	push   %edi
  118718:	ff 50 10             	call   *0x10(%eax)
  11871b:	5f                   	pop    %edi
  11871c:	58                   	pop    %eax
	int ret = 0;
  11871d:	31 d2                	xor    %edx,%edx
			len = sizeof(float64_value_t);
  11871f:	b8 10 00 00 00       	mov    $0x10,%eax
  118724:	eb 45                	jmp    11876b <lwm2m_write_handler+0x2c8>
}

static inline size_t engine_get_objlnk(struct lwm2m_input_context *in,
				       struct lwm2m_objlnk *value)
{
	return in->reader->get_objlnk(in, value);
  118726:	8b 46 04             	mov    0x4(%esi),%eax
  118729:	53                   	push   %ebx
  11872a:	57                   	push   %edi
  11872b:	ff 50 1c             	call   *0x1c(%eax)
  11872e:	5a                   	pop    %edx
  11872f:	59                   	pop    %ecx
	int ret = 0;
  118730:	31 d2                	xor    %edx,%edx
			len = sizeof(struct lwm2m_objlnk);
  118732:	b8 04 00 00 00       	mov    $0x4,%eax
  118737:	eb 32                	jmp    11876b <lwm2m_write_handler+0x2c8>
			LOG_ERR("unknown obj data_type %d",
  118739:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118740:	74 22                	je     118764 <lwm2m_write_handler+0x2c1>
  118742:	b8 20 31 12 00       	mov    $0x123120,%eax
  118747:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11874c:	c1 e8 03             	shr    $0x3,%eax
  11874f:	c1 e0 06             	shl    $0x6,%eax
  118752:	83 c8 01             	or     $0x1,%eax
  118755:	50                   	push   %eax
  118756:	52                   	push   %edx
  118757:	68 c8 76 12 00       	push   $0x1276c8
  11875c:	e8 15 ae fe ff       	call   103576 <log_1>
  118761:	83 c4 0c             	add    $0xc,%esp
			return -EINVAL;
  118764:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  118769:	eb 5c                	jmp    1187c7 <lwm2m_write_handler+0x324>
	if (res->post_write_cb &&
  11876b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	res_inst->data_len = len;
  11876e:	8b 7d 10             	mov    0x10(%ebp),%edi
	if (res->post_write_cb &&
  118771:	8b 49 08             	mov    0x8(%ecx),%ecx
	res_inst->data_len = len;
  118774:	66 89 47 06          	mov    %ax,0x6(%edi)
	if (res->post_write_cb &&
  118778:	85 c9                	test   %ecx,%ecx
  11877a:	74 32                	je     1187ae <lwm2m_write_handler+0x30b>
  11877c:	8b 7d 14             	mov    0x14(%ebp),%edi
  11877f:	80 7f 03 01          	cmpb   $0x1,0x3(%edi)
  118783:	74 29                	je     1187ae <lwm2m_write_handler+0x30b>
		ret = res->post_write_cb(obj_inst->obj_inst_id,
  118785:	ff 75 d0             	pushl  -0x30(%ebp)
  118788:	0f b7 c0             	movzwl %ax,%eax
  11878b:	6a 01                	push   $0x1
  11878d:	50                   	push   %eax
  11878e:	8b 45 10             	mov    0x10(%ebp),%eax
  118791:	53                   	push   %ebx
  118792:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  118796:	50                   	push   %eax
  118797:	8b 45 0c             	mov    0xc(%ebp),%eax
  11879a:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  11879e:	50                   	push   %eax
  11879f:	8b 45 08             	mov    0x8(%ebp),%eax
  1187a2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  1187a6:	50                   	push   %eax
  1187a7:	ff d1                	call   *%ecx
  1187a9:	83 c4 1c             	add    $0x1c,%esp
  1187ac:	89 c2                	mov    %eax,%edx
	NOTIFY_OBSERVER_PATH(&msg->path);
  1187ae:	83 c6 24             	add    $0x24,%esi
  1187b1:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  1187b4:	56                   	push   %esi
  1187b5:	e8 14 cb ff ff       	call   1152ce <lwm2m_notify_observer_path>
  1187ba:	58                   	pop    %eax
	return ret;
  1187bb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  1187be:	eb 07                	jmp    1187c7 <lwm2m_write_handler+0x324>
			if (ret < 0) {
  1187c0:	31 d2                	xor    %edx,%edx
  1187c2:	e9 93 fe ff ff       	jmp    11865a <lwm2m_write_handler+0x1b7>
}
  1187c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1187ca:	89 d0                	mov    %edx,%eax
  1187cc:	5b                   	pop    %ebx
  1187cd:	5e                   	pop    %esi
  1187ce:	5f                   	pop    %edi
  1187cf:	5d                   	pop    %ebp
  1187d0:	c3                   	ret    

001187d1 <lwm2m_perform_read_op>:
{
  1187d1:	55                   	push   %ebp
  1187d2:	89 e5                	mov    %esp,%ebp
  1187d4:	57                   	push   %edi
  1187d5:	56                   	push   %esi
  1187d6:	53                   	push   %ebx
  1187d7:	83 ec 34             	sub    $0x34,%esp
  1187da:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1187dd:	8b 75 0c             	mov    0xc(%ebp),%esi
	if (msg->path.level >= 2U) {
  1187e0:	80 7b 2c 01          	cmpb   $0x1,0x2c(%ebx)
  1187e4:	76 0f                	jbe    1187f5 <lwm2m_perform_read_op+0x24>
		obj_inst = get_engine_obj_inst(msg->path.obj_id,
  1187e6:	0f b7 53 26          	movzwl 0x26(%ebx),%edx
  1187ea:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  1187ee:	e8 2f c3 ff ff       	call   114b22 <get_engine_obj_inst>
  1187f3:	eb 18                	jmp    11880d <lwm2m_perform_read_op+0x3c>
	} else if (msg->path.level == 1U) {
  1187f5:	74 0a                	je     118801 <lwm2m_perform_read_op+0x30>
		return -ENOENT;
  1187f7:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
  1187fc:	e9 51 04 00 00       	jmp    118c52 <lwm2m_perform_read_op+0x481>
		obj_inst = next_engine_obj_inst(msg->path.obj_id, -1);
  118801:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  118805:	83 ca ff             	or     $0xffffffff,%edx
  118808:	e8 41 c3 ff ff       	call   114b4e <next_engine_obj_inst>
  11880d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if (!obj_inst) {
  118810:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  118814:	74 e1                	je     1187f7 <lwm2m_perform_read_op+0x26>
	ret = coap_append_option_int(msg->out.out_cpkt,
  118816:	0f b7 f6             	movzwl %si,%esi
  118819:	56                   	push   %esi
  11881a:	6a 0c                	push   $0xc
  11881c:	ff 73 1c             	pushl  0x1c(%ebx)
  11881f:	e8 8e 00 ff ff       	call   1088b2 <coap_append_option_int>
  118824:	83 c4 0c             	add    $0xc,%esp
  118827:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
  118829:	85 c0                	test   %eax,%eax
  11882b:	79 29                	jns    118856 <lwm2m_perform_read_op+0x85>
		LOG_ERR("Error setting response content-format: %d", ret);
  11882d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118834:	0f 84 18 04 00 00    	je     118c52 <lwm2m_perform_read_op+0x481>
  11883a:	b8 20 31 12 00       	mov    $0x123120,%eax
  11883f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  118844:	c1 e8 03             	shr    $0x3,%eax
  118847:	c1 e0 06             	shl    $0x6,%eax
  11884a:	83 c8 01             	or     $0x1,%eax
  11884d:	50                   	push   %eax
  11884e:	57                   	push   %edi
  11884f:	68 69 7a 12 00       	push   $0x127a69
  118854:	eb 36                	jmp    11888c <lwm2m_perform_read_op+0xbb>
	ret = coap_packet_append_payload_marker(msg->out.out_cpkt);
  118856:	ff 73 1c             	pushl  0x1c(%ebx)
  118859:	e8 11 01 ff ff       	call   10896f <coap_packet_append_payload_marker>
  11885e:	5a                   	pop    %edx
  11885f:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
  118861:	85 c0                	test   %eax,%eax
  118863:	79 34                	jns    118899 <lwm2m_perform_read_op+0xc8>
		LOG_ERR("Error appending payload marker: %d", ret);
  118865:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  11886c:	0f 84 e0 03 00 00    	je     118c52 <lwm2m_perform_read_op+0x481>
  118872:	b8 20 31 12 00       	mov    $0x123120,%eax
  118877:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11887c:	c1 e8 03             	shr    $0x3,%eax
  11887f:	c1 e0 06             	shl    $0x6,%eax
  118882:	83 c8 01             	or     $0x1,%eax
  118885:	50                   	push   %eax
  118886:	57                   	push   %edi
  118887:	68 89 7c 12 00       	push   $0x127c89
  11888c:	e8 e5 ac fe ff       	call   103576 <log_1>
  118891:	83 c4 0c             	add    $0xc,%esp
  118894:	e9 b9 03 00 00       	jmp    118c52 <lwm2m_perform_read_op+0x481>
	memcpy(&temp_path, &msg->path, sizeof(temp_path));
  118899:	6a 0a                	push   $0xa
  11889b:	8d 73 24             	lea    0x24(%ebx),%esi
  11889e:	56                   	push   %esi
  11889f:	8d 45 ea             	lea    -0x16(%ebp),%eax
  1188a2:	50                   	push   %eax
  1188a3:	e8 44 35 ff ff       	call   10bdec <memcpy>
	engine_put_begin(&msg->out, &msg->path);
  1188a8:	8d 43 18             	lea    0x18(%ebx),%eax
	memcpy(&temp_path, &msg->path, sizeof(temp_path));
  1188ab:	83 c4 0c             	add    $0xc,%esp
	engine_put_begin(&msg->out, &msg->path);
  1188ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (out->writer->put_begin) {
  1188b1:	8b 43 18             	mov    0x18(%ebx),%eax
  1188b4:	8b 00                	mov    (%eax),%eax
  1188b6:	85 c0                	test   %eax,%eax
  1188b8:	74 08                	je     1188c2 <lwm2m_perform_read_op+0xf1>
		return out->writer->put_begin(out, path);
  1188ba:	56                   	push   %esi
  1188bb:	ff 75 e0             	pushl  -0x20(%ebp)
  1188be:	ff d0                	call   *%eax
  1188c0:	59                   	pop    %ecx
  1188c1:	58                   	pop    %eax
  1188c2:	b8 20 31 12 00       	mov    $0x123120,%eax
  1188c7:	c6 45 c7 00          	movb   $0x0,-0x39(%ebp)
  1188cb:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1188d0:	c1 e8 03             	shr    $0x3,%eax
						LOG_ERR("READ OP: %d", ret);
  1188d3:	c1 e0 06             	shl    $0x6,%eax
  1188d6:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
		if (!obj_inst->resources || obj_inst->resource_count == 0U) {
  1188da:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1188dd:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  1188e1:	0f 84 d9 02 00 00    	je     118bc0 <lwm2m_perform_read_op+0x3ef>
  1188e7:	66 83 78 0e 00       	cmpw   $0x0,0xe(%eax)
  1188ec:	0f 84 ce 02 00 00    	je     118bc0 <lwm2m_perform_read_op+0x3ef>
		msg->path.obj_inst_id = obj_inst->obj_inst_id;
  1188f2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1188f5:	8b 43 18             	mov    0x18(%ebx),%eax
		if (msg->path.level <= 1U) {
  1188f8:	80 7b 2c 01          	cmpb   $0x1,0x2c(%ebx)
		msg->path.obj_inst_id = obj_inst->obj_inst_id;
  1188fc:	8b 51 0c             	mov    0xc(%ecx),%edx
  1188ff:	66 89 53 26          	mov    %dx,0x26(%ebx)
		if (msg->path.level <= 1U) {
  118903:	77 0f                	ja     118914 <lwm2m_perform_read_op+0x143>
	if (out->writer->put_begin_oi) {
  118905:	8b 40 08             	mov    0x8(%eax),%eax
  118908:	85 c0                	test   %eax,%eax
  11890a:	74 08                	je     118914 <lwm2m_perform_read_op+0x143>
		return out->writer->put_begin_oi(out, path);
  11890c:	56                   	push   %esi
  11890d:	ff 75 e0             	pushl  -0x20(%ebp)
  118910:	ff d0                	call   *%eax
  118912:	58                   	pop    %eax
  118913:	5a                   	pop    %edx
			ret = 0;
  118914:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		for (index = 0; index < obj_inst->resource_count; index++) {
  11891b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11891e:	8a 53 2c             	mov    0x2c(%ebx),%dl
  118921:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  118925:	39 45 d0             	cmp    %eax,-0x30(%ebp)
  118928:	0f 8d 92 02 00 00    	jge    118bc0 <lwm2m_perform_read_op+0x3ef>
			if (msg->path.level > 2 &&
  11892e:	6b 45 d0 18          	imul   $0x18,-0x30(%ebp),%eax
  118932:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  118935:	03 41 08             	add    0x8(%ecx),%eax
  118938:	80 fa 02             	cmp    $0x2,%dl
  11893b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  11893e:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  118942:	76 0a                	jbe    11894e <lwm2m_perform_read_op+0x17d>
  118944:	66 3b 43 28          	cmp    0x28(%ebx),%ax
  118948:	0f 85 6a 02 00 00    	jne    118bb8 <lwm2m_perform_read_op+0x3e7>
			msg->path.res_id = res->res_id;
  11894e:	66 89 43 28          	mov    %ax,0x28(%ebx)
			obj_field = lwm2m_get_engine_obj_field(obj_inst->obj,
  118952:	50                   	push   %eax
  118953:	8b 45 dc             	mov    -0x24(%ebp),%eax
  118956:	ff 70 04             	pushl  0x4(%eax)
  118959:	e8 9f c9 ff ff       	call   1152fd <lwm2m_get_engine_obj_field>
  11895e:	5a                   	pop    %edx
  11895f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  118962:	59                   	pop    %ecx
			if (!obj_field) {
  118963:	85 c0                	test   %eax,%eax
  118965:	0f 84 40 02 00 00    	je     118bab <lwm2m_perform_read_op+0x3da>
				ret = -EPERM;
  11896b:	83 cf ff             	or     $0xffffffff,%edi
			} else if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_R)) {
  11896e:	f6 40 02 01          	testb  $0x1,0x2(%eax)
  118972:	0f 84 38 02 00 00    	je     118bb0 <lwm2m_perform_read_op+0x3df>
	if (out->writer->put_begin_r) {
  118978:	8b 43 18             	mov    0x18(%ebx),%eax
  11897b:	8b 40 10             	mov    0x10(%eax),%eax
  11897e:	85 c0                	test   %eax,%eax
  118980:	74 08                	je     11898a <lwm2m_perform_read_op+0x1b9>
		return out->writer->put_begin_r(out, path);
  118982:	56                   	push   %esi
  118983:	ff 75 e0             	pushl  -0x20(%ebp)
  118986:	ff d0                	call   *%eax
  118988:	59                   	pop    %ecx
  118989:	5f                   	pop    %edi
	loop_max = res->res_inst_count;
  11898a:	8b 45 d8             	mov    -0x28(%ebp),%eax
	size_t data_len = 0;
  11898d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	loop_max = res->res_inst_count;
  118994:	0f b6 40 16          	movzbl 0x16(%eax),%eax
  118998:	89 45 cc             	mov    %eax,-0x34(%ebp)
	if (loop_max > 1) {
  11899b:	48                   	dec    %eax
  11899c:	7e 22                	jle    1189c0 <lwm2m_perform_read_op+0x1ef>
			if (res->res_instances[i].res_inst_id !=
  11899e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1189a1:	8b 50 10             	mov    0x10(%eax),%edx
		for (i = 0; i < loop_max; i++) {
  1189a4:	31 c0                	xor    %eax,%eax
			if (res->res_instances[i].res_inst_id !=
  1189a6:	6b c8 0c             	imul   $0xc,%eax,%ecx
  1189a9:	66 83 7c 0a 08 ff    	cmpw   $0xffff,0x8(%edx,%ecx,1)
  1189af:	0f 85 7e 02 00 00    	jne    118c33 <lwm2m_perform_read_op+0x462>
		for (i = 0; i < loop_max; i++) {
  1189b5:	40                   	inc    %eax
  1189b6:	39 45 cc             	cmp    %eax,-0x34(%ebp)
  1189b9:	7f eb                	jg     1189a6 <lwm2m_perform_read_op+0x1d5>
  1189bb:	e9 99 01 00 00       	jmp    118b59 <lwm2m_perform_read_op+0x388>
	uint16_t res_inst_id_tmp = 0U;
  1189c0:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
	for (i = 0; i < loop_max; i++) {
  1189c6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  1189cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1189d0:	8b 7d c8             	mov    -0x38(%ebp),%edi
  1189d3:	39 7d cc             	cmp    %edi,-0x34(%ebp)
  1189d6:	8a 48 16             	mov    0x16(%eax),%cl
  1189d9:	0f 8e 5a 01 00 00    	jle    118b39 <lwm2m_perform_read_op+0x368>
		if (res->res_instances[i].res_inst_id ==
  1189df:	6b 55 c8 0c          	imul   $0xc,-0x38(%ebp),%edx
  1189e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1189e6:	03 50 10             	add    0x10(%eax),%edx
  1189e9:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  1189ed:	66 83 f8 ff          	cmp    $0xffff,%ax
  1189f1:	0f 84 3a 01 00 00    	je     118b31 <lwm2m_perform_read_op+0x360>
		if (res->res_inst_count > 1) {
  1189f7:	80 f9 01             	cmp    $0x1,%cl
  1189fa:	76 04                	jbe    118a00 <lwm2m_perform_read_op+0x22f>
			msg->path.res_inst_id =
  1189fc:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
		data_ptr = res->res_instances[i].data_ptr;
  118a00:	8b 3a                	mov    (%edx),%edi
		if (res->read_cb) {
  118a02:	8b 4d d8             	mov    -0x28(%ebp),%ecx
		data_len = res->res_instances[i].data_len;
  118a05:	0f b7 52 06          	movzwl 0x6(%edx),%edx
  118a09:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		if (res->read_cb) {
  118a0c:	8b 11                	mov    (%ecx),%edx
  118a0e:	85 d2                	test   %edx,%edx
  118a10:	74 1c                	je     118a2e <lwm2m_perform_read_op+0x25d>
			data_ptr = res->read_cb(obj_inst->obj_inst_id,
  118a12:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  118a15:	51                   	push   %ecx
  118a16:	50                   	push   %eax
  118a17:	8b 45 d8             	mov    -0x28(%ebp),%eax
  118a1a:	0f b7 40 14          	movzwl 0x14(%eax),%eax
  118a1e:	50                   	push   %eax
  118a1f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  118a22:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  118a26:	50                   	push   %eax
  118a27:	ff d2                	call   *%edx
  118a29:	83 c4 10             	add    $0x10,%esp
  118a2c:	89 c7                	mov    %eax,%edi
		if (!data_ptr || data_len == 0) {
  118a2e:	85 ff                	test   %edi,%edi
  118a30:	0f 84 23 01 00 00    	je     118b59 <lwm2m_perform_read_op+0x388>
  118a36:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  118a39:	85 c9                	test   %ecx,%ecx
  118a3b:	0f 84 18 01 00 00    	je     118b59 <lwm2m_perform_read_op+0x388>
		switch (obj_field->data_type) {
  118a41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  118a44:	0f b6 40 03          	movzbl 0x3(%eax),%eax
  118a48:	8d 50 ff             	lea    -0x1(%eax),%edx
  118a4b:	80 fa 0e             	cmp    $0xe,%dl
  118a4e:	0f 87 b7 00 00 00    	ja     118b0b <lwm2m_perform_read_op+0x33a>
  118a54:	0f b6 d2             	movzbl %dl,%edx
  118a57:	ff 24 95 48 45 12 00 	jmp    *0x124548(,%edx,4)
	if (out->writer->put_opaque) {
  118a5e:	8b 43 18             	mov    0x18(%ebx),%eax
  118a61:	8b 40 40             	mov    0x40(%eax),%eax
  118a64:	85 c0                	test   %eax,%eax
  118a66:	0f 84 c5 00 00 00    	je     118b31 <lwm2m_perform_read_op+0x360>
		return out->writer->put_opaque(out, path, buf, buflen);
  118a6c:	51                   	push   %ecx
  118a6d:	57                   	push   %edi
  118a6e:	56                   	push   %esi
  118a6f:	ff 75 e0             	pushl  -0x20(%ebp)
  118a72:	ff d0                	call   *%eax
  118a74:	eb 14                	jmp    118a8a <lwm2m_perform_read_op+0x2b9>
			engine_put_string(&msg->out, &msg->path,
  118a76:	57                   	push   %edi
  118a77:	e8 a0 32 ff ff       	call   10bd1c <strlen>
	return out->writer->put_string(out, path, buf, buflen);
  118a7c:	8b 53 18             	mov    0x18(%ebx),%edx
  118a7f:	89 04 24             	mov    %eax,(%esp)
  118a82:	57                   	push   %edi
  118a83:	56                   	push   %esi
  118a84:	ff 75 e0             	pushl  -0x20(%ebp)
  118a87:	ff 52 30             	call   *0x30(%edx)
  118a8a:	83 c4 10             	add    $0x10,%esp
  118a8d:	e9 9f 00 00 00       	jmp    118b31 <lwm2m_perform_read_op+0x360>
	return out->writer->put_s64(out, path, value);
  118a92:	8b 43 18             	mov    0x18(%ebx),%eax
  118a95:	ff 77 04             	pushl  0x4(%edi)
  118a98:	ff 37                	pushl  (%edi)
  118a9a:	56                   	push   %esi
  118a9b:	ff 75 e0             	pushl  -0x20(%ebp)
  118a9e:	ff 50 2c             	call   *0x2c(%eax)
  118aa1:	eb e7                	jmp    118a8a <lwm2m_perform_read_op+0x2b9>
	return out->writer->put_s32(out, path, value);
  118aa3:	8b 43 18             	mov    0x18(%ebx),%eax
  118aa6:	ff 37                	pushl  (%edi)
  118aa8:	56                   	push   %esi
  118aa9:	ff 75 e0             	pushl  -0x20(%ebp)
  118aac:	ff 50 28             	call   *0x28(%eax)
  118aaf:	eb 55                	jmp    118b06 <lwm2m_perform_read_op+0x335>
			engine_put_s16(&msg->out, &msg->path,
  118ab1:	0f bf 17             	movswl (%edi),%edx
	return out->writer->put_s16(out, path, value);
  118ab4:	8b 43 18             	mov    0x18(%ebx),%eax
  118ab7:	52                   	push   %edx
  118ab8:	56                   	push   %esi
  118ab9:	ff 75 e0             	pushl  -0x20(%ebp)
  118abc:	ff 50 24             	call   *0x24(%eax)
  118abf:	eb 45                	jmp    118b06 <lwm2m_perform_read_op+0x335>
			engine_put_s8(&msg->out, &msg->path,
  118ac1:	0f be 17             	movsbl (%edi),%edx
	return out->writer->put_s8(out, path, value);
  118ac4:	8b 43 18             	mov    0x18(%ebx),%eax
  118ac7:	52                   	push   %edx
  118ac8:	56                   	push   %esi
  118ac9:	ff 75 e0             	pushl  -0x20(%ebp)
  118acc:	ff 50 20             	call   *0x20(%eax)
  118acf:	eb 35                	jmp    118b06 <lwm2m_perform_read_op+0x335>
			engine_put_bool(&msg->out, &msg->path,
  118ad1:	0f b6 17             	movzbl (%edi),%edx
	return out->writer->put_bool(out, path, value);
  118ad4:	8b 43 18             	mov    0x18(%ebx),%eax
  118ad7:	52                   	push   %edx
  118ad8:	56                   	push   %esi
  118ad9:	ff 75 e0             	pushl  -0x20(%ebp)
  118adc:	ff 50 3c             	call   *0x3c(%eax)
  118adf:	eb 25                	jmp    118b06 <lwm2m_perform_read_op+0x335>
	return out->writer->put_float32fix(out, path, value);
  118ae1:	8b 43 18             	mov    0x18(%ebx),%eax
  118ae4:	57                   	push   %edi
  118ae5:	56                   	push   %esi
  118ae6:	ff 75 e0             	pushl  -0x20(%ebp)
  118ae9:	ff 50 34             	call   *0x34(%eax)
  118aec:	eb 18                	jmp    118b06 <lwm2m_perform_read_op+0x335>
	return out->writer->put_float64fix(out, path, value);
  118aee:	8b 43 18             	mov    0x18(%ebx),%eax
  118af1:	57                   	push   %edi
  118af2:	56                   	push   %esi
  118af3:	ff 75 e0             	pushl  -0x20(%ebp)
  118af6:	ff 50 38             	call   *0x38(%eax)
  118af9:	eb 0b                	jmp    118b06 <lwm2m_perform_read_op+0x335>
	return out->writer->put_objlnk(out, path, value);
  118afb:	8b 43 18             	mov    0x18(%ebx),%eax
  118afe:	57                   	push   %edi
  118aff:	56                   	push   %esi
  118b00:	ff 75 e0             	pushl  -0x20(%ebp)
  118b03:	ff 50 44             	call   *0x44(%eax)
  118b06:	83 c4 0c             	add    $0xc,%esp
  118b09:	eb 26                	jmp    118b31 <lwm2m_perform_read_op+0x360>
			LOG_ERR("unknown obj data_type %d",
  118b0b:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
			return -EINVAL;
  118b12:	bf ea ff ff ff       	mov    $0xffffffea,%edi
			LOG_ERR("unknown obj data_type %d",
  118b17:	74 45                	je     118b5e <lwm2m_perform_read_op+0x38d>
  118b19:	66 8b 55 c2          	mov    -0x3e(%ebp),%dx
  118b1d:	83 ca 01             	or     $0x1,%edx
  118b20:	52                   	push   %edx
  118b21:	50                   	push   %eax
  118b22:	68 c8 76 12 00       	push   $0x1276c8
  118b27:	e8 4a aa fe ff       	call   103576 <log_1>
  118b2c:	83 c4 0c             	add    $0xc,%esp
				if (ret < 0) {
  118b2f:	eb 2d                	jmp    118b5e <lwm2m_perform_read_op+0x38d>
	for (i = 0; i < loop_max; i++) {
  118b31:	ff 45 c8             	incl   -0x38(%ebp)
  118b34:	e9 94 fe ff ff       	jmp    1189cd <lwm2m_perform_read_op+0x1fc>
	if (res->res_inst_count > 1) {
  118b39:	80 f9 01             	cmp    $0x1,%cl
  118b3c:	76 50                	jbe    118b8e <lwm2m_perform_read_op+0x3bd>
	if (out->writer->put_end_ri) {
  118b3e:	8b 43 18             	mov    0x18(%ebx),%eax
  118b41:	8b 40 1c             	mov    0x1c(%eax),%eax
  118b44:	85 c0                	test   %eax,%eax
  118b46:	74 08                	je     118b50 <lwm2m_perform_read_op+0x37f>
		return out->writer->put_end_ri(out, path);
  118b48:	56                   	push   %esi
  118b49:	ff 75 e0             	pushl  -0x20(%ebp)
  118b4c:	ff d0                	call   *%eax
  118b4e:	59                   	pop    %ecx
  118b4f:	5f                   	pop    %edi
		msg->path.res_inst_id = res_inst_id_tmp;
  118b50:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  118b53:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
				if (ret < 0) {
  118b57:	eb 35                	jmp    118b8e <lwm2m_perform_read_op+0x3bd>
  118b59:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
					if (msg->path.level > 2 &&
  118b5e:	80 7b 2c 02          	cmpb   $0x2,0x2c(%ebx)
  118b62:	76 2f                	jbe    118b93 <lwm2m_perform_read_op+0x3c2>
  118b64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  118b67:	80 78 02 00          	cmpb   $0x0,0x2(%eax)
  118b6b:	78 26                	js     118b93 <lwm2m_perform_read_op+0x3c2>
						LOG_ERR("READ OP: %d", ret);
  118b6d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118b74:	74 1d                	je     118b93 <lwm2m_perform_read_op+0x3c2>
  118b76:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
  118b7a:	83 c8 01             	or     $0x1,%eax
  118b7d:	50                   	push   %eax
  118b7e:	57                   	push   %edi
  118b7f:	68 ac 7c 12 00       	push   $0x127cac
  118b84:	e8 ed a9 fe ff       	call   103576 <log_1>
  118b89:	83 c4 0c             	add    $0xc,%esp
  118b8c:	eb 05                	jmp    118b93 <lwm2m_perform_read_op+0x3c2>
					num_read += 1U;
  118b8e:	fe 45 c7             	incb   -0x39(%ebp)
  118b91:	31 ff                	xor    %edi,%edi
	if (out->writer->put_end_r) {
  118b93:	8b 43 18             	mov    0x18(%ebx),%eax
  118b96:	8b 40 14             	mov    0x14(%eax),%eax
  118b99:	85 c0                	test   %eax,%eax
  118b9b:	74 08                	je     118ba5 <lwm2m_perform_read_op+0x3d4>
		return out->writer->put_end_r(out, path);
  118b9d:	56                   	push   %esi
  118b9e:	ff 75 e0             	pushl  -0x20(%ebp)
  118ba1:	ff d0                	call   *%eax
  118ba3:	58                   	pop    %eax
  118ba4:	5a                   	pop    %edx
			if (ret < 0 && msg->path.level > 2) {
  118ba5:	85 ff                	test   %edi,%edi
  118ba7:	74 0f                	je     118bb8 <lwm2m_perform_read_op+0x3e7>
  118ba9:	eb 05                	jmp    118bb0 <lwm2m_perform_read_op+0x3df>
				ret = -ENOENT;
  118bab:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
			if (ret < 0 && msg->path.level > 2) {
  118bb0:	80 7b 2c 02          	cmpb   $0x2,0x2c(%ebx)
  118bb4:	77 0a                	ja     118bc0 <lwm2m_perform_read_op+0x3ef>
			ret = 0;
  118bb6:	31 ff                	xor    %edi,%edi
		for (index = 0; index < obj_inst->resource_count; index++) {
  118bb8:	ff 45 d0             	incl   -0x30(%ebp)
  118bbb:	e9 5b fd ff ff       	jmp    11891b <lwm2m_perform_read_op+0x14a>
		if (msg->path.level <= 1U) {
  118bc0:	80 7b 2c 01          	cmpb   $0x1,0x2c(%ebx)
  118bc4:	77 18                	ja     118bde <lwm2m_perform_read_op+0x40d>
	if (out->writer->put_end_oi) {
  118bc6:	8b 43 18             	mov    0x18(%ebx),%eax
  118bc9:	8b 40 0c             	mov    0xc(%eax),%eax
  118bcc:	85 c0                	test   %eax,%eax
  118bce:	74 22                	je     118bf2 <lwm2m_perform_read_op+0x421>
		return out->writer->put_end_oi(out, path);
  118bd0:	56                   	push   %esi
  118bd1:	ff 75 e0             	pushl  -0x20(%ebp)
  118bd4:	ff d0                	call   *%eax
  118bd6:	59                   	pop    %ecx
		if (msg->path.level <= 1U) {
  118bd7:	80 7b 2c 01          	cmpb   $0x1,0x2c(%ebx)
  118bdb:	58                   	pop    %eax
  118bdc:	76 14                	jbe    118bf2 <lwm2m_perform_read_op+0x421>
	if (out->writer->put_end) {
  118bde:	8b 43 18             	mov    0x18(%ebx),%eax
  118be1:	8b 40 04             	mov    0x4(%eax),%eax
  118be4:	85 c0                	test   %eax,%eax
  118be6:	74 27                	je     118c0f <lwm2m_perform_read_op+0x43e>
		return out->writer->put_end(out, path);
  118be8:	56                   	push   %esi
  118be9:	ff 75 e0             	pushl  -0x20(%ebp)
  118bec:	ff d0                	call   *%eax
  118bee:	58                   	pop    %eax
  118bef:	5a                   	pop    %edx
  118bf0:	eb 1d                	jmp    118c0f <lwm2m_perform_read_op+0x43e>
			obj_inst = next_engine_obj_inst(msg->path.obj_id,
  118bf2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  118bf5:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  118bf9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  118bfd:	e8 4c bf ff ff       	call   114b4e <next_engine_obj_inst>
  118c02:	89 45 dc             	mov    %eax,-0x24(%ebp)
	while (obj_inst) {
  118c05:	85 c0                	test   %eax,%eax
  118c07:	0f 85 cd fc ff ff    	jne    1188da <lwm2m_perform_read_op+0x109>
  118c0d:	eb cf                	jmp    118bde <lwm2m_perform_read_op+0x40d>
	memcpy(&msg->path, &temp_path, sizeof(temp_path));
  118c0f:	6a 0a                	push   $0xa
  118c11:	8d 45 ea             	lea    -0x16(%ebp),%eax
  118c14:	50                   	push   %eax
  118c15:	56                   	push   %esi
  118c16:	e8 d1 31 ff ff       	call   10bdec <memcpy>
  118c1b:	83 c4 0c             	add    $0xc,%esp
	if (ret == 0 && num_read == 0U && msg->path.level == 3U) {
  118c1e:	85 ff                	test   %edi,%edi
  118c20:	75 30                	jne    118c52 <lwm2m_perform_read_op+0x481>
  118c22:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  118c26:	75 2a                	jne    118c52 <lwm2m_perform_read_op+0x481>
  118c28:	80 7b 2c 03          	cmpb   $0x3,0x2c(%ebx)
  118c2c:	75 24                	jne    118c52 <lwm2m_perform_read_op+0x481>
  118c2e:	e9 c4 fb ff ff       	jmp    1187f7 <lwm2m_perform_read_op+0x26>
	if (out->writer->put_begin_ri) {
  118c33:	8b 43 18             	mov    0x18(%ebx),%eax
  118c36:	8b 40 18             	mov    0x18(%eax),%eax
  118c39:	85 c0                	test   %eax,%eax
  118c3b:	74 08                	je     118c45 <lwm2m_perform_read_op+0x474>
		return out->writer->put_begin_ri(out, path);
  118c3d:	56                   	push   %esi
  118c3e:	ff 75 e0             	pushl  -0x20(%ebp)
  118c41:	ff d0                	call   *%eax
  118c43:	58                   	pop    %eax
  118c44:	5a                   	pop    %edx
		res_inst_id_tmp = msg->path.res_inst_id;
  118c45:	66 8b 43 2a          	mov    0x2a(%ebx),%ax
  118c49:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
  118c4d:	e9 74 fd ff ff       	jmp    1189c6 <lwm2m_perform_read_op+0x1f5>
}
  118c52:	8d 65 f4             	lea    -0xc(%ebp),%esp
  118c55:	89 f8                	mov    %edi,%eax
  118c57:	5b                   	pop    %ebx
  118c58:	5e                   	pop    %esi
  118c59:	5f                   	pop    %edi
  118c5a:	5d                   	pop    %ebp
  118c5b:	c3                   	ret    

00118c5c <lwm2m_get_or_create_engine_obj>:
{
  118c5c:	55                   	push   %ebp
  118c5d:	89 e5                	mov    %esp,%ebp
  118c5f:	57                   	push   %edi
  118c60:	56                   	push   %esi
  118c61:	53                   	push   %ebx
  118c62:	50                   	push   %eax
  118c63:	8b 5d 10             	mov    0x10(%ebp),%ebx
  118c66:	8b 75 08             	mov    0x8(%ebp),%esi
	if (created) {
  118c69:	85 db                	test   %ebx,%ebx
  118c6b:	74 03                	je     118c70 <lwm2m_get_or_create_engine_obj+0x14>
		*created = 0U;
  118c6d:	c6 03 00             	movb   $0x0,(%ebx)
	*obj_inst = get_engine_obj_inst(msg->path.obj_id,
  118c70:	0f b7 7e 24          	movzwl 0x24(%esi),%edi
  118c74:	0f b7 56 26          	movzwl 0x26(%esi),%edx
  118c78:	89 f8                	mov    %edi,%eax
  118c7a:	e8 a3 be ff ff       	call   114b22 <get_engine_obj_inst>
  118c7f:	89 c1                	mov    %eax,%ecx
  118c81:	8b 45 0c             	mov    0xc(%ebp),%eax
  118c84:	89 08                	mov    %ecx,(%eax)
	int ret = 0;
  118c86:	31 c0                	xor    %eax,%eax
	if (!*obj_inst) {
  118c88:	85 c9                	test   %ecx,%ecx
  118c8a:	75 2e                	jne    118cba <lwm2m_get_or_create_engine_obj+0x5e>
		ret = lwm2m_create_obj_inst(msg->path.obj_id,
  118c8c:	ff 75 0c             	pushl  0xc(%ebp)
  118c8f:	52                   	push   %edx
  118c90:	57                   	push   %edi
  118c91:	e8 7b ce ff ff       	call   115b11 <lwm2m_create_obj_inst>
  118c96:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
  118c99:	85 c0                	test   %eax,%eax
  118c9b:	78 1d                	js     118cba <lwm2m_get_or_create_engine_obj+0x5e>
		if (created) {
  118c9d:	85 db                	test   %ebx,%ebx
  118c9f:	74 03                	je     118ca4 <lwm2m_get_or_create_engine_obj+0x48>
			*created = 1U;
  118ca1:	c6 03 01             	movb   $0x1,(%ebx)
		if (!msg->ctx->bootstrap_mode) {
  118ca4:	8b 16                	mov    (%esi),%edx
  118ca6:	80 ba 58 01 00 00 00 	cmpb   $0x0,0x158(%edx)
  118cad:	75 0b                	jne    118cba <lwm2m_get_or_create_engine_obj+0x5e>
  118caf:	89 45 f0             	mov    %eax,-0x10(%ebp)
			engine_trigger_update();
  118cb2:	e8 65 4a 00 00       	call   11d71c <engine_trigger_update>
  118cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  118cba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  118cbd:	5b                   	pop    %ebx
  118cbe:	5e                   	pop    %esi
  118cbf:	5f                   	pop    %edi
  118cc0:	5d                   	pop    %ebp
  118cc1:	c3                   	ret    

00118cc2 <engine_next_service_timeout_ms>:
{
  118cc2:	55                   	push   %ebp
  118cc3:	89 e5                	mov    %esp,%ebp
  118cc5:	57                   	push   %edi
  118cc6:	56                   	push   %esi
  118cc7:	53                   	push   %ebx
  118cc8:	83 ec 0c             	sub    $0xc,%esp
  118ccb:	8b 45 08             	mov    0x8(%ebp),%eax
  118cce:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint64_t time_left_ms, timestamp = k_uptime_get();
  118cd1:	e8 6c bf ff ff       	call   114c42 <k_uptime_get>
  118cd6:	89 d1                	mov    %edx,%ecx
  118cd8:	89 c2                	mov    %eax,%edx
	return list->head;
  118cda:	a1 9c ec 12 00       	mov    0x12ec9c,%eax
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_service_list, srv, node) {
  118cdf:	85 c0                	test   %eax,%eax
  118ce1:	74 35                	je     118d18 <engine_next_service_timeout_ms+0x56>
		time_left_ms = srv->last_timestamp + srv->min_call_period;
  118ce3:	8b 70 08             	mov    0x8(%eax),%esi
  118ce6:	31 ff                	xor    %edi,%edi
  118ce8:	03 70 0c             	add    0xc(%eax),%esi
  118ceb:	13 78 10             	adc    0x10(%eax),%edi
		if (time_left_ms < timestamp) {
  118cee:	39 d6                	cmp    %edx,%esi
  118cf0:	89 fb                	mov    %edi,%ebx
  118cf2:	19 cb                	sbb    %ecx,%ebx
  118cf4:	72 27                	jb     118d1d <engine_next_service_timeout_ms+0x5b>
		time_left_ms -= timestamp;
  118cf6:	29 d6                	sub    %edx,%esi
		if (time_left_ms < timeout) {
  118cf8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		time_left_ms -= timestamp;
  118cfb:	19 cf                	sbb    %ecx,%edi
		if (time_left_ms < timeout) {
  118cfd:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  118d00:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  118d03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  118d0a:	89 fb                	mov    %edi,%ebx
  118d0c:	1b 5d ec             	sbb    -0x14(%ebp),%ebx
  118d0f:	73 03                	jae    118d14 <engine_next_service_timeout_ms+0x52>
			timeout = time_left_ms;
  118d11:	89 75 f0             	mov    %esi,-0x10(%ebp)
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  118d14:	8b 00                	mov    (%eax),%eax
	return node->next;
  118d16:	eb c7                	jmp    118cdf <engine_next_service_timeout_ms+0x1d>
	return timeout;
  118d18:	8b 45 f0             	mov    -0x10(%ebp),%eax
  118d1b:	eb 02                	jmp    118d1f <engine_next_service_timeout_ms+0x5d>
			return 0;
  118d1d:	31 c0                	xor    %eax,%eax
}
  118d1f:	83 c4 0c             	add    $0xc,%esp
  118d22:	5b                   	pop    %ebx
  118d23:	5e                   	pop    %esi
  118d24:	5f                   	pop    %edi
  118d25:	5d                   	pop    %ebp
  118d26:	c3                   	ret    

00118d27 <lwm2m_engine_service>:
{
  118d27:	55                   	push   %ebp
  118d28:	89 e5                	mov    %esp,%ebp
  118d2a:	57                   	push   %edi
  118d2b:	56                   	push   %esi
  118d2c:	53                   	push   %ebx
  118d2d:	83 ec 08             	sub    $0x8,%esp
	timestamp = k_uptime_get();
  118d30:	e8 0d bf ff ff       	call   114c42 <k_uptime_get>
  118d35:	8b 1d a4 ec 12 00    	mov    0x12eca4,%ebx
  118d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  118d3e:	89 55 ec             	mov    %edx,-0x14(%ebp)
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_observer_list, obs, node) {
  118d41:	85 db                	test   %ebx,%ebx
  118d43:	74 54                	je     118d99 <lwm2m_engine_service+0x72>
		if (obs->event_timestamp > obs->last_timestamp &&
  118d45:	8b 73 24             	mov    0x24(%ebx),%esi
  118d48:	8b 7b 28             	mov    0x28(%ebx),%edi
  118d4b:	3b 73 1c             	cmp    0x1c(%ebx),%esi
  118d4e:	89 f8                	mov    %edi,%eax
  118d50:	1b 43 20             	sbb    0x20(%ebx),%eax
  118d53:	7d 17                	jge    118d6c <lwm2m_engine_service+0x45>
				MSEC_PER_SEC * obs->min_period_sec) {
  118d55:	69 43 2c e8 03 00 00 	imul   $0x3e8,0x2c(%ebx),%eax
  118d5c:	31 d2                	xor    %edx,%edx
		    timestamp > obs->last_timestamp +
  118d5e:	01 f0                	add    %esi,%eax
  118d60:	11 fa                	adc    %edi,%edx
		if (obs->event_timestamp > obs->last_timestamp &&
  118d62:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  118d65:	89 d0                	mov    %edx,%eax
  118d67:	1b 45 ec             	sbb    -0x14(%ebp),%eax
  118d6a:	7c 17                	jl     118d83 <lwm2m_engine_service+0x5c>
				MSEC_PER_SEC * obs->max_period_sec) {
  118d6c:	69 43 30 e8 03 00 00 	imul   $0x3e8,0x30(%ebx),%eax
  118d73:	31 d2                	xor    %edx,%edx
		} else if (timestamp > obs->last_timestamp +
  118d75:	01 f0                	add    %esi,%eax
  118d77:	11 fa                	adc    %edi,%edx
  118d79:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  118d7c:	89 d0                	mov    %edx,%eax
  118d7e:	1b 45 ec             	sbb    -0x14(%ebp),%eax
  118d81:	7d 12                	jge    118d95 <lwm2m_engine_service+0x6e>
			obs->last_timestamp = k_uptime_get();
  118d83:	e8 ba be ff ff       	call   114c42 <k_uptime_get>
  118d88:	89 43 24             	mov    %eax,0x24(%ebx)
  118d8b:	89 53 28             	mov    %edx,0x28(%ebx)
			generate_notify_message(obs, false);
  118d8e:	89 d8                	mov    %ebx,%eax
  118d90:	e8 17 f0 ff ff       	call   117dac <generate_notify_message.constprop.0>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  118d95:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  118d97:	eb a8                	jmp    118d41 <lwm2m_engine_service+0x1a>
	timestamp = k_uptime_get();
  118d99:	e8 a4 be ff ff       	call   114c42 <k_uptime_get>
  118d9e:	8b 1d 9c ec 12 00    	mov    0x12ec9c,%ebx
  118da4:	89 c6                	mov    %eax,%esi
  118da6:	89 d7                	mov    %edx,%edi
	SYS_SLIST_FOR_EACH_CONTAINER(&engine_service_list, srv, node) {
  118da8:	85 db                	test   %ebx,%ebx
  118daa:	74 28                	je     118dd4 <lwm2m_engine_service+0xad>
					srv->min_call_period;
  118dac:	8b 43 08             	mov    0x8(%ebx),%eax
  118daf:	31 d2                	xor    %edx,%edx
		service_due_timestamp = srv->last_timestamp +
  118db1:	03 43 0c             	add    0xc(%ebx),%eax
		if (timestamp >= service_due_timestamp) {
  118db4:	89 f9                	mov    %edi,%ecx
		service_due_timestamp = srv->last_timestamp +
  118db6:	13 53 10             	adc    0x10(%ebx),%edx
		if (timestamp >= service_due_timestamp) {
  118db9:	39 c6                	cmp    %eax,%esi
  118dbb:	19 d1                	sbb    %edx,%ecx
  118dbd:	7c 11                	jl     118dd0 <lwm2m_engine_service+0xa9>
			srv->last_timestamp = k_uptime_get();
  118dbf:	e8 7e be ff ff       	call   114c42 <k_uptime_get>
  118dc4:	89 43 0c             	mov    %eax,0xc(%ebx)
  118dc7:	89 53 10             	mov    %edx,0x10(%ebx)
			srv->service_work(NULL);
  118dca:	6a 00                	push   $0x0
  118dcc:	ff 53 04             	call   *0x4(%ebx)
  118dcf:	59                   	pop    %ecx
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  118dd0:	8b 1b                	mov    (%ebx),%ebx
	return node->next;
  118dd2:	eb d4                	jmp    118da8 <lwm2m_engine_service+0x81>
	return engine_next_service_timeout_ms(ENGINE_UPDATE_INTERVAL_MS);
  118dd4:	68 f4 01 00 00       	push   $0x1f4
  118dd9:	e8 e4 fe ff ff       	call   118cc2 <engine_next_service_timeout_ms>
  118dde:	5a                   	pop    %edx
}
  118ddf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  118de2:	5b                   	pop    %ebx
  118de3:	5e                   	pop    %esi
  118de4:	5f                   	pop    %edi
  118de5:	5d                   	pop    %ebp
  118de6:	c3                   	ret    

00118de7 <socket_receive_loop>:
{
  118de7:	55                   	push   %ebp
  118de8:	b8 20 31 12 00       	mov    $0x123120,%eax
  118ded:	89 e5                	mov    %esp,%ebp
  118def:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  118df4:	c1 e8 03             	shr    $0x3,%eax
  118df7:	57                   	push   %edi
			LOG_ERR("Err sending response: %d", r);
  118df8:	c1 e0 06             	shl    $0x6,%eax
{
  118dfb:	56                   	push   %esi
  118dfc:	53                   	push   %ebx
  118dfd:	83 ec 28             	sub    $0x28,%esp
			LOG_ERR("Err sending response: %d", r);
  118e00:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
		if (sock_nfds < 1) {
  118e04:	83 3d 74 ec 12 00 00 	cmpl   $0x0,0x12ec74
  118e0b:	7f 24                	jg     118e31 <socket_receive_loop+0x4a>
			k_msleep(lwm2m_engine_service());
  118e0d:	e8 15 ff ff ff       	call   118d27 <lwm2m_engine_service>
	return k_sleep(Z_TIMEOUT_MS(ms));
  118e12:	85 c0                	test   %eax,%eax
  118e14:	79 02                	jns    118e18 <socket_receive_loop+0x31>
  118e16:	31 c0                	xor    %eax,%eax
  118e18:	6a 00                	push   $0x0
  118e1a:	99                   	cltd   
		t += off;
  118e1b:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  118e1e:	6a 0a                	push   $0xa
		t += off;
  118e20:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  118e23:	52                   	push   %edx
  118e24:	50                   	push   %eax
  118e25:	e8 f6 73 fe ff       	call   100220 <__udivdi3>
  118e2a:	83 c4 10             	add    $0x10,%esp
	return z_impl_k_sleep(timeout);
  118e2d:	52                   	push   %edx
  118e2e:	50                   	push   %eax
  118e2f:	eb 54                	jmp    118e85 <socket_receive_loop+0x9e>
		if (poll(sock_fds, sock_nfds, lwm2m_engine_service()) < 0) {
  118e31:	e8 f1 fe ff ff       	call   118d27 <lwm2m_engine_service>
  118e36:	8b 15 74 ec 12 00    	mov    0x12ec74,%edx
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&fds, *(uintptr_t *)&nfds, *(uintptr_t *)&timeout, K_SYSCALL_ZSOCK_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_poll(fds, nfds, timeout);
  118e3c:	50                   	push   %eax
		for (i = 0; i < sock_nfds; i++) {
  118e3d:	31 db                	xor    %ebx,%ebx
  118e3f:	52                   	push   %edx
  118e40:	68 78 ec 12 00       	push   $0x12ec78
  118e45:	e8 5c 10 ff ff       	call   109ea6 <z_impl_zsock_poll>
  118e4a:	83 c4 0c             	add    $0xc,%esp
		if (poll(sock_fds, sock_nfds, lwm2m_engine_service()) < 0) {
  118e4d:	85 c0                	test   %eax,%eax
  118e4f:	79 71                	jns    118ec2 <socket_receive_loop+0xdb>
			LOG_ERR("Error in poll:%d", errno);
  118e51:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118e58:	74 1c                	je     118e76 <socket_receive_loop+0x8f>
  118e5a:	66 8b 5d d6          	mov    -0x2a(%ebp),%bx
  118e5e:	e8 b0 be ff ff       	call   114d13 <z_errno>
  118e63:	83 cb 01             	or     $0x1,%ebx
  118e66:	53                   	push   %ebx
  118e67:	ff 30                	pushl  (%eax)
  118e69:	68 b8 7c 12 00       	push   $0x127cb8
  118e6e:	e8 03 a7 fe ff       	call   103576 <log_1>
  118e73:	83 c4 0c             	add    $0xc,%esp
			errno = 0;
  118e76:	e8 98 be ff ff       	call   114d13 <z_errno>
  118e7b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  118e81:	6a 00                	push   $0x0
  118e83:	6a 32                	push   $0x32
  118e85:	e8 89 89 00 00       	call   121813 <z_impl_k_sleep>
  118e8a:	5b                   	pop    %ebx
  118e8b:	5e                   	pop    %esi
			continue;
  118e8c:	e9 73 ff ff ff       	jmp    118e04 <socket_receive_loop+0x1d>
			if ((sock_fds[i].revents & POLLERR) ||
  118e91:	0f bf 04 dd 7e ec 12 	movswl 0x12ec7e(,%ebx,8),%eax
  118e98:	00 
			    (sock_fds[i].revents & POLLNVAL) ||
  118e99:	a8 38                	test   $0x38,%al
  118e9b:	74 32                	je     118ecf <socket_receive_loop+0xe8>
				LOG_ERR("Poll reported a socket error, %02x.",
  118e9d:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118ea4:	74 16                	je     118ebc <socket_receive_loop+0xd5>
  118ea6:	66 8b 55 d6          	mov    -0x2a(%ebp),%dx
  118eaa:	83 ca 01             	or     $0x1,%edx
  118ead:	52                   	push   %edx
  118eae:	50                   	push   %eax
  118eaf:	68 c9 7c 12 00       	push   $0x127cc9
  118eb4:	e8 bd a6 fe ff       	call   103576 <log_1>
  118eb9:	83 c4 0c             	add    $0xc,%esp
				engine_trigger_restart();
  118ebc:	e8 32 48 00 00       	call   11d6f3 <engine_trigger_restart>
		for (i = 0; i < sock_nfds; i++) {
  118ec1:	43                   	inc    %ebx
  118ec2:	3b 1d 74 ec 12 00    	cmp    0x12ec74,%ebx
  118ec8:	7c c7                	jl     118e91 <socket_receive_loop+0xaa>
  118eca:	e9 35 ff ff ff       	jmp    118e04 <socket_receive_loop+0x1d>
			if (!(sock_fds[i].revents & POLLIN) ||
  118ecf:	a8 01                	test   $0x1,%al
  118ed1:	74 0b                	je     118ede <socket_receive_loop+0xf7>
			    sock_ctx[i] == NULL) {
  118ed3:	8b 04 9d 90 ec 12 00 	mov    0x12ec90(,%ebx,4),%eax
			if (!(sock_fds[i].revents & POLLIN) ||
  118eda:	85 c0                	test   %eax,%eax
  118edc:	75 0c                	jne    118eea <socket_receive_loop+0x103>
				sock_fds[i].revents = 0;
  118ede:	66 c7 04 dd 7e ec 12 	movw   $0x0,0x12ec7e(,%ebx,8)
  118ee5:	00 00 00 
				continue;
  118ee8:	eb d7                	jmp    118ec1 <socket_receive_loop+0xda>
			from_addr_len = sizeof(from_addr);
  118eea:	c7 45 d8 08 00 00 00 	movl   $0x8,-0x28(%ebp)
			sock_fds[i].revents = 0;
  118ef1:	66 c7 04 dd 7e ec 12 	movw   $0x0,0x12ec7e(,%ebx,8)
  118ef8:	00 00 00 
			len = recvfrom(sock_ctx[i]->sock_fd, in_buf,
  118efb:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
  118f01:	8d 55 d8             	lea    -0x28(%ebp),%edx
  118f04:	52                   	push   %edx
  118f05:	68 6c ec 12 00       	push   $0x12ec6c
  118f0a:	6a 00                	push   $0x0
  118f0c:	68 ff 04 00 00       	push   $0x4ff
  118f11:	68 c0 af 12 00       	push   $0x12afc0
  118f16:	50                   	push   %eax
  118f17:	e8 46 0f ff ff       	call   109e62 <z_impl_zsock_recvfrom>
  118f1c:	83 c4 18             	add    $0x18,%esp
			if (len < 0) {
  118f1f:	85 c0                	test   %eax,%eax
  118f21:	79 22                	jns    118f45 <socket_receive_loop+0x15e>
				LOG_ERR("Error reading response: %d", errno);
  118f23:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118f2a:	74 90                	je     118ebc <socket_receive_loop+0xd5>
  118f2c:	66 8b 75 d6          	mov    -0x2a(%ebp),%si
  118f30:	e8 de bd ff ff       	call   114d13 <z_errno>
  118f35:	83 ce 01             	or     $0x1,%esi
  118f38:	56                   	push   %esi
  118f39:	ff 30                	pushl  (%eax)
  118f3b:	68 ed 7c 12 00       	push   $0x127ced
  118f40:	e9 6f ff ff ff       	jmp    118eb4 <socket_receive_loop+0xcd>
			if (len == 0) {
  118f45:	75 1f                	jne    118f66 <socket_receive_loop+0x17f>
				LOG_ERR("Zero length recv");
  118f47:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118f4e:	0f 84 6d ff ff ff    	je     118ec1 <socket_receive_loop+0xda>
  118f54:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
  118f58:	83 c8 01             	or     $0x1,%eax
  118f5b:	50                   	push   %eax
  118f5c:	68 08 7d 12 00       	push   $0x127d08
  118f61:	e9 4e 01 00 00       	jmp    1190b4 <socket_receive_loop+0x2cd>
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
  118f66:	6a 00                	push   $0x0
			in_buf[len] = 0U;
  118f68:	c6 80 c0 af 12 00 00 	movb   $0x0,0x12afc0(%eax)
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
  118f6f:	6a 00                	push   $0x0
  118f71:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  118f74:	0f b7 c0             	movzwl %ax,%eax
  118f77:	50                   	push   %eax
			lwm2m_udp_receive(sock_ctx[i], in_buf, len, &from_addr,
  118f78:	8b 3c 9d 90 ec 12 00 	mov    0x12ec90(,%ebx,4),%edi
	r = coap_packet_parse(&response, buf, buf_len, NULL, 0);
  118f7f:	68 c0 af 12 00       	push   $0x12afc0
  118f84:	56                   	push   %esi
  118f85:	e8 1c fa fe ff       	call   1089a6 <coap_packet_parse>
  118f8a:	83 c4 14             	add    $0x14,%esp
	if (r < 0) {
  118f8d:	85 c0                	test   %eax,%eax
  118f8f:	79 28                	jns    118fb9 <socket_receive_loop+0x1d2>
		LOG_ERR("Invalid data received (err:%d)", r);
  118f91:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  118f98:	0f 84 23 ff ff ff    	je     118ec1 <socket_receive_loop+0xda>
  118f9e:	66 8b 55 d6          	mov    -0x2a(%ebp),%dx
  118fa2:	83 ca 01             	or     $0x1,%edx
  118fa5:	52                   	push   %edx
  118fa6:	50                   	push   %eax
  118fa7:	68 19 7d 12 00       	push   $0x127d19
  118fac:	e8 c5 a5 fe ff       	call   103576 <log_1>
  118fb1:	83 c4 0c             	add    $0xc,%esp
  118fb4:	e9 08 ff ff ff       	jmp    118ec1 <socket_receive_loop+0xda>
	tkl = coap_header_get_token(&response, token);
  118fb9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  118fbc:	50                   	push   %eax
  118fbd:	56                   	push   %esi
  118fbe:	e8 7d fb fe ff       	call   108b40 <coap_header_get_token>
  118fc3:	5a                   	pop    %edx
  118fc4:	88 45 d0             	mov    %al,-0x30(%ebp)
  118fc7:	59                   	pop    %ecx
	pending = coap_pending_received(&response, client_ctx->pendings,
  118fc8:	8d 47 08             	lea    0x8(%edi),%eax
  118fcb:	6a 05                	push   $0x5
  118fcd:	50                   	push   %eax
  118fce:	56                   	push   %esi
  118fcf:	e8 4c ff fe ff       	call   108f20 <coap_pending_received>
  118fd4:	83 c4 0c             	add    $0xc,%esp
	struct lwm2m_message *msg = NULL;
  118fd7:	31 d2                	xor    %edx,%edx
	pending = coap_pending_received(&response, client_ctx->pendings,
  118fd9:	89 c6                	mov    %eax,%esi
	if (pending) {
  118fdb:	85 c0                	test   %eax,%eax
  118fdd:	74 07                	je     118fe6 <socket_receive_loop+0x1ff>
		msg = find_msg(pending, NULL);
  118fdf:	e8 8b bd ff ff       	call   114d6f <find_msg>
  118fe4:	89 c2                	mov    %eax,%edx
	reply = coap_response_received(&response, from_addr,
  118fe6:	6a 05                	push   $0x5
				       client_ctx->replies,
  118fe8:	8d 87 94 00 00 00    	lea    0x94(%edi),%eax
	reply = coap_response_received(&response, from_addr,
  118fee:	50                   	push   %eax
  118fef:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  118ff2:	68 6c ec 12 00       	push   $0x12ec6c
  118ff7:	89 55 cc             	mov    %edx,-0x34(%ebp)
  118ffa:	50                   	push   %eax
  118ffb:	e8 05 00 ff ff       	call   109005 <coap_response_received>
  119000:	83 c4 10             	add    $0x10,%esp
  119003:	89 c1                	mov    %eax,%ecx
	if (reply) {
  119005:	85 c0                	test   %eax,%eax
  119007:	8b 55 cc             	mov    -0x34(%ebp),%edx
  11900a:	74 45                	je     119051 <socket_receive_loop+0x26a>
		if (client_ctx->handle_separate_response && !tkl &&
  11900c:	80 7d d0 00          	cmpb   $0x0,-0x30(%ebp)
  119010:	75 09                	jne    11901b <socket_receive_loop+0x234>
  119012:	80 bf 59 01 00 00 00 	cmpb   $0x0,0x159(%edi)
  119019:	75 17                	jne    119032 <socket_receive_loop+0x24b>
		if (!msg) {
  11901b:	85 d2                	test   %edx,%edx
  11901d:	75 32                	jne    119051 <socket_receive_loop+0x26a>
			msg = find_msg(pending, reply);
  11901f:	89 ca                	mov    %ecx,%edx
  119021:	89 f0                	mov    %esi,%eax
  119023:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  119026:	e8 44 bd ff ff       	call   114d6f <find_msg>
  11902b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  11902e:	89 c2                	mov    %eax,%edx
  119030:	eb 1f                	jmp    119051 <socket_receive_loop+0x26a>
  119032:	89 45 d0             	mov    %eax,-0x30(%ebp)
			coap_header_get_type(&response) == COAP_TYPE_ACK) {
  119035:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  119038:	89 55 cc             	mov    %edx,-0x34(%ebp)
  11903b:	50                   	push   %eax
  11903c:	e8 e2 fa fe ff       	call   108b23 <coap_header_get_type>
  119041:	59                   	pop    %ecx
		if (client_ctx->handle_separate_response && !tkl &&
  119042:	3c 02                	cmp    $0x2,%al
  119044:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  119047:	8b 55 cc             	mov    -0x34(%ebp),%edx
  11904a:	75 cf                	jne    11901b <socket_receive_loop+0x234>
  11904c:	e9 70 fe ff ff       	jmp    118ec1 <socket_receive_loop+0xda>
	if (reply || pending) {
  119051:	09 ce                	or     %ecx,%esi
  119053:	74 26                	je     11907b <socket_receive_loop+0x294>
		if (reply && reply->user_data != COAP_REPLY_STATUS_NONE) {
  119055:	85 c9                	test   %ecx,%ecx
  119057:	74 12                	je     11906b <socket_receive_loop+0x284>
  119059:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
  11905d:	74 0c                	je     11906b <socket_receive_loop+0x284>
			reply->user_data = (void *)COAP_REPLY_STATUS_NONE;
  11905f:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
			return;
  119066:	e9 56 fe ff ff       	jmp    118ec1 <socket_receive_loop+0xda>
		if (msg) {
  11906b:	85 d2                	test   %edx,%edx
  11906d:	0f 84 4e fe ff ff    	je     118ec1 <socket_receive_loop+0xda>
			lwm2m_reset_message(msg, true);
  119073:	6a 01                	push   $0x1
  119075:	52                   	push   %edx
  119076:	e9 ad 00 00 00       	jmp    119128 <socket_receive_loop+0x341>
	    coap_header_get_type(&response) == COAP_TYPE_CON) {
  11907b:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  11907e:	56                   	push   %esi
  11907f:	e8 9f fa fe ff       	call   108b23 <coap_header_get_type>
  119084:	5a                   	pop    %edx
	if (udp_request_handler &&
  119085:	84 c0                	test   %al,%al
  119087:	0f 85 34 fe ff ff    	jne    118ec1 <socket_receive_loop+0xda>
		msg = lwm2m_get_message(client_ctx);
  11908d:	57                   	push   %edi
  11908e:	e8 05 cc ff ff       	call   115c98 <lwm2m_get_message>
  119093:	59                   	pop    %ecx
  119094:	89 c7                	mov    %eax,%edi
		if (!msg) {
  119096:	85 c0                	test   %eax,%eax
  119098:	75 21                	jne    1190bb <socket_receive_loop+0x2d4>
			LOG_ERR("Unable to get a lwm2m message!");
  11909a:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  1190a1:	0f 84 1a fe ff ff    	je     118ec1 <socket_receive_loop+0xda>
  1190a7:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
  1190ab:	83 c8 01             	or     $0x1,%eax
  1190ae:	50                   	push   %eax
  1190af:	68 a1 7b 12 00       	push   $0x127ba1
  1190b4:	e8 94 a4 fe ff       	call   10354d <log_0>
  1190b9:	eb 72                	jmp    11912d <socket_receive_loop+0x346>
		msg->type = COAP_TYPE_ACK;
  1190bb:	c6 80 86 02 00 00 02 	movb   $0x2,0x286(%eax)
		msg->code = coap_header_get_code(&response);
  1190c2:	56                   	push   %esi
  1190c3:	e8 ac fa fe ff       	call   108b74 <coap_header_get_code>
  1190c8:	88 87 87 02 00 00    	mov    %al,0x287(%edi)
		msg->mid = coap_header_get_id(&response);
  1190ce:	89 34 24             	mov    %esi,(%esp)
  1190d1:	e8 fe fa fe ff       	call   108bd4 <coap_header_get_id>
		msg->tkl = 0;
  1190d6:	c6 87 88 02 00 00 00 	movb   $0x0,0x288(%edi)
		msg->mid = coap_header_get_id(&response);
  1190dd:	66 89 87 84 02 00 00 	mov    %ax,0x284(%edi)
		r = udp_request_handler(&response, msg);
  1190e4:	89 3c 24             	mov    %edi,(%esp)
  1190e7:	56                   	push   %esi
  1190e8:	e8 fa cf ff ff       	call   1160e7 <handle_request>
  1190ed:	5e                   	pop    %esi
		if (r < 0) {
  1190ee:	85 c0                	test   %eax,%eax
		r = udp_request_handler(&response, msg);
  1190f0:	5a                   	pop    %edx
		if (r < 0) {
  1190f1:	0f 88 ca fd ff ff    	js     118ec1 <socket_receive_loop+0xda>
		r = lwm2m_send_message(msg);
  1190f7:	57                   	push   %edi
  1190f8:	e8 3b eb ff ff       	call   117c38 <lwm2m_send_message>
  1190fd:	59                   	pop    %ecx
		if (r < 0) {
  1190fe:	85 c0                	test   %eax,%eax
  119100:	0f 89 bb fd ff ff    	jns    118ec1 <socket_receive_loop+0xda>
			LOG_ERR("Err sending response: %d", r);
  119106:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  11910d:	74 16                	je     119125 <socket_receive_loop+0x33e>
  11910f:	66 8b 55 d6          	mov    -0x2a(%ebp),%dx
  119113:	83 ca 01             	or     $0x1,%edx
  119116:	52                   	push   %edx
  119117:	50                   	push   %eax
  119118:	68 38 7d 12 00       	push   $0x127d38
  11911d:	e8 54 a4 fe ff       	call   103576 <log_1>
  119122:	83 c4 0c             	add    $0xc,%esp
			lwm2m_reset_message(msg, true);
  119125:	6a 01                	push   $0x1
  119127:	57                   	push   %edi
  119128:	e8 99 cb ff ff       	call   115cc6 <lwm2m_reset_message>
  11912d:	58                   	pop    %eax
  11912e:	5a                   	pop    %edx
		LOG_DBG("No handler for response");
  11912f:	e9 8d fd ff ff       	jmp    118ec1 <socket_receive_loop+0xda>

00119134 <lwm2m_engine_add_service>:
	for (i = 0; i < MAX_PERIODIC_SERVICE; i++) {
  119134:	31 c0                	xor    %eax,%eax
		if (!service_node_data[i].service_work) {
  119136:	6b d0 14             	imul   $0x14,%eax,%edx
  119139:	83 ba c4 d0 12 00 00 	cmpl   $0x0,0x12d0c4(%edx)
  119140:	74 0c                	je     11914e <lwm2m_engine_add_service+0x1a>
	for (i = 0; i < MAX_PERIODIC_SERVICE; i++) {
  119142:	40                   	inc    %eax
  119143:	83 f8 0a             	cmp    $0xa,%eax
  119146:	75 ee                	jne    119136 <lwm2m_engine_add_service+0x2>
		return -ENOMEM;
  119148:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
  11914d:	c3                   	ret    
{
  11914e:	55                   	push   %ebp
	service_node_data[i].service_work = service;
  11914f:	81 c2 c0 d0 12 00    	add    $0x12d0c0,%edx
{
  119155:	89 e5                	mov    %esp,%ebp
	service_node_data[i].last_timestamp = 0U;
  119157:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
  11915e:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
	service_node_data[i].service_work = service;
  119165:	8b 45 08             	mov    0x8(%ebp),%eax
  119168:	89 42 04             	mov    %eax,0x4(%edx)
	service_node_data[i].min_call_period = period_ms;
  11916b:	8b 45 0c             	mov    0xc(%ebp),%eax
  11916e:	89 42 08             	mov    %eax,0x8(%edx)
	sys_slist_append(&engine_service_list,
  119171:	b8 9c ec 12 00       	mov    $0x12ec9c,%eax
  119176:	e8 1a b9 ff ff       	call   114a95 <sys_slist_append>
	return 0;
  11917b:	31 c0                	xor    %eax,%eax
}
  11917d:	5d                   	pop    %ebp
  11917e:	c3                   	ret    

0011917f <lwm2m_engine_context_init>:
{
  11917f:	55                   	push   %ebp
  119180:	89 e5                	mov    %esp,%ebp
  119182:	53                   	push   %ebx
	k_delayed_work_init(&client_ctx->retransmit_work, retransmit_request);
  119183:	68 27 5d 11 00       	push   $0x115d27
{
  119188:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_delayed_work_init(&client_ctx->retransmit_work, retransmit_request);
  11918b:	8d 83 0c 01 00 00    	lea    0x10c(%ebx),%eax
  119191:	50                   	push   %eax
  119192:	e8 10 8d 00 00       	call   121ea7 <k_delayed_work_init>
  119197:	58                   	pop    %eax
  119198:	5a                   	pop    %edx
	k_mutex_init(&mutex->kernel_mutex);
  119199:	81 c3 30 01 00 00    	add    $0x130,%ebx
	return z_impl_k_mutex_init(mutex);
  11919f:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1191a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1191a5:	c9                   	leave  
  1191a6:	e9 fb 79 00 00       	jmp    120ba6 <z_impl_k_mutex_init>

001191ab <lwm2m_socket_add>:
{
  1191ab:	55                   	push   %ebp
	if (sock_nfds >= MAX_POLL_FD) {
  1191ac:	a1 74 ec 12 00       	mov    0x12ec74,%eax
{
  1191b1:	89 e5                	mov    %esp,%ebp
  1191b3:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (sock_nfds >= MAX_POLL_FD) {
  1191b8:	83 f8 02             	cmp    $0x2,%eax
{
  1191bb:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (sock_nfds >= MAX_POLL_FD) {
  1191be:	7f 26                	jg     1191e6 <lwm2m_socket_add+0x3b>
	sock_fds[sock_nfds].fd = ctx->sock_fd;
  1191c0:	8b 91 5c 01 00 00    	mov    0x15c(%ecx),%edx
	sock_ctx[sock_nfds] = ctx;
  1191c6:	89 0c 85 90 ec 12 00 	mov    %ecx,0x12ec90(,%eax,4)
	sock_fds[sock_nfds].fd = ctx->sock_fd;
  1191cd:	89 14 c5 78 ec 12 00 	mov    %edx,0x12ec78(,%eax,8)
	sock_fds[sock_nfds].events = POLLIN;
  1191d4:	66 c7 04 c5 7c ec 12 	movw   $0x1,0x12ec7c(,%eax,8)
  1191db:	00 01 00 
	sock_nfds++;
  1191de:	40                   	inc    %eax
	return 0;
  1191df:	31 d2                	xor    %edx,%edx
	sock_nfds++;
  1191e1:	a3 74 ec 12 00       	mov    %eax,0x12ec74
}
  1191e6:	89 d0                	mov    %edx,%eax
  1191e8:	5d                   	pop    %ebp
  1191e9:	c3                   	ret    

001191ea <lwm2m_socket_del>:
{
  1191ea:	55                   	push   %ebp
	for (int i = 0; i < sock_nfds; i++) {
  1191eb:	a1 74 ec 12 00       	mov    0x12ec74,%eax
{
  1191f0:	89 e5                	mov    %esp,%ebp
	for (int i = 0; i < sock_nfds; i++) {
  1191f2:	31 d2                	xor    %edx,%edx
{
  1191f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
	for (int i = 0; i < sock_nfds; i++) {
  1191f7:	39 d0                	cmp    %edx,%eax
  1191f9:	7e 57                	jle    119252 <lwm2m_socket_del+0x68>
		if (sock_ctx[i] != ctx) {
  1191fb:	39 0c 95 90 ec 12 00 	cmp    %ecx,0x12ec90(,%edx,4)
  119202:	74 03                	je     119207 <lwm2m_socket_del+0x1d>
	for (int i = 0; i < sock_nfds; i++) {
  119204:	42                   	inc    %edx
  119205:	eb f0                	jmp    1191f7 <lwm2m_socket_del+0xd>
		sock_nfds--;
  119207:	48                   	dec    %eax
  119208:	a3 74 ec 12 00       	mov    %eax,0x12ec74
		if (i < sock_nfds) {
  11920d:	39 d0                	cmp    %edx,%eax
  11920f:	7e 2b                	jle    11923c <lwm2m_socket_del+0x52>
			sock_ctx[i] = sock_ctx[sock_nfds];
  119211:	8b 0c 85 90 ec 12 00 	mov    0x12ec90(,%eax,4),%ecx
  119218:	89 0c 95 90 ec 12 00 	mov    %ecx,0x12ec90(,%edx,4)
			sock_fds[i].fd = sock_fds[sock_nfds].fd;
  11921f:	8b 0c c5 78 ec 12 00 	mov    0x12ec78(,%eax,8),%ecx
  119226:	89 0c d5 78 ec 12 00 	mov    %ecx,0x12ec78(,%edx,8)
			sock_fds[i].events = sock_fds[sock_nfds].events;
  11922d:	8b 0c c5 7c ec 12 00 	mov    0x12ec7c(,%eax,8),%ecx
  119234:	66 89 0c d5 7c ec 12 	mov    %cx,0x12ec7c(,%edx,8)
  11923b:	00 
		sock_ctx[sock_nfds] = NULL;
  11923c:	c7 04 85 90 ec 12 00 	movl   $0x0,0x12ec90(,%eax,4)
  119243:	00 00 00 00 
		sock_fds[sock_nfds].fd = -1;
  119247:	c7 04 c5 78 ec 12 00 	movl   $0xffffffff,0x12ec78(,%eax,8)
  11924e:	ff ff ff ff 
}
  119252:	5d                   	pop    %ebp
  119253:	c3                   	ret    

00119254 <lwm2m_engine_context_close>:
{
  119254:	55                   	push   %ebp
  119255:	89 e5                	mov    %esp,%ebp
  119257:	57                   	push   %edi
  119258:	56                   	push   %esi
  119259:	53                   	push   %ebx
  11925a:	51                   	push   %ecx
  11925b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_delayed_work_cancel(&client_ctx->retransmit_work);
  11925e:	8d 83 0c 01 00 00    	lea    0x10c(%ebx),%eax
	int sock_fd = client_ctx->sock_fd;
  119264:	8b bb 5c 01 00 00    	mov    0x15c(%ebx),%edi
	k_delayed_work_cancel(&client_ctx->retransmit_work);
  11926a:	50                   	push   %eax
  11926b:	e8 ee 8c 00 00       	call   121f5e <k_delayed_work_cancel>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_observer_list,
  119270:	8b 0d a4 ec 12 00    	mov    0x12eca4,%ecx
	k_delayed_work_cancel(&client_ctx->retransmit_work);
  119276:	5e                   	pop    %esi
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_observer_list,
  119277:	85 c9                	test   %ecx,%ecx
  119279:	74 3c                	je     1192b7 <lwm2m_engine_context_close+0x63>
  11927b:	8b 31                	mov    (%ecx),%esi
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
  11927d:	31 d2                	xor    %edx,%edx
		if (obs->ctx == client_ctx) {
  11927f:	39 59 04             	cmp    %ebx,0x4(%ecx)
  119282:	75 1f                	jne    1192a3 <lwm2m_engine_context_close+0x4f>
			sys_slist_remove(&engine_observer_list, prev_node,
  119284:	b8 a4 ec 12 00       	mov    $0x12eca4,%eax
  119289:	89 55 f0             	mov    %edx,-0x10(%ebp)
  11928c:	e8 1d b8 ff ff       	call   114aae <sys_slist_remove>
			(void)memset(obs, 0, sizeof(*obs));
  119291:	6a 3c                	push   $0x3c
  119293:	6a 00                	push   $0x0
  119295:	51                   	push   %ecx
  119296:	e8 c0 2b ff ff       	call   10be5b <memset>
  11929b:	83 c4 0c             	add    $0xc,%esp
  11929e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1192a1:	eb 02                	jmp    1192a5 <lwm2m_engine_context_close+0x51>
			prev_node = &obs->node;
  1192a3:	89 ca                	mov    %ecx,%edx
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&engine_observer_list,
  1192a5:	31 c0                	xor    %eax,%eax
  1192a7:	85 f6                	test   %esi,%esi
  1192a9:	74 02                	je     1192ad <lwm2m_engine_context_close+0x59>
	return node->next;
  1192ab:	8b 06                	mov    (%esi),%eax
  1192ad:	89 f1                	mov    %esi,%ecx
  1192af:	85 f6                	test   %esi,%esi
  1192b1:	74 04                	je     1192b7 <lwm2m_engine_context_close+0x63>
  1192b3:	89 c6                	mov    %eax,%esi
  1192b5:	eb c8                	jmp    11927f <lwm2m_engine_context_close+0x2b>
	for (i = 0, msg = messages; i < ARRAY_SIZE(messages); i++, msg++) {
  1192b7:	be c0 b4 12 00       	mov    $0x12b4c0,%esi
		if (msg->ctx == client_ctx) {
  1192bc:	39 1e                	cmp    %ebx,(%esi)
  1192be:	75 0a                	jne    1192ca <lwm2m_engine_context_close+0x76>
			lwm2m_reset_message(msg, true);
  1192c0:	6a 01                	push   $0x1
  1192c2:	56                   	push   %esi
  1192c3:	e8 fe c9 ff ff       	call   115cc6 <lwm2m_reset_message>
  1192c8:	58                   	pop    %eax
  1192c9:	5a                   	pop    %edx
	for (i = 0, msg = messages; i < ARRAY_SIZE(messages); i++, msg++) {
  1192ca:	81 c6 8c 02 00 00    	add    $0x28c,%esi
  1192d0:	81 fe 38 ce 12 00    	cmp    $0x12ce38,%esi
  1192d6:	75 e4                	jne    1192bc <lwm2m_engine_context_close+0x68>
	coap_pendings_clear(client_ctx->pendings,
  1192d8:	6a 05                	push   $0x5
  1192da:	8d 43 08             	lea    0x8(%ebx),%eax
  1192dd:	50                   	push   %eax
  1192de:	e8 ff fc fe ff       	call   108fe2 <coap_pendings_clear>
  1192e3:	58                   	pop    %eax
	coap_replies_clear(client_ctx->replies,
  1192e4:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
	coap_pendings_clear(client_ctx->pendings,
  1192ea:	5a                   	pop    %edx
	coap_replies_clear(client_ctx->replies,
  1192eb:	6a 05                	push   $0x5
  1192ed:	50                   	push   %eax
  1192ee:	e8 34 fe fe ff       	call   109127 <coap_replies_clear>
  1192f3:	59                   	pop    %ecx
  1192f4:	5e                   	pop    %esi
	lwm2m_socket_del(client_ctx);
  1192f5:	53                   	push   %ebx
  1192f6:	e8 ef fe ff ff       	call   1191ea <lwm2m_socket_del>
  1192fb:	58                   	pop    %eax
	if (sock_fd >= 0) {
  1192fc:	85 ff                	test   %edi,%edi
	client_ctx->sock_fd = -1;
  1192fe:	c7 83 5c 01 00 00 ff 	movl   $0xffffffff,0x15c(%ebx)
  119305:	ff ff ff 
	if (sock_fd >= 0) {
  119308:	78 0f                	js     119319 <lwm2m_engine_context_close+0xc5>
	return z_impl_zsock_close(sock);
  11930a:	89 7d 08             	mov    %edi,0x8(%ebp)
}
  11930d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  119310:	5b                   	pop    %ebx
  119311:	5e                   	pop    %esi
  119312:	5f                   	pop    %edi
  119313:	5d                   	pop    %ebp
  119314:	e9 5e 02 ff ff       	jmp    109577 <z_impl_zsock_close>
  119319:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11931c:	31 c0                	xor    %eax,%eax
  11931e:	5b                   	pop    %ebx
  11931f:	5e                   	pop    %esi
  119320:	5f                   	pop    %edi
  119321:	5d                   	pop    %ebp
  119322:	c3                   	ret    

00119323 <lwm2m_socket_start>:
{
  119323:	55                   	push   %ebp
  119324:	89 e5                	mov    %esp,%ebp
  119326:	56                   	push   %esi
  119327:	53                   	push   %ebx
  119328:	8b 75 08             	mov    0x8(%ebp),%esi
		client_ctx->sock_fd = socket(client_ctx->remote_addr.sa_family,
  11932b:	0f b7 06             	movzwl (%esi),%eax
	return z_impl_zsock_socket(family, type, proto);
  11932e:	6a 11                	push   $0x11
  119330:	6a 02                	push   $0x2
  119332:	50                   	push   %eax
  119333:	e8 36 01 ff ff       	call   10946e <z_impl_zsock_socket>
  119338:	83 c4 0c             	add    $0xc,%esp
  11933b:	89 86 5c 01 00 00    	mov    %eax,0x15c(%esi)
	if (client_ctx->sock_fd < 0) {
  119341:	85 c0                	test   %eax,%eax
  119343:	79 34                	jns    119379 <lwm2m_socket_start+0x56>
		LOG_ERR("Failed to create socket: %d", errno);
  119345:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  11934c:	74 74                	je     1193c2 <lwm2m_socket_start+0x9f>
  11934e:	e8 c0 b9 ff ff       	call   114d13 <z_errno>
  119353:	bb 20 31 12 00       	mov    $0x123120,%ebx
  119358:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11935e:	c1 eb 03             	shr    $0x3,%ebx
  119361:	c1 e3 06             	shl    $0x6,%ebx
  119364:	83 cb 01             	or     $0x1,%ebx
  119367:	53                   	push   %ebx
  119368:	ff 30                	pushl  (%eax)
  11936a:	68 51 7d 12 00       	push   $0x127d51
  11936f:	e8 02 a2 fe ff       	call   103576 <log_1>
  119374:	83 c4 0c             	add    $0xc,%esp
		return -errno;
  119377:	eb 49                	jmp    1193c2 <lwm2m_socket_start+0x9f>
	return z_impl_zsock_connect(sock, addr, addrlen);
  119379:	6a 08                	push   $0x8
  11937b:	56                   	push   %esi
  11937c:	50                   	push   %eax
  11937d:	e8 fb 02 ff ff       	call   10967d <z_impl_zsock_connect>
  119382:	83 c4 0c             	add    $0xc,%esp
	if (connect(client_ctx->sock_fd, &client_ctx->remote_addr,
  119385:	85 c0                	test   %eax,%eax
  119387:	79 44                	jns    1193cd <lwm2m_socket_start+0xaa>
		LOG_ERR("Cannot connect UDP (-%d)", errno);
  119389:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
  119390:	74 29                	je     1193bb <lwm2m_socket_start+0x98>
  119392:	e8 7c b9 ff ff       	call   114d13 <z_errno>
  119397:	bb 20 31 12 00       	mov    $0x123120,%ebx
  11939c:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  1193a2:	c1 eb 03             	shr    $0x3,%ebx
  1193a5:	c1 e3 06             	shl    $0x6,%ebx
  1193a8:	83 cb 01             	or     $0x1,%ebx
  1193ab:	53                   	push   %ebx
  1193ac:	ff 30                	pushl  (%eax)
  1193ae:	68 6d 7d 12 00       	push   $0x127d6d
  1193b3:	e8 be a1 fe ff       	call   103576 <log_1>
  1193b8:	83 c4 0c             	add    $0xc,%esp
		lwm2m_engine_context_close(client_ctx);
  1193bb:	56                   	push   %esi
  1193bc:	e8 93 fe ff ff       	call   119254 <lwm2m_engine_context_close>
  1193c1:	5a                   	pop    %edx
		return -errno;
  1193c2:	e8 4c b9 ff ff       	call   114d13 <z_errno>
  1193c7:	8b 00                	mov    (%eax),%eax
  1193c9:	f7 d8                	neg    %eax
  1193cb:	eb 09                	jmp    1193d6 <lwm2m_socket_start+0xb3>
	lwm2m_socket_add(client_ctx);
  1193cd:	56                   	push   %esi
  1193ce:	e8 d8 fd ff ff       	call   1191ab <lwm2m_socket_add>
  1193d3:	58                   	pop    %eax
	return 0;
  1193d4:	31 c0                	xor    %eax,%eax
}
  1193d6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1193d9:	5b                   	pop    %ebx
  1193da:	5e                   	pop    %esi
  1193db:	5d                   	pop    %ebp
  1193dc:	c3                   	ret    

001193dd <lwm2m_parse_peerinfo>:
{
  1193dd:	55                   	push   %ebp
  1193de:	89 e5                	mov    %esp,%ebp
  1193e0:	57                   	push   %edi
  1193e1:	56                   	push   %esi
  1193e2:	53                   	push   %ebx
	http_parser_url_init(&parser);
  1193e3:	8d 5d d4             	lea    -0x2c(%ebp),%ebx
{
  1193e6:	83 ec 28             	sub    $0x28,%esp
  1193e9:	8b 7d 08             	mov    0x8(%ebp),%edi
  1193ec:	8b 75 0c             	mov    0xc(%ebp),%esi
	http_parser_url_init(&parser);
  1193ef:	53                   	push   %ebx
  1193f0:	e8 9c 67 00 00       	call   11fb91 <http_parser_url_init>
	ret = http_parser_parse_url(url, strlen(url), 0, &parser);
  1193f5:	89 3c 24             	mov    %edi,(%esp)
  1193f8:	e8 1f 29 ff ff       	call   10bd1c <strlen>
  1193fd:	89 1c 24             	mov    %ebx,(%esp)
  119400:	6a 00                	push   $0x0
  119402:	50                   	push   %eax
  119403:	57                   	push   %edi
  119404:	e8 9c 67 00 00       	call   11fba5 <http_parser_parse_url>
  119409:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
  11940c:	85 c0                	test   %eax,%eax
  11940e:	79 49                	jns    119459 <lwm2m_parse_peerinfo+0x7c>
		LOG_ERR("Invalid url: %s", log_strdup(url));
  119410:	f6 05 d0 5b 14 00 07 	testb  $0x7,0x145bd0
		return -ENOTSUP;
  119417:	ba dd ff ff ff       	mov    $0xffffffdd,%edx
		LOG_ERR("Invalid url: %s", log_strdup(url));
  11941c:	0f 84 17 01 00 00    	je     119539 <lwm2m_parse_peerinfo+0x15c>
  119422:	57                   	push   %edi
  119423:	89 55 d0             	mov    %edx,-0x30(%ebp)
  119426:	e8 2c 9e fe ff       	call   103257 <log_strdup>
  11942b:	bb 20 31 12 00       	mov    $0x123120,%ebx
  119430:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  119436:	c1 eb 03             	shr    $0x3,%ebx
  119439:	c1 e3 06             	shl    $0x6,%ebx
  11943c:	83 cb 01             	or     $0x1,%ebx
  11943f:	66 89 1c 24          	mov    %bx,(%esp)
  119443:	50                   	push   %eax
  119444:	68 86 7d 12 00       	push   $0x127d86
  119449:	e8 28 a1 fe ff       	call   103576 <log_1>
  11944e:	83 c4 0c             	add    $0xc,%esp
  119451:	8b 55 d0             	mov    -0x30(%ebp),%edx
  119454:	e9 e0 00 00 00       	jmp    119539 <lwm2m_parse_peerinfo+0x15c>
	len = parser.field_data[UF_SCHEMA].len;
  119459:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
	if (strncmp(url + off, "coaps", len) != 0) {
  11945d:	0f b7 5d d8          	movzwl -0x28(%ebp),%ebx
  119461:	50                   	push   %eax
  119462:	01 fb                	add    %edi,%ebx
  119464:	68 96 7d 12 00       	push   $0x127d96
  119469:	89 45 d0             	mov    %eax,-0x30(%ebp)
  11946c:	53                   	push   %ebx
  11946d:	e8 dd 28 ff ff       	call   10bd4f <strncmp>
  119472:	83 c4 0c             	add    $0xc,%esp
  119475:	8b 55 d0             	mov    -0x30(%ebp),%edx
  119478:	85 c0                	test   %eax,%eax
  11947a:	74 0a                	je     119486 <lwm2m_parse_peerinfo+0xa9>
		return -EPROTONOSUPPORT;
  11947c:	ba d5 ff ff ff       	mov    $0xffffffd5,%edx
  119481:	e9 b3 00 00 00       	jmp    119539 <lwm2m_parse_peerinfo+0x15c>
	if (len == 5U && strncmp(url + off, "coaps", len) == 0) {
  119486:	66 83 fa 05          	cmp    $0x5,%dx
	*use_dtls = false;
  11948a:	8b 45 10             	mov    0x10(%ebp),%eax
  11948d:	c6 00 00             	movb   $0x0,(%eax)
	if (len == 5U && strncmp(url + off, "coaps", len) == 0) {
  119490:	74 0e                	je     1194a0 <lwm2m_parse_peerinfo+0xc3>
	if (!(parser.field_set & (1 << UF_PORT))) {
  119492:	f6 45 d4 04          	testb  $0x4,-0x2c(%ebp)
  119496:	75 1e                	jne    1194b6 <lwm2m_parse_peerinfo+0xd9>
		parser.port = CONFIG_LWM2M_PEER_PORT;
  119498:	66 c7 45 d6 33 16    	movw   $0x1633,-0x2a(%ebp)
  11949e:	eb 16                	jmp    1194b6 <lwm2m_parse_peerinfo+0xd9>
	if (len == 5U && strncmp(url + off, "coaps", len) == 0) {
  1194a0:	6a 05                	push   $0x5
  1194a2:	68 96 7d 12 00       	push   $0x127d96
  1194a7:	53                   	push   %ebx
  1194a8:	e8 a2 28 ff ff       	call   10bd4f <strncmp>
  1194ad:	83 c4 0c             	add    $0xc,%esp
  1194b0:	85 c0                	test   %eax,%eax
  1194b2:	75 de                	jne    119492 <lwm2m_parse_peerinfo+0xb5>
  1194b4:	eb c6                	jmp    11947c <lwm2m_parse_peerinfo+0x9f>
	tmp = url[off + len];
  1194b6:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  1194ba:	0f b7 5d de          	movzwl -0x22(%ebp),%ebx
  1194be:	01 d3                	add    %edx,%ebx
  1194c0:	89 55 cc             	mov    %edx,-0x34(%ebp)
  1194c3:	01 fb                	add    %edi,%ebx
  1194c5:	8a 03                	mov    (%ebx),%al
	url[off + len] = '\0';
  1194c7:	c6 03 00             	movb   $0x0,(%ebx)
	(void)memset(addr, 0, sizeof(*addr));
  1194ca:	6a 08                	push   $0x8
	tmp = url[off + len];
  1194cc:	88 45 d0             	mov    %al,-0x30(%ebp)
	(void)memset(addr, 0, sizeof(*addr));
  1194cf:	6a 00                	push   $0x0
  1194d1:	56                   	push   %esi
  1194d2:	e8 84 29 ff ff       	call   10be5b <memset>
	ret = net_addr_pton(AF_INET6, url + off,
  1194d7:	8b 55 cc             	mov    -0x34(%ebp),%edx
	(void)memset(addr, 0, sizeof(*addr));
  1194da:	83 c4 0c             	add    $0xc,%esp
	addr->sa_family = AF_INET6;
  1194dd:	66 c7 06 02 00       	movw   $0x2,(%esi)
			    &((struct sockaddr_in6 *)addr)->sin6_addr);
  1194e2:	8d 4e 04             	lea    0x4(%esi),%ecx
	ret = net_addr_pton(AF_INET6, url + off,
  1194e5:	01 d7                	add    %edx,%edi
  1194e7:	51                   	push   %ecx
  1194e8:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  1194eb:	57                   	push   %edi
  1194ec:	6a 02                	push   $0x2
  1194ee:	e8 ea 4c ff ff       	call   10e1dd <z_impl_net_addr_pton>
  1194f3:	83 c4 0c             	add    $0xc,%esp
  1194f6:	89 c2                	mov    %eax,%edx
	if (ret < 0) {
  1194f8:	85 c0                	test   %eax,%eax
  1194fa:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  1194fd:	79 17                	jns    119516 <lwm2m_parse_peerinfo+0x139>
		addr->sa_family = AF_INET;
  1194ff:	66 c7 06 01 00       	movw   $0x1,(%esi)
  119504:	51                   	push   %ecx
  119505:	57                   	push   %edi
  119506:	6a 01                	push   $0x1
  119508:	e8 d0 4c ff ff       	call   10e1dd <z_impl_net_addr_pton>
  11950d:	83 c4 0c             	add    $0xc,%esp
  119510:	89 c2                	mov    %eax,%edx
	if (ret < 0) {
  119512:	85 c0                	test   %eax,%eax
  119514:	78 1e                	js     119534 <lwm2m_parse_peerinfo+0x157>
	if (addr->sa_family == AF_INET6) {
  119516:	66 8b 06             	mov    (%esi),%ax
  119519:	66 83 f8 02          	cmp    $0x2,%ax
  11951d:	74 04                	je     119523 <lwm2m_parse_peerinfo+0x146>
	} else if (addr->sa_family == AF_INET) {
  11951f:	66 48                	dec    %ax
  119521:	75 0c                	jne    11952f <lwm2m_parse_peerinfo+0x152>
		net_sin(addr)->sin_port = htons(parser.port);
  119523:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
  119527:	86 e0                	xchg   %ah,%al
  119529:	66 89 46 02          	mov    %ax,0x2(%esi)
  11952d:	eb 05                	jmp    119534 <lwm2m_parse_peerinfo+0x157>
		ret = -EPROTONOSUPPORT;
  11952f:	ba d5 ff ff ff       	mov    $0xffffffd5,%edx
	url[off + len] = tmp;
  119534:	8a 45 d0             	mov    -0x30(%ebp),%al
  119537:	88 03                	mov    %al,(%ebx)
}
  119539:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11953c:	89 d0                	mov    %edx,%eax
  11953e:	5b                   	pop    %ebx
  11953f:	5e                   	pop    %esi
  119540:	5f                   	pop    %edi
  119541:	5d                   	pop    %ebp
  119542:	c3                   	ret    

00119543 <lwm2m_engine_start>:
{
  119543:	55                   	push   %ebp
  119544:	89 e5                	mov    %esp,%ebp
  119546:	56                   	push   %esi
  119547:	53                   	push   %ebx
  119548:	83 ec 1c             	sub    $0x1c,%esp
	snprintk(pathstr, sizeof(pathstr), "0/%d/0", client_ctx->sec_obj_inst);
  11954b:	8d 75 e4             	lea    -0x1c(%ebp),%esi
{
  11954e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	snprintk(pathstr, sizeof(pathstr), "0/%d/0", client_ctx->sec_obj_inst);
  119551:	ff b3 50 01 00 00    	pushl  0x150(%ebx)
  119557:	68 9c 7d 12 00       	push   $0x127d9c
  11955c:	6a 14                	push   $0x14
  11955e:	56                   	push   %esi
  11955f:	e8 9b 7d fe ff       	call   1012ff <snprintk>
  119564:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_engine_get_res_data(pathstr, (void **)&url, &url_len,
  119567:	8d 45 dd             	lea    -0x23(%ebp),%eax
  11956a:	50                   	push   %eax
  11956b:	8d 45 de             	lea    -0x22(%ebp),%eax
  11956e:	50                   	push   %eax
  11956f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  119572:	50                   	push   %eax
  119573:	56                   	push   %esi
  119574:	e8 a4 ec ff ff       	call   11821d <lwm2m_engine_get_res_data>
  119579:	83 c4 10             	add    $0x10,%esp
	if (ret < 0) {
  11957c:	85 c0                	test   %eax,%eax
  11957e:	78 31                	js     1195b1 <lwm2m_engine_start+0x6e>
	url[url_len] = '\0';
  119580:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  119584:	8b 55 e0             	mov    -0x20(%ebp),%edx
  119587:	c6 04 02 00          	movb   $0x0,(%edx,%eax,1)
	ret = lwm2m_parse_peerinfo(url, &client_ctx->remote_addr,
  11958b:	8d 83 4c 01 00 00    	lea    0x14c(%ebx),%eax
  119591:	50                   	push   %eax
  119592:	53                   	push   %ebx
  119593:	ff 75 e0             	pushl  -0x20(%ebp)
  119596:	e8 42 fe ff ff       	call   1193dd <lwm2m_parse_peerinfo>
  11959b:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  11959e:	85 c0                	test   %eax,%eax
  1195a0:	78 0f                	js     1195b1 <lwm2m_engine_start+0x6e>
	lwm2m_engine_context_init(client_ctx);
  1195a2:	53                   	push   %ebx
  1195a3:	e8 d7 fb ff ff       	call   11917f <lwm2m_engine_context_init>
	return lwm2m_socket_start(client_ctx);
  1195a8:	89 1c 24             	mov    %ebx,(%esp)
  1195ab:	e8 73 fd ff ff       	call   119323 <lwm2m_socket_start>
  1195b0:	5a                   	pop    %edx
}
  1195b1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1195b4:	5b                   	pop    %ebx
  1195b5:	5e                   	pop    %esi
  1195b6:	5d                   	pop    %ebp
  1195b7:	c3                   	ret    

001195b8 <lwm2m_security_init>:

	return inst[index].obj_inst_id;
}

static int lwm2m_security_init(const struct device *dev)
{
  1195b8:	55                   	push   %ebp
  1195b9:	89 e5                	mov    %esp,%ebp
  1195bb:	83 ec 08             	sub    $0x8,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
	int ret = 0;

	security.obj_id = LWM2M_OBJECT_SECURITY_ID;
	security.fields = fields;
  1195be:	c7 05 e4 d7 12 00 00 	movl   $0x145800,0x12d7e4
  1195c5:	58 14 00 
	security.obj_id = LWM2M_OBJECT_SECURITY_ID;
  1195c8:	c7 05 f8 d7 12 00 00 	movl   $0xd0000,0x12d7f8
  1195cf:	00 0d 00 
	security.field_count = ARRAY_SIZE(fields);
	security.max_instance_count = MAX_INSTANCE_COUNT;
	security.create_cb = security_create;
	lwm2m_register_obj(&security);
  1195d2:	68 e0 d7 12 00       	push   $0x12d7e0
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  1195d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	security.max_instance_count = MAX_INSTANCE_COUNT;
  1195de:	66 c7 05 fe d7 12 00 	movw   $0x2,0x12d7fe
  1195e5:	02 00 
	security.create_cb = security_create;
  1195e7:	c7 05 e8 d7 12 00 40 	movl   $0x119640,0x12d7e8
  1195ee:	96 11 00 
	lwm2m_register_obj(&security);
  1195f1:	e8 f6 bc ff ff       	call   1152ec <lwm2m_register_obj>

	/* auto create the first instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_SECURITY_ID, 0, &obj_inst);
  1195f6:	8d 45 fc             	lea    -0x4(%ebp),%eax
  1195f9:	89 04 24             	mov    %eax,(%esp)
  1195fc:	6a 00                	push   $0x0
  1195fe:	6a 00                	push   $0x0
  119600:	e8 0c c5 ff ff       	call   115b11 <lwm2m_create_obj_inst>
  119605:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  119608:	85 c0                	test   %eax,%eax
  11960a:	79 32                	jns    11963e <lwm2m_security_init+0x86>
		LOG_ERR("Create LWM2M security instance 0 error: %d", ret);
  11960c:	f6 05 e4 5b 14 00 07 	testb  $0x7,0x145be4
  119613:	74 29                	je     11963e <lwm2m_security_init+0x86>
  119615:	ba 48 31 12 00       	mov    $0x123148,%edx
  11961a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11961d:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  119623:	c1 ea 03             	shr    $0x3,%edx
  119626:	c1 e2 06             	shl    $0x6,%edx
  119629:	83 ca 01             	or     $0x1,%edx
  11962c:	52                   	push   %edx
  11962d:	50                   	push   %eax
  11962e:	68 c1 7d 12 00       	push   $0x127dc1
  119633:	e8 3e 9f fe ff       	call   103576 <log_1>
  119638:	83 c4 0c             	add    $0xc,%esp
  11963b:	8b 45 f8             	mov    -0x8(%ebp),%eax
	}

	return ret;
}
  11963e:	c9                   	leave  
  11963f:	c3                   	ret    

00119640 <security_create>:
{
  119640:	55                   	push   %ebp
  119641:	89 e5                	mov    %esp,%ebp
  119643:	57                   	push   %edi
  119644:	56                   	push   %esi
  119645:	53                   	push   %ebx
  119646:	83 ec 08             	sub    $0x8,%esp
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
  119649:	a1 c4 d7 12 00       	mov    0x12d7c4,%eax
{
  11964e:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
  119651:	85 c0                	test   %eax,%eax
  119653:	74 09                	je     11965e <security_create+0x1e>
  119655:	66 39 15 cc d7 12 00 	cmp    %dx,0x12d7cc
  11965c:	74 1d                	je     11967b <security_create+0x3b>
  11965e:	83 3d d4 d7 12 00 00 	cmpl   $0x0,0x12d7d4
  119665:	74 0b                	je     119672 <security_create+0x32>
  119667:	66 3b 15 dc d7 12 00 	cmp    0x12d7dc,%dx
  11966e:	75 39                	jne    1196a9 <security_create+0x69>
  119670:	eb 09                	jmp    11967b <security_create+0x3b>
		if (!inst[index].obj) {
  119672:	31 db                	xor    %ebx,%ebx
  119674:	85 c0                	test   %eax,%eax
  119676:	0f 95 c3             	setne  %bl
  119679:	eb 6d                	jmp    1196e8 <security_create+0xa8>
			return NULL;
  11967b:	31 db                	xor    %ebx,%ebx
			LOG_ERR("Can not create instance - "
  11967d:	f6 05 e4 5b 14 00 07 	testb  $0x7,0x145be4
  119684:	0f 84 4c 03 00 00    	je     1199d6 <security_create+0x396>
  11968a:	b8 48 31 12 00       	mov    $0x123148,%eax
  11968f:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  119694:	c1 e8 03             	shr    $0x3,%eax
  119697:	c1 e0 06             	shl    $0x6,%eax
  11969a:	83 c8 01             	or     $0x1,%eax
  11969d:	50                   	push   %eax
  11969e:	0f b7 d2             	movzwl %dx,%edx
  1196a1:	52                   	push   %edx
  1196a2:	68 ec 7d 12 00       	push   $0x127dec
  1196a7:	eb 30                	jmp    1196d9 <security_create+0x99>
		if (!inst[index].obj) {
  1196a9:	85 c0                	test   %eax,%eax
  1196ab:	74 39                	je     1196e6 <security_create+0xa6>
			return NULL;
  1196ad:	31 db                	xor    %ebx,%ebx
		LOG_ERR("Can not create instance - "
  1196af:	f6 05 e4 5b 14 00 07 	testb  $0x7,0x145be4
  1196b6:	0f 84 1a 03 00 00    	je     1199d6 <security_create+0x396>
  1196bc:	b8 48 31 12 00       	mov    $0x123148,%eax
  1196c1:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1196c6:	c1 e8 03             	shr    $0x3,%eax
  1196c9:	c1 e0 06             	shl    $0x6,%eax
  1196cc:	83 c8 01             	or     $0x1,%eax
  1196cf:	50                   	push   %eax
  1196d0:	0f b7 d2             	movzwl %dx,%edx
  1196d3:	52                   	push   %edx
  1196d4:	68 1b 7e 12 00       	push   $0x127e1b
  1196d9:	e8 98 9e fe ff       	call   103576 <log_1>
  1196de:	83 c4 0c             	add    $0xc,%esp
  1196e1:	e9 f0 02 00 00       	jmp    1199d6 <security_create+0x396>
	for (index = 0; index < MAX_INSTANCE_COUNT; index++) {
  1196e6:	31 db                	xor    %ebx,%ebx
	security_uri[index][0] = '\0';
  1196e8:	69 c3 ff 00 00 00    	imul   $0xff,%ebx,%eax
	init_res_instance(res_inst[index], ARRAY_SIZE(res_inst[index]));
  1196ee:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
	security_uri[index][0] = '\0';
  1196f4:	c6 80 40 d9 12 00 00 	movb   $0x0,0x12d940(%eax)
	client_identity[index][0] = '\0';
  1196fb:	89 d8                	mov    %ebx,%eax
  1196fd:	c1 e0 07             	shl    $0x7,%eax
	(void)memset(res[index], 0,
  119700:	68 38 01 00 00       	push   $0x138
  119705:	6a 00                	push   $0x0
	bootstrap_flag[index] = 0;
  119707:	c6 83 7b ed 12 00 00 	movb   $0x0,0x12ed7b(%ebx)
	client_identity[index][0] = '\0';
  11970e:	c6 80 40 d8 12 00 00 	movb   $0x0,0x12d840(%eax)
	security_mode[index] = 0U;
  119715:	c6 83 79 ed 12 00 00 	movb   $0x0,0x12ed79(%ebx)
	(void)memset(res[index], 0,
  11971c:	69 c3 38 01 00 00    	imul   $0x138,%ebx,%eax
  119722:	05 40 d5 12 00       	add    $0x12d540,%eax
	short_server_id[index] = 0U;
  119727:	66 c7 84 1b bc ec 12 	movw   $0x0,0x12ecbc(%ebx,%ebx,1)
  11972e:	00 00 00 
	(void)memset(res[index], 0,
  119731:	50                   	push   %eax
  119732:	89 45 ec             	mov    %eax,-0x14(%ebp)
  119735:	e8 21 27 ff ff       	call   10be5b <memset>
  11973a:	83 c4 0c             	add    $0xc,%esp
	memset(ri, 0, sizeof(*ri) * ri_len);
  11973d:	68 9c 00 00 00       	push   $0x9c
	init_res_instance(res_inst[index], ARRAY_SIZE(res_inst[index]));
  119742:	81 c6 00 d4 12 00    	add    $0x12d400,%esi
  119748:	6a 00                	push   $0x0
  11974a:	56                   	push   %esi
  11974b:	e8 0b 27 ff ff       	call   10be5b <memset>
  119750:	83 c4 0c             	add    $0xc,%esp
  119753:	31 c0                	xor    %eax,%eax
		ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  119755:	66 c7 44 06 08 ff ff 	movw   $0xffff,0x8(%esi,%eax,1)
	for (i = 0; i < ri_len; i++) {
  11975c:	83 c0 0c             	add    $0xc,%eax
  11975f:	3d 9c 00 00 00       	cmp    $0x9c,%eax
  119764:	75 ef                	jne    119755 <security_create+0x115>
	INIT_OBJ_RES_DATA(SECURITY_SERVER_URI_ID, res[index], i,
  119766:	69 d3 38 01 00 00    	imul   $0x138,%ebx,%edx
  11976c:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  119772:	69 fb ff 00 00 00    	imul   $0xff,%ebx,%edi
  119778:	8d 82 40 d5 12 00    	lea    0x12d540(%edx),%eax
  11977e:	81 c7 40 d9 12 00    	add    $0x12d940,%edi
  119784:	89 b9 00 d4 12 00    	mov    %edi,0x12d400(%ecx)
	INIT_OBJ_RES_DATA(SECURITY_BOOTSTRAP_FLAG_ID, res[index], i,
  11978a:	8d 7e 0c             	lea    0xc(%esi),%edi
	INIT_OBJ_RES_DATA(SECURITY_SERVER_URI_ID, res[index], i,
  11978d:	89 70 10             	mov    %esi,0x10(%eax)
  119790:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  119796:	c6 40 16 01          	movb   $0x1,0x16(%eax)
  11979a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  1197a1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  1197a8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  1197af:	c7 81 04 d4 12 00 ff 	movl   $0xff00ff,0x12d404(%ecx)
  1197b6:	00 ff 00 
	INIT_OBJ_RES_DATA(SECURITY_BOOTSTRAP_FLAG_ID, res[index], i,
  1197b9:	89 78 28             	mov    %edi,0x28(%eax)
  1197bc:	8d bb 7b ed 12 00    	lea    0x12ed7b(%ebx),%edi
  1197c2:	66 c7 40 2c 01 00    	movw   $0x1,0x2c(%eax)
  1197c8:	89 b9 0c d4 12 00    	mov    %edi,0x12d40c(%ecx)
	INIT_OBJ_RES_DATA(SECURITY_MODE_ID, res[index], i,
  1197ce:	8d 7e 18             	lea    0x18(%esi),%edi
	INIT_OBJ_RES_DATA(SECURITY_BOOTSTRAP_FLAG_ID, res[index], i,
  1197d1:	c6 40 2e 01          	movb   $0x1,0x2e(%eax)
  1197d5:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  1197dc:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  1197e3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	INIT_OBJ_RES_DATA(SECURITY_SERVER_URI_ID, res[index], i,
  1197ea:	c7 82 40 d5 12 00 00 	movl   $0x0,0x12d540(%edx)
  1197f1:	00 00 00 
	INIT_OBJ_RES_DATA(SECURITY_BOOTSTRAP_FLAG_ID, res[index], i,
  1197f4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  1197fb:	c7 81 10 d4 12 00 01 	movl   $0x10001,0x12d410(%ecx)
  119802:	00 01 00 
	INIT_OBJ_RES_DATA(SECURITY_MODE_ID, res[index], i,
  119805:	89 78 40             	mov    %edi,0x40(%eax)
  119808:	8d bb 79 ed 12 00    	lea    0x12ed79(%ebx),%edi
  11980e:	66 c7 40 44 02 00    	movw   $0x2,0x44(%eax)
  119814:	89 b9 18 d4 12 00    	mov    %edi,0x12d418(%ecx)
	INIT_OBJ_RES_DATA(SECURITY_CLIENT_PK_ID, res[index], i,
  11981a:	8d 7e 24             	lea    0x24(%esi),%edi
	INIT_OBJ_RES_DATA(SECURITY_MODE_ID, res[index], i,
  11981d:	c6 40 46 01          	movb   $0x1,0x46(%eax)
  119821:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  119828:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  11982f:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  119836:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  11983d:	c7 81 1c d4 12 00 01 	movl   $0x10001,0x12d41c(%ecx)
  119844:	00 01 00 
	INIT_OBJ_RES_DATA(SECURITY_CLIENT_PK_ID, res[index], i,
  119847:	89 78 58             	mov    %edi,0x58(%eax)
  11984a:	89 df                	mov    %ebx,%edi
  11984c:	c1 e7 07             	shl    $0x7,%edi
  11984f:	66 c7 40 5c 03 00    	movw   $0x3,0x5c(%eax)
  119855:	81 c7 40 d8 12 00    	add    $0x12d840,%edi
	INIT_OBJ_RES_DATA(SECURITY_SERVER_URI_ID, res[index], i,
  11985b:	66 c7 81 08 d4 12 00 	movw   $0x0,0x12d408(%ecx)
  119862:	00 00 
	INIT_OBJ_RES_DATA(SECURITY_BOOTSTRAP_FLAG_ID, res[index], i,
  119864:	66 c7 81 14 d4 12 00 	movw   $0x0,0x12d414(%ecx)
  11986b:	00 00 
	INIT_OBJ_RES_DATA(SECURITY_MODE_ID, res[index], i,
  11986d:	66 c7 81 20 d4 12 00 	movw   $0x0,0x12d420(%ecx)
  119874:	00 00 
	INIT_OBJ_RES_DATA(SECURITY_CLIENT_PK_ID, res[index], i,
  119876:	c6 40 5e 01          	movb   $0x1,0x5e(%eax)
  11987a:	89 b9 24 d4 12 00    	mov    %edi,0x12d424(%ecx)
	INIT_OBJ_RES_DATA(SECURITY_SERVER_PK_ID, res[index], i,
  119880:	8d 7e 30             	lea    0x30(%esi),%edi
	INIT_OBJ_RES_DATA(SECURITY_CLIENT_PK_ID, res[index], i,
  119883:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  11988a:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  119891:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  119898:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  11989f:	c7 81 28 d4 12 00 80 	movl   $0x800080,0x12d428(%ecx)
  1198a6:	00 80 00 
	INIT_OBJ_RES_DATA(SECURITY_SERVER_PK_ID, res[index], i,
  1198a9:	89 78 70             	mov    %edi,0x70(%eax)
  1198ac:	89 df                	mov    %ebx,%edi
  1198ae:	c1 e7 04             	shl    $0x4,%edi
  1198b1:	66 c7 40 74 04 00    	movw   $0x4,0x74(%eax)
  1198b7:	89 7d f0             	mov    %edi,-0x10(%ebp)
  1198ba:	81 c7 20 d8 12 00    	add    $0x12d820,%edi
  1198c0:	89 b9 30 d4 12 00    	mov    %edi,0x12d430(%ecx)
	INIT_OBJ_RES_DATA(SECURITY_SECRET_KEY_ID, res[index], i,
  1198c6:	8d 7e 3c             	lea    0x3c(%esi),%edi
	INIT_OBJ_RES_DATA(SECURITY_SERVER_PK_ID, res[index], i,
  1198c9:	c6 40 76 01          	movb   $0x1,0x76(%eax)
  1198cd:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
  1198d4:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  1198db:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
  1198e2:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
  1198e9:	c7 81 34 d4 12 00 10 	movl   $0x100010,0x12d434(%ecx)
  1198f0:	00 10 00 
	INIT_OBJ_RES_DATA(SECURITY_SECRET_KEY_ID, res[index], i,
  1198f3:	89 b8 88 00 00 00    	mov    %edi,0x88(%eax)
  1198f9:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1198fc:	81 c7 00 d8 12 00    	add    $0x12d800,%edi
	INIT_OBJ_RES_DATA(SECURITY_SHORT_SERVER_ID, res[index], i,
  119902:	83 c6 48             	add    $0x48,%esi
	INIT_OBJ_RES_DATA(SECURITY_SECRET_KEY_ID, res[index], i,
  119905:	66 c7 80 8c 00 00 00 	movw   $0x5,0x8c(%eax)
  11990c:	05 00 
  11990e:	c6 80 8e 00 00 00 01 	movb   $0x1,0x8e(%eax)
  119915:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
  11991c:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
  119923:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
  11992a:	00 00 00 
  11992d:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
  119934:	00 00 00 
	INIT_OBJ_RES_DATA(SECURITY_CLIENT_PK_ID, res[index], i,
  119937:	66 c7 81 2c d4 12 00 	movw   $0x0,0x12d42c(%ecx)
  11993e:	00 00 
	INIT_OBJ_RES_DATA(SECURITY_SECRET_KEY_ID, res[index], i,
  119940:	c7 81 40 d4 12 00 10 	movl   $0x100010,0x12d440(%ecx)
  119947:	00 10 00 
	INIT_OBJ_RES_DATA(SECURITY_SERVER_PK_ID, res[index], i,
  11994a:	66 c7 81 38 d4 12 00 	movw   $0x0,0x12d438(%ecx)
  119951:	00 00 
	INIT_OBJ_RES_DATA(SECURITY_SHORT_SERVER_ID, res[index], i,
  119953:	66 c7 80 a4 00 00 00 	movw   $0xa,0xa4(%eax)
  11995a:	0a 00 
  11995c:	89 b0 a0 00 00 00    	mov    %esi,0xa0(%eax)
  119962:	c6 80 a6 00 00 00 01 	movb   $0x1,0xa6(%eax)
	INIT_OBJ_RES_DATA(SECURITY_SECRET_KEY_ID, res[index], i,
  119969:	89 b9 3c d4 12 00    	mov    %edi,0x12d43c(%ecx)
  11996f:	66 c7 81 44 d4 12 00 	movw   $0x0,0x12d444(%ecx)
  119976:	00 00 
	INIT_OBJ_RES_DATA(SECURITY_SHORT_SERVER_ID, res[index], i,
  119978:	01 db                	add    %ebx,%ebx
  11997a:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
  119981:	00 00 00 
  119984:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
  11998b:	00 00 00 
  11998e:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
  119995:	00 00 00 
  119998:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
  11999f:	00 00 00 
	inst[index].resources = res[index];
  1199a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
	INIT_OBJ_RES_DATA(SECURITY_SHORT_SERVER_ID, res[index], i,
  1199a5:	81 c3 bc ec 12 00    	add    $0x12ecbc,%ebx
  1199ab:	c7 81 4c d4 12 00 02 	movl   $0x20002,0x12d44c(%ecx)
  1199b2:	00 02 00 
  1199b5:	89 99 48 d4 12 00    	mov    %ebx,0x12d448(%ecx)
	inst[index].resources = res[index];
  1199bb:	8d 98 c0 d7 12 00    	lea    0x12d7c0(%eax),%ebx
  1199c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
	INIT_OBJ_RES_DATA(SECURITY_SHORT_SERVER_ID, res[index], i,
  1199c4:	66 c7 81 50 d4 12 00 	movw   $0x0,0x12d450(%ecx)
  1199cb:	00 00 
	inst[index].resources = res[index];
  1199cd:	89 43 08             	mov    %eax,0x8(%ebx)
	inst[index].resource_count = i;
  1199d0:	66 c7 43 0e 07 00    	movw   $0x7,0xe(%ebx)
}
  1199d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1199d9:	89 d8                	mov    %ebx,%eax
  1199db:	5b                   	pop    %ebx
  1199dc:	5e                   	pop    %esi
  1199dd:	5f                   	pop    %edi
  1199de:	5d                   	pop    %ebp
  1199df:	c3                   	ret    

001199e0 <lwm2m_security_inst_id_to_index>:
{
  1199e0:	55                   	push   %ebp
  1199e1:	89 e5                	mov    %esp,%ebp
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  1199e3:	83 3d c4 d7 12 00 00 	cmpl   $0x0,0x12d7c4
{
  1199ea:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  1199ed:	74 0b                	je     1199fa <lwm2m_security_inst_id_to_index+0x1a>
	for (i = 0; i < MAX_INSTANCE_COUNT; i++) {
  1199ef:	31 c0                	xor    %eax,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  1199f1:	66 3b 15 cc d7 12 00 	cmp    0x12d7cc,%dx
  1199f8:	74 1e                	je     119a18 <lwm2m_security_inst_id_to_index+0x38>
  1199fa:	83 3d d4 d7 12 00 00 	cmpl   $0x0,0x12d7d4
	return -ENOENT;
  119a01:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119a06:	74 10                	je     119a18 <lwm2m_security_inst_id_to_index+0x38>
	for (i = 0; i < MAX_INSTANCE_COUNT; i++) {
  119a08:	31 c0                	xor    %eax,%eax
  119a0a:	66 39 15 dc d7 12 00 	cmp    %dx,0x12d7dc
  119a11:	0f 94 c0             	sete   %al
  119a14:	8d 44 40 fe          	lea    -0x2(%eax,%eax,2),%eax
}
  119a18:	5d                   	pop    %ebp
  119a19:	c3                   	ret    

00119a1a <lwm2m_security_index_to_inst_id>:
{
  119a1a:	55                   	push   %ebp
		return -EINVAL;
  119a1b:	ba ea ff ff ff       	mov    $0xffffffea,%edx
{
  119a20:	89 e5                	mov    %esp,%ebp
  119a22:	8b 45 08             	mov    0x8(%ebp),%eax
	if (index >= MAX_INSTANCE_COUNT) {
  119a25:	83 f8 01             	cmp    $0x1,%eax
  119a28:	7f 18                	jg     119a42 <lwm2m_security_index_to_inst_id+0x28>
	if (!inst[index].obj) {
  119a2a:	c1 e0 04             	shl    $0x4,%eax
		return -ENOENT;
  119a2d:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
	if (!inst[index].obj) {
  119a32:	83 b8 c4 d7 12 00 00 	cmpl   $0x0,0x12d7c4(%eax)
  119a39:	74 07                	je     119a42 <lwm2m_security_index_to_inst_id+0x28>
	return inst[index].obj_inst_id;
  119a3b:	0f b7 90 cc d7 12 00 	movzwl 0x12d7cc(%eax),%edx
}
  119a42:	89 d0                	mov    %edx,%eax
  119a44:	5d                   	pop    %ebp
  119a45:	c3                   	ret    

00119a46 <disable_cb>:
static struct lwm2m_engine_res res[MAX_INSTANCE_COUNT][SERVER_MAX_ID];
static struct lwm2m_engine_res_inst
			res_inst[MAX_INSTANCE_COUNT][RESOURCE_INSTANCE_COUNT];

static int disable_cb(uint16_t obj_inst_id)
{
  119a46:	55                   	push   %ebp
  119a47:	89 e5                	mov    %esp,%ebp
	int i;

	LOG_DBG("DISABLE %d", obj_inst_id);
	for (i = 0; i < MAX_INSTANCE_COUNT; i++) {
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119a49:	83 3d c4 dd 12 00 00 	cmpl   $0x0,0x12ddc4
{
  119a50:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119a53:	74 0b                	je     119a60 <disable_cb+0x1a>
			server_flag_disabled[i] = 1U;
			return 0;
  119a55:	31 c0                	xor    %eax,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119a57:	66 3b 15 cc dd 12 00 	cmp    0x12ddcc,%dx
  119a5e:	74 1e                	je     119a7e <disable_cb+0x38>
  119a60:	83 3d d4 dd 12 00 00 	cmpl   $0x0,0x12ddd4
		}
	}

	return -ENOENT;
  119a67:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119a6c:	74 10                	je     119a7e <disable_cb+0x38>
			return 0;
  119a6e:	31 c0                	xor    %eax,%eax
  119a70:	66 39 15 dc dd 12 00 	cmp    %dx,0x12dddc
  119a77:	0f 94 c0             	sete   %al
  119a7a:	8d 44 00 fe          	lea    -0x2(%eax,%eax,1),%eax
}
  119a7e:	5d                   	pop    %ebp
  119a7f:	c3                   	ret    

00119a80 <lwm2m_server_init>:
	LOG_DBG("Create LWM2M server instance: %d", obj_inst_id);
	return &inst[index];
}

static int lwm2m_server_init(const struct device *dev)
{
  119a80:	55                   	push   %ebp
  119a81:	89 e5                	mov    %esp,%ebp
  119a83:	83 ec 08             	sub    $0x8,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
	int ret = 0;

	server.obj_id = LWM2M_OBJECT_SERVER_ID;
	server.fields = fields;
  119a86:	c7 05 e4 dd 12 00 40 	movl   $0x145840,0x12dde4
  119a8d:	58 14 00 
	server.obj_id = LWM2M_OBJECT_SERVER_ID;
  119a90:	c7 05 f8 dd 12 00 01 	movl   $0x90001,0x12ddf8
  119a97:	00 09 00 
	server.field_count = ARRAY_SIZE(fields);
	server.max_instance_count = MAX_INSTANCE_COUNT;
	server.create_cb = server_create;
	lwm2m_register_obj(&server);
  119a9a:	68 e0 dd 12 00       	push   $0x12dde0
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  119a9f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	server.max_instance_count = MAX_INSTANCE_COUNT;
  119aa6:	66 c7 05 fe dd 12 00 	movw   $0x2,0x12ddfe
  119aad:	02 00 
	server.create_cb = server_create;
  119aaf:	c7 05 e8 dd 12 00 14 	movl   $0x119b14,0x12dde8
  119ab6:	9b 11 00 
	lwm2m_register_obj(&server);
  119ab9:	e8 2e b8 ff ff       	call   1152ec <lwm2m_register_obj>

	/* auto create the first instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_SERVER_ID, 0, &obj_inst);
  119abe:	8d 45 fc             	lea    -0x4(%ebp),%eax
  119ac1:	89 04 24             	mov    %eax,(%esp)
  119ac4:	6a 00                	push   $0x0
  119ac6:	6a 01                	push   $0x1
  119ac8:	e8 44 c0 ff ff       	call   115b11 <lwm2m_create_obj_inst>
  119acd:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  119ad0:	85 c0                	test   %eax,%eax
  119ad2:	79 32                	jns    119b06 <lwm2m_server_init+0x86>
		LOG_ERR("Create LWM2M server instance 0 error: %d", ret);
  119ad4:	f6 05 e8 5b 14 00 07 	testb  $0x7,0x145be8
  119adb:	74 29                	je     119b06 <lwm2m_server_init+0x86>
  119add:	ba 50 31 12 00       	mov    $0x123150,%edx
  119ae2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  119ae5:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  119aeb:	c1 ea 03             	shr    $0x3,%edx
  119aee:	c1 e2 06             	shl    $0x6,%edx
  119af1:	83 ca 01             	or     $0x1,%edx
  119af4:	52                   	push   %edx
  119af5:	50                   	push   %eax
  119af6:	68 5d 7e 12 00       	push   $0x127e5d
  119afb:	e8 76 9a fe ff       	call   103576 <log_1>
  119b00:	83 c4 0c             	add    $0xc,%esp
  119b03:	8b 45 f8             	mov    -0x8(%ebp),%eax
	}

	return ret;
}
  119b06:	c9                   	leave  
  119b07:	c3                   	ret    

00119b08 <update_trigger_cb>:
{
  119b08:	55                   	push   %ebp
  119b09:	89 e5                	mov    %esp,%ebp
	engine_trigger_update();
  119b0b:	e8 0c 3c 00 00       	call   11d71c <engine_trigger_update>
}
  119b10:	31 c0                	xor    %eax,%eax
  119b12:	5d                   	pop    %ebp
  119b13:	c3                   	ret    

00119b14 <server_create>:
{
  119b14:	55                   	push   %ebp
  119b15:	89 e5                	mov    %esp,%ebp
  119b17:	57                   	push   %edi
  119b18:	56                   	push   %esi
  119b19:	53                   	push   %ebx
  119b1a:	83 ec 0c             	sub    $0xc,%esp
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
  119b1d:	a1 c4 dd 12 00       	mov    0x12ddc4,%eax
{
  119b22:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[index].obj && inst[index].obj_inst_id == obj_inst_id) {
  119b25:	85 c0                	test   %eax,%eax
  119b27:	74 09                	je     119b32 <server_create+0x1e>
  119b29:	66 3b 15 cc dd 12 00 	cmp    0x12ddcc,%dx
  119b30:	74 1d                	je     119b4f <server_create+0x3b>
  119b32:	83 3d d4 dd 12 00 00 	cmpl   $0x0,0x12ddd4
  119b39:	74 0b                	je     119b46 <server_create+0x32>
  119b3b:	66 3b 15 dc dd 12 00 	cmp    0x12dddc,%dx
  119b42:	75 39                	jne    119b7d <server_create+0x69>
  119b44:	eb 09                	jmp    119b4f <server_create+0x3b>
		if (!inst[index].obj) {
  119b46:	31 db                	xor    %ebx,%ebx
  119b48:	85 c0                	test   %eax,%eax
  119b4a:	0f 95 c3             	setne  %bl
  119b4d:	eb 6d                	jmp    119bbc <server_create+0xa8>
			return NULL;
  119b4f:	31 db                	xor    %ebx,%ebx
			LOG_ERR("Can not create instance - "
  119b51:	f6 05 e8 5b 14 00 07 	testb  $0x7,0x145be8
  119b58:	0f 84 e0 03 00 00    	je     119f3e <server_create+0x42a>
  119b5e:	b8 50 31 12 00       	mov    $0x123150,%eax
  119b63:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  119b68:	c1 e8 03             	shr    $0x3,%eax
  119b6b:	c1 e0 06             	shl    $0x6,%eax
  119b6e:	83 c8 01             	or     $0x1,%eax
  119b71:	50                   	push   %eax
  119b72:	0f b7 d2             	movzwl %dx,%edx
  119b75:	52                   	push   %edx
  119b76:	68 ec 7d 12 00       	push   $0x127dec
  119b7b:	eb 30                	jmp    119bad <server_create+0x99>
		if (!inst[index].obj) {
  119b7d:	85 c0                	test   %eax,%eax
  119b7f:	74 39                	je     119bba <server_create+0xa6>
			return NULL;
  119b81:	31 db                	xor    %ebx,%ebx
		LOG_ERR("Can not create instance - "
  119b83:	f6 05 e8 5b 14 00 07 	testb  $0x7,0x145be8
  119b8a:	0f 84 ae 03 00 00    	je     119f3e <server_create+0x42a>
  119b90:	b8 50 31 12 00       	mov    $0x123150,%eax
  119b95:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  119b9a:	c1 e8 03             	shr    $0x3,%eax
  119b9d:	c1 e0 06             	shl    $0x6,%eax
  119ba0:	83 c8 01             	or     $0x1,%eax
  119ba3:	50                   	push   %eax
  119ba4:	0f b7 d2             	movzwl %dx,%edx
  119ba7:	52                   	push   %edx
  119ba8:	68 1b 7e 12 00       	push   $0x127e1b
  119bad:	e8 c4 99 fe ff       	call   103576 <log_1>
  119bb2:	83 c4 0c             	add    $0xc,%esp
  119bb5:	e9 84 03 00 00       	jmp    119f3e <server_create+0x42a>
	for (index = 0; index < MAX_INSTANCE_COUNT; index++) {
  119bba:	31 db                	xor    %ebx,%ebx
	server_id[index] = index + 1;
  119bbc:	8d 43 01             	lea    0x1(%ebx),%eax
	server_flag_store_notify[index] = 0U;
  119bbf:	c6 83 7d ed 12 00 00 	movb   $0x0,0x12ed7d(%ebx)
	server_id[index] = index + 1;
  119bc6:	66 89 84 1b e8 ec 12 	mov    %ax,0x12ece8(%ebx,%ebx,1)
  119bcd:	00 
	lifetime[index] = CONFIG_LWM2M_ENGINE_DEFAULT_LIFETIME;
  119bce:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
  119bd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	lwm2m_engine_get_binding(transport_binding[index]);
  119bd8:	05 c0 ec 12 00       	add    $0x12ecc0,%eax
  119bdd:	50                   	push   %eax
  119bde:	89 45 ec             	mov    %eax,-0x14(%ebp)
	lifetime[index] = CONFIG_LWM2M_ENGINE_DEFAULT_LIFETIME;
  119be1:	c7 04 9d e0 ec 12 00 	movl   $0x1e,0x12ece0(,%ebx,4)
  119be8:	1e 00 00 00 
	default_min_period[index] = CONFIG_LWM2M_SERVER_DEFAULT_PMIN;
  119bec:	c7 04 9d d8 ec 12 00 	movl   $0xa,0x12ecd8(,%ebx,4)
  119bf3:	0a 00 00 00 
	default_max_period[index] = CONFIG_LWM2M_SERVER_DEFAULT_PMAX;
  119bf7:	c7 04 9d d0 ec 12 00 	movl   $0x3c,0x12ecd0(,%ebx,4)
  119bfe:	3c 00 00 00 
	disabled_timeout[index] = 86400U;
  119c02:	c7 04 9d c8 ec 12 00 	movl   $0x15180,0x12ecc8(,%ebx,4)
  119c09:	80 51 01 00 
	lwm2m_engine_get_binding(transport_binding[index]);
  119c0d:	e8 bd e7 ff ff       	call   1183cf <lwm2m_engine_get_binding>
	(void)memset(res[index], 0,
  119c12:	c7 04 24 d8 00 00 00 	movl   $0xd8,(%esp)
  119c19:	69 c3 d8 00 00 00    	imul   $0xd8,%ebx,%eax
	init_res_instance(res_inst[index], ARRAY_SIZE(res_inst[index]));
  119c1f:	6b f3 54             	imul   $0x54,%ebx,%esi
	(void)memset(res[index], 0,
  119c22:	05 00 dc 12 00       	add    $0x12dc00,%eax
  119c27:	6a 00                	push   $0x0
  119c29:	50                   	push   %eax
  119c2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  119c2d:	e8 29 22 ff ff       	call   10be5b <memset>
  119c32:	83 c4 0c             	add    $0xc,%esp
	memset(ri, 0, sizeof(*ri) * ri_len);
  119c35:	6a 54                	push   $0x54
	init_res_instance(res_inst[index], ARRAY_SIZE(res_inst[index]));
  119c37:	81 c6 40 db 12 00    	add    $0x12db40,%esi
  119c3d:	6a 00                	push   $0x0
  119c3f:	56                   	push   %esi
  119c40:	e8 16 22 ff ff       	call   10be5b <memset>
  119c45:	83 c4 0c             	add    $0xc,%esp
  119c48:	31 c0                	xor    %eax,%eax
		ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  119c4a:	66 c7 44 06 08 ff ff 	movw   $0xffff,0x8(%esi,%eax,1)
	for (i = 0; i < ri_len; i++) {
  119c51:	83 c0 0c             	add    $0xc,%eax
  119c54:	83 f8 54             	cmp    $0x54,%eax
  119c57:	75 f1                	jne    119c4a <server_create+0x136>
	INIT_OBJ_RES_DATA(SERVER_SHORT_SERVER_ID, res[index], i,
  119c59:	69 d3 d8 00 00 00    	imul   $0xd8,%ebx,%edx
  119c5f:	6b cb 54             	imul   $0x54,%ebx,%ecx
  119c62:	8d 3c 1b             	lea    (%ebx,%ebx,1),%edi
  119c65:	8d 82 00 dc 12 00    	lea    0x12dc00(%edx),%eax
  119c6b:	81 c7 e8 ec 12 00    	add    $0x12ece8,%edi
  119c71:	c7 82 00 dc 12 00 00 	movl   $0x0,0x12dc00(%edx)
  119c78:	00 00 00 
  119c7b:	89 b9 40 db 12 00    	mov    %edi,0x12db40(%ecx)
	INIT_OBJ_RES_DATA(SERVER_LIFETIME_ID, res[index], i,
  119c81:	8d 7e 0c             	lea    0xc(%esi),%edi
	INIT_OBJ_RES_DATA(SERVER_SHORT_SERVER_ID, res[index], i,
  119c84:	89 70 10             	mov    %esi,0x10(%eax)
  119c87:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  119c8d:	c6 40 16 01          	movb   $0x1,0x16(%eax)
  119c91:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  119c98:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  119c9f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  119ca6:	c7 81 44 db 12 00 02 	movl   $0x20002,0x12db44(%ecx)
  119cad:	00 02 00 
	INIT_OBJ_RES_DATA(SERVER_LIFETIME_ID, res[index], i,
  119cb0:	89 78 28             	mov    %edi,0x28(%eax)
  119cb3:	8b 7d f0             	mov    -0x10(%ebp),%edi
  119cb6:	66 c7 40 2c 01 00    	movw   $0x1,0x2c(%eax)
  119cbc:	81 c7 e0 ec 12 00    	add    $0x12ece0,%edi
  119cc2:	c6 40 2e 01          	movb   $0x1,0x2e(%eax)
  119cc6:	89 b9 4c db 12 00    	mov    %edi,0x12db4c(%ecx)
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MIN_PERIOD_ID, res[index], i,
  119ccc:	8d 7e 18             	lea    0x18(%esi),%edi
	INIT_OBJ_RES_DATA(SERVER_LIFETIME_ID, res[index], i,
  119ccf:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  119cd6:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  119cdd:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  119ce4:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
  119ceb:	c7 81 50 db 12 00 04 	movl   $0x40004,0x12db50(%ecx)
  119cf2:	00 04 00 
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MIN_PERIOD_ID, res[index], i,
  119cf5:	89 78 40             	mov    %edi,0x40(%eax)
  119cf8:	8b 7d f0             	mov    -0x10(%ebp),%edi
  119cfb:	66 c7 40 44 02 00    	movw   $0x2,0x44(%eax)
  119d01:	81 c7 d8 ec 12 00    	add    $0x12ecd8,%edi
  119d07:	c6 40 46 01          	movb   $0x1,0x46(%eax)
  119d0b:	89 b9 58 db 12 00    	mov    %edi,0x12db58(%ecx)
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MAX_PERIOD_ID, res[index], i,
  119d11:	8d 7e 24             	lea    0x24(%esi),%edi
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MIN_PERIOD_ID, res[index], i,
  119d14:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  119d1b:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  119d22:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  119d29:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
	INIT_OBJ_RES_DATA(SERVER_SHORT_SERVER_ID, res[index], i,
  119d30:	66 c7 81 48 db 12 00 	movw   $0x0,0x12db48(%ecx)
  119d37:	00 00 
	INIT_OBJ_RES_DATA(SERVER_LIFETIME_ID, res[index], i,
  119d39:	66 c7 81 54 db 12 00 	movw   $0x0,0x12db54(%ecx)
  119d40:	00 00 
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MIN_PERIOD_ID, res[index], i,
  119d42:	c7 81 5c db 12 00 04 	movl   $0x40004,0x12db5c(%ecx)
  119d49:	00 04 00 
  119d4c:	66 c7 81 60 db 12 00 	movw   $0x0,0x12db60(%ecx)
  119d53:	00 00 
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MAX_PERIOD_ID, res[index], i,
  119d55:	66 c7 40 5c 03 00    	movw   $0x3,0x5c(%eax)
  119d5b:	89 78 58             	mov    %edi,0x58(%eax)
  119d5e:	8b 7d f0             	mov    -0x10(%ebp),%edi
  119d61:	c6 40 5e 01          	movb   $0x1,0x5e(%eax)
  119d65:	81 c7 d0 ec 12 00    	add    $0x12ecd0,%edi
  119d6b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  119d72:	89 b9 64 db 12 00    	mov    %edi,0x12db64(%ecx)
	INIT_OBJ_RES_DATA(SERVER_DISABLE_TIMEOUT_ID, res[index], i,
  119d78:	8d 7e 30             	lea    0x30(%esi),%edi
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MAX_PERIOD_ID, res[index], i,
  119d7b:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  119d82:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  119d89:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  119d90:	c7 81 68 db 12 00 04 	movl   $0x40004,0x12db68(%ecx)
  119d97:	00 04 00 
	INIT_OBJ_RES_DATA(SERVER_DISABLE_TIMEOUT_ID, res[index], i,
  119d9a:	89 b8 88 00 00 00    	mov    %edi,0x88(%eax)
  119da0:	8b 7d f0             	mov    -0x10(%ebp),%edi
  119da3:	81 c7 c8 ec 12 00    	add    $0x12ecc8,%edi
	INIT_OBJ_RES_EXECUTE(SERVER_DISABLE_ID, res[index], i, disable_cb);
  119da9:	66 c7 40 74 04 00    	movw   $0x4,0x74(%eax)
	INIT_OBJ_RES_DATA(SERVER_DISABLE_TIMEOUT_ID, res[index], i,
  119daf:	89 b9 70 db 12 00    	mov    %edi,0x12db70(%ecx)
	INIT_OBJ_RES_DATA(SERVER_STORE_NOTIFY_ID, res[index], i,
  119db5:	8d 7e 3c             	lea    0x3c(%esi),%edi
	INIT_OBJ_RES_EXECUTE(SERVER_DISABLE_ID, res[index], i, disable_cb);
  119db8:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
  119dbf:	c6 40 76 00          	movb   $0x0,0x76(%eax)
  119dc3:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
  119dca:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  119dd1:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
  119dd8:	c7 40 6c 46 9a 11 00 	movl   $0x119a46,0x6c(%eax)
	INIT_OBJ_RES_DATA(SERVER_DISABLE_TIMEOUT_ID, res[index], i,
  119ddf:	66 c7 80 8c 00 00 00 	movw   $0x5,0x8c(%eax)
  119de6:	05 00 
  119de8:	c6 80 8e 00 00 00 01 	movb   $0x1,0x8e(%eax)
  119def:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
  119df6:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
  119dfd:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
  119e04:	00 00 00 
  119e07:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
  119e0e:	00 00 00 
  119e11:	c7 81 74 db 12 00 04 	movl   $0x40004,0x12db74(%ecx)
  119e18:	00 04 00 
	INIT_OBJ_RES_DATA(SERVER_STORE_NOTIFY_ID, res[index], i,
  119e1b:	89 b8 a0 00 00 00    	mov    %edi,0xa0(%eax)
  119e21:	8d bb 7d ed 12 00    	lea    0x12ed7d(%ebx),%edi
	INIT_OBJ_RES_DATA(SERVER_TRANSPORT_BINDING_ID, res[index], i,
  119e27:	83 c6 48             	add    $0x48,%esi
	inst[index].resources = res[index];
  119e2a:	c1 e3 04             	shl    $0x4,%ebx
	INIT_OBJ_RES_DATA(SERVER_STORE_NOTIFY_ID, res[index], i,
  119e2d:	66 c7 80 a4 00 00 00 	movw   $0x6,0xa4(%eax)
  119e34:	06 00 
	inst[index].resources = res[index];
  119e36:	81 c3 c0 dd 12 00    	add    $0x12ddc0,%ebx
	INIT_OBJ_RES_DATA(SERVER_STORE_NOTIFY_ID, res[index], i,
  119e3c:	c6 80 a6 00 00 00 01 	movb   $0x1,0xa6(%eax)
  119e43:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
  119e4a:	00 00 00 
	INIT_OBJ_RES_DATA(SERVER_DEFAULT_MAX_PERIOD_ID, res[index], i,
  119e4d:	66 c7 81 6c db 12 00 	movw   $0x0,0x12db6c(%ecx)
  119e54:	00 00 
	INIT_OBJ_RES_DATA(SERVER_DISABLE_TIMEOUT_ID, res[index], i,
  119e56:	66 c7 81 78 db 12 00 	movw   $0x0,0x12db78(%ecx)
  119e5d:	00 00 
	INIT_OBJ_RES_DATA(SERVER_STORE_NOTIFY_ID, res[index], i,
  119e5f:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
  119e66:	00 00 00 
  119e69:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
  119e70:	00 00 00 
  119e73:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
  119e7a:	00 00 00 
  119e7d:	c7 81 80 db 12 00 01 	movl   $0x10001,0x12db80(%ecx)
  119e84:	00 01 00 
	INIT_OBJ_RES_DATA(SERVER_TRANSPORT_BINDING_ID, res[index], i,
  119e87:	89 b0 b8 00 00 00    	mov    %esi,0xb8(%eax)
  119e8d:	66 c7 80 bc 00 00 00 	movw   $0x7,0xbc(%eax)
  119e94:	07 00 
  119e96:	c6 80 be 00 00 00 01 	movb   $0x1,0xbe(%eax)
  119e9d:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  119ea4:	00 00 00 
  119ea7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
  119eae:	00 00 00 
  119eb1:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
  119eb8:	00 00 00 
  119ebb:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  119ec2:	00 00 00 
  119ec5:	8b 75 ec             	mov    -0x14(%ebp),%esi
  119ec8:	c7 81 8c db 12 00 04 	movl   $0x40004,0x12db8c(%ecx)
  119ecf:	00 04 00 
	INIT_OBJ_RES_EXECUTE(SERVER_REG_UPDATE_TRIGGER_ID, res[index], i,
  119ed2:	66 c7 80 d4 00 00 00 	movw   $0x8,0xd4(%eax)
  119ed9:	08 00 
  119edb:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
  119ee2:	00 00 00 
  119ee5:	c6 80 d6 00 00 00 00 	movb   $0x0,0xd6(%eax)
  119eec:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
  119ef3:	00 00 00 
  119ef6:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
  119efd:	00 00 00 
  119f00:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
  119f07:	00 00 00 
  119f0a:	c7 80 cc 00 00 00 08 	movl   $0x119b08,0xcc(%eax)
  119f11:	9b 11 00 
	inst[index].resources = res[index];
  119f14:	8b 45 e8             	mov    -0x18(%ebp),%eax
	INIT_OBJ_RES_DATA(SERVER_STORE_NOTIFY_ID, res[index], i,
  119f17:	89 b9 7c db 12 00    	mov    %edi,0x12db7c(%ecx)
  119f1d:	66 c7 81 84 db 12 00 	movw   $0x0,0x12db84(%ecx)
  119f24:	00 00 
	INIT_OBJ_RES_DATA(SERVER_TRANSPORT_BINDING_ID, res[index], i,
  119f26:	89 b1 88 db 12 00    	mov    %esi,0x12db88(%ecx)
  119f2c:	66 c7 81 90 db 12 00 	movw   $0x0,0x12db90(%ecx)
  119f33:	00 00 
	inst[index].resources = res[index];
  119f35:	89 43 08             	mov    %eax,0x8(%ebx)
	inst[index].resource_count = i;
  119f38:	66 c7 43 0e 09 00    	movw   $0x9,0xe(%ebx)
}
  119f3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  119f41:	89 d8                	mov    %ebx,%eax
  119f43:	5b                   	pop    %ebx
  119f44:	5e                   	pop    %esi
  119f45:	5f                   	pop    %edi
  119f46:	5d                   	pop    %ebp
  119f47:	c3                   	ret    

00119f48 <lwm2m_server_get_pmin>:
{
  119f48:	55                   	push   %ebp
  119f49:	89 e5                	mov    %esp,%ebp
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119f4b:	83 3d c4 dd 12 00 00 	cmpl   $0x0,0x12ddc4
{
  119f52:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119f55:	74 09                	je     119f60 <lwm2m_server_get_pmin+0x18>
  119f57:	66 3b 15 cc dd 12 00 	cmp    0x12ddcc,%dx
  119f5e:	74 1e                	je     119f7e <lwm2m_server_get_pmin+0x36>
  119f60:	83 3d d4 dd 12 00 00 	cmpl   $0x0,0x12ddd4
	return default_value;
  119f67:	b8 0a 00 00 00       	mov    $0xa,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119f6c:	74 19                	je     119f87 <lwm2m_server_get_pmin+0x3f>
  119f6e:	66 3b 15 dc dd 12 00 	cmp    0x12dddc,%dx
  119f75:	75 10                	jne    119f87 <lwm2m_server_get_pmin+0x3f>
	for (i = 0; i < ARRAY_SIZE(inst); i++) {
  119f77:	b8 01 00 00 00       	mov    $0x1,%eax
  119f7c:	eb 02                	jmp    119f80 <lwm2m_server_get_pmin+0x38>
  119f7e:	31 c0                	xor    %eax,%eax
			return data[i];
  119f80:	8b 04 85 d8 ec 12 00 	mov    0x12ecd8(,%eax,4),%eax
}
  119f87:	5d                   	pop    %ebp
  119f88:	c3                   	ret    

00119f89 <lwm2m_server_get_pmax>:
{
  119f89:	55                   	push   %ebp
  119f8a:	89 e5                	mov    %esp,%ebp
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119f8c:	83 3d c4 dd 12 00 00 	cmpl   $0x0,0x12ddc4
{
  119f93:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119f96:	74 09                	je     119fa1 <lwm2m_server_get_pmax+0x18>
  119f98:	66 3b 15 cc dd 12 00 	cmp    0x12ddcc,%dx
  119f9f:	74 1e                	je     119fbf <lwm2m_server_get_pmax+0x36>
  119fa1:	83 3d d4 dd 12 00 00 	cmpl   $0x0,0x12ddd4
	return default_value;
  119fa8:	b8 3c 00 00 00       	mov    $0x3c,%eax
		if (inst[i].obj && inst[i].obj_inst_id == obj_inst_id) {
  119fad:	74 19                	je     119fc8 <lwm2m_server_get_pmax+0x3f>
  119faf:	66 3b 15 dc dd 12 00 	cmp    0x12dddc,%dx
  119fb6:	75 10                	jne    119fc8 <lwm2m_server_get_pmax+0x3f>
	for (i = 0; i < ARRAY_SIZE(inst); i++) {
  119fb8:	b8 01 00 00 00       	mov    $0x1,%eax
  119fbd:	eb 02                	jmp    119fc1 <lwm2m_server_get_pmax+0x38>
  119fbf:	31 c0                	xor    %eax,%eax
			return data[i];
  119fc1:	8b 04 85 d0 ec 12 00 	mov    0x12ecd0(,%eax,4),%eax
}
  119fc8:	5d                   	pop    %ebp
  119fc9:	c3                   	ret    

00119fca <lwm2m_server_short_id_to_inst>:
{
  119fca:	55                   	push   %ebp
  119fcb:	89 e5                	mov    %esp,%ebp
		if (inst[i].obj && server_id[i] == short_id) {
  119fcd:	83 3d c4 dd 12 00 00 	cmpl   $0x0,0x12ddc4
{
  119fd4:	8b 55 08             	mov    0x8(%ebp),%edx
		if (inst[i].obj && server_id[i] == short_id) {
  119fd7:	74 09                	je     119fe2 <lwm2m_server_short_id_to_inst+0x18>
  119fd9:	66 3b 15 e8 ec 12 00 	cmp    0x12ece8,%dx
  119fe0:	74 1e                	je     11a000 <lwm2m_server_short_id_to_inst+0x36>
  119fe2:	83 3d d4 dd 12 00 00 	cmpl   $0x0,0x12ddd4
	return -ENOENT;
  119fe9:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (inst[i].obj && server_id[i] == short_id) {
  119fee:	74 1c                	je     11a00c <lwm2m_server_short_id_to_inst+0x42>
  119ff0:	66 3b 15 ea ec 12 00 	cmp    0x12ecea,%dx
  119ff7:	75 13                	jne    11a00c <lwm2m_server_short_id_to_inst+0x42>
	for (i = 0; i < ARRAY_SIZE(inst); i++) {
  119ff9:	b8 01 00 00 00       	mov    $0x1,%eax
  119ffe:	eb 02                	jmp    11a002 <lwm2m_server_short_id_to_inst+0x38>
  11a000:	31 c0                	xor    %eax,%eax
			return inst[i].obj_inst_id;
  11a002:	c1 e0 04             	shl    $0x4,%eax
  11a005:	0f b7 80 cc dd 12 00 	movzwl 0x12ddcc(%eax),%eax
}
  11a00c:	5d                   	pop    %ebp
  11a00d:	c3                   	ret    

0011a00e <reset_error_list_cb>:
	int i;

	/* "delete" error codes */
	for (i = 0; i < DEVICE_ERROR_CODE_MAX; i++) {
		error_code_list[i] = 0;
		error_code_ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  11a00e:	8b 0d ec ec 12 00    	mov    0x12ecec,%ecx
	for (i = 0; i < DEVICE_ERROR_CODE_MAX; i++) {
  11a014:	31 c0                	xor    %eax,%eax
		error_code_ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  11a016:	6b d0 0c             	imul   $0xc,%eax,%edx
		error_code_list[i] = 0;
  11a019:	c6 80 10 ed 12 00 00 	movb   $0x0,0x12ed10(%eax)
	for (i = 0; i < DEVICE_ERROR_CODE_MAX; i++) {
  11a020:	40                   	inc    %eax
		error_code_ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  11a021:	66 c7 44 11 08 ff ff 	movw   $0xffff,0x8(%ecx,%edx,1)
	for (i = 0; i < DEVICE_ERROR_CODE_MAX; i++) {
  11a028:	83 f8 0a             	cmp    $0xa,%eax
  11a02b:	75 e9                	jne    11a016 <reset_error_list_cb+0x8>
	}

	return 0;
}
  11a02d:	31 c0                	xor    %eax,%eax
  11a02f:	c3                   	ret    

0011a030 <current_time_pre_write_cb>:
	return &time_temp;
}

static void *current_time_pre_write_cb(uint16_t obj_inst_id, uint16_t res_id,
				       uint16_t res_inst_id, size_t *data_len)
{
  11a030:	55                   	push   %ebp
  11a031:	89 e5                	mov    %esp,%ebp
	*data_len = sizeof(time_temp);
  11a033:	8b 45 14             	mov    0x14(%ebp),%eax
  11a036:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
	return &time_temp;
}
  11a03c:	b8 0c ed 12 00       	mov    $0x12ed0c,%eax
  11a041:	5d                   	pop    %ebp
  11a042:	c3                   	ret    

0011a043 <device_periodic_service>:

	return 0;
}

static void device_periodic_service(struct k_work *work)
{
  11a043:	55                   	push   %ebp
  11a044:	89 e5                	mov    %esp,%ebp
	NOTIFY_OBSERVER(LWM2M_OBJECT_DEVICE_ID, 0, DEVICE_CURRENT_TIME_ID);
  11a046:	6a 0d                	push   $0xd
  11a048:	6a 00                	push   $0x0
  11a04a:	6a 03                	push   $0x3
  11a04c:	e8 20 b2 ff ff       	call   115271 <lwm2m_notify_observer>
  11a051:	83 c4 0c             	add    $0xc,%esp
}
  11a054:	c9                   	leave  
  11a055:	c3                   	ret    

0011a056 <lwm2m_device_init>:
	LOG_DBG("Create LWM2M device instance: %d", obj_inst_id);
	return &inst;
}

static int lwm2m_device_init(const struct device *dev)
{
  11a056:	55                   	push   %ebp
  11a057:	89 e5                	mov    %esp,%ebp
  11a059:	50                   	push   %eax
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
	int ret = 0;

	/* Set default values */
	time_offset = 0U;
	lwm2m_engine_get_binding(binding_mode);
  11a05a:	68 00 ed 12 00       	push   $0x12ed00
	time_offset = 0U;
  11a05f:	c7 05 08 ed 12 00 00 	movl   $0x0,0x12ed08
  11a066:	00 00 00 
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11a069:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	lwm2m_engine_get_binding(binding_mode);
  11a070:	e8 5a e3 ff ff       	call   1183cf <lwm2m_engine_get_binding>
	device.obj_id = LWM2M_OBJECT_DEVICE_ID;
	device.fields = fields;
	device.field_count = ARRAY_SIZE(fields);
	device.max_instance_count = 1U;
	device.create_cb = device_create;
	lwm2m_register_obj(&device);
  11a075:	c7 04 24 60 e2 12 00 	movl   $0x12e260,(%esp)
	device.fields = fields;
  11a07c:	c7 05 64 e2 12 00 80 	movl   $0x145880,0x12e264
  11a083:	58 14 00 
	device.obj_id = LWM2M_OBJECT_DEVICE_ID;
  11a086:	c7 05 78 e2 12 00 03 	movl   $0x170003,0x12e278
  11a08d:	00 17 00 
	device.max_instance_count = 1U;
  11a090:	66 c7 05 7e e2 12 00 	movw   $0x1,0x12e27e
  11a097:	01 00 
	device.create_cb = device_create;
  11a099:	c7 05 68 e2 12 00 0d 	movl   $0x11a10d,0x12e268
  11a0a0:	a1 11 00 
	lwm2m_register_obj(&device);
  11a0a3:	e8 44 b2 ff ff       	call   1152ec <lwm2m_register_obj>

	/* auto create the only instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_DEVICE_ID, 0, &obj_inst);
  11a0a8:	8d 45 fc             	lea    -0x4(%ebp),%eax
  11a0ab:	89 04 24             	mov    %eax,(%esp)
  11a0ae:	6a 00                	push   $0x0
  11a0b0:	6a 03                	push   $0x3
  11a0b2:	e8 5a ba ff ff       	call   115b11 <lwm2m_create_obj_inst>
  11a0b7:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
		LOG_DBG("Create LWM2M instance 0 error: %d", ret);
	}

	/* call device_periodic_service() every 10 seconds */
	ret = lwm2m_engine_add_service(device_periodic_service,
  11a0ba:	68 10 27 00 00       	push   $0x2710
  11a0bf:	68 43 a0 11 00       	push   $0x11a043
  11a0c4:	e8 6b f0 ff ff       	call   119134 <lwm2m_engine_add_service>
  11a0c9:	5a                   	pop    %edx
  11a0ca:	59                   	pop    %ecx
				       DEVICE_SERVICE_INTERVAL_MS);
	return ret;
}
  11a0cb:	c9                   	leave  
  11a0cc:	c3                   	ret    

0011a0cd <current_time_read_cb>:
{
  11a0cd:	55                   	push   %ebp
  11a0ce:	89 e5                	mov    %esp,%ebp
	return z_impl_k_uptime_ticks();
  11a0d0:	e8 b2 82 00 00       	call   122387 <z_impl_k_uptime_ticks>
	time_temp = time_offset + (k_uptime_get() / 1000);
  11a0d5:	6a 00                	push   $0x0
			return t * (to_hz / from_hz);
  11a0d7:	6b ca 0a             	imul   $0xa,%edx,%ecx
  11a0da:	ba 0a 00 00 00       	mov    $0xa,%edx
  11a0df:	68 e8 03 00 00       	push   $0x3e8
  11a0e4:	f7 e2                	mul    %edx
  11a0e6:	01 ca                	add    %ecx,%edx
  11a0e8:	52                   	push   %edx
  11a0e9:	50                   	push   %eax
  11a0ea:	e8 f1 5f fe ff       	call   1000e0 <__divdi3>
  11a0ef:	03 05 08 ed 12 00    	add    0x12ed08,%eax
  11a0f5:	83 c4 10             	add    $0x10,%esp
  11a0f8:	a3 0c ed 12 00       	mov    %eax,0x12ed0c
	*data_len = sizeof(time_temp);
  11a0fd:	8b 45 14             	mov    0x14(%ebp),%eax
  11a100:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
}
  11a106:	b8 0c ed 12 00       	mov    $0x12ed0c,%eax
  11a10b:	c9                   	leave  
  11a10c:	c3                   	ret    

0011a10d <device_create>:
{
  11a10d:	55                   	push   %ebp
  11a10e:	89 e5                	mov    %esp,%ebp
	memset(ri, 0, sizeof(*ri) * ri_len);
  11a110:	68 1c 02 00 00       	push   $0x21c
  11a115:	6a 00                	push   $0x0
  11a117:	68 00 de 12 00       	push   $0x12de00
  11a11c:	e8 3a 1d ff ff       	call   10be5b <memset>
  11a121:	83 c4 0c             	add    $0xc,%esp
  11a124:	31 c0                	xor    %eax,%eax
		ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  11a126:	66 c7 80 08 de 12 00 	movw   $0xffff,0x12de08(%eax)
  11a12d:	ff ff 
	for (i = 0; i < ri_len; i++) {
  11a12f:	83 c0 0c             	add    $0xc,%eax
  11a132:	3d 1c 02 00 00       	cmp    $0x21c,%eax
  11a137:	75 ed                	jne    11a126 <device_create+0x19>
	INIT_OBJ_RES_OPTDATA(DEVICE_MANUFACTURER_ID, res, i, res_inst, j);
  11a139:	66 c7 05 34 e0 12 00 	movw   $0x0,0x12e034
  11a140:	00 00 
  11a142:	c7 05 30 e0 12 00 00 	movl   $0x12de00,0x12e030
  11a149:	de 12 00 
  11a14c:	c6 05 36 e0 12 00 01 	movb   $0x1,0x12e036
  11a153:	c7 05 20 e0 12 00 00 	movl   $0x0,0x12e020
  11a15a:	00 00 00 
  11a15d:	c7 05 24 e0 12 00 00 	movl   $0x0,0x12e024
  11a164:	00 00 00 
  11a167:	c7 05 28 e0 12 00 00 	movl   $0x0,0x12e028
  11a16e:	00 00 00 
  11a171:	c7 05 2c e0 12 00 00 	movl   $0x0,0x12e02c
  11a178:	00 00 00 
  11a17b:	c7 05 00 de 12 00 00 	movl   $0x0,0x12de00
  11a182:	00 00 00 
  11a185:	c7 05 04 de 12 00 00 	movl   $0x0,0x12de04
  11a18c:	00 00 00 
  11a18f:	66 c7 05 08 de 12 00 	movw   $0x0,0x12de08
  11a196:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_MODEL_NUMBER_ID, res, i, res_inst, j);
  11a198:	66 c7 05 4c e0 12 00 	movw   $0x1,0x12e04c
  11a19f:	01 00 
  11a1a1:	c7 05 48 e0 12 00 0c 	movl   $0x12de0c,0x12e048
  11a1a8:	de 12 00 
  11a1ab:	c6 05 4e e0 12 00 01 	movb   $0x1,0x12e04e
  11a1b2:	c7 05 38 e0 12 00 00 	movl   $0x0,0x12e038
  11a1b9:	00 00 00 
  11a1bc:	c7 05 3c e0 12 00 00 	movl   $0x0,0x12e03c
  11a1c3:	00 00 00 
  11a1c6:	c7 05 40 e0 12 00 00 	movl   $0x0,0x12e040
  11a1cd:	00 00 00 
  11a1d0:	c7 05 44 e0 12 00 00 	movl   $0x0,0x12e044
  11a1d7:	00 00 00 
  11a1da:	c7 05 0c de 12 00 00 	movl   $0x0,0x12de0c
  11a1e1:	00 00 00 
  11a1e4:	c7 05 10 de 12 00 00 	movl   $0x0,0x12de10
  11a1eb:	00 00 00 
  11a1ee:	66 c7 05 14 de 12 00 	movw   $0x0,0x12de14
  11a1f5:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_SERIAL_NUMBER_ID, res, i, res_inst, j);
  11a1f7:	66 c7 05 64 e0 12 00 	movw   $0x2,0x12e064
  11a1fe:	02 00 
  11a200:	c7 05 60 e0 12 00 18 	movl   $0x12de18,0x12e060
  11a207:	de 12 00 
  11a20a:	c6 05 66 e0 12 00 01 	movb   $0x1,0x12e066
  11a211:	c7 05 50 e0 12 00 00 	movl   $0x0,0x12e050
  11a218:	00 00 00 
  11a21b:	c7 05 54 e0 12 00 00 	movl   $0x0,0x12e054
  11a222:	00 00 00 
  11a225:	c7 05 58 e0 12 00 00 	movl   $0x0,0x12e058
  11a22c:	00 00 00 
  11a22f:	c7 05 5c e0 12 00 00 	movl   $0x0,0x12e05c
  11a236:	00 00 00 
  11a239:	c7 05 18 de 12 00 00 	movl   $0x0,0x12de18
  11a240:	00 00 00 
  11a243:	c7 05 1c de 12 00 00 	movl   $0x0,0x12de1c
  11a24a:	00 00 00 
  11a24d:	66 c7 05 20 de 12 00 	movw   $0x0,0x12de20
  11a254:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_FIRMWARE_VERSION_ID, res, i, res_inst, j);
  11a256:	66 c7 05 7c e0 12 00 	movw   $0x3,0x12e07c
  11a25d:	03 00 
  11a25f:	c7 05 78 e0 12 00 24 	movl   $0x12de24,0x12e078
  11a266:	de 12 00 
	INIT_OBJ_RES_MULTI_OPTDATA(DEVICE_AVAILABLE_POWER_SOURCES_ID, res, i,
  11a269:	31 c0                	xor    %eax,%eax
	INIT_OBJ_RES_OPTDATA(DEVICE_FIRMWARE_VERSION_ID, res, i, res_inst, j);
  11a26b:	c6 05 7e e0 12 00 01 	movb   $0x1,0x12e07e
  11a272:	c7 05 68 e0 12 00 00 	movl   $0x0,0x12e068
  11a279:	00 00 00 
  11a27c:	c7 05 6c e0 12 00 00 	movl   $0x0,0x12e06c
  11a283:	00 00 00 
  11a286:	c7 05 70 e0 12 00 00 	movl   $0x0,0x12e070
  11a28d:	00 00 00 
  11a290:	c7 05 74 e0 12 00 00 	movl   $0x0,0x12e074
  11a297:	00 00 00 
  11a29a:	c7 05 24 de 12 00 00 	movl   $0x0,0x12de24
  11a2a1:	00 00 00 
  11a2a4:	c7 05 28 de 12 00 00 	movl   $0x0,0x12de28
  11a2ab:	00 00 00 
  11a2ae:	66 c7 05 2c de 12 00 	movw   $0x0,0x12de2c
  11a2b5:	00 00 
	INIT_OBJ_RES_EXECUTE(DEVICE_REBOOT_ID, res, i, NULL);
  11a2b7:	66 c7 05 94 e0 12 00 	movw   $0x4,0x12e094
  11a2be:	04 00 
  11a2c0:	c7 05 90 e0 12 00 00 	movl   $0x0,0x12e090
  11a2c7:	00 00 00 
  11a2ca:	c6 05 96 e0 12 00 00 	movb   $0x0,0x12e096
  11a2d1:	c7 05 80 e0 12 00 00 	movl   $0x0,0x12e080
  11a2d8:	00 00 00 
  11a2db:	c7 05 84 e0 12 00 00 	movl   $0x0,0x12e084
  11a2e2:	00 00 00 
  11a2e5:	c7 05 88 e0 12 00 00 	movl   $0x0,0x12e088
  11a2ec:	00 00 00 
  11a2ef:	c7 05 8c e0 12 00 00 	movl   $0x0,0x12e08c
  11a2f6:	00 00 00 
	INIT_OBJ_RES_EXECUTE(DEVICE_FACTORY_DEFAULT_ID, res, i, NULL);
  11a2f9:	66 c7 05 ac e0 12 00 	movw   $0x5,0x12e0ac
  11a300:	05 00 
  11a302:	c7 05 a8 e0 12 00 00 	movl   $0x0,0x12e0a8
  11a309:	00 00 00 
  11a30c:	c6 05 ae e0 12 00 00 	movb   $0x0,0x12e0ae
  11a313:	c7 05 98 e0 12 00 00 	movl   $0x0,0x12e098
  11a31a:	00 00 00 
  11a31d:	c7 05 9c e0 12 00 00 	movl   $0x0,0x12e09c
  11a324:	00 00 00 
  11a327:	c7 05 a0 e0 12 00 00 	movl   $0x0,0x12e0a0
  11a32e:	00 00 00 
  11a331:	c7 05 a4 e0 12 00 00 	movl   $0x0,0x12e0a4
  11a338:	00 00 00 
	INIT_OBJ_RES_MULTI_OPTDATA(DEVICE_AVAILABLE_POWER_SOURCES_ID, res, i,
  11a33b:	66 c7 05 c4 e0 12 00 	movw   $0x6,0x12e0c4
  11a342:	06 00 
  11a344:	c7 05 c0 e0 12 00 30 	movl   $0x12de30,0x12e0c0
  11a34b:	de 12 00 
  11a34e:	c6 05 c6 e0 12 00 05 	movb   $0x5,0x12e0c6
  11a355:	c7 05 b0 e0 12 00 00 	movl   $0x0,0x12e0b0
  11a35c:	00 00 00 
  11a35f:	c7 05 b4 e0 12 00 00 	movl   $0x0,0x12e0b4
  11a366:	00 00 00 
  11a369:	c7 05 b8 e0 12 00 00 	movl   $0x0,0x12e0b8
  11a370:	00 00 00 
  11a373:	c7 05 bc e0 12 00 00 	movl   $0x0,0x12e0bc
  11a37a:	00 00 00 
  11a37d:	c7 80 30 de 12 00 00 	movl   $0x0,0x12de30(%eax)
  11a384:	00 00 00 
  11a387:	66 c7 80 34 de 12 00 	movw   $0x0,0x12de34(%eax)
  11a38e:	00 00 
  11a390:	66 c7 80 36 de 12 00 	movw   $0x0,0x12de36(%eax)
  11a397:	00 00 
  11a399:	66 c7 80 38 de 12 00 	movw   $0xffff,0x12de38(%eax)
  11a3a0:	ff ff 
  11a3a2:	83 c0 0c             	add    $0xc,%eax
  11a3a5:	83 f8 3c             	cmp    $0x3c,%eax
  11a3a8:	75 d3                	jne    11a37d <device_create+0x270>
	INIT_OBJ_RES_MULTI_OPTDATA(DEVICE_POWER_SOURCE_VOLTAGE_ID, res, i,
  11a3aa:	66 c7 05 dc e0 12 00 	movw   $0x7,0x12e0dc
  11a3b1:	07 00 
  11a3b3:	c7 05 d8 e0 12 00 6c 	movl   $0x12de6c,0x12e0d8
  11a3ba:	de 12 00 
  11a3bd:	c6 05 de e0 12 00 05 	movb   $0x5,0x12e0de
  11a3c4:	c7 05 c8 e0 12 00 00 	movl   $0x0,0x12e0c8
  11a3cb:	00 00 00 
  11a3ce:	c7 05 cc e0 12 00 00 	movl   $0x0,0x12e0cc
  11a3d5:	00 00 00 
  11a3d8:	c7 05 d0 e0 12 00 00 	movl   $0x0,0x12e0d0
  11a3df:	00 00 00 
  11a3e2:	c7 05 d4 e0 12 00 00 	movl   $0x0,0x12e0d4
  11a3e9:	00 00 00 
  11a3ec:	31 c0                	xor    %eax,%eax
  11a3ee:	c7 80 6c de 12 00 00 	movl   $0x0,0x12de6c(%eax)
  11a3f5:	00 00 00 
  11a3f8:	66 c7 80 70 de 12 00 	movw   $0x0,0x12de70(%eax)
  11a3ff:	00 00 
  11a401:	66 c7 80 72 de 12 00 	movw   $0x0,0x12de72(%eax)
  11a408:	00 00 
  11a40a:	66 c7 80 74 de 12 00 	movw   $0xffff,0x12de74(%eax)
  11a411:	ff ff 
  11a413:	83 c0 0c             	add    $0xc,%eax
  11a416:	83 f8 3c             	cmp    $0x3c,%eax
  11a419:	75 d3                	jne    11a3ee <device_create+0x2e1>
	INIT_OBJ_RES_MULTI_OPTDATA(DEVICE_POWER_SOURCE_CURRENT_ID, res, i,
  11a41b:	66 c7 05 f4 e0 12 00 	movw   $0x8,0x12e0f4
  11a422:	08 00 
  11a424:	c7 05 f0 e0 12 00 a8 	movl   $0x12dea8,0x12e0f0
  11a42b:	de 12 00 
  11a42e:	c6 05 f6 e0 12 00 05 	movb   $0x5,0x12e0f6
  11a435:	c7 05 e0 e0 12 00 00 	movl   $0x0,0x12e0e0
  11a43c:	00 00 00 
  11a43f:	c7 05 e4 e0 12 00 00 	movl   $0x0,0x12e0e4
  11a446:	00 00 00 
  11a449:	c7 05 e8 e0 12 00 00 	movl   $0x0,0x12e0e8
  11a450:	00 00 00 
  11a453:	c7 05 ec e0 12 00 00 	movl   $0x0,0x12e0ec
  11a45a:	00 00 00 
  11a45d:	31 c0                	xor    %eax,%eax
  11a45f:	c7 80 a8 de 12 00 00 	movl   $0x0,0x12dea8(%eax)
  11a466:	00 00 00 
  11a469:	66 c7 80 ac de 12 00 	movw   $0x0,0x12deac(%eax)
  11a470:	00 00 
  11a472:	66 c7 80 ae de 12 00 	movw   $0x0,0x12deae(%eax)
  11a479:	00 00 
  11a47b:	66 c7 80 b0 de 12 00 	movw   $0xffff,0x12deb0(%eax)
  11a482:	ff ff 
  11a484:	83 c0 0c             	add    $0xc,%eax
  11a487:	83 f8 3c             	cmp    $0x3c,%eax
  11a48a:	75 d3                	jne    11a45f <device_create+0x352>
	INIT_OBJ_RES_OPTDATA(DEVICE_BATTERY_LEVEL_ID, res, i, res_inst, j);
  11a48c:	66 c7 05 0c e1 12 00 	movw   $0x9,0x12e10c
  11a493:	09 00 
  11a495:	c7 05 08 e1 12 00 e4 	movl   $0x12dee4,0x12e108
  11a49c:	de 12 00 
  11a49f:	c6 05 0e e1 12 00 01 	movb   $0x1,0x12e10e
  11a4a6:	c7 05 f8 e0 12 00 00 	movl   $0x0,0x12e0f8
  11a4ad:	00 00 00 
  11a4b0:	c7 05 fc e0 12 00 00 	movl   $0x0,0x12e0fc
  11a4b7:	00 00 00 
  11a4ba:	c7 05 00 e1 12 00 00 	movl   $0x0,0x12e100
  11a4c1:	00 00 00 
  11a4c4:	c7 05 04 e1 12 00 00 	movl   $0x0,0x12e104
  11a4cb:	00 00 00 
  11a4ce:	c7 05 e4 de 12 00 00 	movl   $0x0,0x12dee4
  11a4d5:	00 00 00 
  11a4d8:	c7 05 e8 de 12 00 00 	movl   $0x0,0x12dee8
  11a4df:	00 00 00 
  11a4e2:	66 c7 05 ec de 12 00 	movw   $0x0,0x12deec
  11a4e9:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_MEMORY_FREE_ID, res, i, res_inst, j);
  11a4eb:	66 c7 05 24 e1 12 00 	movw   $0xa,0x12e124
  11a4f2:	0a 00 
  11a4f4:	c7 05 20 e1 12 00 f0 	movl   $0x12def0,0x12e120
  11a4fb:	de 12 00 
  11a4fe:	c6 05 26 e1 12 00 01 	movb   $0x1,0x12e126
  11a505:	c7 05 10 e1 12 00 00 	movl   $0x0,0x12e110
  11a50c:	00 00 00 
  11a50f:	c7 05 14 e1 12 00 00 	movl   $0x0,0x12e114
  11a516:	00 00 00 
  11a519:	c7 05 18 e1 12 00 00 	movl   $0x0,0x12e118
  11a520:	00 00 00 
  11a523:	c7 05 1c e1 12 00 00 	movl   $0x0,0x12e11c
  11a52a:	00 00 00 
  11a52d:	c7 05 f0 de 12 00 00 	movl   $0x0,0x12def0
  11a534:	00 00 00 
  11a537:	c7 05 f4 de 12 00 00 	movl   $0x0,0x12def4
  11a53e:	00 00 00 
  11a541:	66 c7 05 f8 de 12 00 	movw   $0x0,0x12def8
  11a548:	00 00 
	error_code_ri = &res_inst[j];
  11a54a:	c7 05 ec ec 12 00 fc 	movl   $0x12defc,0x12ecec
  11a551:	de 12 00 
	INIT_OBJ_RES_MULTI_DATA(DEVICE_ERROR_CODE_ID, res, i,
  11a554:	66 c7 05 3c e1 12 00 	movw   $0xb,0x12e13c
  11a55b:	0b 00 
  11a55d:	c7 05 38 e1 12 00 fc 	movl   $0x12defc,0x12e138
  11a564:	de 12 00 
  11a567:	c6 05 3e e1 12 00 0a 	movb   $0xa,0x12e13e
  11a56e:	c7 05 28 e1 12 00 00 	movl   $0x0,0x12e128
  11a575:	00 00 00 
  11a578:	c7 05 2c e1 12 00 00 	movl   $0x0,0x12e12c
  11a57f:	00 00 00 
  11a582:	c7 05 30 e1 12 00 00 	movl   $0x0,0x12e130
  11a589:	00 00 00 
  11a58c:	c7 05 34 e1 12 00 00 	movl   $0x0,0x12e134
  11a593:	00 00 00 
  11a596:	ba 10 ed 12 00       	mov    $0x12ed10,%edx
  11a59b:	31 c0                	xor    %eax,%eax
  11a59d:	89 90 fc de 12 00    	mov    %edx,0x12defc(%eax)
  11a5a3:	66 c7 80 00 df 12 00 	movw   $0x1,0x12df00(%eax)
  11a5aa:	01 00 
  11a5ac:	66 c7 80 02 df 12 00 	movw   $0x1,0x12df02(%eax)
  11a5b3:	01 00 
  11a5b5:	66 c7 80 04 df 12 00 	movw   $0xffff,0x12df04(%eax)
  11a5bc:	ff ff 
  11a5be:	83 c0 0c             	add    $0xc,%eax
  11a5c1:	42                   	inc    %edx
  11a5c2:	83 f8 78             	cmp    $0x78,%eax
  11a5c5:	75 d6                	jne    11a59d <device_create+0x490>
	INIT_OBJ_RES_EXECUTE(DEVICE_RESET_ERROR_CODE_ID, res, i,
  11a5c7:	66 c7 05 54 e1 12 00 	movw   $0xc,0x12e154
  11a5ce:	0c 00 
  11a5d0:	c7 05 50 e1 12 00 00 	movl   $0x0,0x12e150
  11a5d7:	00 00 00 
  11a5da:	c6 05 56 e1 12 00 00 	movb   $0x0,0x12e156
  11a5e1:	c7 05 40 e1 12 00 00 	movl   $0x0,0x12e140
  11a5e8:	00 00 00 
  11a5eb:	c7 05 44 e1 12 00 00 	movl   $0x0,0x12e144
  11a5f2:	00 00 00 
  11a5f5:	c7 05 48 e1 12 00 00 	movl   $0x0,0x12e148
  11a5fc:	00 00 00 
  11a5ff:	c7 05 4c e1 12 00 0e 	movl   $0x11a00e,0x12e14c
  11a606:	a0 11 00 
	INIT_OBJ_RES_OPT(DEVICE_CURRENT_TIME_ID, res, i, res_inst, j, 1, true,
  11a609:	66 c7 05 6c e1 12 00 	movw   $0xd,0x12e16c
  11a610:	0d 00 
  11a612:	c7 05 68 e1 12 00 74 	movl   $0x12df74,0x12e168
  11a619:	df 12 00 
  11a61c:	c6 05 6e e1 12 00 01 	movb   $0x1,0x12e16e
  11a623:	c7 05 58 e1 12 00 cd 	movl   $0x11a0cd,0x12e158
  11a62a:	a0 11 00 
  11a62d:	c7 05 5c e1 12 00 30 	movl   $0x11a030,0x12e15c
  11a634:	a0 11 00 
  11a637:	c7 05 60 e1 12 00 eb 	movl   $0x11a9eb,0x12e160
  11a63e:	a9 11 00 
  11a641:	c7 05 64 e1 12 00 00 	movl   $0x0,0x12e164
  11a648:	00 00 00 
  11a64b:	c7 05 74 df 12 00 00 	movl   $0x0,0x12df74
  11a652:	00 00 00 
  11a655:	c7 05 78 df 12 00 00 	movl   $0x0,0x12df78
  11a65c:	00 00 00 
  11a65f:	66 c7 05 7c df 12 00 	movw   $0x0,0x12df7c
  11a666:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_UTC_OFFSET_ID, res, i, res_inst, j);
  11a668:	66 c7 05 84 e1 12 00 	movw   $0xe,0x12e184
  11a66f:	0e 00 
  11a671:	c7 05 80 e1 12 00 80 	movl   $0x12df80,0x12e180
  11a678:	df 12 00 
  11a67b:	c6 05 86 e1 12 00 01 	movb   $0x1,0x12e186
  11a682:	c7 05 70 e1 12 00 00 	movl   $0x0,0x12e170
  11a689:	00 00 00 
  11a68c:	c7 05 74 e1 12 00 00 	movl   $0x0,0x12e174
  11a693:	00 00 00 
  11a696:	c7 05 78 e1 12 00 00 	movl   $0x0,0x12e178
  11a69d:	00 00 00 
  11a6a0:	c7 05 7c e1 12 00 00 	movl   $0x0,0x12e17c
  11a6a7:	00 00 00 
  11a6aa:	c7 05 80 df 12 00 00 	movl   $0x0,0x12df80
  11a6b1:	00 00 00 
  11a6b4:	c7 05 84 df 12 00 00 	movl   $0x0,0x12df84
  11a6bb:	00 00 00 
  11a6be:	66 c7 05 88 df 12 00 	movw   $0x0,0x12df88
  11a6c5:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_TIMEZONE_ID, res, i, res_inst, j);
  11a6c7:	66 c7 05 9c e1 12 00 	movw   $0xf,0x12e19c
  11a6ce:	0f 00 
  11a6d0:	c7 05 98 e1 12 00 8c 	movl   $0x12df8c,0x12e198
  11a6d7:	df 12 00 
  11a6da:	c6 05 9e e1 12 00 01 	movb   $0x1,0x12e19e
  11a6e1:	c7 05 88 e1 12 00 00 	movl   $0x0,0x12e188
  11a6e8:	00 00 00 
  11a6eb:	c7 05 8c e1 12 00 00 	movl   $0x0,0x12e18c
  11a6f2:	00 00 00 
	INIT_OBJ_RES_MULTI_OPTDATA(DEVICE_EXT_DEV_INFO_ID, res, i, res_inst, j,
  11a6f5:	31 c0                	xor    %eax,%eax
	INIT_OBJ_RES_OPTDATA(DEVICE_TIMEZONE_ID, res, i, res_inst, j);
  11a6f7:	c7 05 90 e1 12 00 00 	movl   $0x0,0x12e190
  11a6fe:	00 00 00 
  11a701:	c7 05 94 e1 12 00 00 	movl   $0x0,0x12e194
  11a708:	00 00 00 
  11a70b:	c7 05 8c df 12 00 00 	movl   $0x0,0x12df8c
  11a712:	00 00 00 
  11a715:	c7 05 90 df 12 00 00 	movl   $0x0,0x12df90
  11a71c:	00 00 00 
  11a71f:	66 c7 05 94 df 12 00 	movw   $0x0,0x12df94
  11a726:	00 00 
	INIT_OBJ_RES_DATA(DEVICE_SUPPORTED_BINDING_MODES_ID, res, i,
  11a728:	66 c7 05 b4 e1 12 00 	movw   $0x10,0x12e1b4
  11a72f:	10 00 
  11a731:	c7 05 b0 e1 12 00 98 	movl   $0x12df98,0x12e1b0
  11a738:	df 12 00 
  11a73b:	c6 05 b6 e1 12 00 01 	movb   $0x1,0x12e1b6
  11a742:	c7 05 a0 e1 12 00 00 	movl   $0x0,0x12e1a0
  11a749:	00 00 00 
  11a74c:	c7 05 a4 e1 12 00 00 	movl   $0x0,0x12e1a4
  11a753:	00 00 00 
  11a756:	c7 05 a8 e1 12 00 00 	movl   $0x0,0x12e1a8
  11a75d:	00 00 00 
  11a760:	c7 05 ac e1 12 00 00 	movl   $0x0,0x12e1ac
  11a767:	00 00 00 
  11a76a:	c7 05 98 df 12 00 00 	movl   $0x12ed00,0x12df98
  11a771:	ed 12 00 
  11a774:	c7 05 9c df 12 00 08 	movl   $0x80008,0x12df9c
  11a77b:	00 08 00 
  11a77e:	66 c7 05 a0 df 12 00 	movw   $0x0,0x12dfa0
  11a785:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_TYPE_ID, res, i, res_inst, j);
  11a787:	66 c7 05 cc e1 12 00 	movw   $0x11,0x12e1cc
  11a78e:	11 00 
  11a790:	c7 05 c8 e1 12 00 a4 	movl   $0x12dfa4,0x12e1c8
  11a797:	df 12 00 
  11a79a:	c6 05 ce e1 12 00 01 	movb   $0x1,0x12e1ce
  11a7a1:	c7 05 b8 e1 12 00 00 	movl   $0x0,0x12e1b8
  11a7a8:	00 00 00 
  11a7ab:	c7 05 bc e1 12 00 00 	movl   $0x0,0x12e1bc
  11a7b2:	00 00 00 
  11a7b5:	c7 05 c0 e1 12 00 00 	movl   $0x0,0x12e1c0
  11a7bc:	00 00 00 
  11a7bf:	c7 05 c4 e1 12 00 00 	movl   $0x0,0x12e1c4
  11a7c6:	00 00 00 
  11a7c9:	c7 05 a4 df 12 00 00 	movl   $0x0,0x12dfa4
  11a7d0:	00 00 00 
  11a7d3:	c7 05 a8 df 12 00 00 	movl   $0x0,0x12dfa8
  11a7da:	00 00 00 
  11a7dd:	66 c7 05 ac df 12 00 	movw   $0x0,0x12dfac
  11a7e4:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_HARDWARE_VERSION_ID, res, i, res_inst, j);
  11a7e6:	66 c7 05 e4 e1 12 00 	movw   $0x12,0x12e1e4
  11a7ed:	12 00 
  11a7ef:	c7 05 e0 e1 12 00 b0 	movl   $0x12dfb0,0x12e1e0
  11a7f6:	df 12 00 
  11a7f9:	c6 05 e6 e1 12 00 01 	movb   $0x1,0x12e1e6
  11a800:	c7 05 d0 e1 12 00 00 	movl   $0x0,0x12e1d0
  11a807:	00 00 00 
  11a80a:	c7 05 d4 e1 12 00 00 	movl   $0x0,0x12e1d4
  11a811:	00 00 00 
  11a814:	c7 05 d8 e1 12 00 00 	movl   $0x0,0x12e1d8
  11a81b:	00 00 00 
  11a81e:	c7 05 dc e1 12 00 00 	movl   $0x0,0x12e1dc
  11a825:	00 00 00 
  11a828:	c7 05 b0 df 12 00 00 	movl   $0x0,0x12dfb0
  11a82f:	00 00 00 
  11a832:	c7 05 b4 df 12 00 00 	movl   $0x0,0x12dfb4
  11a839:	00 00 00 
  11a83c:	66 c7 05 b8 df 12 00 	movw   $0x0,0x12dfb8
  11a843:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_SOFTWARE_VERSION_ID, res, i, res_inst, j);
  11a845:	66 c7 05 fc e1 12 00 	movw   $0x13,0x12e1fc
  11a84c:	13 00 
  11a84e:	c7 05 f8 e1 12 00 bc 	movl   $0x12dfbc,0x12e1f8
  11a855:	df 12 00 
  11a858:	c6 05 fe e1 12 00 01 	movb   $0x1,0x12e1fe
  11a85f:	c7 05 e8 e1 12 00 00 	movl   $0x0,0x12e1e8
  11a866:	00 00 00 
  11a869:	c7 05 ec e1 12 00 00 	movl   $0x0,0x12e1ec
  11a870:	00 00 00 
  11a873:	c7 05 f0 e1 12 00 00 	movl   $0x0,0x12e1f0
  11a87a:	00 00 00 
  11a87d:	c7 05 f4 e1 12 00 00 	movl   $0x0,0x12e1f4
  11a884:	00 00 00 
  11a887:	c7 05 bc df 12 00 00 	movl   $0x0,0x12dfbc
  11a88e:	00 00 00 
  11a891:	c7 05 c0 df 12 00 00 	movl   $0x0,0x12dfc0
  11a898:	00 00 00 
  11a89b:	66 c7 05 c4 df 12 00 	movw   $0x0,0x12dfc4
  11a8a2:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_BATTERY_STATUS_ID, res, i, res_inst, j);
  11a8a4:	66 c7 05 14 e2 12 00 	movw   $0x14,0x12e214
  11a8ab:	14 00 
  11a8ad:	c7 05 10 e2 12 00 c8 	movl   $0x12dfc8,0x12e210
  11a8b4:	df 12 00 
  11a8b7:	c6 05 16 e2 12 00 01 	movb   $0x1,0x12e216
  11a8be:	c7 05 00 e2 12 00 00 	movl   $0x0,0x12e200
  11a8c5:	00 00 00 
  11a8c8:	c7 05 04 e2 12 00 00 	movl   $0x0,0x12e204
  11a8cf:	00 00 00 
  11a8d2:	c7 05 08 e2 12 00 00 	movl   $0x0,0x12e208
  11a8d9:	00 00 00 
  11a8dc:	c7 05 0c e2 12 00 00 	movl   $0x0,0x12e20c
  11a8e3:	00 00 00 
  11a8e6:	c7 05 c8 df 12 00 00 	movl   $0x0,0x12dfc8
  11a8ed:	00 00 00 
  11a8f0:	c7 05 cc df 12 00 00 	movl   $0x0,0x12dfcc
  11a8f7:	00 00 00 
  11a8fa:	66 c7 05 d0 df 12 00 	movw   $0x0,0x12dfd0
  11a901:	00 00 
	INIT_OBJ_RES_OPTDATA(DEVICE_MEMORY_TOTAL_ID, res, i, res_inst, j);
  11a903:	66 c7 05 2c e2 12 00 	movw   $0x15,0x12e22c
  11a90a:	15 00 
  11a90c:	c7 05 28 e2 12 00 d4 	movl   $0x12dfd4,0x12e228
  11a913:	df 12 00 
  11a916:	c6 05 2e e2 12 00 01 	movb   $0x1,0x12e22e
  11a91d:	c7 05 18 e2 12 00 00 	movl   $0x0,0x12e218
  11a924:	00 00 00 
  11a927:	c7 05 1c e2 12 00 00 	movl   $0x0,0x12e21c
  11a92e:	00 00 00 
  11a931:	c7 05 20 e2 12 00 00 	movl   $0x0,0x12e220
  11a938:	00 00 00 
  11a93b:	c7 05 24 e2 12 00 00 	movl   $0x0,0x12e224
  11a942:	00 00 00 
  11a945:	c7 05 d4 df 12 00 00 	movl   $0x0,0x12dfd4
  11a94c:	00 00 00 
  11a94f:	c7 05 d8 df 12 00 00 	movl   $0x0,0x12dfd8
  11a956:	00 00 00 
  11a959:	66 c7 05 dc df 12 00 	movw   $0x0,0x12dfdc
  11a960:	00 00 
	INIT_OBJ_RES_MULTI_OPTDATA(DEVICE_EXT_DEV_INFO_ID, res, i, res_inst, j,
  11a962:	66 c7 05 44 e2 12 00 	movw   $0x16,0x12e244
  11a969:	16 00 
  11a96b:	c7 05 40 e2 12 00 e0 	movl   $0x12dfe0,0x12e240
  11a972:	df 12 00 
  11a975:	c6 05 46 e2 12 00 05 	movb   $0x5,0x12e246
  11a97c:	c7 05 30 e2 12 00 00 	movl   $0x0,0x12e230
  11a983:	00 00 00 
  11a986:	c7 05 34 e2 12 00 00 	movl   $0x0,0x12e234
  11a98d:	00 00 00 
  11a990:	c7 05 38 e2 12 00 00 	movl   $0x0,0x12e238
  11a997:	00 00 00 
  11a99a:	c7 05 3c e2 12 00 00 	movl   $0x0,0x12e23c
  11a9a1:	00 00 00 
  11a9a4:	c7 80 e0 df 12 00 00 	movl   $0x0,0x12dfe0(%eax)
  11a9ab:	00 00 00 
  11a9ae:	66 c7 80 e4 df 12 00 	movw   $0x0,0x12dfe4(%eax)
  11a9b5:	00 00 
  11a9b7:	66 c7 80 e6 df 12 00 	movw   $0x0,0x12dfe6(%eax)
  11a9be:	00 00 
  11a9c0:	66 c7 80 e8 df 12 00 	movw   $0xffff,0x12dfe8(%eax)
  11a9c7:	ff ff 
  11a9c9:	83 c0 0c             	add    $0xc,%eax
  11a9cc:	83 f8 3c             	cmp    $0x3c,%eax
  11a9cf:	75 d3                	jne    11a9a4 <device_create+0x897>
	inst.resources = res;
  11a9d1:	c7 05 f8 ec 12 00 20 	movl   $0x12e020,0x12ecf8
  11a9d8:	e0 12 00 
	inst.resource_count = i;
  11a9db:	66 c7 05 fe ec 12 00 	movw   $0x17,0x12ecfe
  11a9e2:	17 00 
}
  11a9e4:	b8 f0 ec 12 00       	mov    $0x12ecf0,%eax
  11a9e9:	c9                   	leave  
  11a9ea:	c3                   	ret    

0011a9eb <current_time_post_write_cb>:
{
  11a9eb:	55                   	push   %ebp
  11a9ec:	89 e5                	mov    %esp,%ebp
  11a9ee:	53                   	push   %ebx
  11a9ef:	8b 55 18             	mov    0x18(%ebp),%edx
	if (data_len == 4U) {
  11a9f2:	66 83 fa 04          	cmp    $0x4,%dx
  11a9f6:	75 33                	jne    11aa2b <current_time_post_write_cb+0x40>
		time_offset = *(int32_t *)data - (int32_t)(k_uptime_get() / 1000);
  11a9f8:	8b 45 14             	mov    0x14(%ebp),%eax
  11a9fb:	8b 18                	mov    (%eax),%ebx
  11a9fd:	e8 85 79 00 00       	call   122387 <z_impl_k_uptime_ticks>
  11aa02:	6a 00                	push   $0x0
  11aa04:	6b ca 0a             	imul   $0xa,%edx,%ecx
  11aa07:	ba 0a 00 00 00       	mov    $0xa,%edx
  11aa0c:	68 e8 03 00 00       	push   $0x3e8
  11aa11:	f7 e2                	mul    %edx
  11aa13:	01 ca                	add    %ecx,%edx
  11aa15:	52                   	push   %edx
  11aa16:	50                   	push   %eax
  11aa17:	e8 c4 56 fe ff       	call   1000e0 <__divdi3>
  11aa1c:	29 c3                	sub    %eax,%ebx
  11aa1e:	83 c4 10             	add    $0x10,%esp
  11aa21:	89 1d 08 ed 12 00    	mov    %ebx,0x12ed08
  11aa27:	31 db                	xor    %ebx,%ebx
  11aa29:	eb 33                	jmp    11aa5e <current_time_post_write_cb+0x73>
	LOG_ERR("unknown size %u", data_len);
  11aa2b:	f6 05 d8 5b 14 00 07 	testb  $0x7,0x145bd8
	return -EINVAL;
  11aa32:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	LOG_ERR("unknown size %u", data_len);
  11aa37:	74 25                	je     11aa5e <current_time_post_write_cb+0x73>
  11aa39:	b8 30 31 12 00       	mov    $0x123130,%eax
  11aa3e:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11aa43:	c1 e8 03             	shr    $0x3,%eax
  11aa46:	c1 e0 06             	shl    $0x6,%eax
  11aa49:	83 c8 01             	or     $0x1,%eax
  11aa4c:	50                   	push   %eax
  11aa4d:	0f b7 d2             	movzwl %dx,%edx
  11aa50:	52                   	push   %edx
  11aa51:	68 9b 7e 12 00       	push   $0x127e9b
  11aa56:	e8 1b 8b fe ff       	call   103576 <log_1>
  11aa5b:	83 c4 0c             	add    $0xc,%esp
}
  11aa5e:	89 d8                	mov    %ebx,%eax
  11aa60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11aa63:	c9                   	leave  
  11aa64:	c3                   	ret    

0011aa65 <buf_read>:
{
  11aa65:	55                   	push   %ebp
  11aa66:	89 e5                	mov    %esp,%ebp
  11aa68:	57                   	push   %edi
  11aa69:	56                   	push   %esi
  11aa6a:	53                   	push   %ebx
  11aa6b:	83 ec 08             	sub    $0x8,%esp
	if (!src) {
  11aa6e:	85 c9                	test   %ecx,%ecx
{
  11aa70:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!src) {
  11aa73:	74 3f                	je     11aab4 <buf_read+0x4f>
	if (*offset + len > src_len) {
  11aa75:	8b 75 0c             	mov    0xc(%ebp),%esi
  11aa78:	89 d7                	mov    %edx,%edi
  11aa7a:	0f b7 db             	movzwl %bx,%ebx
  11aa7d:	0f b7 36             	movzwl (%esi),%esi
  11aa80:	89 75 f0             	mov    %esi,-0x10(%ebp)
  11aa83:	0f b7 f2             	movzwl %dx,%esi
  11aa86:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11aa89:	01 f2                	add    %esi,%edx
  11aa8b:	89 55 ec             	mov    %edx,-0x14(%ebp)
		return -ENOMEM;
  11aa8e:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (*offset + len > src_len) {
  11aa93:	39 5d ec             	cmp    %ebx,-0x14(%ebp)
  11aa96:	7f 21                	jg     11aab9 <buf_read+0x54>
	if (dst) {
  11aa98:	85 c0                	test   %eax,%eax
  11aa9a:	74 0e                	je     11aaaa <buf_read+0x45>
		memcpy(dst, src + *offset, len);
  11aa9c:	03 4d f0             	add    -0x10(%ebp),%ecx
  11aa9f:	56                   	push   %esi
  11aaa0:	51                   	push   %ecx
  11aaa1:	50                   	push   %eax
  11aaa2:	e8 45 13 ff ff       	call   10bdec <memcpy>
  11aaa7:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
  11aaaa:	8b 45 0c             	mov    0xc(%ebp),%eax
	return 0;
  11aaad:	31 d2                	xor    %edx,%edx
	*offset += len;
  11aaaf:	66 01 38             	add    %di,(%eax)
	return 0;
  11aab2:	eb 05                	jmp    11aab9 <buf_read+0x54>
		return -EINVAL;
  11aab4:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  11aab9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11aabc:	89 d0                	mov    %edx,%eax
  11aabe:	5b                   	pop    %ebx
  11aabf:	5e                   	pop    %esi
  11aac0:	5f                   	pop    %edi
  11aac1:	5d                   	pop    %ebp
  11aac2:	c3                   	ret    

0011aac3 <get_bool>:
				      true, true);
}

static size_t get_bool(struct lwm2m_input_context *in,
		       bool *value)
{
  11aac3:	55                   	push   %ebp
  11aac4:	89 e5                	mov    %esp,%ebp
  11aac6:	50                   	push   %eax
  11aac7:	8b 45 08             	mov    0x8(%ebp),%eax
	uint8_t tmp;

	if (buf_read_u8(&tmp, CPKT_BUF_READ(in->in_cpkt), &in->offset) < 0) {
  11aaca:	83 c0 08             	add    $0x8,%eax
  11aacd:	8b 50 fc             	mov    -0x4(%eax),%edx
}

static inline int buf_read_u8(uint8_t *value, uint8_t *src, uint16_t src_len,
			      uint16_t *offset)
{
	return buf_read(value, sizeof(uint8_t), src, src_len, offset);
  11aad0:	50                   	push   %eax
  11aad1:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  11aad5:	8b 0a                	mov    (%edx),%ecx
  11aad7:	50                   	push   %eax
  11aad8:	ba 01 00 00 00       	mov    $0x1,%edx
  11aadd:	8d 45 ff             	lea    -0x1(%ebp),%eax
  11aae0:	e8 80 ff ff ff       	call   11aa65 <buf_read>
  11aae5:	5a                   	pop    %edx
  11aae6:	89 c2                	mov    %eax,%edx
  11aae8:	59                   	pop    %ecx
		return 0;
  11aae9:	31 c0                	xor    %eax,%eax
	if (buf_read_u8(&tmp, CPKT_BUF_READ(in->in_cpkt), &in->offset) < 0) {
  11aaeb:	85 d2                	test   %edx,%edx
  11aaed:	78 19                	js     11ab08 <get_bool+0x45>
	}

	if (tmp == '1' || tmp == '0') {
  11aaef:	8a 55 ff             	mov    -0x1(%ebp),%dl
  11aaf2:	8d 4a d0             	lea    -0x30(%edx),%ecx
  11aaf5:	80 f9 01             	cmp    $0x1,%cl
  11aaf8:	77 0e                	ja     11ab08 <get_bool+0x45>
		*value = (tmp == '1') ? true : false;
  11aafa:	8b 45 0c             	mov    0xc(%ebp),%eax
  11aafd:	80 fa 31             	cmp    $0x31,%dl
  11ab00:	0f 94 00             	sete   (%eax)
		return 1;
  11ab03:	b8 01 00 00 00       	mov    $0x1,%eax
	}

	return 0;
}
  11ab08:	c9                   	leave  
  11ab09:	c3                   	ret    

0011ab0a <get_string>:
{
  11ab0a:	55                   	push   %ebp
  11ab0b:	89 e5                	mov    %esp,%ebp
  11ab0d:	56                   	push   %esi
  11ab0e:	53                   	push   %ebx
  11ab0f:	53                   	push   %ebx
	coap_packet_get_payload(in->in_cpkt, &in_len);
  11ab10:	8d 45 f6             	lea    -0xa(%ebp),%eax
{
  11ab13:	8b 5d 08             	mov    0x8(%ebp),%ebx
	coap_packet_get_payload(in->in_cpkt, &in_len);
  11ab16:	50                   	push   %eax
{
  11ab17:	8b 75 0c             	mov    0xc(%ebp),%esi
	coap_packet_get_payload(in->in_cpkt, &in_len);
  11ab1a:	ff 73 04             	pushl  0x4(%ebx)
  11ab1d:	e8 d5 e0 fe ff       	call   108bf7 <coap_packet_get_payload>
  11ab22:	58                   	pop    %eax
	if (in_len > buflen) {
  11ab23:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
	coap_packet_get_payload(in->in_cpkt, &in_len);
  11ab27:	5a                   	pop    %edx
	if (in_len > buflen) {
  11ab28:	3b 45 10             	cmp    0x10(%ebp),%eax
  11ab2b:	76 08                	jbe    11ab35 <get_string+0x2b>
		in_len = buflen - 1;
  11ab2d:	8b 45 10             	mov    0x10(%ebp),%eax
  11ab30:	48                   	dec    %eax
  11ab31:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	if (buf_read(value, in_len, CPKT_BUF_READ(in->in_cpkt),
  11ab35:	8b 43 04             	mov    0x4(%ebx),%eax
  11ab38:	83 c3 08             	add    $0x8,%ebx
  11ab3b:	53                   	push   %ebx
  11ab3c:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ab40:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
  11ab44:	51                   	push   %ecx
  11ab45:	8b 08                	mov    (%eax),%ecx
  11ab47:	89 f0                	mov    %esi,%eax
  11ab49:	e8 17 ff ff ff       	call   11aa65 <buf_read>
  11ab4e:	5a                   	pop    %edx
  11ab4f:	59                   	pop    %ecx
  11ab50:	85 c0                	test   %eax,%eax
  11ab52:	79 07                	jns    11ab5b <get_string+0x51>
		value[0] = '\0';
  11ab54:	c6 06 00             	movb   $0x0,(%esi)
		return 0;
  11ab57:	31 c0                	xor    %eax,%eax
  11ab59:	eb 08                	jmp    11ab63 <get_string+0x59>
	value[in_len] = '\0';
  11ab5b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  11ab5f:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
}
  11ab63:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11ab66:	5b                   	pop    %ebx
  11ab67:	5e                   	pop    %esi
  11ab68:	5d                   	pop    %ebp
  11ab69:	c3                   	ret    

0011ab6a <get_opaque>:

static size_t get_opaque(struct lwm2m_input_context *in,
			 uint8_t *value, size_t buflen,
			 struct lwm2m_opaque_context *opaque,
			 bool *last_block)
{
  11ab6a:	55                   	push   %ebp
  11ab6b:	89 e5                	mov    %esp,%ebp
  11ab6d:	56                   	push   %esi
  11ab6e:	53                   	push   %ebx
  11ab6f:	51                   	push   %ecx
  11ab70:	8b 5d 14             	mov    0x14(%ebp),%ebx
  11ab73:	8b 75 08             	mov    0x8(%ebp),%esi
	uint16_t in_len;

	if (opaque->remaining == 0) {
  11ab76:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  11ab7a:	75 43                	jne    11abbf <get_opaque+0x55>
		coap_packet_get_payload(in->in_cpkt, &in_len);
  11ab7c:	8d 45 f6             	lea    -0xa(%ebp),%eax
  11ab7f:	50                   	push   %eax
  11ab80:	ff 76 04             	pushl  0x4(%esi)
  11ab83:	e8 6f e0 fe ff       	call   108bf7 <coap_packet_get_payload>
  11ab88:	58                   	pop    %eax
  11ab89:	5a                   	pop    %edx

		if (in->block_ctx != NULL) {
  11ab8a:	8b 56 0c             	mov    0xc(%esi),%edx
  11ab8d:	85 d2                	test   %edx,%edx
  11ab8f:	74 25                	je     11abb6 <get_opaque+0x4c>
  11ab91:	8b 42 08             	mov    0x8(%edx),%eax
  11ab94:	8d 48 04             	lea    0x4(%eax),%ecx
  11ab97:	b8 01 00 00 00       	mov    $0x1,%eax
  11ab9c:	d3 e0                	shl    %cl,%eax
			uint32_t block_num =
				in->block_ctx->ctx.current /
				coap_block_size_to_bytes(
  11ab9e:	0f b7 c0             	movzwl %ax,%eax
					in->block_ctx->ctx.block_size);

			if (block_num == 0) {
  11aba1:	39 42 04             	cmp    %eax,0x4(%edx)
  11aba4:	73 04                	jae    11abaa <get_opaque+0x40>
				opaque->len = in->block_ctx->ctx.total_size;
  11aba6:	8b 02                	mov    (%edx),%eax
  11aba8:	89 03                	mov    %eax,(%ebx)
			}

			if (opaque->len == 0) {
  11abaa:	8b 03                	mov    (%ebx),%eax
  11abac:	85 c0                	test   %eax,%eax
  11abae:	75 0c                	jne    11abbc <get_opaque+0x52>
				/* No size1 option provided, use current
				 * payload size. This will reset on next packet
				 * received.
				 */
				opaque->remaining = in_len;
  11abb0:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  11abb4:	eb 06                	jmp    11abbc <get_opaque+0x52>
			} else {
				opaque->remaining = opaque->len;
			}

		} else {
			opaque->len = in_len;
  11abb6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  11abba:	89 03                	mov    %eax,(%ebx)
			opaque->remaining = in_len;
  11abbc:	89 43 04             	mov    %eax,0x4(%ebx)
		}
	}

	return lwm2m_engine_get_opaque_more(in, value, buflen,
  11abbf:	ff 75 18             	pushl  0x18(%ebp)
  11abc2:	53                   	push   %ebx
  11abc3:	ff 75 10             	pushl  0x10(%ebp)
  11abc6:	ff 75 0c             	pushl  0xc(%ebp)
  11abc9:	56                   	push   %esi
  11abca:	e8 3e d8 ff ff       	call   11840d <lwm2m_engine_get_opaque_more>
  11abcf:	83 c4 14             	add    $0x14,%esp
					    opaque, last_block);
}
  11abd2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11abd5:	5b                   	pop    %ebx
  11abd6:	5e                   	pop    %esi
  11abd7:	5d                   	pop    %ebp
  11abd8:	c3                   	ret    

0011abd9 <plain_text_read_number>:
{
  11abd9:	55                   	push   %ebp
  11abda:	89 e5                	mov    %esp,%ebp
  11abdc:	57                   	push   %edi
  11abdd:	56                   	push   %esi
  11abde:	89 c7                	mov    %eax,%edi
  11abe0:	53                   	push   %ebx
  11abe1:	83 ec 14             	sub    $0x14,%esp
  11abe4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  11abe7:	8a 45 08             	mov    0x8(%ebp),%al
  11abea:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  11abed:	88 45 e1             	mov    %al,-0x1f(%ebp)
  11abf0:	8a 45 0c             	mov    0xc(%ebp),%al
  11abf3:	88 45 e0             	mov    %al,-0x20(%ebp)
	*value1 = 0;
  11abf6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  11abfc:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	if (value2) {
  11ac03:	85 c9                	test   %ecx,%ecx
  11ac05:	74 0d                	je     11ac14 <plain_text_read_number+0x3b>
		*value2 = 0;
  11ac07:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  11ac0d:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
  11ac14:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  11ac17:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  11ac1b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  11ac1f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	while (in->offset < in->in_cpkt->offset) {
  11ac26:	8b 47 04             	mov    0x4(%edi),%eax
  11ac29:	8b 58 04             	mov    0x4(%eax),%ebx
  11ac2c:	66 39 5f 08          	cmp    %bx,0x8(%edi)
  11ac30:	0f 83 95 00 00 00    	jae    11accb <plain_text_read_number+0xf2>
		if (buf_read_u8(&tmp, CPKT_BUF_READ(in->in_cpkt),
  11ac36:	8d 57 08             	lea    0x8(%edi),%edx
  11ac39:	8b 08                	mov    (%eax),%ecx
  11ac3b:	52                   	push   %edx
  11ac3c:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11ac40:	8d 45 f3             	lea    -0xd(%ebp),%eax
  11ac43:	52                   	push   %edx
  11ac44:	ba 01 00 00 00       	mov    $0x1,%edx
  11ac49:	e8 17 fe ff ff       	call   11aa65 <buf_read>
  11ac4e:	5a                   	pop    %edx
  11ac4f:	59                   	pop    %ecx
  11ac50:	85 c0                	test   %eax,%eax
  11ac52:	78 77                	js     11accb <plain_text_read_number+0xf2>
		if (tmp == '-' && accept_sign && i == 0) {
  11ac54:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
  11ac58:	80 f9 2d             	cmp    $0x2d,%cl
  11ac5b:	75 0e                	jne    11ac6b <plain_text_read_number+0x92>
  11ac5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  11ac61:	0f 94 c0             	sete   %al
  11ac64:	22 45 e1             	and    -0x1f(%ebp),%al
  11ac67:	75 4f                	jne    11acb8 <plain_text_read_number+0xdf>
  11ac69:	eb 22                	jmp    11ac8d <plain_text_read_number+0xb4>
		} else if (tmp == '.' && i > 0 && accept_dot && !dot_found &&
  11ac6b:	80 f9 2e             	cmp    $0x2e,%cl
  11ac6e:	75 1d                	jne    11ac8d <plain_text_read_number+0xb4>
  11ac70:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  11ac74:	7e 17                	jle    11ac8d <plain_text_read_number+0xb4>
  11ac76:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
  11ac7a:	74 11                	je     11ac8d <plain_text_read_number+0xb4>
  11ac7c:	8a 45 e2             	mov    -0x1e(%ebp),%al
  11ac7f:	83 f0 01             	xor    $0x1,%eax
  11ac82:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  11ac86:	0f 95 c2             	setne  %dl
  11ac89:	20 d0                	and    %dl,%al
  11ac8b:	75 30                	jne    11acbd <plain_text_read_number+0xe4>
  11ac8d:	8d 59 d0             	lea    -0x30(%ecx),%ebx
		} else if (isdigit(tmp)) {
  11ac90:	83 fb 09             	cmp    $0x9,%ebx
  11ac93:	77 1d                	ja     11acb2 <plain_text_read_number+0xd9>
			*counter = *counter * 10 + (tmp - '0');
  11ac95:	b8 0a 00 00 00       	mov    $0xa,%eax
  11ac9a:	6b 4e 04 0a          	imul   $0xa,0x4(%esi),%ecx
  11ac9e:	f7 26                	mull   (%esi)
  11aca0:	01 ca                	add    %ecx,%edx
  11aca2:	89 d9                	mov    %ebx,%ecx
  11aca4:	c1 fb 1f             	sar    $0x1f,%ebx
  11aca7:	01 c8                	add    %ecx,%eax
  11aca9:	11 da                	adc    %ebx,%edx
  11acab:	89 06                	mov    %eax,(%esi)
  11acad:	89 56 04             	mov    %edx,0x4(%esi)
  11acb0:	eb 11                	jmp    11acc3 <plain_text_read_number+0xea>
			in->offset--;
  11acb2:	66 ff 4f 08          	decw   0x8(%edi)
			break;
  11acb6:	eb 13                	jmp    11accb <plain_text_read_number+0xf2>
			neg = true;
  11acb8:	88 45 e3             	mov    %al,-0x1d(%ebp)
  11acbb:	eb 06                	jmp    11acc3 <plain_text_read_number+0xea>
			dot_found = true;
  11acbd:	88 45 e2             	mov    %al,-0x1e(%ebp)
  11acc0:	8b 75 e8             	mov    -0x18(%ebp),%esi
		i++;
  11acc3:	ff 45 ec             	incl   -0x14(%ebp)
  11acc6:	e9 5b ff ff ff       	jmp    11ac26 <plain_text_read_number+0x4d>
	if (neg) {
  11accb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  11accf:	74 0c                	je     11acdd <plain_text_read_number+0x104>
		*value1 = -*value1;
  11acd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11acd4:	f7 18                	negl   (%eax)
  11acd6:	83 50 04 00          	adcl   $0x0,0x4(%eax)
  11acda:	f7 58 04             	negl   0x4(%eax)
}
  11acdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11ace0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11ace3:	5b                   	pop    %ebx
  11ace4:	5e                   	pop    %esi
  11ace5:	5f                   	pop    %edi
  11ace6:	5d                   	pop    %ebp
  11ace7:	c3                   	ret    

0011ace8 <get_objlnk>:


static size_t get_objlnk(struct lwm2m_input_context *in,
			 struct lwm2m_objlnk *value)
{
  11ace8:	55                   	push   %ebp
	int64_t tmp;
	size_t len;

	len = plain_text_read_number(in, &tmp, NULL, false, false);
  11ace9:	31 c9                	xor    %ecx,%ecx
{
  11aceb:	89 e5                	mov    %esp,%ebp
  11aced:	57                   	push   %edi
  11acee:	56                   	push   %esi
  11acef:	53                   	push   %ebx
	len = plain_text_read_number(in, &tmp, NULL, false, false);
  11acf0:	8d 55 ec             	lea    -0x14(%ebp),%edx
{
  11acf3:	83 ec 08             	sub    $0x8,%esp
  11acf6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11acf9:	8b 7d 0c             	mov    0xc(%ebp),%edi
	len = plain_text_read_number(in, &tmp, NULL, false, false);
  11acfc:	6a 00                	push   $0x0
  11acfe:	89 d8                	mov    %ebx,%eax
  11ad00:	6a 00                	push   $0x0
  11ad02:	e8 d2 fe ff ff       	call   11abd9 <plain_text_read_number>
  11ad07:	5a                   	pop    %edx
  11ad08:	89 c6                	mov    %eax,%esi
	value->obj_id = (uint16_t)tmp;
  11ad0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
	len = plain_text_read_number(in, &tmp, NULL, false, false);
  11ad0d:	59                   	pop    %ecx
	value->obj_id = (uint16_t)tmp;
  11ad0e:	66 89 07             	mov    %ax,(%edi)

	/* Skip ':' delimeter. */
	in->offset++;
	len++;

	len += plain_text_read_number(in, &tmp, NULL, false, false);
  11ad11:	8d 55 ec             	lea    -0x14(%ebp),%edx
	in->offset++;
  11ad14:	66 ff 43 08          	incw   0x8(%ebx)
	len += plain_text_read_number(in, &tmp, NULL, false, false);
  11ad18:	89 d8                	mov    %ebx,%eax
  11ad1a:	6a 00                	push   $0x0
  11ad1c:	31 c9                	xor    %ecx,%ecx
  11ad1e:	6a 00                	push   $0x0
  11ad20:	e8 b4 fe ff ff       	call   11abd9 <plain_text_read_number>
  11ad25:	5b                   	pop    %ebx
  11ad26:	5a                   	pop    %edx
	value->obj_inst = (uint16_t)tmp;
  11ad27:	8b 55 ec             	mov    -0x14(%ebp),%edx
  11ad2a:	66 89 57 02          	mov    %dx,0x2(%edi)

	return len;
}
  11ad2e:	8d 65 f4             	lea    -0xc(%ebp),%esp
	len += plain_text_read_number(in, &tmp, NULL, false, false);
  11ad31:	8d 44 06 01          	lea    0x1(%esi,%eax,1),%eax
}
  11ad35:	5b                   	pop    %ebx
  11ad36:	5e                   	pop    %esi
  11ad37:	5f                   	pop    %edi
  11ad38:	5d                   	pop    %ebp
  11ad39:	c3                   	ret    

0011ad3a <get_float64fix>:
{
  11ad3a:	55                   	push   %ebp
  11ad3b:	89 e5                	mov    %esp,%ebp
  11ad3d:	8b 55 0c             	mov    0xc(%ebp),%edx
  11ad40:	8b 45 08             	mov    0x8(%ebp),%eax
	return plain_text_read_number(in, &value->val1, &value->val2,
  11ad43:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
  11ad4a:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
  11ad51:	8d 4a 08             	lea    0x8(%edx),%ecx
}
  11ad54:	5d                   	pop    %ebp
	return plain_text_read_number(in, &value->val1, &value->val2,
  11ad55:	e9 7f fe ff ff       	jmp    11abd9 <plain_text_read_number>

0011ad5a <get_float32fix>:
{
  11ad5a:	55                   	push   %ebp
  11ad5b:	89 e5                	mov    %esp,%ebp
  11ad5d:	53                   	push   %ebx
  11ad5e:	83 ec 10             	sub    $0x10,%esp
	len = plain_text_read_number(in, &tmp1, &tmp2, true, true);
  11ad61:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  11ad64:	8d 55 ec             	lea    -0x14(%ebp),%edx
  11ad67:	6a 01                	push   $0x1
  11ad69:	8b 45 08             	mov    0x8(%ebp),%eax
  11ad6c:	6a 01                	push   $0x1
{
  11ad6e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len = plain_text_read_number(in, &tmp1, &tmp2, true, true);
  11ad71:	e8 63 fe ff ff       	call   11abd9 <plain_text_read_number>
  11ad76:	5a                   	pop    %edx
  11ad77:	59                   	pop    %ecx
	if (len > 0) {
  11ad78:	85 c0                	test   %eax,%eax
  11ad7a:	74 0b                	je     11ad87 <get_float32fix+0x2d>
		value->val1 = (int32_t)tmp1;
  11ad7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  11ad7f:	89 13                	mov    %edx,(%ebx)
		value->val2 = (int32_t)tmp2;
  11ad81:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11ad84:	89 53 04             	mov    %edx,0x4(%ebx)
}
  11ad87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11ad8a:	c9                   	leave  
  11ad8b:	c3                   	ret    

0011ad8c <get_s64>:
{
  11ad8c:	55                   	push   %ebp
	return plain_text_read_number(in, value, NULL, true, false);
  11ad8d:	31 c9                	xor    %ecx,%ecx
{
  11ad8f:	89 e5                	mov    %esp,%ebp
  11ad91:	8b 45 08             	mov    0x8(%ebp),%eax
  11ad94:	8b 55 0c             	mov    0xc(%ebp),%edx
	return plain_text_read_number(in, value, NULL, true, false);
  11ad97:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
  11ad9e:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
  11ada5:	5d                   	pop    %ebp
	return plain_text_read_number(in, value, NULL, true, false);
  11ada6:	e9 2e fe ff ff       	jmp    11abd9 <plain_text_read_number>

0011adab <get_s32>:
{
  11adab:	55                   	push   %ebp
	len = plain_text_read_number(in, &tmp, NULL, true, false);
  11adac:	31 c9                	xor    %ecx,%ecx
{
  11adae:	89 e5                	mov    %esp,%ebp
  11adb0:	83 ec 08             	sub    $0x8,%esp
	len = plain_text_read_number(in, &tmp, NULL, true, false);
  11adb3:	8d 55 f8             	lea    -0x8(%ebp),%edx
  11adb6:	6a 00                	push   $0x0
  11adb8:	8b 45 08             	mov    0x8(%ebp),%eax
  11adbb:	6a 01                	push   $0x1
	int64_t tmp = 0;
  11adbd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  11adc4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	len = plain_text_read_number(in, &tmp, NULL, true, false);
  11adcb:	e8 09 fe ff ff       	call   11abd9 <plain_text_read_number>
  11add0:	5a                   	pop    %edx
  11add1:	59                   	pop    %ecx
	if (len > 0) {
  11add2:	85 c0                	test   %eax,%eax
  11add4:	74 08                	je     11adde <get_s32+0x33>
		*value = (int32_t)tmp;
  11add6:	8b 55 0c             	mov    0xc(%ebp),%edx
  11add9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11addc:	89 0a                	mov    %ecx,(%edx)
}
  11adde:	c9                   	leave  
  11addf:	c3                   	ret    

0011ade0 <put_string>:
{
  11ade0:	55                   	push   %ebp
  11ade1:	89 e5                	mov    %esp,%ebp
  11ade3:	57                   	push   %edi
  11ade4:	56                   	push   %esi
  11ade5:	53                   	push   %ebx
  11ade6:	83 ec 08             	sub    $0x8,%esp
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, buflen) < 0) {
  11ade9:	8b 45 08             	mov    0x8(%ebp),%eax
{
  11adec:	8b 75 14             	mov    0x14(%ebp),%esi
  11adef:	66 89 75 ee          	mov    %si,-0x12(%ebp)
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), buf, buflen) < 0) {
  11adf3:	8b 58 04             	mov    0x4(%eax),%ebx
  11adf6:	8b 3b                	mov    (%ebx),%edi
  11adf8:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  11adfc:	89 7d f0             	mov    %edi,-0x10(%ebp)
	if (!dst || !src) {
  11adff:	85 ff                	test   %edi,%edi
  11ae01:	74 2e                	je     11ae31 <put_string+0x51>
  11ae03:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  11ae07:	74 28                	je     11ae31 <put_string+0x51>
	if (*dst_len + src_len > dst_size) {
  11ae09:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
  11ae0d:	0f b7 ce             	movzwl %si,%ecx
  11ae10:	89 c7                	mov    %eax,%edi
  11ae12:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  11ae15:	39 c7                	cmp    %eax,%edi
  11ae17:	7c 18                	jl     11ae31 <put_string+0x51>
	memcpy(dst + *dst_len, src, src_len);
  11ae19:	51                   	push   %ecx
  11ae1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ae1d:	ff 75 10             	pushl  0x10(%ebp)
  11ae20:	01 d0                	add    %edx,%eax
  11ae22:	50                   	push   %eax
  11ae23:	e8 c4 0f ff ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11ae28:	66 01 73 04          	add    %si,0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
  11ae2c:	83 c4 0c             	add    $0xc,%esp
	return 0;
  11ae2f:	eb 02                	jmp    11ae33 <put_string+0x53>
		return 0;
  11ae31:	31 f6                	xor    %esi,%esi
}
  11ae33:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11ae36:	89 f0                	mov    %esi,%eax
  11ae38:	5b                   	pop    %ebx
  11ae39:	5e                   	pop    %esi
  11ae3a:	5f                   	pop    %edi
  11ae3b:	5d                   	pop    %ebp
  11ae3c:	c3                   	ret    

0011ae3d <plain_text_put_format>:
{
  11ae3d:	55                   	push   %ebp
  11ae3e:	89 e5                	mov    %esp,%ebp
  11ae40:	57                   	push   %edi
  11ae41:	56                   	push   %esi
  11ae42:	53                   	push   %ebx
	va_start(vargs, format);
  11ae43:	8d 45 10             	lea    0x10(%ebp),%eax
{
  11ae46:	83 ec 08             	sub    $0x8,%esp
	n = vsnprintk(pt_buffer, sizeof(pt_buffer), format, vargs);
  11ae49:	50                   	push   %eax
  11ae4a:	ff 75 0c             	pushl  0xc(%ebp)
  11ae4d:	6a 2a                	push   $0x2a
  11ae4f:	68 80 e2 12 00       	push   $0x12e280
  11ae54:	e8 64 64 fe ff       	call   1012bd <vsnprintk>
  11ae59:	83 c4 10             	add    $0x10,%esp
	if (n < 0) {
  11ae5c:	85 c0                	test   %eax,%eax
  11ae5e:	79 04                	jns    11ae64 <plain_text_put_format+0x27>
		return 0;
  11ae60:	31 db                	xor    %ebx,%ebx
  11ae62:	eb 4c                	jmp    11aeb0 <plain_text_put_format+0x73>
	n = strlen(pt_buffer);
  11ae64:	68 80 e2 12 00       	push   $0x12e280
  11ae69:	e8 ae 0e ff ff       	call   10bd1c <strlen>
  11ae6e:	89 c3                	mov    %eax,%ebx
  11ae70:	5a                   	pop    %edx
  11ae71:	0f b7 c8             	movzwl %ax,%ecx
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), pt_buffer, n) < 0) {
  11ae74:	8b 45 08             	mov    0x8(%ebp),%eax
  11ae77:	66 89 5d ee          	mov    %bx,-0x12(%ebp)
  11ae7b:	8b 70 04             	mov    0x4(%eax),%esi
  11ae7e:	8b 3e                	mov    (%esi),%edi
  11ae80:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  11ae84:	89 7d f0             	mov    %edi,-0x10(%ebp)
	if (!dst || !src) {
  11ae87:	85 ff                	test   %edi,%edi
  11ae89:	74 d5                	je     11ae60 <plain_text_put_format+0x23>
	if (*dst_len + src_len > dst_size) {
  11ae8b:	0f b7 56 04          	movzwl 0x4(%esi),%edx
  11ae8f:	89 c7                	mov    %eax,%edi
  11ae91:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
  11ae94:	39 c7                	cmp    %eax,%edi
  11ae96:	7c c8                	jl     11ae60 <plain_text_put_format+0x23>
	memcpy(dst + *dst_len, src, src_len);
  11ae98:	51                   	push   %ecx
  11ae99:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ae9c:	68 80 e2 12 00       	push   $0x12e280
  11aea1:	01 d0                	add    %edx,%eax
  11aea3:	50                   	push   %eax
  11aea4:	e8 43 0f ff ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11aea9:	66 01 5e 04          	add    %bx,0x4(%esi)
	memcpy(dst + *dst_len, src, src_len);
  11aead:	83 c4 0c             	add    $0xc,%esp
}
  11aeb0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11aeb3:	89 d8                	mov    %ebx,%eax
  11aeb5:	5b                   	pop    %ebx
  11aeb6:	5e                   	pop    %esi
  11aeb7:	5f                   	pop    %edi
  11aeb8:	5d                   	pop    %ebp
  11aeb9:	c3                   	ret    

0011aeba <plain_text_put_float32fix>:
{
  11aeba:	55                   	push   %ebp
  11aebb:	89 e5                	mov    %esp,%ebp
  11aebd:	56                   	push   %esi
  11aebe:	53                   	push   %ebx
  11aebf:	83 ec 08             	sub    $0x8,%esp
	len = snprintk(buf, sizeof(buf), "%06d", abs(value->val2));
  11aec2:	8d 5d f1             	lea    -0xf(%ebp),%ebx
{
  11aec5:	8b 75 10             	mov    0x10(%ebp),%esi
	len = snprintk(buf, sizeof(buf), "%06d", abs(value->val2));
  11aec8:	8b 46 04             	mov    0x4(%esi),%eax
  11aecb:	8b 56 04             	mov    0x4(%esi),%edx
  11aece:	c1 f8 1f             	sar    $0x1f,%eax
  11aed1:	31 c2                	xor    %eax,%edx
  11aed3:	29 c2                	sub    %eax,%edx
  11aed5:	52                   	push   %edx
  11aed6:	68 c0 7e 12 00       	push   $0x127ec0
  11aedb:	6a 07                	push   $0x7
  11aedd:	53                   	push   %ebx
  11aede:	e8 1c 64 fe ff       	call   1012ff <snprintk>
  11aee3:	83 c4 10             	add    $0x10,%esp
	if (len != 6U) {
  11aee6:	83 f8 06             	cmp    $0x6,%eax
  11aee9:	75 05                	jne    11aef0 <plain_text_put_float32fix+0x36>
  11aeeb:	8d 45 f6             	lea    -0xa(%ebp),%eax
  11aeee:	eb 17                	jmp    11af07 <plain_text_put_float32fix+0x4d>
		strcpy(buf, "0");
  11aef0:	68 13 49 12 00       	push   $0x124913
  11aef5:	53                   	push   %ebx
  11aef6:	e8 86 0d ff ff       	call   10bc81 <strcpy>
  11aefb:	58                   	pop    %eax
  11aefc:	5a                   	pop    %edx
  11aefd:	eb 0d                	jmp    11af0c <plain_text_put_float32fix+0x52>
			buf[--len] = '\0';
  11aeff:	c6 00 00             	movb   $0x0,(%eax)
		while (len > 1U && buf[len - 1] == '0') {
  11af02:	48                   	dec    %eax
  11af03:	39 d8                	cmp    %ebx,%eax
  11af05:	74 05                	je     11af0c <plain_text_put_float32fix+0x52>
  11af07:	80 38 30             	cmpb   $0x30,(%eax)
  11af0a:	74 f3                	je     11aeff <plain_text_put_float32fix+0x45>
	return plain_text_put_format(out, "%s%d.%s",
  11af0c:	8b 16                	mov    (%esi),%edx
  11af0e:	b8 02 4e 12 00       	mov    $0x124e02,%eax
  11af13:	85 d2                	test   %edx,%edx
  11af15:	75 0b                	jne    11af22 <plain_text_put_float32fix+0x68>
				     (value->val1 == 0 && value->val2 < 0) ?
  11af17:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  11af1b:	79 05                	jns    11af22 <plain_text_put_float32fix+0x68>
	return plain_text_put_format(out, "%s%d.%s",
  11af1d:	b8 5c 75 12 00       	mov    $0x12755c,%eax
  11af22:	53                   	push   %ebx
  11af23:	52                   	push   %edx
  11af24:	50                   	push   %eax
  11af25:	68 c5 7e 12 00       	push   $0x127ec5
  11af2a:	ff 75 08             	pushl  0x8(%ebp)
  11af2d:	e8 0b ff ff ff       	call   11ae3d <plain_text_put_format>
  11af32:	83 c4 14             	add    $0x14,%esp
}
  11af35:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11af38:	5b                   	pop    %ebx
  11af39:	5e                   	pop    %esi
  11af3a:	5d                   	pop    %ebp
  11af3b:	c3                   	ret    

0011af3c <plain_text_put_float64fix>:
{
  11af3c:	55                   	push   %ebp
  11af3d:	89 e5                	mov    %esp,%ebp
  11af3f:	57                   	push   %edi
  11af40:	56                   	push   %esi
  11af41:	53                   	push   %ebx
  11af42:	83 ec 0c             	sub    $0xc,%esp
  11af45:	8b 75 10             	mov    0x10(%ebp),%esi
	len = snprintf(buf, sizeof(buf), "%09lld",
  11af48:	8b 5e 0c             	mov    0xc(%esi),%ebx
  11af4b:	8b 7e 08             	mov    0x8(%esi),%edi
  11af4e:	c1 fb 1f             	sar    $0x1f,%ebx
  11af51:	31 df                	xor    %ebx,%edi
  11af53:	89 d8                	mov    %ebx,%eax
  11af55:	89 f9                	mov    %edi,%ecx
  11af57:	8b 7e 0c             	mov    0xc(%esi),%edi
  11af5a:	31 df                	xor    %ebx,%edi
  11af5c:	29 c1                	sub    %eax,%ecx
  11af5e:	89 fb                	mov    %edi,%ebx
  11af60:	19 c3                	sbb    %eax,%ebx
  11af62:	53                   	push   %ebx
  11af63:	8d 5d ea             	lea    -0x16(%ebp),%ebx
  11af66:	51                   	push   %ecx
  11af67:	68 cd 7e 12 00       	push   $0x127ecd
  11af6c:	6a 0a                	push   $0xa
  11af6e:	53                   	push   %ebx
  11af6f:	e8 8a 0f ff ff       	call   10befe <snprintf>
  11af74:	83 c4 14             	add    $0x14,%esp
	if (len != 9U) {
  11af77:	83 f8 09             	cmp    $0x9,%eax
  11af7a:	75 05                	jne    11af81 <plain_text_put_float64fix+0x45>
  11af7c:	8d 45 f2             	lea    -0xe(%ebp),%eax
  11af7f:	eb 17                	jmp    11af98 <plain_text_put_float64fix+0x5c>
		strcpy(buf, "0");
  11af81:	68 13 49 12 00       	push   $0x124913
  11af86:	53                   	push   %ebx
  11af87:	e8 f5 0c ff ff       	call   10bc81 <strcpy>
  11af8c:	58                   	pop    %eax
  11af8d:	5a                   	pop    %edx
  11af8e:	eb 0d                	jmp    11af9d <plain_text_put_float64fix+0x61>
			buf[--len] = '\0';
  11af90:	c6 00 00             	movb   $0x0,(%eax)
		while (len > 1U && buf[len - 1] == '0') {
  11af93:	48                   	dec    %eax
  11af94:	39 d8                	cmp    %ebx,%eax
  11af96:	74 05                	je     11af9d <plain_text_put_float64fix+0x61>
  11af98:	80 38 30             	cmpb   $0x30,(%eax)
  11af9b:	74 f3                	je     11af90 <plain_text_put_float64fix+0x54>
	return plain_text_put_format(out, "%s%lld.%s",
  11af9d:	8b 56 04             	mov    0x4(%esi),%edx
  11afa0:	8b 06                	mov    (%esi),%eax
  11afa2:	89 d7                	mov    %edx,%edi
  11afa4:	b9 02 4e 12 00       	mov    $0x124e02,%ecx
  11afa9:	09 c7                	or     %eax,%edi
  11afab:	75 0b                	jne    11afb8 <plain_text_put_float64fix+0x7c>
				     (value->val1 == 0 && value->val2 < 0) ?
  11afad:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  11afb1:	79 05                	jns    11afb8 <plain_text_put_float64fix+0x7c>
	return plain_text_put_format(out, "%s%lld.%s",
  11afb3:	b9 5c 75 12 00       	mov    $0x12755c,%ecx
  11afb8:	53                   	push   %ebx
  11afb9:	52                   	push   %edx
  11afba:	50                   	push   %eax
  11afbb:	51                   	push   %ecx
  11afbc:	68 d4 7e 12 00       	push   $0x127ed4
  11afc1:	ff 75 08             	pushl  0x8(%ebp)
  11afc4:	e8 74 fe ff ff       	call   11ae3d <plain_text_put_format>
  11afc9:	83 c4 18             	add    $0x18,%esp
}
  11afcc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11afcf:	5b                   	pop    %ebx
  11afd0:	5e                   	pop    %esi
  11afd1:	5f                   	pop    %edi
  11afd2:	5d                   	pop    %ebp
  11afd3:	c3                   	ret    

0011afd4 <put_objlnk>:
{
  11afd4:	55                   	push   %ebp
  11afd5:	89 e5                	mov    %esp,%ebp
  11afd7:	8b 45 10             	mov    0x10(%ebp),%eax
	return plain_text_put_format(out, "%u:%u", value->obj_id,
  11afda:	0f b7 50 02          	movzwl 0x2(%eax),%edx
  11afde:	52                   	push   %edx
  11afdf:	0f b7 00             	movzwl (%eax),%eax
  11afe2:	50                   	push   %eax
  11afe3:	68 de 7e 12 00       	push   $0x127ede
  11afe8:	ff 75 08             	pushl  0x8(%ebp)
  11afeb:	e8 4d fe ff ff       	call   11ae3d <plain_text_put_format>
  11aff0:	83 c4 10             	add    $0x10,%esp
}
  11aff3:	c9                   	leave  
  11aff4:	c3                   	ret    

0011aff5 <put_bool>:
{
  11aff5:	55                   	push   %ebp
  11aff6:	89 e5                	mov    %esp,%ebp
	if (value) {
  11aff8:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
  11affc:	74 09                	je     11b007 <put_bool+0x12>
		return plain_text_put_format(out, "%u", 1);
  11affe:	c7 45 10 01 00 00 00 	movl   $0x1,0x10(%ebp)
  11b005:	eb 07                	jmp    11b00e <put_bool+0x19>
		return plain_text_put_format(out, "%u", 0);
  11b007:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
  11b00e:	c7 45 0c 4b 82 12 00 	movl   $0x12824b,0xc(%ebp)
}
  11b015:	5d                   	pop    %ebp
		return plain_text_put_format(out, "%u", 0);
  11b016:	e9 22 fe ff ff       	jmp    11ae3d <plain_text_put_format>

0011b01b <put_s64>:
{
  11b01b:	55                   	push   %ebp
  11b01c:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%lld", value);
  11b01e:	c7 45 0c e4 7e 12 00 	movl   $0x127ee4,0xc(%ebp)
}
  11b025:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%lld", value);
  11b026:	e9 12 fe ff ff       	jmp    11ae3d <plain_text_put_format>

0011b02b <put_s32>:
{
  11b02b:	55                   	push   %ebp
  11b02c:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%d", value);
  11b02e:	c7 45 0c 62 61 12 00 	movl   $0x126162,0xc(%ebp)
}
  11b035:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%d", value);
  11b036:	e9 02 fe ff ff       	jmp    11ae3d <plain_text_put_format>

0011b03b <put_s16>:
{
  11b03b:	55                   	push   %ebp
  11b03c:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%d", value);
  11b03e:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  11b042:	c7 45 0c 62 61 12 00 	movl   $0x126162,0xc(%ebp)
  11b049:	89 45 10             	mov    %eax,0x10(%ebp)
}
  11b04c:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%d", value);
  11b04d:	e9 eb fd ff ff       	jmp    11ae3d <plain_text_put_format>

0011b052 <put_s8>:
{
  11b052:	55                   	push   %ebp
  11b053:	89 e5                	mov    %esp,%ebp
	return plain_text_put_format(out, "%d", value);
  11b055:	0f be 45 10          	movsbl 0x10(%ebp),%eax
  11b059:	c7 45 0c 62 61 12 00 	movl   $0x126162,0xc(%ebp)
  11b060:	89 45 10             	mov    %eax,0x10(%ebp)
}
  11b063:	5d                   	pop    %ebp
	return plain_text_put_format(out, "%d", value);
  11b064:	e9 d4 fd ff ff       	jmp    11ae3d <plain_text_put_format>

0011b069 <do_read_op_plain_text>:
	.get_opaque = get_opaque,
	.get_objlnk = get_objlnk,
};

int do_read_op_plain_text(struct lwm2m_message *msg, int content_format)
{
  11b069:	55                   	push   %ebp
  11b06a:	89 e5                	mov    %esp,%ebp
	/* Plain text can only return single resource */
	if (msg->path.level != 3U) {
  11b06c:	8b 55 08             	mov    0x8(%ebp),%edx
{
  11b06f:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (msg->path.level != 3U) {
  11b072:	80 7a 2c 03          	cmpb   $0x3,0x2c(%edx)
  11b076:	75 0c                	jne    11b084 <do_read_op_plain_text+0x1b>
		return -EPERM; /* NOT_ALLOWED */
	}

	return lwm2m_perform_read_op(msg, content_format);
  11b078:	0f b7 c0             	movzwl %ax,%eax
  11b07b:	89 45 0c             	mov    %eax,0xc(%ebp)
}
  11b07e:	5d                   	pop    %ebp
	return lwm2m_perform_read_op(msg, content_format);
  11b07f:	e9 4d d7 ff ff       	jmp    1187d1 <lwm2m_perform_read_op>
}
  11b084:	83 c8 ff             	or     $0xffffffff,%eax
  11b087:	5d                   	pop    %ebp
  11b088:	c3                   	ret    

0011b089 <do_write_op_plain_text>:

int do_write_op_plain_text(struct lwm2m_message *msg)
{
  11b089:	55                   	push   %ebp
  11b08a:	89 e5                	mov    %esp,%ebp
  11b08c:	57                   	push   %edi
  11b08d:	56                   	push   %esi
  11b08e:	53                   	push   %ebx
	struct lwm2m_engine_res *res = NULL;
	struct lwm2m_engine_res_inst *res_inst = NULL;
	int ret, i;
	uint8_t created = 0U;

	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
  11b08f:	8d 45 ef             	lea    -0x11(%ebp),%eax
{
  11b092:	83 ec 10             	sub    $0x10,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11b095:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
{
  11b09c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t created = 0U;
  11b09f:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
  11b0a3:	50                   	push   %eax
  11b0a4:	8d 45 f0             	lea    -0x10(%ebp),%eax
  11b0a7:	50                   	push   %eax
  11b0a8:	53                   	push   %ebx
  11b0a9:	e8 ae db ff ff       	call   118c5c <lwm2m_get_or_create_engine_obj>
  11b0ae:	83 c4 0c             	add    $0xc,%esp
  11b0b1:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
  11b0b3:	85 c0                	test   %eax,%eax
  11b0b5:	0f 88 a2 00 00 00    	js     11b15d <do_write_op_plain_text+0xd4>
		return ret;
	}

	obj_field = lwm2m_get_engine_obj_field(obj_inst->obj, msg->path.res_id);
  11b0bb:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  11b0bf:	50                   	push   %eax
  11b0c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (!obj_field) {
		return -ENOENT;
  11b0c3:	be fe ff ff ff       	mov    $0xfffffffe,%esi
	obj_field = lwm2m_get_engine_obj_field(obj_inst->obj, msg->path.res_id);
  11b0c8:	ff 70 04             	pushl  0x4(%eax)
  11b0cb:	e8 2d a2 ff ff       	call   1152fd <lwm2m_get_engine_obj_field>
  11b0d0:	5a                   	pop    %edx
  11b0d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  11b0d4:	59                   	pop    %ecx
	if (!obj_field) {
  11b0d5:	85 c0                	test   %eax,%eax
  11b0d7:	0f 84 80 00 00 00    	je     11b15d <do_write_op_plain_text+0xd4>
	}

	if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
  11b0dd:	8a 50 02             	mov    0x2(%eax),%dl
		return -EPERM;
  11b0e0:	83 ce ff             	or     $0xffffffff,%esi
	if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
  11b0e3:	83 e2 06             	and    $0x6,%edx
  11b0e6:	80 fa 06             	cmp    $0x6,%dl
  11b0e9:	75 72                	jne    11b15d <do_write_op_plain_text+0xd4>
	}

	if (!obj_inst->resources || obj_inst->resource_count == 0U) {
  11b0eb:	8b 7d f0             	mov    -0x10(%ebp),%edi
		return -EINVAL;
  11b0ee:	be ea ff ff ff       	mov    $0xffffffea,%esi
	if (!obj_inst->resources || obj_inst->resource_count == 0U) {
  11b0f3:	8b 57 08             	mov    0x8(%edi),%edx
  11b0f6:	85 d2                	test   %edx,%edx
  11b0f8:	74 63                	je     11b15d <do_write_op_plain_text+0xd4>
  11b0fa:	0f b7 4f 0e          	movzwl 0xe(%edi),%ecx
  11b0fe:	66 85 c9             	test   %cx,%cx
  11b101:	74 5a                	je     11b15d <do_write_op_plain_text+0xd4>
	}

	for (i = 0; i < obj_inst->resource_count; i++) {
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
  11b103:	8b 73 28             	mov    0x28(%ebx),%esi
  11b106:	89 f0                	mov    %esi,%eax
	for (i = 0; i < obj_inst->resource_count; i++) {
  11b108:	31 f6                	xor    %esi,%esi
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
  11b10a:	66 39 42 14          	cmp    %ax,0x14(%edx)
  11b10e:	75 0b                	jne    11b11b <do_write_op_plain_text+0x92>

	if (!res) {
		return -ENOENT;
	}

	for (i = 0; i < res->res_inst_count; i++) {
  11b110:	0f b6 42 16          	movzbl 0x16(%edx),%eax
  11b114:	31 f6                	xor    %esi,%esi
  11b116:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11b119:	eb 1b                	jmp    11b136 <do_write_op_plain_text+0xad>
	for (i = 0; i < obj_inst->resource_count; i++) {
  11b11b:	46                   	inc    %esi
  11b11c:	83 c2 18             	add    $0x18,%edx
  11b11f:	39 f1                	cmp    %esi,%ecx
  11b121:	7f e7                	jg     11b10a <do_write_op_plain_text+0x81>
  11b123:	eb 16                	jmp    11b13b <do_write_op_plain_text+0xb2>
		if (res->res_instances[i].res_inst_id ==
  11b125:	6b ce 0c             	imul   $0xc,%esi,%ecx
  11b128:	03 4a 10             	add    0x10(%edx),%ecx
  11b12b:	66 8b 43 2a          	mov    0x2a(%ebx),%ax
  11b12f:	66 39 41 08          	cmp    %ax,0x8(%ecx)
  11b133:	74 0d                	je     11b142 <do_write_op_plain_text+0xb9>
	for (i = 0; i < res->res_inst_count; i++) {
  11b135:	46                   	inc    %esi
  11b136:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  11b139:	7f ea                	jg     11b125 <do_write_op_plain_text+0x9c>
		return -ENOENT;
  11b13b:	be fe ff ff ff       	mov    $0xfffffffe,%esi
  11b140:	eb 1b                	jmp    11b15d <do_write_op_plain_text+0xd4>

	if (!res_inst) {
		return -ENOENT;
	}

	if (msg->path.level < 3) {
  11b142:	80 7b 2c 02          	cmpb   $0x2,0x2c(%ebx)
  11b146:	77 04                	ja     11b14c <do_write_op_plain_text+0xc3>
		msg->path.level = 3U;
  11b148:	c6 43 2c 03          	movb   $0x3,0x2c(%ebx)
	}

	return lwm2m_write_handler(obj_inst, res, res_inst, obj_field, msg);
  11b14c:	53                   	push   %ebx
  11b14d:	ff 75 e8             	pushl  -0x18(%ebp)
  11b150:	51                   	push   %ecx
  11b151:	52                   	push   %edx
  11b152:	57                   	push   %edi
  11b153:	e8 4b d3 ff ff       	call   1184a3 <lwm2m_write_handler>
  11b158:	83 c4 14             	add    $0x14,%esp
  11b15b:	89 c6                	mov    %eax,%esi
}
  11b15d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b160:	89 f0                	mov    %esi,%eax
  11b162:	5b                   	pop    %ebx
  11b163:	5e                   	pop    %esi
  11b164:	5f                   	pop    %edi
  11b165:	5d                   	pop    %ebp
  11b166:	c3                   	ret    

0011b167 <put_begin_oi>:
	return len;
}

static size_t put_begin_oi(struct lwm2m_output_context *out,
			   struct lwm2m_obj_path *path)
{
  11b167:	55                   	push   %ebp
  11b168:	89 e5                	mov    %esp,%ebp
  11b16a:	8b 55 08             	mov    0x8(%ebp),%edx
	struct tlv_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
  11b16d:	8b 42 08             	mov    0x8(%edx),%eax
	if (!fd) {
  11b170:	85 c0                	test   %eax,%eax
  11b172:	74 0a                	je     11b17e <put_begin_oi+0x17>
	*mark_pos = out->out_cpkt->offset;
  11b174:	8b 52 04             	mov    0x4(%edx),%edx
  11b177:	8b 52 04             	mov    0x4(%edx),%edx
  11b17a:	66 89 50 02          	mov    %dx,0x2(%eax)
		return 0;
	}

	return put_begin_tlv(out, &fd->mark_pos_oi, &fd->writer_flags, 0);
}
  11b17e:	31 c0                	xor    %eax,%eax
  11b180:	5d                   	pop    %ebp
  11b181:	c3                   	ret    

0011b182 <put_begin_ri>:
			   OMA_TLV_TYPE_OBJECT_INSTANCE, path->obj_inst_id);
}

static size_t put_begin_ri(struct lwm2m_output_context *out,
			   struct lwm2m_obj_path *path)
{
  11b182:	55                   	push   %ebp
  11b183:	89 e5                	mov    %esp,%ebp
  11b185:	8b 55 08             	mov    0x8(%ebp),%edx
	struct tlv_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
  11b188:	8b 42 08             	mov    0x8(%edx),%eax
	if (!fd) {
  11b18b:	85 c0                	test   %eax,%eax
  11b18d:	74 0e                	je     11b19d <put_begin_ri+0x1b>
	*writer_flags |= writer_flag;
  11b18f:	80 48 06 02          	orb    $0x2,0x6(%eax)
	*mark_pos = out->out_cpkt->offset;
  11b193:	8b 52 04             	mov    0x4(%edx),%edx
  11b196:	8b 52 04             	mov    0x4(%edx),%edx
  11b199:	66 89 50 04          	mov    %dx,0x4(%eax)
		return 0;
	}

	return put_begin_tlv(out, &fd->mark_pos_ri, &fd->writer_flags,
			     WRITER_RESOURCE_INSTANCE);
}
  11b19d:	31 c0                	xor    %eax,%eax
  11b19f:	5d                   	pop    %ebp
  11b1a0:	c3                   	ret    

0011b1a1 <buf_read>:
{
  11b1a1:	55                   	push   %ebp
  11b1a2:	89 e5                	mov    %esp,%ebp
  11b1a4:	57                   	push   %edi
  11b1a5:	56                   	push   %esi
  11b1a6:	53                   	push   %ebx
  11b1a7:	83 ec 08             	sub    $0x8,%esp
	if (!src) {
  11b1aa:	85 c9                	test   %ecx,%ecx
{
  11b1ac:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!src) {
  11b1af:	74 3f                	je     11b1f0 <buf_read+0x4f>
	if (*offset + len > src_len) {
  11b1b1:	8b 75 0c             	mov    0xc(%ebp),%esi
  11b1b4:	89 d7                	mov    %edx,%edi
  11b1b6:	0f b7 db             	movzwl %bx,%ebx
  11b1b9:	0f b7 36             	movzwl (%esi),%esi
  11b1bc:	89 75 f0             	mov    %esi,-0x10(%ebp)
  11b1bf:	0f b7 f2             	movzwl %dx,%esi
  11b1c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11b1c5:	01 f2                	add    %esi,%edx
  11b1c7:	89 55 ec             	mov    %edx,-0x14(%ebp)
		return -ENOMEM;
  11b1ca:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (*offset + len > src_len) {
  11b1cf:	39 5d ec             	cmp    %ebx,-0x14(%ebp)
  11b1d2:	7f 21                	jg     11b1f5 <buf_read+0x54>
	if (dst) {
  11b1d4:	85 c0                	test   %eax,%eax
  11b1d6:	74 0e                	je     11b1e6 <buf_read+0x45>
		memcpy(dst, src + *offset, len);
  11b1d8:	03 4d f0             	add    -0x10(%ebp),%ecx
  11b1db:	56                   	push   %esi
  11b1dc:	51                   	push   %ecx
  11b1dd:	50                   	push   %eax
  11b1de:	e8 09 0c ff ff       	call   10bdec <memcpy>
  11b1e3:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
  11b1e6:	8b 45 0c             	mov    0xc(%ebp),%eax
	return 0;
  11b1e9:	31 d2                	xor    %edx,%edx
	*offset += len;
  11b1eb:	66 01 38             	add    %di,(%eax)
	return 0;
  11b1ee:	eb 05                	jmp    11b1f5 <buf_read+0x54>
		return -EINVAL;
  11b1f0:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  11b1f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b1f8:	89 d0                	mov    %edx,%eax
  11b1fa:	5b                   	pop    %ebx
  11b1fb:	5e                   	pop    %esi
  11b1fc:	5f                   	pop    %edi
  11b1fd:	5d                   	pop    %ebp
  11b1fe:	c3                   	ret    

0011b1ff <oma_tlv_get>:
{
  11b1ff:	55                   	push   %ebp
  11b200:	89 e5                	mov    %esp,%ebp
  11b202:	57                   	push   %edi
  11b203:	56                   	push   %esi
  11b204:	89 d6                	mov    %edx,%esi
  11b206:	53                   	push   %ebx
	return buf_read(value, sizeof(uint8_t), src, src_len, offset);
  11b207:	8d 7d f0             	lea    -0x10(%ebp),%edi
  11b20a:	83 ec 10             	sub    $0x10,%esp
  11b20d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	tmp_offset = in->offset;
  11b210:	8b 42 08             	mov    0x8(%edx),%eax
{
  11b213:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	tmp_offset = in->offset;
  11b216:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	if (buf_read_u8(&buf[0], CPKT_BUF_READ(in->in_cpkt), &tmp_offset) < 0) {
  11b21a:	8b 42 04             	mov    0x4(%edx),%eax
  11b21d:	57                   	push   %edi
  11b21e:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b222:	8b 08                	mov    (%eax),%ecx
  11b224:	52                   	push   %edx
  11b225:	8d 45 f2             	lea    -0xe(%ebp),%eax
  11b228:	ba 01 00 00 00       	mov    $0x1,%edx
  11b22d:	e8 6f ff ff ff       	call   11b1a1 <buf_read>
  11b232:	59                   	pop    %ecx
  11b233:	5b                   	pop    %ebx
  11b234:	85 c0                	test   %eax,%eax
  11b236:	0f 88 e9 00 00 00    	js     11b325 <oma_tlv_get+0x126>
	tlv->type = (buf[0] >> 6) & 3;
  11b23c:	8a 5d f2             	mov    -0xe(%ebp),%bl
  11b23f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11b242:	88 d8                	mov    %bl,%al
  11b244:	c0 e8 06             	shr    $0x6,%al
  11b247:	88 01                	mov    %al,(%ecx)
  11b249:	57                   	push   %edi
	len_pos = 1 + (((buf[0] & (1 << 5)) != 0U) ? 2 : 1);
  11b24a:	f6 c3 20             	test   $0x20,%bl
  11b24d:	0f 95 c0             	setne  %al
  11b250:	83 c0 02             	add    $0x2,%eax
  11b253:	88 45 ef             	mov    %al,-0x11(%ebp)
	if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt), &tmp_offset) < 0) {
  11b256:	8b 46 04             	mov    0x4(%esi),%eax
  11b259:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b25d:	8b 08                	mov    (%eax),%ecx
  11b25f:	52                   	push   %edx
  11b260:	8d 45 f3             	lea    -0xd(%ebp),%eax
  11b263:	ba 01 00 00 00       	mov    $0x1,%edx
  11b268:	e8 34 ff ff ff       	call   11b1a1 <buf_read>
  11b26d:	59                   	pop    %ecx
  11b26e:	5a                   	pop    %edx
  11b26f:	85 c0                	test   %eax,%eax
  11b271:	0f 88 bb 00 00 00    	js     11b332 <oma_tlv_get+0x133>
	tlv->id = buf[1];
  11b277:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  11b27b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	if (len_pos > 2) {
  11b27e:	80 7d ef 03          	cmpb   $0x3,-0x11(%ebp)
	tlv->id = buf[1];
  11b282:	66 89 41 02          	mov    %ax,0x2(%ecx)
	if (len_pos > 2) {
  11b286:	75 37                	jne    11b2bf <oma_tlv_get+0xc0>
		if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt),
  11b288:	8b 46 04             	mov    0x4(%esi),%eax
  11b28b:	57                   	push   %edi
  11b28c:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b290:	8b 08                	mov    (%eax),%ecx
  11b292:	52                   	push   %edx
  11b293:	8d 45 f3             	lea    -0xd(%ebp),%eax
  11b296:	ba 01 00 00 00       	mov    $0x1,%edx
  11b29b:	e8 01 ff ff ff       	call   11b1a1 <buf_read>
  11b2a0:	5f                   	pop    %edi
  11b2a1:	5a                   	pop    %edx
  11b2a2:	85 c0                	test   %eax,%eax
  11b2a4:	78 7f                	js     11b325 <oma_tlv_get+0x126>
		tlv->id = (tlv->id << 8) + buf[1];
  11b2a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11b2a9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  11b2ac:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  11b2b0:	c1 e0 08             	shl    $0x8,%eax
  11b2b3:	89 c2                	mov    %eax,%edx
  11b2b5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  11b2b9:	01 d0                	add    %edx,%eax
  11b2bb:	66 89 41 02          	mov    %ax,0x2(%ecx)
	len_type = (buf[0] >> 3) & 3;
  11b2bf:	c0 eb 03             	shr    $0x3,%bl
	if (len_type == 0U) {
  11b2c2:	80 e3 03             	and    $0x3,%bl
  11b2c5:	75 0d                	jne    11b2d4 <oma_tlv_get+0xd5>
		tlv_len = buf[0] & 7;
  11b2c7:	8a 45 f2             	mov    -0xe(%ebp),%al
  11b2ca:	8a 5d ef             	mov    -0x11(%ebp),%bl
  11b2cd:	89 c7                	mov    %eax,%edi
  11b2cf:	83 e7 07             	and    $0x7,%edi
  11b2d2:	eb 37                	jmp    11b30b <oma_tlv_get+0x10c>
  11b2d4:	02 5d ef             	add    -0x11(%ebp),%bl
		tlv_len = 0;
  11b2d7:	31 ff                	xor    %edi,%edi
			if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt),
  11b2d9:	8b 46 04             	mov    0x4(%esi),%eax
  11b2dc:	8d 55 f0             	lea    -0x10(%ebp),%edx
  11b2df:	52                   	push   %edx
  11b2e0:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b2e4:	8b 08                	mov    (%eax),%ecx
  11b2e6:	52                   	push   %edx
  11b2e7:	8d 45 f3             	lea    -0xd(%ebp),%eax
  11b2ea:	ba 01 00 00 00       	mov    $0x1,%edx
  11b2ef:	e8 ad fe ff ff       	call   11b1a1 <buf_read>
  11b2f4:	5a                   	pop    %edx
  11b2f5:	59                   	pop    %ecx
  11b2f6:	85 c0                	test   %eax,%eax
  11b2f8:	78 2b                	js     11b325 <oma_tlv_get+0x126>
			len_pos++;
  11b2fa:	fe 45 ef             	incb   -0x11(%ebp)
			tlv_len = tlv_len << 8 | buf[1];
  11b2fd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  11b301:	c1 e7 08             	shl    $0x8,%edi
  11b304:	09 c7                	or     %eax,%edi
		while (len_type > 0) {
  11b306:	3a 5d ef             	cmp    -0x11(%ebp),%bl
  11b309:	75 ce                	jne    11b2d9 <oma_tlv_get+0xda>
	tlv->length = tlv_len;
  11b30b:	8b 45 e8             	mov    -0x18(%ebp),%eax
	if (!dont_advance) {
  11b30e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
	tlv->length = tlv_len;
  11b312:	89 78 04             	mov    %edi,0x4(%eax)
	if (!dont_advance) {
  11b315:	75 07                	jne    11b31e <oma_tlv_get+0x11f>
		in->offset = tmp_offset;
  11b317:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b31a:	66 89 46 08          	mov    %ax,0x8(%esi)
	return len_pos + tlv_len;
  11b31e:	0f b6 c3             	movzbl %bl,%eax
  11b321:	01 f8                	add    %edi,%eax
  11b323:	eb 0f                	jmp    11b334 <oma_tlv_get+0x135>
	if (!dont_advance) {
  11b325:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  11b329:	75 07                	jne    11b332 <oma_tlv_get+0x133>
		in->offset = tmp_offset;
  11b32b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b32e:	66 89 46 08          	mov    %ax,0x8(%esi)
	return 0;
  11b332:	31 c0                	xor    %eax,%eax
}
  11b334:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b337:	5b                   	pop    %ebx
  11b338:	5e                   	pop    %esi
  11b339:	5f                   	pop    %edi
  11b33a:	5d                   	pop    %ebp
  11b33b:	c3                   	ret    

0011b33c <do_write_op_tlv_dummy_read>:
	engine_clear_out_user_data(&msg->out);
	return ret;
}

static int do_write_op_tlv_dummy_read(struct lwm2m_message *msg)
{
  11b33c:	55                   	push   %ebp
	struct oma_tlv tlv;
	uint8_t read_char;

	oma_tlv_get(&tlv, &msg->in, false);
  11b33d:	8d 50 04             	lea    0x4(%eax),%edx
{
  11b340:	89 e5                	mov    %esp,%ebp
  11b342:	53                   	push   %ebx
  11b343:	83 ec 0c             	sub    $0xc,%esp
  11b346:	89 c3                	mov    %eax,%ebx
	oma_tlv_get(&tlv, &msg->in, false);
  11b348:	31 c9                	xor    %ecx,%ecx
  11b34a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  11b34d:	e8 ad fe ff ff       	call   11b1ff <oma_tlv_get>
	while (tlv.length--) {
  11b352:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11b355:	85 c0                	test   %eax,%eax
  11b357:	8d 50 ff             	lea    -0x1(%eax),%edx
  11b35a:	89 55 f8             	mov    %edx,-0x8(%ebp)
  11b35d:	74 21                	je     11b380 <do_write_op_tlv_dummy_read+0x44>
		if (buf_read_u8(&read_char, CPKT_BUF_READ(msg->in.in_cpkt),
  11b35f:	8b 43 08             	mov    0x8(%ebx),%eax
  11b362:	8d 53 0c             	lea    0xc(%ebx),%edx
  11b365:	52                   	push   %edx
  11b366:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b36a:	8b 08                	mov    (%eax),%ecx
  11b36c:	52                   	push   %edx
  11b36d:	8d 45 f3             	lea    -0xd(%ebp),%eax
  11b370:	ba 01 00 00 00       	mov    $0x1,%edx
  11b375:	e8 27 fe ff ff       	call   11b1a1 <buf_read>
  11b37a:	5a                   	pop    %edx
  11b37b:	59                   	pop    %ecx
  11b37c:	85 c0                	test   %eax,%eax
  11b37e:	79 d2                	jns    11b352 <do_write_op_tlv_dummy_read+0x16>
			break;
		}
	}

	return 0;
}
  11b380:	31 c0                	xor    %eax,%eax
  11b382:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11b385:	c9                   	leave  
  11b386:	c3                   	ret    

0011b387 <do_write_op_tlv_item>:

static int do_write_op_tlv_item(struct lwm2m_message *msg)
{
  11b387:	55                   	push   %ebp
  11b388:	89 e5                	mov    %esp,%ebp
  11b38a:	57                   	push   %edi
  11b38b:	56                   	push   %esi
  11b38c:	53                   	push   %ebx
  11b38d:	89 c3                	mov    %eax,%ebx
  11b38f:	83 ec 18             	sub    $0x18,%esp
	struct lwm2m_engine_res_inst *res_inst = NULL;
	struct lwm2m_engine_obj_field *obj_field = NULL;
	uint8_t created = 0U;
	int ret, i;

	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
  11b392:	8d 45 ef             	lea    -0x11(%ebp),%eax
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11b395:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint8_t created = 0U;
  11b39c:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
	ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst, &created);
  11b3a0:	50                   	push   %eax
  11b3a1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  11b3a4:	50                   	push   %eax
  11b3a5:	53                   	push   %ebx
  11b3a6:	e8 b1 d8 ff ff       	call   118c5c <lwm2m_get_or_create_engine_obj>
  11b3ab:	83 c4 0c             	add    $0xc,%esp
  11b3ae:	89 c6                	mov    %eax,%esi
	if (ret < 0) {
  11b3b0:	85 c0                	test   %eax,%eax
  11b3b2:	0f 88 f6 00 00 00    	js     11b4ae <do_write_op_tlv_item+0x127>
		goto error;
	}

	obj_field = lwm2m_get_engine_obj_field(obj_inst->obj,
  11b3b8:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  11b3bc:	50                   	push   %eax
  11b3bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b3c0:	ff 70 04             	pushl  0x4(%eax)
  11b3c3:	e8 35 9f ff ff       	call   1152fd <lwm2m_get_engine_obj_field>
  11b3c8:	5a                   	pop    %edx
  11b3c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11b3cc:	59                   	pop    %ecx
					       msg->path.res_id);
	if (!obj_field) {
  11b3cd:	85 c0                	test   %eax,%eax
  11b3cf:	0f 84 c8 00 00 00    	je     11b49d <do_write_op_tlv_item+0x116>
		ret = -ENOENT;
		goto error;
	}

	if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
  11b3d5:	8a 48 02             	mov    0x2(%eax),%cl
  11b3d8:	88 ca                	mov    %cl,%dl
  11b3da:	88 4d e3             	mov    %cl,-0x1d(%ebp)
  11b3dd:	83 e2 06             	and    $0x6,%edx
  11b3e0:	80 fa 06             	cmp    $0x6,%dl
  11b3e3:	0f 85 bb 00 00 00    	jne    11b4a4 <do_write_op_tlv_item+0x11d>
		ret = -EPERM;
		goto error;
	}

	if (!obj_inst->resources || obj_inst->resource_count == 0U) {
  11b3e9:	8b 7d f0             	mov    -0x10(%ebp),%edi
  11b3ec:	89 7d e8             	mov    %edi,-0x18(%ebp)
  11b3ef:	8b 57 08             	mov    0x8(%edi),%edx
  11b3f2:	85 d2                	test   %edx,%edx
  11b3f4:	0f 84 af 00 00 00    	je     11b4a9 <do_write_op_tlv_item+0x122>
  11b3fa:	0f b7 77 0e          	movzwl 0xe(%edi),%esi
  11b3fe:	66 85 f6             	test   %si,%si
  11b401:	0f 84 a2 00 00 00    	je     11b4a9 <do_write_op_tlv_item+0x122>
		ret = -EINVAL;
		goto error;
	}

	for (i = 0; i < obj_inst->resource_count; i++) {
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
  11b407:	8b 7b 28             	mov    0x28(%ebx),%edi
	for (i = 0; i < obj_inst->resource_count; i++) {
  11b40a:	31 c9                	xor    %ecx,%ecx
  11b40c:	89 f0                	mov    %esi,%eax
		if (obj_inst->resources[i].res_id == msg->path.res_id) {
  11b40e:	66 39 7a 14          	cmp    %di,0x14(%edx)
  11b412:	89 d6                	mov    %edx,%esi
  11b414:	75 0b                	jne    11b421 <do_write_op_tlv_item+0x9a>
			break;
		}
	}

	if (res) {
		for (i = 0; i < res->res_inst_count; i++) {
  11b416:	0f b6 7a 16          	movzbl 0x16(%edx),%edi
  11b41a:	89 7d dc             	mov    %edi,-0x24(%ebp)
  11b41d:	31 ff                	xor    %edi,%edi
  11b41f:	eb 1d                	jmp    11b43e <do_write_op_tlv_item+0xb7>
	for (i = 0; i < obj_inst->resource_count; i++) {
  11b421:	41                   	inc    %ecx
  11b422:	8d 52 18             	lea    0x18(%edx),%edx
  11b425:	39 c8                	cmp    %ecx,%eax
  11b427:	7f e5                	jg     11b40e <do_write_op_tlv_item+0x87>
	struct lwm2m_engine_res *res = NULL;
  11b429:	31 f6                	xor    %esi,%esi
  11b42b:	eb 16                	jmp    11b443 <do_write_op_tlv_item+0xbc>
			if (res->res_instances[i].res_inst_id ==
  11b42d:	6b cf 0c             	imul   $0xc,%edi,%ecx
  11b430:	03 4a 10             	add    0x10(%edx),%ecx
  11b433:	66 8b 43 2a          	mov    0x2a(%ebx),%ax
  11b437:	66 39 41 08          	cmp    %ax,0x8(%ecx)
  11b43b:	74 08                	je     11b445 <do_write_op_tlv_item+0xbe>
		for (i = 0; i < res->res_inst_count; i++) {
  11b43d:	47                   	inc    %edi
  11b43e:	39 7d dc             	cmp    %edi,-0x24(%ebp)
  11b441:	7f ea                	jg     11b42d <do_write_op_tlv_item+0xa6>
	struct lwm2m_engine_res_inst *res_inst = NULL;
  11b443:	31 c9                	xor    %ecx,%ecx
				break;
			}
		}
	}

	if (!res || !res_inst) {
  11b445:	85 f6                	test   %esi,%esi
  11b447:	74 04                	je     11b44d <do_write_op_tlv_item+0xc6>
  11b449:	85 c9                	test   %ecx,%ecx
  11b44b:	75 28                	jne    11b475 <do_write_op_tlv_item+0xee>
		/* if OPTIONAL and BOOTSTRAP-WRITE or CREATE use ENOTSUP */
		if ((msg->ctx->bootstrap_mode ||
  11b44d:	8b 03                	mov    (%ebx),%eax
  11b44f:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  11b456:	75 0e                	jne    11b466 <do_write_op_tlv_item+0xdf>
  11b458:	80 bb 89 02 00 00 02 	cmpb   $0x2,0x289(%ebx)
		    LWM2M_HAS_PERM(obj_field, BIT(LWM2M_FLAG_OPTIONAL))) {
			ret = -ENOTSUP;
			goto error;
		}

		ret = -ENOENT;
  11b45f:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		if ((msg->ctx->bootstrap_mode ||
  11b464:	75 48                	jne    11b4ae <do_write_op_tlv_item+0x127>
			ret = -ENOTSUP;
  11b466:	0f be 75 e3          	movsbl -0x1d(%ebp),%esi
  11b46a:	c1 fe 1f             	sar    $0x1f,%esi
  11b46d:	83 e6 df             	and    $0xffffffdf,%esi
  11b470:	83 ee 02             	sub    $0x2,%esi
  11b473:	eb 39                	jmp    11b4ae <do_write_op_tlv_item+0x127>
		goto error;
	}

	ret = lwm2m_write_handler(obj_inst, res, res_inst, obj_field, msg);
  11b475:	53                   	push   %ebx
  11b476:	ff 75 e4             	pushl  -0x1c(%ebp)
  11b479:	51                   	push   %ecx
  11b47a:	56                   	push   %esi
  11b47b:	ff 75 e8             	pushl  -0x18(%ebp)
  11b47e:	e8 20 d0 ff ff       	call   1184a3 <lwm2m_write_handler>
  11b483:	83 c4 14             	add    $0x14,%esp
  11b486:	89 c6                	mov    %eax,%esi
	if (ret == -EACCES || ret == -ENOENT) {
  11b488:	83 f8 f3             	cmp    $0xfffffff3,%eax
  11b48b:	74 05                	je     11b492 <do_write_op_tlv_item+0x10b>
  11b48d:	83 f8 fe             	cmp    $0xfffffffe,%eax
  11b490:	75 23                	jne    11b4b5 <do_write_op_tlv_item+0x12e>
		/* if read-only or non-existent data buffer move on */
		do_write_op_tlv_dummy_read(msg);
  11b492:	89 d8                	mov    %ebx,%eax
		ret = 0;
  11b494:	31 f6                	xor    %esi,%esi
		do_write_op_tlv_dummy_read(msg);
  11b496:	e8 a1 fe ff ff       	call   11b33c <do_write_op_tlv_dummy_read>
		ret = 0;
  11b49b:	eb 18                	jmp    11b4b5 <do_write_op_tlv_item+0x12e>
		ret = -ENOENT;
  11b49d:	be fe ff ff ff       	mov    $0xfffffffe,%esi
  11b4a2:	eb 0a                	jmp    11b4ae <do_write_op_tlv_item+0x127>
		ret = -EPERM;
  11b4a4:	83 ce ff             	or     $0xffffffff,%esi
  11b4a7:	eb 05                	jmp    11b4ae <do_write_op_tlv_item+0x127>
		ret = -EINVAL;
  11b4a9:	be ea ff ff ff       	mov    $0xffffffea,%esi
	}

	return ret;

error:
	do_write_op_tlv_dummy_read(msg);
  11b4ae:	89 d8                	mov    %ebx,%eax
  11b4b0:	e8 87 fe ff ff       	call   11b33c <do_write_op_tlv_dummy_read>
	return ret;
}
  11b4b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b4b8:	89 f0                	mov    %esi,%eax
  11b4ba:	5b                   	pop    %ebx
  11b4bb:	5e                   	pop    %esi
  11b4bc:	5f                   	pop    %edi
  11b4bd:	5d                   	pop    %ebp
  11b4be:	c3                   	ret    

0011b4bf <get_number>:
{
  11b4bf:	55                   	push   %ebp
  11b4c0:	89 e5                	mov    %esp,%ebp
  11b4c2:	57                   	push   %edi
  11b4c3:	56                   	push   %esi
  11b4c4:	89 c7                	mov    %eax,%edi
  11b4c6:	53                   	push   %ebx
  11b4c7:	89 d3                	mov    %edx,%ebx
  11b4c9:	83 ec 14             	sub    $0x14,%esp
	size_t size = oma_tlv_get(&tlv, in, false);
  11b4cc:	89 c2                	mov    %eax,%edx
{
  11b4ce:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	size_t size = oma_tlv_get(&tlv, in, false);
  11b4d1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  11b4d4:	31 c9                	xor    %ecx,%ecx
  11b4d6:	e8 24 fd ff ff       	call   11b1ff <oma_tlv_get>
	*value = 0;
  11b4db:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  11b4e1:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	if (size > 0) {
  11b4e8:	85 c0                	test   %eax,%eax
  11b4ea:	0f 84 a6 00 00 00    	je     11b596 <get_number+0xd7>
		if (tlv.length > max_len) {
  11b4f0:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
  11b4f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11b4f7:	39 ca                	cmp    %ecx,%edx
  11b4f9:	77 70                	ja     11b56b <get_number+0xac>
  11b4fb:	89 c6                	mov    %eax,%esi
			     CPKT_BUF_READ(in->in_cpkt), &in->offset) < 0) {
  11b4fd:	8b 47 04             	mov    0x4(%edi),%eax
		if (buf_read((uint8_t *)&temp, tlv.length,
  11b500:	83 c7 08             	add    $0x8,%edi
  11b503:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11b507:	57                   	push   %edi
  11b508:	51                   	push   %ecx
  11b509:	8b 08                	mov    (%eax),%ecx
  11b50b:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11b50e:	e8 8e fc ff ff       	call   11b1a1 <buf_read>
  11b513:	5a                   	pop    %edx
  11b514:	59                   	pop    %ecx
  11b515:	85 c0                	test   %eax,%eax
  11b517:	78 7d                	js     11b596 <get_number+0xd7>
		switch (tlv.length) {
  11b519:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11b51c:	83 fa 04             	cmp    $0x4,%edx
  11b51f:	74 3a                	je     11b55b <get_number+0x9c>
  11b521:	77 14                	ja     11b537 <get_number+0x78>
  11b523:	83 fa 01             	cmp    $0x1,%edx
  11b526:	74 25                	je     11b54d <get_number+0x8e>
  11b528:	83 fa 02             	cmp    $0x2,%edx
  11b52b:	75 3e                	jne    11b56b <get_number+0xac>
			*value = sys_cpu_to_be16((int16_t)temp);
  11b52d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b530:	86 e0                	xchg   %ah,%al
  11b532:	0f b7 c0             	movzwl %ax,%eax
  11b535:	eb 29                	jmp    11b560 <get_number+0xa1>
		switch (tlv.length) {
  11b537:	83 fa 08             	cmp    $0x8,%edx
  11b53a:	75 2f                	jne    11b56b <get_number+0xac>
			*value = sys_cpu_to_be64(temp);
  11b53c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b53f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11b542:	0f c8                	bswap  %eax
  11b544:	0f ca                	bswap  %edx
  11b546:	89 13                	mov    %edx,(%ebx)
  11b548:	89 43 04             	mov    %eax,0x4(%ebx)
			break;
  11b54b:	eb 4b                	jmp    11b598 <get_number+0xd9>
			*value = (int8_t)temp;
  11b54d:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
  11b551:	89 03                	mov    %eax,(%ebx)
  11b553:	c1 f8 1f             	sar    $0x1f,%eax
  11b556:	89 43 04             	mov    %eax,0x4(%ebx)
			break;
  11b559:	eb 3d                	jmp    11b598 <get_number+0xd9>
			*value = sys_cpu_to_be32((int32_t)temp);
  11b55b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b55e:	0f c8                	bswap  %eax
  11b560:	89 03                	mov    %eax,(%ebx)
  11b562:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
			break;
  11b569:	eb 2d                	jmp    11b598 <get_number+0xd9>
			LOG_ERR("invalid length: %u", tlv.length);
  11b56b:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11b572:	74 22                	je     11b596 <get_number+0xd7>
  11b574:	b8 58 31 12 00       	mov    $0x123158,%eax
  11b579:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11b57e:	c1 e8 03             	shr    $0x3,%eax
  11b581:	c1 e0 06             	shl    $0x6,%eax
  11b584:	83 c8 01             	or     $0x1,%eax
  11b587:	50                   	push   %eax
  11b588:	52                   	push   %edx
  11b589:	68 fe 7e 12 00       	push   $0x127efe
  11b58e:	e8 e3 7f fe ff       	call   103576 <log_1>
  11b593:	83 c4 0c             	add    $0xc,%esp
			return 0;
  11b596:	31 f6                	xor    %esi,%esi
}
  11b598:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b59b:	89 f0                	mov    %esi,%eax
  11b59d:	5b                   	pop    %ebx
  11b59e:	5e                   	pop    %esi
  11b59f:	5f                   	pop    %edi
  11b5a0:	5d                   	pop    %ebp
  11b5a1:	c3                   	ret    

0011b5a2 <get_bool>:
{
  11b5a2:	55                   	push   %ebp
	size = get_number(in, &temp, 2);
  11b5a3:	b9 02 00 00 00       	mov    $0x2,%ecx
{
  11b5a8:	89 e5                	mov    %esp,%ebp
  11b5aa:	53                   	push   %ebx
  11b5ab:	83 ec 08             	sub    $0x8,%esp
  11b5ae:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size = get_number(in, &temp, 2);
  11b5b1:	8d 55 f4             	lea    -0xc(%ebp),%edx
  11b5b4:	8b 45 08             	mov    0x8(%ebp),%eax
	*value = 0;
  11b5b7:	c6 03 00             	movb   $0x0,(%ebx)
	size = get_number(in, &temp, 2);
  11b5ba:	e8 00 ff ff ff       	call   11b4bf <get_number>
	if (size > 0) {
  11b5bf:	85 c0                	test   %eax,%eax
  11b5c1:	74 09                	je     11b5cc <get_bool+0x2a>
		*value = (temp != 0);
  11b5c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11b5c6:	0b 55 f8             	or     -0x8(%ebp),%edx
  11b5c9:	0f 95 03             	setne  (%ebx)
}
  11b5cc:	5a                   	pop    %edx
  11b5cd:	59                   	pop    %ecx
  11b5ce:	5b                   	pop    %ebx
  11b5cf:	5d                   	pop    %ebp
  11b5d0:	c3                   	ret    

0011b5d1 <get_s64>:
{
  11b5d1:	55                   	push   %ebp
	return get_number(in, value, 8);
  11b5d2:	b9 08 00 00 00       	mov    $0x8,%ecx
{
  11b5d7:	89 e5                	mov    %esp,%ebp
	return get_number(in, value, 8);
  11b5d9:	8b 55 0c             	mov    0xc(%ebp),%edx
  11b5dc:	8b 45 08             	mov    0x8(%ebp),%eax
}
  11b5df:	5d                   	pop    %ebp
	return get_number(in, value, 8);
  11b5e0:	e9 da fe ff ff       	jmp    11b4bf <get_number>

0011b5e5 <get_s32>:
{
  11b5e5:	55                   	push   %ebp
	size = get_number(in, &temp, 4);
  11b5e6:	b9 04 00 00 00       	mov    $0x4,%ecx
{
  11b5eb:	89 e5                	mov    %esp,%ebp
  11b5ed:	53                   	push   %ebx
  11b5ee:	83 ec 08             	sub    $0x8,%esp
  11b5f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size = get_number(in, &temp, 4);
  11b5f4:	8d 55 f4             	lea    -0xc(%ebp),%edx
  11b5f7:	8b 45 08             	mov    0x8(%ebp),%eax
	*value = 0;
  11b5fa:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	size = get_number(in, &temp, 4);
  11b600:	e8 ba fe ff ff       	call   11b4bf <get_number>
	if (size > 0) {
  11b605:	85 c0                	test   %eax,%eax
  11b607:	74 05                	je     11b60e <get_s32+0x29>
		*value = (int32_t)temp;
  11b609:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11b60c:	89 13                	mov    %edx,(%ebx)
}
  11b60e:	5a                   	pop    %edx
  11b60f:	59                   	pop    %ecx
  11b610:	5b                   	pop    %ebx
  11b611:	5d                   	pop    %ebp
  11b612:	c3                   	ret    

0011b613 <get_objlnk>:
{
  11b613:	55                   	push   %ebp
  11b614:	89 e5                	mov    %esp,%ebp
  11b616:	53                   	push   %ebx
  11b617:	50                   	push   %eax
	size = get_s32(in, &value_s32);
  11b618:	8d 45 f8             	lea    -0x8(%ebp),%eax
{
  11b61b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size = get_s32(in, &value_s32);
  11b61e:	50                   	push   %eax
  11b61f:	ff 75 08             	pushl  0x8(%ebp)
  11b622:	e8 be ff ff ff       	call   11b5e5 <get_s32>
  11b627:	5a                   	pop    %edx
	value->obj_id = (value_s32 >> 16) & 0xFFFF;
  11b628:	8b 55 f8             	mov    -0x8(%ebp),%edx
	size = get_s32(in, &value_s32);
  11b62b:	59                   	pop    %ecx
	value->obj_id = (value_s32 >> 16) & 0xFFFF;
  11b62c:	89 d1                	mov    %edx,%ecx
  11b62e:	c1 e9 10             	shr    $0x10,%ecx
	value->obj_inst = value_s32 & 0xFFFF;
  11b631:	66 89 53 02          	mov    %dx,0x2(%ebx)
	value->obj_id = (value_s32 >> 16) & 0xFFFF;
  11b635:	66 89 0b             	mov    %cx,(%ebx)
}
  11b638:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11b63b:	c9                   	leave  
  11b63c:	c3                   	ret    

0011b63d <get_string>:
{
  11b63d:	55                   	push   %ebp
	size_t size = oma_tlv_get(&tlv, in, false);
  11b63e:	31 c9                	xor    %ecx,%ecx
{
  11b640:	89 e5                	mov    %esp,%ebp
  11b642:	57                   	push   %edi
  11b643:	56                   	push   %esi
  11b644:	53                   	push   %ebx
	size_t size = oma_tlv_get(&tlv, in, false);
  11b645:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  11b648:	83 ec 08             	sub    $0x8,%esp
  11b64b:	8b 75 08             	mov    0x8(%ebp),%esi
  11b64e:	8b 7d 0c             	mov    0xc(%ebp),%edi
	size_t size = oma_tlv_get(&tlv, in, false);
  11b651:	89 f2                	mov    %esi,%edx
  11b653:	e8 a7 fb ff ff       	call   11b1ff <oma_tlv_get>
	if (size > 0) {
  11b658:	85 c0                	test   %eax,%eax
  11b65a:	75 04                	jne    11b660 <get_string+0x23>
{
  11b65c:	31 db                	xor    %ebx,%ebx
  11b65e:	eb 2f                	jmp    11b68f <get_string+0x52>
		if (buflen <= tlv.length) {
  11b660:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11b663:	3b 55 10             	cmp    0x10(%ebp),%edx
  11b666:	73 f4                	jae    11b65c <get_string+0x1f>
  11b668:	89 c3                	mov    %eax,%ebx
		if (buf_read(buf, tlv.length, CPKT_BUF_READ(in->in_cpkt),
  11b66a:	8b 46 04             	mov    0x4(%esi),%eax
  11b66d:	83 c6 08             	add    $0x8,%esi
  11b670:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11b674:	56                   	push   %esi
  11b675:	51                   	push   %ecx
  11b676:	8b 08                	mov    (%eax),%ecx
  11b678:	0f b7 d2             	movzwl %dx,%edx
  11b67b:	89 f8                	mov    %edi,%eax
  11b67d:	e8 1f fb ff ff       	call   11b1a1 <buf_read>
  11b682:	5a                   	pop    %edx
  11b683:	59                   	pop    %ecx
  11b684:	85 c0                	test   %eax,%eax
  11b686:	78 d4                	js     11b65c <get_string+0x1f>
		buf[tlv.length] = '\0';
  11b688:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b68b:	c6 04 07 00          	movb   $0x0,(%edi,%eax,1)
}
  11b68f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b692:	89 d8                	mov    %ebx,%eax
  11b694:	5b                   	pop    %ebx
  11b695:	5e                   	pop    %esi
  11b696:	5f                   	pop    %edi
  11b697:	5d                   	pop    %ebp
  11b698:	c3                   	ret    

0011b699 <get_opaque>:
{
  11b699:	55                   	push   %ebp
  11b69a:	89 e5                	mov    %esp,%ebp
  11b69c:	56                   	push   %esi
  11b69d:	53                   	push   %ebx
  11b69e:	83 ec 08             	sub    $0x8,%esp
  11b6a1:	8b 5d 14             	mov    0x14(%ebp),%ebx
  11b6a4:	8b 75 08             	mov    0x8(%ebp),%esi
	if (opaque->remaining == 0) {
  11b6a7:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  11b6ab:	75 14                	jne    11b6c1 <get_opaque+0x28>
		size = oma_tlv_get(&tlv, in, false);
  11b6ad:	31 c9                	xor    %ecx,%ecx
  11b6af:	89 f2                	mov    %esi,%edx
  11b6b1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  11b6b4:	e8 46 fb ff ff       	call   11b1ff <oma_tlv_get>
		opaque->len = tlv.length;
  11b6b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  11b6bc:	89 03                	mov    %eax,(%ebx)
		opaque->remaining = tlv.length;
  11b6be:	89 43 04             	mov    %eax,0x4(%ebx)
	return lwm2m_engine_get_opaque_more(in, value, buflen,
  11b6c1:	ff 75 18             	pushl  0x18(%ebp)
  11b6c4:	53                   	push   %ebx
  11b6c5:	ff 75 10             	pushl  0x10(%ebp)
  11b6c8:	ff 75 0c             	pushl  0xc(%ebp)
  11b6cb:	56                   	push   %esi
  11b6cc:	e8 3c cd ff ff       	call   11840d <lwm2m_engine_get_opaque_more>
  11b6d1:	83 c4 14             	add    $0x14,%esp
}
  11b6d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11b6d7:	5b                   	pop    %ebx
  11b6d8:	5e                   	pop    %esi
  11b6d9:	5d                   	pop    %ebp
  11b6da:	c3                   	ret    

0011b6db <get_float64fix>:
{
  11b6db:	55                   	push   %ebp
	size_t size = oma_tlv_get(&tlv, in, false);
  11b6dc:	31 c9                	xor    %ecx,%ecx
{
  11b6de:	89 e5                	mov    %esp,%ebp
  11b6e0:	57                   	push   %edi
  11b6e1:	56                   	push   %esi
  11b6e2:	53                   	push   %ebx
	size_t size = oma_tlv_get(&tlv, in, false);
  11b6e3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
{
  11b6e6:	83 ec 10             	sub    $0x10,%esp
  11b6e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t size = oma_tlv_get(&tlv, in, false);
  11b6ec:	89 da                	mov    %ebx,%edx
  11b6ee:	e8 0c fb ff ff       	call   11b1ff <oma_tlv_get>
	if (size > 0) {
  11b6f3:	85 c0                	test   %eax,%eax
  11b6f5:	0f 84 c8 00 00 00    	je     11b7c3 <get_float64fix+0xe8>
		if (tlv.length != 8U) {
  11b6fb:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11b6fe:	83 fa 08             	cmp    $0x8,%edx
  11b701:	74 5d                	je     11b760 <get_float64fix+0x85>
			LOG_ERR("invalid float64 length: %d", tlv.length);
  11b703:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11b70a:	74 45                	je     11b751 <get_float64fix+0x76>
  11b70c:	b8 58 31 12 00       	mov    $0x123158,%eax
  11b711:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11b716:	c1 e8 03             	shr    $0x3,%eax
  11b719:	c1 e0 06             	shl    $0x6,%eax
  11b71c:	83 c8 01             	or     $0x1,%eax
  11b71f:	50                   	push   %eax
  11b720:	52                   	push   %edx
  11b721:	68 11 7f 12 00       	push   $0x127f11
  11b726:	e8 4b 7e fe ff       	call   103576 <log_1>
  11b72b:	83 c4 0c             	add    $0xc,%esp
  11b72e:	eb 21                	jmp    11b751 <get_float64fix+0x76>
						CPKT_BUF_READ(in->in_cpkt),
  11b730:	8b 43 04             	mov    0x4(%ebx),%eax
				if (buf_read_u8(b64,
  11b733:	8d 53 08             	lea    0x8(%ebx),%edx
  11b736:	52                   	push   %edx
  11b737:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b73b:	8b 08                	mov    (%eax),%ecx
  11b73d:	52                   	push   %edx
  11b73e:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11b741:	ba 01 00 00 00       	mov    $0x1,%edx
  11b746:	e8 56 fa ff ff       	call   11b1a1 <buf_read>
  11b74b:	5e                   	pop    %esi
  11b74c:	5f                   	pop    %edi
  11b74d:	85 c0                	test   %eax,%eax
  11b74f:	78 72                	js     11b7c3 <get_float64fix+0xe8>
			while (tlv.length--) {
  11b751:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11b754:	85 c0                	test   %eax,%eax
  11b756:	8d 50 ff             	lea    -0x1(%eax),%edx
  11b759:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11b75c:	75 d2                	jne    11b730 <get_float64fix+0x55>
  11b75e:	eb 63                	jmp    11b7c3 <get_float64fix+0xe8>
  11b760:	89 c6                	mov    %eax,%esi
		if (buf_read(b64, tlv.length, CPKT_BUF_READ(in->in_cpkt),
  11b762:	8b 43 04             	mov    0x4(%ebx),%eax
  11b765:	83 c3 08             	add    $0x8,%ebx
  11b768:	8d 7d ec             	lea    -0x14(%ebp),%edi
  11b76b:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b76f:	53                   	push   %ebx
  11b770:	8b 08                	mov    (%eax),%ecx
  11b772:	52                   	push   %edx
  11b773:	89 f8                	mov    %edi,%eax
  11b775:	ba 08 00 00 00       	mov    $0x8,%edx
  11b77a:	e8 22 fa ff ff       	call   11b1a1 <buf_read>
  11b77f:	5a                   	pop    %edx
  11b780:	59                   	pop    %ecx
  11b781:	85 c0                	test   %eax,%eax
  11b783:	78 3e                	js     11b7c3 <get_float64fix+0xe8>
		ret = lwm2m_b64_to_f64(b64, sizeof(b64), value);
  11b785:	ff 75 0c             	pushl  0xc(%ebp)
  11b788:	6a 08                	push   $0x8
  11b78a:	57                   	push   %edi
  11b78b:	e8 94 0c 00 00       	call   11c424 <lwm2m_b64_to_f64>
  11b790:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
  11b793:	85 c0                	test   %eax,%eax
  11b795:	79 2e                	jns    11b7c5 <get_float64fix+0xea>
			LOG_ERR("binary64 conversion error: %d", ret);
  11b797:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11b79e:	74 23                	je     11b7c3 <get_float64fix+0xe8>
  11b7a0:	ba 58 31 12 00       	mov    $0x123158,%edx
  11b7a5:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11b7ab:	c1 ea 03             	shr    $0x3,%edx
  11b7ae:	c1 e2 06             	shl    $0x6,%edx
  11b7b1:	83 ca 01             	or     $0x1,%edx
  11b7b4:	52                   	push   %edx
  11b7b5:	50                   	push   %eax
  11b7b6:	68 2c 7f 12 00       	push   $0x127f2c
  11b7bb:	e8 b6 7d fe ff       	call   103576 <log_1>
  11b7c0:	83 c4 0c             	add    $0xc,%esp
			return 0;
  11b7c3:	31 f6                	xor    %esi,%esi
}
  11b7c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b7c8:	89 f0                	mov    %esi,%eax
  11b7ca:	5b                   	pop    %ebx
  11b7cb:	5e                   	pop    %esi
  11b7cc:	5f                   	pop    %edi
  11b7cd:	5d                   	pop    %ebp
  11b7ce:	c3                   	ret    

0011b7cf <get_float32fix>:
{
  11b7cf:	55                   	push   %ebp
	size_t size = oma_tlv_get(&tlv, in, false);
  11b7d0:	31 c9                	xor    %ecx,%ecx
{
  11b7d2:	89 e5                	mov    %esp,%ebp
  11b7d4:	57                   	push   %edi
  11b7d5:	56                   	push   %esi
  11b7d6:	53                   	push   %ebx
	size_t size = oma_tlv_get(&tlv, in, false);
  11b7d7:	8d 45 ec             	lea    -0x14(%ebp),%eax
{
  11b7da:	83 ec 0c             	sub    $0xc,%esp
  11b7dd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	size_t size = oma_tlv_get(&tlv, in, false);
  11b7e0:	89 da                	mov    %ebx,%edx
  11b7e2:	e8 18 fa ff ff       	call   11b1ff <oma_tlv_get>
	if (size > 0) {
  11b7e7:	85 c0                	test   %eax,%eax
  11b7e9:	0f 84 c8 00 00 00    	je     11b8b7 <get_float32fix+0xe8>
		if (tlv.length != 4U) {
  11b7ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11b7f2:	83 fa 04             	cmp    $0x4,%edx
  11b7f5:	74 5d                	je     11b854 <get_float32fix+0x85>
			LOG_ERR("Invalid float32 length: %d", tlv.length);
  11b7f7:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11b7fe:	74 45                	je     11b845 <get_float32fix+0x76>
  11b800:	b8 58 31 12 00       	mov    $0x123158,%eax
  11b805:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11b80a:	c1 e8 03             	shr    $0x3,%eax
  11b80d:	c1 e0 06             	shl    $0x6,%eax
  11b810:	83 c8 01             	or     $0x1,%eax
  11b813:	50                   	push   %eax
  11b814:	52                   	push   %edx
  11b815:	68 4a 7f 12 00       	push   $0x127f4a
  11b81a:	e8 57 7d fe ff       	call   103576 <log_1>
  11b81f:	83 c4 0c             	add    $0xc,%esp
  11b822:	eb 21                	jmp    11b845 <get_float32fix+0x76>
						CPKT_BUF_READ(in->in_cpkt),
  11b824:	8b 43 04             	mov    0x4(%ebx),%eax
				if (buf_read_u8(b32,
  11b827:	8d 53 08             	lea    0x8(%ebx),%edx
  11b82a:	52                   	push   %edx
  11b82b:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b82f:	8b 08                	mov    (%eax),%ecx
  11b831:	52                   	push   %edx
  11b832:	8d 45 e8             	lea    -0x18(%ebp),%eax
  11b835:	ba 01 00 00 00       	mov    $0x1,%edx
  11b83a:	e8 62 f9 ff ff       	call   11b1a1 <buf_read>
  11b83f:	5e                   	pop    %esi
  11b840:	5f                   	pop    %edi
  11b841:	85 c0                	test   %eax,%eax
  11b843:	78 72                	js     11b8b7 <get_float32fix+0xe8>
			while (tlv.length--) {
  11b845:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b848:	85 c0                	test   %eax,%eax
  11b84a:	8d 50 ff             	lea    -0x1(%eax),%edx
  11b84d:	89 55 f0             	mov    %edx,-0x10(%ebp)
  11b850:	75 d2                	jne    11b824 <get_float32fix+0x55>
  11b852:	eb 63                	jmp    11b8b7 <get_float32fix+0xe8>
  11b854:	89 c6                	mov    %eax,%esi
		if (buf_read(b32, tlv.length, CPKT_BUF_READ(in->in_cpkt),
  11b856:	8b 43 04             	mov    0x4(%ebx),%eax
  11b859:	83 c3 08             	add    $0x8,%ebx
  11b85c:	8d 7d e8             	lea    -0x18(%ebp),%edi
  11b85f:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11b863:	53                   	push   %ebx
  11b864:	8b 08                	mov    (%eax),%ecx
  11b866:	52                   	push   %edx
  11b867:	89 f8                	mov    %edi,%eax
  11b869:	ba 04 00 00 00       	mov    $0x4,%edx
  11b86e:	e8 2e f9 ff ff       	call   11b1a1 <buf_read>
  11b873:	5a                   	pop    %edx
  11b874:	59                   	pop    %ecx
  11b875:	85 c0                	test   %eax,%eax
  11b877:	78 3e                	js     11b8b7 <get_float32fix+0xe8>
		ret = lwm2m_b32_to_f32(b32, sizeof(b32), value);
  11b879:	ff 75 0c             	pushl  0xc(%ebp)
  11b87c:	6a 04                	push   $0x4
  11b87e:	57                   	push   %edi
  11b87f:	e8 d3 0a 00 00       	call   11c357 <lwm2m_b32_to_f32>
  11b884:	83 c4 0c             	add    $0xc,%esp
		if (ret < 0) {
  11b887:	85 c0                	test   %eax,%eax
  11b889:	79 2e                	jns    11b8b9 <get_float32fix+0xea>
			LOG_ERR("binary32 conversion error: %d", ret);
  11b88b:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11b892:	74 23                	je     11b8b7 <get_float32fix+0xe8>
  11b894:	ba 58 31 12 00       	mov    $0x123158,%edx
  11b899:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11b89f:	c1 ea 03             	shr    $0x3,%edx
  11b8a2:	c1 e2 06             	shl    $0x6,%edx
  11b8a5:	83 ca 01             	or     $0x1,%edx
  11b8a8:	52                   	push   %edx
  11b8a9:	50                   	push   %eax
  11b8aa:	68 65 7f 12 00       	push   $0x127f65
  11b8af:	e8 c2 7c fe ff       	call   103576 <log_1>
  11b8b4:	83 c4 0c             	add    $0xc,%esp
			return 0;
  11b8b7:	31 f6                	xor    %esi,%esi
}
  11b8b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b8bc:	89 f0                	mov    %esi,%eax
  11b8be:	5b                   	pop    %ebx
  11b8bf:	5e                   	pop    %esi
  11b8c0:	5f                   	pop    %edi
  11b8c1:	5d                   	pop    %ebp
  11b8c2:	c3                   	ret    

0011b8c3 <oma_tlv_put_u8>:
{
  11b8c3:	55                   	push   %ebp
  11b8c4:	89 e5                	mov    %esp,%ebp
  11b8c6:	57                   	push   %edi
  11b8c7:	56                   	push   %esi
  11b8c8:	53                   	push   %ebx
  11b8c9:	83 ec 10             	sub    $0x10,%esp
  11b8cc:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if (insert) {
  11b8cf:	84 c9                	test   %cl,%cl
  11b8d1:	74 70                	je     11b943 <oma_tlv_put_u8+0x80>
		fd = engine_get_out_user_data(out);
  11b8d3:	8b 70 08             	mov    0x8(%eax),%esi
			return 0;
  11b8d6:	31 ff                	xor    %edi,%edi
		if (!fd) {
  11b8d8:	85 f6                	test   %esi,%esi
  11b8da:	0f 84 9c 00 00 00    	je     11b97c <oma_tlv_put_u8+0xb9>
		ret = buf_insert(CPKT_BUF_WRITE(out->out_cpkt),
  11b8e0:	8b 58 04             	mov    0x4(%eax),%ebx
		return -EINVAL;
  11b8e3:	bf ea ff ff ff       	mov    $0xffffffea,%edi
  11b8e8:	0f b7 16             	movzwl (%esi),%edx
  11b8eb:	8b 0b                	mov    (%ebx),%ecx
  11b8ed:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
	if (!dst || !src) {
  11b8f1:	85 c9                	test   %ecx,%ecx
  11b8f3:	0f 84 83 00 00 00    	je     11b97c <oma_tlv_put_u8+0xb9>
	if (*dst_len + src_len > dst_size) {
  11b8f9:	0f b7 7b 04          	movzwl 0x4(%ebx),%edi
  11b8fd:	89 7d ec             	mov    %edi,-0x14(%ebp)
  11b900:	47                   	inc    %edi
  11b901:	89 7d e8             	mov    %edi,-0x18(%ebp)
  11b904:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11b907:	8b 45 e8             	mov    -0x18(%ebp),%eax
		return -ENOMEM;
  11b90a:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (*dst_len + src_len > dst_size) {
  11b90f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  11b912:	7c 68                	jl     11b97c <oma_tlv_put_u8+0xb9>
	memmove(dst + offset + src_len, dst + offset, *dst_len - offset);
  11b914:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11b917:	8d 3c 11             	lea    (%ecx,%edx,1),%edi
  11b91a:	29 d0                	sub    %edx,%eax
  11b91c:	50                   	push   %eax
  11b91d:	8d 44 11 01          	lea    0x1(%ecx,%edx,1),%eax
  11b921:	57                   	push   %edi
  11b922:	50                   	push   %eax
  11b923:	e8 89 04 ff ff       	call   10bdb1 <memmove>
  11b928:	83 c4 0c             	add    $0xc,%esp
	memcpy(dst + offset, src, src_len);
  11b92b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  11b92e:	6a 01                	push   $0x1
  11b930:	50                   	push   %eax
  11b931:	57                   	push   %edi
  11b932:	e8 b5 04 ff ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11b937:	66 ff 43 04          	incw   0x4(%ebx)
	memcpy(dst + offset, src, src_len);
  11b93b:	83 c4 0c             	add    $0xc,%esp
		fd->mark_pos++;
  11b93e:	66 ff 06             	incw   (%esi)
  11b941:	eb 37                	jmp    11b97a <oma_tlv_put_u8+0xb7>
		ret = buf_append(CPKT_BUF_WRITE(out->out_cpkt), &value, 1);
  11b943:	8b 58 04             	mov    0x4(%eax),%ebx
		return -EINVAL;
  11b946:	bf ea ff ff ff       	mov    $0xffffffea,%edi
  11b94b:	8b 03                	mov    (%ebx),%eax
  11b94d:	0f b7 73 06          	movzwl 0x6(%ebx),%esi
	if (!dst || !src) {
  11b951:	85 c0                	test   %eax,%eax
  11b953:	74 27                	je     11b97c <oma_tlv_put_u8+0xb9>
	if (*dst_len + src_len > dst_size) {
  11b955:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
		return -ENOMEM;
  11b959:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	if (*dst_len + src_len > dst_size) {
  11b95e:	8d 4a 01             	lea    0x1(%edx),%ecx
  11b961:	39 ce                	cmp    %ecx,%esi
  11b963:	7c 17                	jl     11b97c <oma_tlv_put_u8+0xb9>
	memcpy(dst + *dst_len, src, src_len);
  11b965:	6a 01                	push   $0x1
  11b967:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  11b96a:	51                   	push   %ecx
  11b96b:	01 d0                	add    %edx,%eax
  11b96d:	50                   	push   %eax
  11b96e:	e8 79 04 ff ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11b973:	66 ff 43 04          	incw   0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
  11b977:	83 c4 0c             	add    $0xc,%esp
	return 0;
  11b97a:	31 ff                	xor    %edi,%edi
}
  11b97c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11b97f:	89 f8                	mov    %edi,%eax
  11b981:	5b                   	pop    %ebx
  11b982:	5e                   	pop    %esi
  11b983:	5f                   	pop    %edi
  11b984:	5d                   	pop    %ebp
  11b985:	c3                   	ret    

0011b986 <oma_tlv_put>:
{
  11b986:	55                   	push   %ebp
  11b987:	89 e5                	mov    %esp,%ebp
  11b989:	57                   	push   %edi
  11b98a:	56                   	push   %esi
  11b98b:	89 c7                	mov    %eax,%edi
  11b98d:	53                   	push   %ebx
  11b98e:	83 ec 14             	sub    $0x14,%esp
  11b991:	89 55 f0             	mov    %edx,-0x10(%ebp)
  11b994:	8b 45 08             	mov    0x8(%ebp),%eax
	len_type = get_len_type(tlv);
  11b997:	8b 57 04             	mov    0x4(%edi),%edx
{
  11b99a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  11b99d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return 0;
  11b9a0:	31 c9                	xor    %ecx,%ecx
	if (tlv->length < 8) {
  11b9a2:	83 fa 07             	cmp    $0x7,%edx
  11b9a5:	76 16                	jbe    11b9bd <oma_tlv_put+0x37>
		return 1;
  11b9a7:	b1 01                	mov    $0x1,%cl
	} else if (tlv->length < 0x100) {
  11b9a9:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  11b9af:	76 0c                	jbe    11b9bd <oma_tlv_put+0x37>
		return 2;
  11b9b1:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  11b9b7:	0f 97 c1             	seta   %cl
  11b9ba:	83 c1 02             	add    $0x2,%ecx
	tmp = (tlv->type << 6) |
  11b9bd:	0f b6 07             	movzbl (%edi),%eax
  11b9c0:	c1 e0 06             	shl    $0x6,%eax
  11b9c3:	66 81 7f 02 00 01    	cmpw   $0x100,0x2(%edi)
	      (len_type << 3) |
  11b9c9:	0f b6 f1             	movzbl %cl,%esi
	tmp = (tlv->type << 6) |
  11b9cc:	19 db                	sbb    %ebx,%ebx
	      (len_type << 3) |
  11b9ce:	89 75 e0             	mov    %esi,-0x20(%ebp)
	tmp = (tlv->type << 6) |
  11b9d1:	f7 d3                	not    %ebx
	      (len_type << 3) |
  11b9d3:	c1 e6 03             	shl    $0x3,%esi
	tmp = (tlv->type << 6) |
  11b9d6:	83 e3 20             	and    $0x20,%ebx
	      (tlv->id > 255 ? (1 << 5) : 0) |
  11b9d9:	09 f0                	or     %esi,%eax
  11b9db:	09 d8                	or     %ebx,%eax
	      (len_type << 3) |
  11b9dd:	84 c9                	test   %cl,%cl
  11b9df:	74 02                	je     11b9e3 <oma_tlv_put+0x5d>
  11b9e1:	31 d2                	xor    %edx,%edx
	ret = oma_tlv_put_u8(out, tmp, insert);
  11b9e3:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
	tmp = (tlv->type << 6) |
  11b9e7:	09 c2                	or     %eax,%edx
	ret = oma_tlv_put_u8(out, tmp, insert);
  11b9e9:	89 f1                	mov    %esi,%ecx
  11b9eb:	0f b6 d2             	movzbl %dl,%edx
  11b9ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11b9f1:	e8 cd fe ff ff       	call   11b8c3 <oma_tlv_put_u8>
	if (ret < 0) {
  11b9f6:	85 c0                	test   %eax,%eax
  11b9f8:	79 07                	jns    11ba01 <oma_tlv_put+0x7b>
		return 0;
  11b9fa:	31 c0                	xor    %eax,%eax
  11b9fc:	e9 d3 00 00 00       	jmp    11bad4 <oma_tlv_put+0x14e>
	if (tlv->id > 255) {
  11ba01:	66 8b 57 02          	mov    0x2(%edi),%dx
  11ba05:	66 81 fa ff 00       	cmp    $0xff,%dx
  11ba0a:	76 18                	jbe    11ba24 <oma_tlv_put+0x9e>
		ret = oma_tlv_put_u8(out, (tlv->id >> 8) & 0xff, insert);
  11ba0c:	0f b6 d6             	movzbl %dh,%edx
  11ba0f:	89 f1                	mov    %esi,%ecx
  11ba11:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ba14:	e8 aa fe ff ff       	call   11b8c3 <oma_tlv_put_u8>
		pos++;
  11ba19:	bb 02 00 00 00       	mov    $0x2,%ebx
		if (ret < 0) {
  11ba1e:	85 c0                	test   %eax,%eax
  11ba20:	79 07                	jns    11ba29 <oma_tlv_put+0xa3>
  11ba22:	eb d6                	jmp    11b9fa <oma_tlv_put+0x74>
	pos = 1;
  11ba24:	bb 01 00 00 00       	mov    $0x1,%ebx
	ret = oma_tlv_put_u8(out, tlv->id & 0xff, insert);
  11ba29:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  11ba2d:	89 f1                	mov    %esi,%ecx
  11ba2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ba32:	e8 8c fe ff ff       	call   11b8c3 <oma_tlv_put_u8>
	if (ret < 0) {
  11ba37:	85 c0                	test   %eax,%eax
  11ba39:	78 bf                	js     11b9fa <oma_tlv_put+0x74>
	pos++;
  11ba3b:	8d 43 01             	lea    0x1(%ebx),%eax
	for (i = 2; i >= 0; i--) {
  11ba3e:	bb 02 00 00 00       	mov    $0x2,%ebx
	pos++;
  11ba43:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (len_type > i) {
  11ba46:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
  11ba49:	7e 20                	jle    11ba6b <oma_tlv_put+0xe5>
					     (tlv->length >> (i * 8)) & 0xff,
  11ba4b:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
  11ba52:	8b 57 04             	mov    0x4(%edi),%edx
  11ba55:	d3 ea                	shr    %cl,%edx
			ret = oma_tlv_put_u8(out,
  11ba57:	0f b6 d2             	movzbl %dl,%edx
  11ba5a:	89 f1                	mov    %esi,%ecx
  11ba5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ba5f:	e8 5f fe ff ff       	call   11b8c3 <oma_tlv_put_u8>
			if (ret < 0) {
  11ba64:	85 c0                	test   %eax,%eax
  11ba66:	78 92                	js     11b9fa <oma_tlv_put+0x74>
			pos++;
  11ba68:	ff 45 ec             	incl   -0x14(%ebp)
	for (i = 2; i >= 0; i--) {
  11ba6b:	4b                   	dec    %ebx
  11ba6c:	83 fb ff             	cmp    $0xffffffff,%ebx
  11ba6f:	75 d5                	jne    11ba46 <oma_tlv_put+0xc0>
	if (value != NULL && tlv->length > 0 && !insert) {
  11ba71:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  11ba75:	74 57                	je     11bace <oma_tlv_put+0x148>
  11ba77:	8b 77 04             	mov    0x4(%edi),%esi
  11ba7a:	85 f6                	test   %esi,%esi
  11ba7c:	74 50                	je     11bace <oma_tlv_put+0x148>
  11ba7e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  11ba82:	75 4a                	jne    11bace <oma_tlv_put+0x148>
		if (buf_append(CPKT_BUF_WRITE(out->out_cpkt),
  11ba84:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ba87:	0f b7 d6             	movzwl %si,%edx
  11ba8a:	8b 58 04             	mov    0x4(%eax),%ebx
  11ba8d:	8b 0b                	mov    (%ebx),%ecx
  11ba8f:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  11ba93:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if (!dst || !src) {
  11ba96:	85 c9                	test   %ecx,%ecx
  11ba98:	0f 84 5c ff ff ff    	je     11b9fa <oma_tlv_put+0x74>
	if (*dst_len + src_len > dst_size) {
  11ba9e:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  11baa2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  11baa5:	01 d1                	add    %edx,%ecx
  11baa7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  11baaa:	89 c1                	mov    %eax,%ecx
  11baac:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11baaf:	39 c1                	cmp    %eax,%ecx
  11bab1:	0f 8c 43 ff ff ff    	jl     11b9fa <oma_tlv_put+0x74>
	memcpy(dst + *dst_len, src, src_len);
  11bab7:	52                   	push   %edx
  11bab8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11babb:	ff 75 e8             	pushl  -0x18(%ebp)
  11babe:	03 45 f0             	add    -0x10(%ebp),%eax
  11bac1:	50                   	push   %eax
  11bac2:	e8 25 03 ff ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11bac7:	66 01 73 04          	add    %si,0x4(%ebx)
	memcpy(dst + *dst_len, src, src_len);
  11bacb:	83 c4 0c             	add    $0xc,%esp
	return pos + tlv->length;
  11bace:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11bad1:	03 47 04             	add    0x4(%edi),%eax
}
  11bad4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11bad7:	5b                   	pop    %ebx
  11bad8:	5e                   	pop    %esi
  11bad9:	5f                   	pop    %edi
  11bada:	5d                   	pop    %ebp
  11badb:	c3                   	ret    

0011badc <put_float64fix>:
{
  11badc:	55                   	push   %ebp
  11badd:	89 e5                	mov    %esp,%ebp
  11badf:	56                   	push   %esi
  11bae0:	53                   	push   %ebx
  11bae1:	83 ec 10             	sub    $0x10,%esp
  11bae4:	8b 55 08             	mov    0x8(%ebp),%edx
  11bae7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fd = engine_get_out_user_data(out);
  11baea:	8b 72 08             	mov    0x8(%edx),%esi
	if (!fd) {
  11baed:	85 f6                	test   %esi,%esi
  11baef:	74 4a                	je     11bb3b <put_float64fix+0x5f>
	ret = lwm2m_f64_to_b64(value, b64, sizeof(b64));
  11baf1:	6a 08                	push   $0x8
  11baf3:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  11baf6:	51                   	push   %ecx
  11baf7:	89 55 08             	mov    %edx,0x8(%ebp)
  11bafa:	ff 75 10             	pushl  0x10(%ebp)
  11bafd:	e8 71 06 00 00       	call   11c173 <lwm2m_f64_to_b64>
  11bb02:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  11bb05:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  11bb08:	85 c0                	test   %eax,%eax
  11bb0a:	8b 55 08             	mov    0x8(%ebp),%edx
  11bb0d:	79 30                	jns    11bb3f <put_float64fix+0x63>
		LOG_ERR("float64 conversion error: %d", ret);
  11bb0f:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11bb16:	74 23                	je     11bb3b <put_float64fix+0x5f>
  11bb18:	ba 58 31 12 00       	mov    $0x123158,%edx
  11bb1d:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11bb23:	c1 ea 03             	shr    $0x3,%edx
  11bb26:	c1 e2 06             	shl    $0x6,%edx
  11bb29:	83 ca 01             	or     $0x1,%edx
  11bb2c:	52                   	push   %edx
  11bb2d:	50                   	push   %eax
  11bb2e:	68 83 7f 12 00       	push   $0x127f83
  11bb33:	e8 3e 7a fe ff       	call   103576 <log_1>
  11bb38:	83 c4 0c             	add    $0xc,%esp
		return 0;
  11bb3b:	31 c0                	xor    %eax,%eax
  11bb3d:	eb 2d                	jmp    11bb6c <put_float64fix+0x90>
			path->res_inst_id : path->res_id;
  11bb3f:	f6 46 06 02          	testb  $0x2,0x6(%esi)
  11bb43:	74 08                	je     11bb4d <put_float64fix+0x71>
  11bb45:	66 8b 43 06          	mov    0x6(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bb49:	b3 01                	mov    $0x1,%bl
  11bb4b:	eb 06                	jmp    11bb53 <put_float64fix+0x77>
			path->res_inst_id : path->res_id;
  11bb4d:	66 8b 43 04          	mov    0x4(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bb51:	b3 03                	mov    $0x3,%bl
		tlv->id = id;
  11bb53:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
	len = oma_tlv_put(&tlv, out, b64, false);
  11bb57:	6a 00                	push   $0x0
  11bb59:	8d 45 e8             	lea    -0x18(%ebp),%eax
		tlv->type = type;
  11bb5c:	88 5d e8             	mov    %bl,-0x18(%ebp)
		tlv->length = buflen;
  11bb5f:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
	len = oma_tlv_put(&tlv, out, b64, false);
  11bb66:	e8 1b fe ff ff       	call   11b986 <oma_tlv_put>
  11bb6b:	5a                   	pop    %edx
}
  11bb6c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11bb6f:	5b                   	pop    %ebx
  11bb70:	5e                   	pop    %esi
  11bb71:	5d                   	pop    %ebp
  11bb72:	c3                   	ret    

0011bb73 <put_string>:
{
  11bb73:	55                   	push   %ebp
  11bb74:	31 c0                	xor    %eax,%eax
  11bb76:	89 e5                	mov    %esp,%ebp
  11bb78:	53                   	push   %ebx
  11bb79:	83 ec 08             	sub    $0x8,%esp
  11bb7c:	8b 55 08             	mov    0x8(%ebp),%edx
  11bb7f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	fd = engine_get_out_user_data(out);
  11bb82:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!fd) {
  11bb85:	85 db                	test   %ebx,%ebx
  11bb87:	74 2f                	je     11bbb8 <put_string+0x45>
			path->res_inst_id : path->res_id;
  11bb89:	f6 43 06 02          	testb  $0x2,0x6(%ebx)
  11bb8d:	74 08                	je     11bb97 <put_string+0x24>
  11bb8f:	66 8b 41 06          	mov    0x6(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bb93:	b1 01                	mov    $0x1,%cl
  11bb95:	eb 06                	jmp    11bb9d <put_string+0x2a>
			path->res_inst_id : path->res_id;
  11bb97:	66 8b 41 04          	mov    0x4(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bb9b:	b1 03                	mov    $0x3,%cl
		tlv->id = id;
  11bb9d:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
		tlv->length = buflen;
  11bba1:	8b 45 14             	mov    0x14(%ebp),%eax
		tlv->type = type;
  11bba4:	88 4d f4             	mov    %cl,-0xc(%ebp)
		tlv->length = buflen;
  11bba7:	89 45 f8             	mov    %eax,-0x8(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)buf, false);
  11bbaa:	6a 00                	push   $0x0
  11bbac:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11bbaf:	8d 45 f4             	lea    -0xc(%ebp),%eax
  11bbb2:	e8 cf fd ff ff       	call   11b986 <oma_tlv_put>
  11bbb7:	5a                   	pop    %edx
}
  11bbb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11bbbb:	c9                   	leave  
  11bbbc:	c3                   	ret    

0011bbbd <put_opaque>:
	return put_string(out, path, buf, buflen);
  11bbbd:	e9 b1 ff ff ff       	jmp    11bb73 <put_string>

0011bbc2 <put_s8>:
{
  11bbc2:	55                   	push   %ebp
  11bbc3:	89 e5                	mov    %esp,%ebp
  11bbc5:	53                   	push   %ebx
  11bbc6:	83 ec 0c             	sub    $0xc,%esp
  11bbc9:	8b 55 08             	mov    0x8(%ebp),%edx
  11bbcc:	8b 45 10             	mov    0x10(%ebp),%eax
  11bbcf:	88 45 f0             	mov    %al,-0x10(%ebp)
  11bbd2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	fd = engine_get_out_user_data(out);
  11bbd5:	8b 5a 08             	mov    0x8(%edx),%ebx
	if (!fd) {
  11bbd8:	31 c0                	xor    %eax,%eax
  11bbda:	85 db                	test   %ebx,%ebx
  11bbdc:	74 30                	je     11bc0e <put_s8+0x4c>
			path->res_inst_id : path->res_id;
  11bbde:	f6 43 06 02          	testb  $0x2,0x6(%ebx)
  11bbe2:	74 08                	je     11bbec <put_s8+0x2a>
  11bbe4:	66 8b 41 06          	mov    0x6(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bbe8:	b1 01                	mov    $0x1,%cl
  11bbea:	eb 06                	jmp    11bbf2 <put_s8+0x30>
			path->res_inst_id : path->res_id;
  11bbec:	66 8b 41 04          	mov    0x4(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bbf0:	b1 03                	mov    $0x3,%cl
		tlv->type = type;
  11bbf2:	88 4d f4             	mov    %cl,-0xc(%ebp)
		tlv->id = id;
  11bbf5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&value, false);
  11bbf9:	6a 00                	push   $0x0
  11bbfb:	8d 4d f0             	lea    -0x10(%ebp),%ecx
  11bbfe:	8d 45 f4             	lea    -0xc(%ebp),%eax
		tlv->length = buflen;
  11bc01:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&value, false);
  11bc08:	e8 79 fd ff ff       	call   11b986 <oma_tlv_put>
  11bc0d:	5a                   	pop    %edx
}
  11bc0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11bc11:	c9                   	leave  
  11bc12:	c3                   	ret    

0011bc13 <put_bool>:
{
  11bc13:	55                   	push   %ebp
  11bc14:	89 e5                	mov    %esp,%ebp
	return put_s8(out, path, value_s8);
  11bc16:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  11bc1a:	89 45 10             	mov    %eax,0x10(%ebp)
}
  11bc1d:	5d                   	pop    %ebp
	return put_s8(out, path, value_s8);
  11bc1e:	e9 9f ff ff ff       	jmp    11bbc2 <put_s8>

0011bc23 <put_s16>:
{
  11bc23:	55                   	push   %ebp
  11bc24:	89 e5                	mov    %esp,%ebp
  11bc26:	56                   	push   %esi
  11bc27:	53                   	push   %ebx
  11bc28:	83 ec 0c             	sub    $0xc,%esp
  11bc2b:	8b 55 10             	mov    0x10(%ebp),%edx
  11bc2e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11bc31:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if (INT8_MIN <= value && value <= INT8_MAX) {
  11bc34:	8d 82 80 00 00 00    	lea    0x80(%edx),%eax
  11bc3a:	66 3d ff 00          	cmp    $0xff,%ax
  11bc3e:	77 10                	ja     11bc50 <put_s16+0x2d>
		return put_s8(out, path, (int8_t)value);
  11bc40:	0f be d2             	movsbl %dl,%edx
  11bc43:	52                   	push   %edx
  11bc44:	51                   	push   %ecx
  11bc45:	53                   	push   %ebx
  11bc46:	e8 77 ff ff ff       	call   11bbc2 <put_s8>
  11bc4b:	83 c4 0c             	add    $0xc,%esp
  11bc4e:	eb 41                	jmp    11bc91 <put_s16+0x6e>
	fd = engine_get_out_user_data(out);
  11bc50:	8b 73 08             	mov    0x8(%ebx),%esi
		return 0;
  11bc53:	31 c0                	xor    %eax,%eax
	if (!fd) {
  11bc55:	85 f6                	test   %esi,%esi
  11bc57:	74 38                	je     11bc91 <put_s16+0x6e>
	net_value = sys_cpu_to_be16(value);
  11bc59:	86 f2                	xchg   %dh,%dl
			path->res_inst_id : path->res_id;
  11bc5b:	f6 46 06 02          	testb  $0x2,0x6(%esi)
	net_value = sys_cpu_to_be16(value);
  11bc5f:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
			path->res_inst_id : path->res_id;
  11bc63:	74 08                	je     11bc6d <put_s16+0x4a>
  11bc65:	66 8b 41 06          	mov    0x6(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bc69:	b2 01                	mov    $0x1,%dl
  11bc6b:	eb 06                	jmp    11bc73 <put_s16+0x50>
			path->res_inst_id : path->res_id;
  11bc6d:	66 8b 41 04          	mov    0x4(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bc71:	b2 03                	mov    $0x3,%dl
		tlv->type = type;
  11bc73:	88 55 f0             	mov    %dl,-0x10(%ebp)
		tlv->id = id;
  11bc76:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&net_value, false);
  11bc7a:	6a 00                	push   $0x0
  11bc7c:	89 da                	mov    %ebx,%edx
  11bc7e:	8d 4d ee             	lea    -0x12(%ebp),%ecx
  11bc81:	8d 45 f0             	lea    -0x10(%ebp),%eax
		tlv->length = buflen;
  11bc84:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&net_value, false);
  11bc8b:	e8 f6 fc ff ff       	call   11b986 <oma_tlv_put>
  11bc90:	5a                   	pop    %edx
}
  11bc91:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11bc94:	5b                   	pop    %ebx
  11bc95:	5e                   	pop    %esi
  11bc96:	5d                   	pop    %ebp
  11bc97:	c3                   	ret    

0011bc98 <put_s32>:
{
  11bc98:	55                   	push   %ebp
  11bc99:	89 e5                	mov    %esp,%ebp
  11bc9b:	56                   	push   %esi
  11bc9c:	53                   	push   %ebx
  11bc9d:	83 ec 0c             	sub    $0xc,%esp
  11bca0:	8b 55 10             	mov    0x10(%ebp),%edx
  11bca3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  11bca6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if (INT16_MIN <= value && value <= INT16_MAX) {
  11bca9:	8d 82 00 80 00 00    	lea    0x8000(%edx),%eax
  11bcaf:	3d ff ff 00 00       	cmp    $0xffff,%eax
  11bcb4:	77 10                	ja     11bcc6 <put_s32+0x2e>
		return put_s16(out, path, (int16_t)value);
  11bcb6:	0f bf d2             	movswl %dx,%edx
  11bcb9:	52                   	push   %edx
  11bcba:	51                   	push   %ecx
  11bcbb:	53                   	push   %ebx
  11bcbc:	e8 62 ff ff ff       	call   11bc23 <put_s16>
  11bcc1:	83 c4 0c             	add    $0xc,%esp
  11bcc4:	eb 40                	jmp    11bd06 <put_s32+0x6e>
	fd = engine_get_out_user_data(out);
  11bcc6:	8b 73 08             	mov    0x8(%ebx),%esi
		return 0;
  11bcc9:	31 c0                	xor    %eax,%eax
	if (!fd) {
  11bccb:	85 f6                	test   %esi,%esi
  11bccd:	74 37                	je     11bd06 <put_s32+0x6e>
	net_value = sys_cpu_to_be32(value);
  11bccf:	0f ca                	bswap  %edx
			path->res_inst_id : path->res_id;
  11bcd1:	f6 46 06 02          	testb  $0x2,0x6(%esi)
	net_value = sys_cpu_to_be32(value);
  11bcd5:	89 55 ec             	mov    %edx,-0x14(%ebp)
			path->res_inst_id : path->res_id;
  11bcd8:	74 08                	je     11bce2 <put_s32+0x4a>
  11bcda:	66 8b 41 06          	mov    0x6(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bcde:	b2 01                	mov    $0x1,%dl
  11bce0:	eb 06                	jmp    11bce8 <put_s32+0x50>
			path->res_inst_id : path->res_id;
  11bce2:	66 8b 41 04          	mov    0x4(%ecx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bce6:	b2 03                	mov    $0x3,%dl
		tlv->type = type;
  11bce8:	88 55 f0             	mov    %dl,-0x10(%ebp)
		tlv->id = id;
  11bceb:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&net_value, false);
  11bcef:	6a 00                	push   $0x0
  11bcf1:	89 da                	mov    %ebx,%edx
  11bcf3:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  11bcf6:	8d 45 f0             	lea    -0x10(%ebp),%eax
		tlv->length = buflen;
  11bcf9:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&net_value, false);
  11bd00:	e8 81 fc ff ff       	call   11b986 <oma_tlv_put>
  11bd05:	5a                   	pop    %edx
}
  11bd06:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11bd09:	5b                   	pop    %ebx
  11bd0a:	5e                   	pop    %esi
  11bd0b:	5d                   	pop    %ebp
  11bd0c:	c3                   	ret    

0011bd0d <put_objlnk>:
{
  11bd0d:	55                   	push   %ebp
  11bd0e:	89 e5                	mov    %esp,%ebp
  11bd10:	8b 55 10             	mov    0x10(%ebp),%edx
	int32_t value_s32 = (value->obj_id << 16) | value->obj_inst;
  11bd13:	0f b7 02             	movzwl (%edx),%eax
  11bd16:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  11bd1a:	c1 e0 10             	shl    $0x10,%eax
  11bd1d:	09 d0                	or     %edx,%eax
	return put_s32(out, path, value_s32);
  11bd1f:	89 45 10             	mov    %eax,0x10(%ebp)
}
  11bd22:	5d                   	pop    %ebp
	return put_s32(out, path, value_s32);
  11bd23:	e9 70 ff ff ff       	jmp    11bc98 <put_s32>

0011bd28 <put_s64>:
{
  11bd28:	55                   	push   %ebp
  11bd29:	89 e5                	mov    %esp,%ebp
  11bd2b:	57                   	push   %edi
  11bd2c:	56                   	push   %esi
  11bd2d:	53                   	push   %ebx
  11bd2e:	83 ec 10             	sub    $0x10,%esp
  11bd31:	8b 4d 10             	mov    0x10(%ebp),%ecx
  11bd34:	8b 5d 14             	mov    0x14(%ebp),%ebx
	if (INT32_MIN <= value && value <= INT32_MAX) {
  11bd37:	89 c8                	mov    %ecx,%eax
  11bd39:	89 da                	mov    %ebx,%edx
  11bd3b:	05 00 00 00 80       	add    $0x80000000,%eax
{
  11bd40:	8b 75 08             	mov    0x8(%ebp),%esi
	if (INT32_MIN <= value && value <= INT32_MAX) {
  11bd43:	83 d2 00             	adc    $0x0,%edx
{
  11bd46:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (INT32_MIN <= value && value <= INT32_MAX) {
  11bd49:	83 fa 00             	cmp    $0x0,%edx
  11bd4c:	77 0d                	ja     11bd5b <put_s64+0x33>
		return put_s32(out, path, (int32_t)value);
  11bd4e:	51                   	push   %ecx
  11bd4f:	57                   	push   %edi
  11bd50:	56                   	push   %esi
  11bd51:	e8 42 ff ff ff       	call   11bc98 <put_s32>
  11bd56:	83 c4 0c             	add    $0xc,%esp
  11bd59:	eb 49                	jmp    11bda4 <put_s64+0x7c>
	fd = engine_get_out_user_data(out);
  11bd5b:	8b 56 08             	mov    0x8(%esi),%edx
		return 0;
  11bd5e:	31 c0                	xor    %eax,%eax
	if (!fd) {
  11bd60:	85 d2                	test   %edx,%edx
  11bd62:	74 40                	je     11bda4 <put_s64+0x7c>
	net_value = sys_cpu_to_be64(value);
  11bd64:	89 c8                	mov    %ecx,%eax
  11bd66:	89 d9                	mov    %ebx,%ecx
  11bd68:	0f c8                	bswap  %eax
  11bd6a:	0f c9                	bswap  %ecx
  11bd6c:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11bd6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
			path->res_inst_id : path->res_id;
  11bd72:	f6 42 06 02          	testb  $0x2,0x6(%edx)
  11bd76:	74 08                	je     11bd80 <put_s64+0x58>
  11bd78:	66 8b 47 06          	mov    0x6(%edi),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bd7c:	b2 01                	mov    $0x1,%dl
  11bd7e:	eb 06                	jmp    11bd86 <put_s64+0x5e>
			path->res_inst_id : path->res_id;
  11bd80:	66 8b 47 04          	mov    0x4(%edi),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11bd84:	b2 03                	mov    $0x3,%dl
		tlv->type = type;
  11bd86:	88 55 e4             	mov    %dl,-0x1c(%ebp)
		tlv->id = id;
  11bd89:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&net_value, false);
  11bd8d:	6a 00                	push   $0x0
  11bd8f:	89 f2                	mov    %esi,%edx
  11bd91:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  11bd94:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		tlv->length = buflen;
  11bd97:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	len = oma_tlv_put(&tlv, out, (uint8_t *)&net_value, false);
  11bd9e:	e8 e3 fb ff ff       	call   11b986 <oma_tlv_put>
  11bda3:	5a                   	pop    %edx
}
  11bda4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11bda7:	5b                   	pop    %ebx
  11bda8:	5e                   	pop    %esi
  11bda9:	5f                   	pop    %edi
  11bdaa:	5d                   	pop    %ebp
  11bdab:	c3                   	ret    

0011bdac <put_end_ri>:
{
  11bdac:	55                   	push   %ebp
  11bdad:	31 c0                	xor    %eax,%eax
  11bdaf:	89 e5                	mov    %esp,%ebp
  11bdb1:	57                   	push   %edi
  11bdb2:	56                   	push   %esi
  11bdb3:	53                   	push   %ebx
  11bdb4:	83 ec 08             	sub    $0x8,%esp
  11bdb7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	fd = engine_get_out_user_data(out);
  11bdba:	8b 53 08             	mov    0x8(%ebx),%edx
	if (!fd) {
  11bdbd:	85 d2                	test   %edx,%edx
  11bdbf:	74 38                	je     11bdf9 <put_end_ri+0x4d>
			   OMA_TLV_TYPE_MULTI_RESOURCE, path->res_id);
  11bdc1:	8b 45 0c             	mov    0xc(%ebp),%eax
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
  11bdc4:	31 c9                	xor    %ecx,%ecx
	return put_end_tlv(out, fd->mark_pos_ri, &fd->writer_flags,
  11bdc6:	0f b7 7a 04          	movzwl 0x4(%edx),%edi
			   OMA_TLV_TYPE_MULTI_RESOURCE, path->res_id);
  11bdca:	66 8b 70 04          	mov    0x4(%eax),%si
	*writer_flags &= ~writer_flag;
  11bdce:	80 62 06 fd          	andb   $0xfd,0x6(%edx)
	len = out->out_cpkt->offset - mark_pos;
  11bdd2:	8b 43 04             	mov    0x4(%ebx),%eax
  11bdd5:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  11bdd9:	29 f8                	sub    %edi,%eax
	fd->mark_pos = mark_pos;
  11bddb:	66 89 3a             	mov    %di,(%edx)
		tlv->length = buflen;
  11bdde:	89 45 f0             	mov    %eax,-0x10(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
  11bde1:	89 da                	mov    %ebx,%edx
  11bde3:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11bde6:	6a 01                	push   $0x1
		tlv->type = type;
  11bde8:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
		tlv->id = id;
  11bdec:	66 89 75 ee          	mov    %si,-0x12(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
  11bdf0:	e8 91 fb ff ff       	call   11b986 <oma_tlv_put>
  11bdf5:	5a                   	pop    %edx
  11bdf6:	2b 45 f0             	sub    -0x10(%ebp),%eax
}
  11bdf9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11bdfc:	5b                   	pop    %ebx
  11bdfd:	5e                   	pop    %esi
  11bdfe:	5f                   	pop    %edi
  11bdff:	5d                   	pop    %ebp
  11be00:	c3                   	ret    

0011be01 <put_float32fix>:
{
  11be01:	55                   	push   %ebp
  11be02:	89 e5                	mov    %esp,%ebp
  11be04:	56                   	push   %esi
  11be05:	53                   	push   %ebx
  11be06:	83 ec 0c             	sub    $0xc,%esp
  11be09:	8b 55 08             	mov    0x8(%ebp),%edx
  11be0c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fd = engine_get_out_user_data(out);
  11be0f:	8b 72 08             	mov    0x8(%edx),%esi
	if (!fd) {
  11be12:	85 f6                	test   %esi,%esi
  11be14:	74 4a                	je     11be60 <put_float32fix+0x5f>
	ret = lwm2m_f32_to_b32(value, b32, sizeof(b32));
  11be16:	6a 04                	push   $0x4
  11be18:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  11be1b:	51                   	push   %ecx
  11be1c:	89 55 08             	mov    %edx,0x8(%ebp)
  11be1f:	ff 75 10             	pushl  0x10(%ebp)
  11be22:	e8 45 02 00 00       	call   11c06c <lwm2m_f32_to_b32>
  11be27:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  11be2a:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  11be2d:	85 c0                	test   %eax,%eax
  11be2f:	8b 55 08             	mov    0x8(%ebp),%edx
  11be32:	79 30                	jns    11be64 <put_float32fix+0x63>
		LOG_ERR("float32 conversion error: %d", ret);
  11be34:	f6 05 ec 5b 14 00 07 	testb  $0x7,0x145bec
  11be3b:	74 23                	je     11be60 <put_float32fix+0x5f>
  11be3d:	ba 58 31 12 00       	mov    $0x123158,%edx
  11be42:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11be48:	c1 ea 03             	shr    $0x3,%edx
  11be4b:	c1 e2 06             	shl    $0x6,%edx
  11be4e:	83 ca 01             	or     $0x1,%edx
  11be51:	52                   	push   %edx
  11be52:	50                   	push   %eax
  11be53:	68 a0 7f 12 00       	push   $0x127fa0
  11be58:	e8 19 77 fe ff       	call   103576 <log_1>
  11be5d:	83 c4 0c             	add    $0xc,%esp
		return 0;
  11be60:	31 c0                	xor    %eax,%eax
  11be62:	eb 2d                	jmp    11be91 <put_float32fix+0x90>
			path->res_inst_id : path->res_id;
  11be64:	f6 46 06 02          	testb  $0x2,0x6(%esi)
  11be68:	74 08                	je     11be72 <put_float32fix+0x71>
  11be6a:	66 8b 43 06          	mov    0x6(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11be6e:	b3 01                	mov    $0x1,%bl
  11be70:	eb 06                	jmp    11be78 <put_float32fix+0x77>
			path->res_inst_id : path->res_id;
  11be72:	66 8b 43 04          	mov    0x4(%ebx),%ax
			OMA_TLV_TYPE_RESOURCE_INSTANCE : OMA_TLV_TYPE_RESOURCE;
  11be76:	b3 03                	mov    $0x3,%bl
		tlv->id = id;
  11be78:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	len = oma_tlv_put(&tlv, out, b32, false);
  11be7c:	6a 00                	push   $0x0
  11be7e:	8d 45 f0             	lea    -0x10(%ebp),%eax
		tlv->type = type;
  11be81:	88 5d f0             	mov    %bl,-0x10(%ebp)
		tlv->length = buflen;
  11be84:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
	len = oma_tlv_put(&tlv, out, b32, false);
  11be8b:	e8 f6 fa ff ff       	call   11b986 <oma_tlv_put>
  11be90:	5a                   	pop    %edx
}
  11be91:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11be94:	5b                   	pop    %ebx
  11be95:	5e                   	pop    %esi
  11be96:	5d                   	pop    %ebp
  11be97:	c3                   	ret    

0011be98 <put_end_oi>:
{
  11be98:	55                   	push   %ebp
  11be99:	31 c0                	xor    %eax,%eax
  11be9b:	89 e5                	mov    %esp,%ebp
  11be9d:	57                   	push   %edi
  11be9e:	56                   	push   %esi
  11be9f:	53                   	push   %ebx
  11bea0:	83 ec 08             	sub    $0x8,%esp
  11bea3:	8b 55 08             	mov    0x8(%ebp),%edx
	fd = engine_get_out_user_data(out);
  11bea6:	8b 4a 08             	mov    0x8(%edx),%ecx
	if (!fd) {
  11bea9:	85 c9                	test   %ecx,%ecx
  11beab:	74 32                	je     11bedf <put_end_oi+0x47>
			   OMA_TLV_TYPE_OBJECT_INSTANCE, path->obj_inst_id);
  11bead:	8b 45 0c             	mov    0xc(%ebp),%eax
	return put_end_tlv(out, fd->mark_pos_oi, &fd->writer_flags, 0,
  11beb0:	0f b7 79 02          	movzwl 0x2(%ecx),%edi
			   OMA_TLV_TYPE_OBJECT_INSTANCE, path->obj_inst_id);
  11beb4:	66 8b 70 02          	mov    0x2(%eax),%si
	len = out->out_cpkt->offset - mark_pos;
  11beb8:	8b 42 04             	mov    0x4(%edx),%eax
  11bebb:	0f b7 40 04          	movzwl 0x4(%eax),%eax
  11bebf:	29 f8                	sub    %edi,%eax
	fd->mark_pos = mark_pos;
  11bec1:	66 89 39             	mov    %di,(%ecx)
		tlv->length = buflen;
  11bec4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
  11bec7:	31 c9                	xor    %ecx,%ecx
  11bec9:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11becc:	6a 01                	push   $0x1
		tlv->type = type;
  11bece:	c6 45 ec 00          	movb   $0x0,-0x14(%ebp)
		tlv->id = id;
  11bed2:	66 89 75 ee          	mov    %si,-0x12(%ebp)
	len = oma_tlv_put(&tlv, out, NULL, true) - tlv.length;
  11bed6:	e8 ab fa ff ff       	call   11b986 <oma_tlv_put>
  11bedb:	5a                   	pop    %edx
  11bedc:	2b 45 f0             	sub    -0x10(%ebp),%eax
}
  11bedf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11bee2:	5b                   	pop    %ebx
  11bee3:	5e                   	pop    %esi
  11bee4:	5f                   	pop    %edi
  11bee5:	5d                   	pop    %ebp
  11bee6:	c3                   	ret    

0011bee7 <do_read_op_tlv>:
{
  11bee7:	55                   	push   %ebp
  11bee8:	89 e5                	mov    %esp,%ebp
  11beea:	56                   	push   %esi
  11beeb:	53                   	push   %ebx
  11beec:	83 ec 08             	sub    $0x8,%esp
	(void)memset(&fd, 0, sizeof(fd));
  11beef:	8d 75 f0             	lea    -0x10(%ebp),%esi
{
  11bef2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void)memset(&fd, 0, sizeof(fd));
  11bef5:	6a 08                	push   $0x8
  11bef7:	6a 00                	push   $0x0
  11bef9:	56                   	push   %esi
  11befa:	e8 5c ff fe ff       	call   10be5b <memset>
  11beff:	83 c4 0c             	add    $0xc,%esp
	out->user_data = user_data;
  11bf02:	89 73 20             	mov    %esi,0x20(%ebx)
	ret = lwm2m_perform_read_op(msg, content_format);
  11bf05:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  11bf09:	50                   	push   %eax
  11bf0a:	53                   	push   %ebx
  11bf0b:	e8 c1 c8 ff ff       	call   1187d1 <lwm2m_perform_read_op>
  11bf10:	5a                   	pop    %edx
  11bf11:	59                   	pop    %ecx
	out->user_data = NULL;
  11bf12:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  11bf19:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11bf1c:	5b                   	pop    %ebx
  11bf1d:	5e                   	pop    %esi
  11bf1e:	5d                   	pop    %ebp
  11bf1f:	c3                   	ret    

0011bf20 <do_write_op_tlv>:

int do_write_op_tlv(struct lwm2m_message *msg)
{
  11bf20:	55                   	push   %ebp
  11bf21:	89 e5                	mov    %esp,%ebp
  11bf23:	57                   	push   %edi
  11bf24:	56                   	push   %esi
  11bf25:	53                   	push   %ebx
  11bf26:	83 ec 18             	sub    $0x18,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11bf29:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
{
  11bf30:	8b 5d 08             	mov    0x8(%ebp),%ebx

	/* In case of Firmware object Package resource go directly to the
	 * message processing - consecutive blocks will not carry the TLV
	 * header.
	 */
	if (msg->path.obj_id == 5 && msg->path.res_id == 0) {
  11bf33:	66 83 7b 24 05       	cmpw   $0x5,0x24(%ebx)
  11bf38:	75 16                	jne    11bf50 <do_write_op_tlv+0x30>
  11bf3a:	66 83 7b 28 00       	cmpw   $0x0,0x28(%ebx)
  11bf3f:	75 0f                	jne    11bf50 <do_write_op_tlv+0x30>
		ret = do_write_op_tlv_item(msg);
  11bf41:	89 d8                	mov    %ebx,%eax
  11bf43:	e8 3f f4 ff ff       	call   11b387 <do_write_op_tlv_item>
		if (ret < 0) {
  11bf48:	85 c0                	test   %eax,%eax
  11bf4a:	0f 88 14 01 00 00    	js     11c064 <do_write_op_tlv+0x144>
	while (true) {
		/*
		 * This initial read of TLV data won't advance frag/offset.
		 * We need tlv.type to determine how to proceed.
		 */
		len = oma_tlv_get(&tlv, &msg->in, true);
  11bf50:	8d 7b 04             	lea    0x4(%ebx),%edi
  11bf53:	b9 01 00 00 00       	mov    $0x1,%ecx
  11bf58:	89 fa                	mov    %edi,%edx
  11bf5a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  11bf5d:	e8 9d f2 ff ff       	call   11b1ff <oma_tlv_get>
		if (len == 0) {
  11bf62:	85 c0                	test   %eax,%eax
  11bf64:	0f 84 f8 00 00 00    	je     11c062 <do_write_op_tlv+0x142>
			break;
		}

		if (tlv.type == OMA_TLV_TYPE_OBJECT_INSTANCE) {
  11bf6a:	8a 45 e4             	mov    -0x1c(%ebp),%al
  11bf6d:	84 c0                	test   %al,%al
  11bf6f:	0f 85 a4 00 00 00    	jne    11c019 <do_write_op_tlv+0xf9>
			struct oma_tlv tlv2;
			int len2;
			int pos = 0;

			oma_tlv_get(&tlv, &msg->in, false);
  11bf75:	31 c9                	xor    %ecx,%ecx
  11bf77:	89 fa                	mov    %edi,%edx
  11bf79:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  11bf7c:	e8 7e f2 ff ff       	call   11b1ff <oma_tlv_get>
			msg->path.obj_inst_id = tlv.id;
  11bf81:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
			if (tlv.length == 0U) {
  11bf85:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
			msg->path.obj_inst_id = tlv.id;
  11bf89:	66 89 43 26          	mov    %ax,0x26(%ebx)
			if (tlv.length == 0U) {
  11bf8d:	75 2a                	jne    11bfb9 <do_write_op_tlv+0x99>
				/* Create only - no data */
				ret = lwm2m_create_obj_inst(
  11bf8f:	8d 55 e0             	lea    -0x20(%ebp),%edx
  11bf92:	52                   	push   %edx
  11bf93:	50                   	push   %eax
  11bf94:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  11bf98:	50                   	push   %eax
  11bf99:	e8 73 9b ff ff       	call   115b11 <lwm2m_create_obj_inst>
  11bf9e:	83 c4 0c             	add    $0xc,%esp
						msg->path.obj_id,
						msg->path.obj_inst_id,
						&obj_inst);
				if (ret < 0) {
  11bfa1:	85 c0                	test   %eax,%eax
  11bfa3:	0f 88 bb 00 00 00    	js     11c064 <do_write_op_tlv+0x144>
					return ret;
				}

#ifdef CONFIG_LWM2M_RD_CLIENT_SUPPORT
				if (!msg->ctx->bootstrap_mode) {
  11bfa9:	8b 03                	mov    (%ebx),%eax
  11bfab:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  11bfb2:	75 05                	jne    11bfb9 <do_write_op_tlv+0x99>
					engine_trigger_update();
  11bfb4:	e8 63 17 00 00       	call   11d71c <engine_trigger_update>
{
  11bfb9:	31 f6                	xor    %esi,%esi
				}
#endif
			}

			while (pos < tlv.length &&
  11bfbb:	39 75 e8             	cmp    %esi,-0x18(%ebp)
  11bfbe:	76 90                	jbe    11bf50 <do_write_op_tlv+0x30>
			       (len2 = oma_tlv_get(&tlv2, &msg->in, true))) {
  11bfc0:	89 fa                	mov    %edi,%edx
  11bfc2:	b9 01 00 00 00       	mov    $0x1,%ecx
  11bfc7:	8d 45 ec             	lea    -0x14(%ebp),%eax
  11bfca:	e8 30 f2 ff ff       	call   11b1ff <oma_tlv_get>
  11bfcf:	89 c2                	mov    %eax,%edx
			while (pos < tlv.length &&
  11bfd1:	85 c0                	test   %eax,%eax
  11bfd3:	0f 84 77 ff ff ff    	je     11bf50 <do_write_op_tlv+0x30>
				if (tlv2.type != OMA_TLV_TYPE_RESOURCE) {
  11bfd9:	80 7d ec 03          	cmpb   $0x3,-0x14(%ebp)
  11bfdd:	75 36                	jne    11c015 <do_write_op_tlv+0xf5>
					pos += len2;
					continue;
				}

				msg->path.res_id = tlv2.id;
  11bfdf:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
				msg->path.level = 3U;
  11bfe3:	c6 43 2c 03          	movb   $0x3,0x2c(%ebx)
				msg->path.res_id = tlv2.id;
  11bfe7:	66 89 43 28          	mov    %ax,0x28(%ebx)
				ret = do_write_op_tlv_item(msg);
  11bfeb:	89 d8                	mov    %ebx,%eax
  11bfed:	89 55 dc             	mov    %edx,-0x24(%ebp)
  11bff0:	e8 92 f3 ff ff       	call   11b387 <do_write_op_tlv_item>
				/*
				 * ignore errors for CREATE op
				 * for OP_CREATE and BOOTSTRAP WRITE: errors on
				 * optional resources are ignored (ENOTSUP)
				 */
				if (ret < 0 &&
  11bff5:	8b 55 dc             	mov    -0x24(%ebp),%edx
  11bff8:	85 c0                	test   %eax,%eax
  11bffa:	79 19                	jns    11c015 <do_write_op_tlv+0xf5>
  11bffc:	83 f8 dd             	cmp    $0xffffffdd,%eax
  11bfff:	75 63                	jne    11c064 <do_write_op_tlv+0x144>
				    !((ret == -ENOTSUP) &&
				      (msg->ctx->bootstrap_mode ||
  11c001:	8b 0b                	mov    (%ebx),%ecx
				    !((ret == -ENOTSUP) &&
  11c003:	80 b9 58 01 00 00 00 	cmpb   $0x0,0x158(%ecx)
  11c00a:	75 09                	jne    11c015 <do_write_op_tlv+0xf5>
				      (msg->ctx->bootstrap_mode ||
  11c00c:	80 bb 89 02 00 00 02 	cmpb   $0x2,0x289(%ebx)
  11c013:	75 4f                	jne    11c064 <do_write_op_tlv+0x144>
				       msg->operation == LWM2M_OP_CREATE))) {
					return ret;
				}

				pos += len2;
  11c015:	01 d6                	add    %edx,%esi
  11c017:	eb a2                	jmp    11bfbb <do_write_op_tlv+0x9b>
			}
		} else if (tlv.type == OMA_TLV_TYPE_RESOURCE) {
  11c019:	3c 03                	cmp    $0x3,%al
  11c01b:	74 07                	je     11c024 <do_write_op_tlv+0x104>
			      (msg->ctx->bootstrap_mode ||
			       msg->operation == LWM2M_OP_CREATE))) {
				return ret;
			}
		} else {
			return -ENOTSUP;
  11c01d:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  11c022:	eb 40                	jmp    11c064 <do_write_op_tlv+0x144>
			msg->path.res_id = tlv.id;
  11c024:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
			msg->path.level = 3U;
  11c028:	c6 43 2c 03          	movb   $0x3,0x2c(%ebx)
			msg->path.res_id = tlv.id;
  11c02c:	66 89 43 28          	mov    %ax,0x28(%ebx)
			ret = do_write_op_tlv_item(msg);
  11c030:	89 d8                	mov    %ebx,%eax
  11c032:	e8 50 f3 ff ff       	call   11b387 <do_write_op_tlv_item>
			if (ret < 0 &&
  11c037:	85 c0                	test   %eax,%eax
  11c039:	0f 89 11 ff ff ff    	jns    11bf50 <do_write_op_tlv+0x30>
  11c03f:	83 f8 dd             	cmp    $0xffffffdd,%eax
  11c042:	75 20                	jne    11c064 <do_write_op_tlv+0x144>
			      (msg->ctx->bootstrap_mode ||
  11c044:	8b 03                	mov    (%ebx),%eax
			    !((ret == -ENOTSUP) &&
  11c046:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
  11c04d:	0f 85 fd fe ff ff    	jne    11bf50 <do_write_op_tlv+0x30>
			      (msg->ctx->bootstrap_mode ||
  11c053:	80 bb 89 02 00 00 02 	cmpb   $0x2,0x289(%ebx)
  11c05a:	0f 84 f0 fe ff ff    	je     11bf50 <do_write_op_tlv+0x30>
  11c060:	eb bb                	jmp    11c01d <do_write_op_tlv+0xfd>
		}
	}

	return 0;
  11c062:	31 c0                	xor    %eax,%eax
}
  11c064:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11c067:	5b                   	pop    %ebx
  11c068:	5e                   	pop    %esi
  11c069:	5f                   	pop    %edi
  11c06a:	5d                   	pop    %ebp
  11c06b:	c3                   	ret    

0011c06c <lwm2m_f32_to_b32>:
#define SHIFT_LEFT(v, o, m) (((v) << (o)) & (m))
#define SHIFT_RIGHT(v, o, m) (((v) >> (o)) & (m))

/* convert from float32 to binary32 */
int lwm2m_f32_to_b32(float32_value_t *f32, uint8_t *b32, size_t len)
{
  11c06c:	55                   	push   %ebp
  11c06d:	89 e5                	mov    %esp,%ebp
  11c06f:	57                   	push   %edi
  11c070:	56                   	push   %esi
  11c071:	53                   	push   %ebx
	int32_t e = -1, v, f = 0;
	int i;

	if (len != 4) {
		return -EINVAL;
  11c072:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
{
  11c077:	50                   	push   %eax
	if (len != 4) {
  11c078:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
{
  11c07c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if (len != 4) {
  11c07f:	0f 85 e4 00 00 00    	jne    11c169 <lwm2m_f32_to_b32+0xfd>
	}

	/* handle zero value special case */
	if (f32->val1 == 0 && f32->val2 == 0) {
  11c085:	8b 45 08             	mov    0x8(%ebp),%eax
  11c088:	8b 55 08             	mov    0x8(%ebp),%edx
  11c08b:	8b 00                	mov    (%eax),%eax
  11c08d:	8b 4a 04             	mov    0x4(%edx),%ecx
  11c090:	89 c3                	mov    %eax,%ebx
  11c092:	09 cb                	or     %ecx,%ebx
  11c094:	75 12                	jne    11c0a8 <lwm2m_f32_to_b32+0x3c>
		memset(b32, 0, len);
  11c096:	6a 04                	push   $0x4
  11c098:	6a 00                	push   $0x0
  11c09a:	57                   	push   %edi
  11c09b:	e8 bb fd fe ff       	call   10be5b <memset>
  11c0a0:	83 c4 0c             	add    $0xc,%esp
		return 0;
  11c0a3:	e9 c1 00 00 00       	jmp    11c169 <lwm2m_f32_to_b32+0xfd>
	}

	/* sign handled later */
	v = abs(f32->val1);
  11c0a8:	89 c3                	mov    %eax,%ebx
	int32_t e = -1, v, f = 0;
  11c0aa:	83 ce ff             	or     $0xffffffff,%esi
	v = abs(f32->val1);
  11c0ad:	c1 fb 1f             	sar    $0x1f,%ebx
  11c0b0:	31 d8                	xor    %ebx,%eax
  11c0b2:	29 d8                	sub    %ebx,%eax
	int32_t e = -1, v, f = 0;
  11c0b4:	31 db                	xor    %ebx,%ebx

	/* add whole value to fraction */
	while (v > 0) {
  11c0b6:	85 c0                	test   %eax,%eax
  11c0b8:	7e 11                	jle    11c0cb <lwm2m_f32_to_b32+0x5f>
		f >>= 1;
  11c0ba:	d1 fb                	sar    %ebx

		if (v & 1) {
  11c0bc:	a8 01                	test   $0x1,%al
  11c0be:	74 06                	je     11c0c6 <lwm2m_f32_to_b32+0x5a>
			f |= (1 << 23);
  11c0c0:	81 cb 00 00 80 00    	or     $0x800000,%ebx
		}

		v >>= 1;
  11c0c6:	d1 f8                	sar    %eax
		e++;
  11c0c8:	46                   	inc    %esi
  11c0c9:	eb eb                	jmp    11c0b6 <lwm2m_f32_to_b32+0x4a>
	}

	/* sign handled later */
	v = abs(f32->val2);
  11c0cb:	89 c8                	mov    %ecx,%eax

	/* add decimal to fraction */
	i = e;
	while (v > 0 && i < 23) {
  11c0cd:	89 f2                	mov    %esi,%edx
	v = abs(f32->val2);
  11c0cf:	c1 f8 1f             	sar    $0x1f,%eax
  11c0d2:	31 c1                	xor    %eax,%ecx
  11c0d4:	29 c1                	sub    %eax,%ecx
	while (v > 0 && i < 23) {
  11c0d6:	85 c9                	test   %ecx,%ecx
  11c0d8:	7e 47                	jle    11c121 <lwm2m_f32_to_b32+0xb5>
  11c0da:	83 fa 16             	cmp    $0x16,%edx
  11c0dd:	7f 42                	jg     11c121 <lwm2m_f32_to_b32+0xb5>
		v *= 2;
  11c0df:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
		if (!f && e < 0 && v < LWM2M_FLOAT32_DEC_MAX) {
  11c0e2:	85 db                	test   %ebx,%ebx
		v *= 2;
  11c0e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11c0e7:	89 c1                	mov    %eax,%ecx
		if (!f && e < 0 && v < LWM2M_FLOAT32_DEC_MAX) {
  11c0e9:	75 0e                	jne    11c0f9 <lwm2m_f32_to_b32+0x8d>
  11c0eb:	85 f6                	test   %esi,%esi
  11c0ed:	79 0a                	jns    11c0f9 <lwm2m_f32_to_b32+0x8d>
  11c0ef:	3d 3f 42 0f 00       	cmp    $0xf423f,%eax
  11c0f4:	7f 0c                	jg     11c102 <lwm2m_f32_to_b32+0x96>
			/* handle -e */
			e--;
  11c0f6:	4e                   	dec    %esi
			continue;
  11c0f7:	eb dd                	jmp    11c0d6 <lwm2m_f32_to_b32+0x6a>
		} else if (v >= LWM2M_FLOAT32_DEC_MAX) {
  11c0f9:	81 7d f0 3f 42 0f 00 	cmpl   $0xf423f,-0x10(%ebp)
  11c100:	7e 1c                	jle    11c11e <lwm2m_f32_to_b32+0xb2>
			v -= LWM2M_FLOAT32_DEC_MAX;
			f |= 1 << (22 - i);
  11c102:	b9 16 00 00 00       	mov    $0x16,%ecx
  11c107:	b8 01 00 00 00       	mov    $0x1,%eax
  11c10c:	29 d1                	sub    %edx,%ecx
  11c10e:	d3 e0                	shl    %cl,%eax
  11c110:	09 c3                	or     %eax,%ebx
		}

		if (v == 0) {
  11c112:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11c115:	2d 40 42 0f 00       	sub    $0xf4240,%eax
  11c11a:	89 c1                	mov    %eax,%ecx
  11c11c:	74 03                	je     11c121 <lwm2m_f32_to_b32+0xb5>
			break;
		}

		i++;
  11c11e:	42                   	inc    %edx
  11c11f:	eb b5                	jmp    11c0d6 <lwm2m_f32_to_b32+0x6a>
	}

	/* adjust exponent for bias */
	e += 127;

	memset(b32, 0, len);
  11c121:	6a 04                	push   $0x4
	e += 127;
  11c123:	83 c6 7f             	add    $0x7f,%esi
	memset(b32, 0, len);
  11c126:	6a 00                	push   $0x0
  11c128:	57                   	push   %edi
  11c129:	e8 2d fd fe ff       	call   10be5b <memset>

	/* sign: bit 31 */
	if (f32->val1 == 0) {
  11c12e:	8b 45 08             	mov    0x8(%ebp),%eax
	memset(b32, 0, len);
  11c131:	83 c4 0c             	add    $0xc,%esp
	if (f32->val1 == 0) {
  11c134:	8b 00                	mov    (%eax),%eax
  11c136:	85 c0                	test   %eax,%eax
  11c138:	75 09                	jne    11c143 <lwm2m_f32_to_b32+0xd7>
		b32[0] = f32->val2 < 0 ? 0x80 : 0;
  11c13a:	8b 45 08             	mov    0x8(%ebp),%eax
  11c13d:	0f be 40 07          	movsbl 0x7(%eax),%eax
  11c141:	eb 03                	jmp    11c146 <lwm2m_f32_to_b32+0xda>
	} else {
		b32[0] = f32->val1 < 0 ? 0x80 : 0;
  11c143:	c1 f8 18             	sar    $0x18,%eax
	}

	/* exponent: bits 30-23 */
	b32[0] |= e >> 1;
  11c146:	89 f2                	mov    %esi,%edx
		b32[0] = f32->val1 < 0 ? 0x80 : 0;
  11c148:	83 e0 80             	and    $0xffffff80,%eax
	b32[0] |= e >> 1;
  11c14b:	d1 fa                	sar    %edx
	b32[1] = (e & 1) << 7;
  11c14d:	c1 e6 07             	shl    $0x7,%esi
	b32[0] |= e >> 1;
  11c150:	09 d0                	or     %edx,%eax
  11c152:	88 07                	mov    %al,(%edi)

	/* fraction: bits 22-0 */
	/* NOTE: ignore the "hidden" bit 23 in fraction */
	b32[1] |= (f >> 16) & 0x7F;
  11c154:	89 d8                	mov    %ebx,%eax
  11c156:	c1 f8 10             	sar    $0x10,%eax
	b32[2] = (f >> 8) & 0xFF;
  11c159:	86 fb                	xchg   %bh,%bl
	b32[1] |= (f >> 16) & 0x7F;
  11c15b:	83 e0 7f             	and    $0x7f,%eax
	b32[2] = (f >> 8) & 0xFF;
  11c15e:	66 89 5f 02          	mov    %bx,0x2(%edi)
	b32[1] |= (f >> 16) & 0x7F;
  11c162:	09 f0                	or     %esi,%eax
	b32[3] = f & 0xFF;

	return 0;
  11c164:	31 db                	xor    %ebx,%ebx
	b32[1] |= (f >> 16) & 0x7F;
  11c166:	88 47 01             	mov    %al,0x1(%edi)
}
  11c169:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11c16c:	89 d8                	mov    %ebx,%eax
  11c16e:	5b                   	pop    %ebx
  11c16f:	5e                   	pop    %esi
  11c170:	5f                   	pop    %edi
  11c171:	5d                   	pop    %ebp
  11c172:	c3                   	ret    

0011c173 <lwm2m_f64_to_b64>:

/* convert from float64 to binary64 */
int lwm2m_f64_to_b64(float64_value_t *f64, uint8_t *b64, size_t len)
{
  11c173:	55                   	push   %ebp
	int64_t v, f = 0;
	int32_t e = -1;
	int i;

	if (len != 8) {
		return -EINVAL;
  11c174:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
  11c179:	89 e5                	mov    %esp,%ebp
  11c17b:	57                   	push   %edi
  11c17c:	56                   	push   %esi
  11c17d:	53                   	push   %ebx
  11c17e:	83 ec 14             	sub    $0x14,%esp
	if (len != 8) {
  11c181:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  11c185:	0f 85 c4 01 00 00    	jne    11c34f <lwm2m_f64_to_b64+0x1dc>
	}

	/* handle zero value special case */
	if (f64->val1 == 0LL && f64->val2 == 0LL) {
  11c18b:	8b 45 08             	mov    0x8(%ebp),%eax
  11c18e:	8b 38                	mov    (%eax),%edi
  11c190:	8b 70 04             	mov    0x4(%eax),%esi
  11c193:	8b 40 08             	mov    0x8(%eax),%eax
  11c196:	89 45 e0             	mov    %eax,-0x20(%ebp)
  11c199:	8b 45 08             	mov    0x8(%ebp),%eax
  11c19c:	8b 40 0c             	mov    0xc(%eax),%eax
  11c19f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11c1a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11c1a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  11c1a8:	09 f8                	or     %edi,%eax
  11c1aa:	09 f2                	or     %esi,%edx
  11c1ac:	09 c2                	or     %eax,%edx
  11c1ae:	75 14                	jne    11c1c4 <lwm2m_f64_to_b64+0x51>
		memset(b64, 0, len);
  11c1b0:	6a 08                	push   $0x8
  11c1b2:	6a 00                	push   $0x0
  11c1b4:	ff 75 0c             	pushl  0xc(%ebp)
  11c1b7:	e8 9f fc fe ff       	call   10be5b <memset>
  11c1bc:	83 c4 0c             	add    $0xc,%esp
		return 0;
  11c1bf:	e9 89 01 00 00       	jmp    11c34d <lwm2m_f64_to_b64+0x1da>
	}

	/* sign handled later */
	v = abs(f64->val1);
  11c1c4:	89 f0                	mov    %esi,%eax
	int32_t e = -1;
  11c1c6:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
	v = abs(f64->val1);
  11c1cd:	c1 f8 1f             	sar    $0x1f,%eax
	int64_t v, f = 0;
  11c1d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	v = abs(f64->val1);
  11c1d7:	89 c1                	mov    %eax,%ecx
  11c1d9:	31 c7                	xor    %eax,%edi
  11c1db:	31 ce                	xor    %ecx,%esi
  11c1dd:	89 f8                	mov    %edi,%eax
  11c1df:	29 c8                	sub    %ecx,%eax
  11c1e1:	89 f2                	mov    %esi,%edx
  11c1e3:	19 ca                	sbb    %ecx,%edx
	int64_t v, f = 0;
  11c1e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/* add whole value to fraction */
	while (v > 0) {
  11c1ec:	31 c9                	xor    %ecx,%ecx
  11c1ee:	39 c1                	cmp    %eax,%ecx
  11c1f0:	89 cf                	mov    %ecx,%edi
  11c1f2:	19 d7                	sbb    %edx,%edi
  11c1f4:	7d 30                	jge    11c226 <lwm2m_f64_to_b64+0xb3>
		f >>= 1;
  11c1f6:	8b 75 f0             	mov    -0x10(%ebp),%esi
  11c1f9:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  11c1fc:	0f ac f3 01          	shrd   $0x1,%esi,%ebx
  11c200:	d1 fe                	sar    %esi
  11c202:	89 5d ec             	mov    %ebx,-0x14(%ebp)

		if (v & 1) {
  11c205:	89 c3                	mov    %eax,%ebx
		f >>= 1;
  11c207:	89 75 f0             	mov    %esi,-0x10(%ebp)
		if (v & 1) {
  11c20a:	83 e3 01             	and    $0x1,%ebx
  11c20d:	74 0c                	je     11c21b <lwm2m_f64_to_b64+0xa8>
			f |= ((int64_t)1 << 52);
  11c20f:	8b 7d f0             	mov    -0x10(%ebp),%edi
  11c212:	81 cf 00 00 10 00    	or     $0x100000,%edi
  11c218:	89 7d f0             	mov    %edi,-0x10(%ebp)
		}

		v >>= 1;
  11c21b:	0f ac d0 01          	shrd   $0x1,%edx,%eax
  11c21f:	d1 fa                	sar    %edx
		e++;
  11c221:	ff 45 e8             	incl   -0x18(%ebp)
  11c224:	eb c8                	jmp    11c1ee <lwm2m_f64_to_b64+0x7b>
	}

	/* sign handled later */
	v = abs(f64->val2);
  11c226:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  11c229:	8b 7d e0             	mov    -0x20(%ebp),%edi
  11c22c:	c1 f8 1f             	sar    $0x1f,%eax

	/* add decimal to fraction */
	i = e;
	while (v > 0 && i < 52) {
  11c22f:	8b 75 e8             	mov    -0x18(%ebp),%esi
	v = abs(f64->val2);
  11c232:	31 c7                	xor    %eax,%edi
  11c234:	89 c1                	mov    %eax,%ecx
  11c236:	89 f8                	mov    %edi,%eax
  11c238:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  11c23b:	31 cf                	xor    %ecx,%edi
  11c23d:	29 c8                	sub    %ecx,%eax
  11c23f:	89 fa                	mov    %edi,%edx
	while (v > 0 && i < 52) {
  11c241:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	v = abs(f64->val2);
  11c244:	19 ca                	sbb    %ecx,%edx
	while (v > 0 && i < 52) {
  11c246:	89 d3                	mov    %edx,%ebx
  11c248:	c1 fb 1f             	sar    $0x1f,%ebx
  11c24b:	89 d9                	mov    %ebx,%ecx
  11c24d:	39 c1                	cmp    %eax,%ecx
  11c24f:	19 d3                	sbb    %edx,%ebx
  11c251:	85 db                	test   %ebx,%ebx
  11c253:	0f 89 93 00 00 00    	jns    11c2ec <lwm2m_f64_to_b64+0x179>
  11c259:	83 7d e4 33          	cmpl   $0x33,-0x1c(%ebp)
  11c25d:	0f 8f 89 00 00 00    	jg     11c2ec <lwm2m_f64_to_b64+0x179>
		v *= 2;
  11c263:	01 c0                	add    %eax,%eax
		if (!f && e < 0 && v < LWM2M_FLOAT64_DEC_MAX) {
  11c265:	8b 7d ec             	mov    -0x14(%ebp),%edi
		v *= 2;
  11c268:	11 d2                	adc    %edx,%edx
  11c26a:	89 c1                	mov    %eax,%ecx
		if (!f && e < 0 && v < LWM2M_FLOAT64_DEC_MAX) {
  11c26c:	0b 7d f0             	or     -0x10(%ebp),%edi
		v *= 2;
  11c26f:	89 d3                	mov    %edx,%ebx
		if (!f && e < 0 && v < LWM2M_FLOAT64_DEC_MAX) {
  11c271:	bf ff c9 9a 3b       	mov    $0x3b9ac9ff,%edi
  11c276:	75 24                	jne    11c29c <lwm2m_f64_to_b64+0x129>
  11c278:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  11c27c:	79 1e                	jns    11c29c <lwm2m_f64_to_b64+0x129>
  11c27e:	39 c7                	cmp    %eax,%edi
  11c280:	be 00 00 00 00       	mov    $0x0,%esi
  11c285:	19 d6                	sbb    %edx,%esi
  11c287:	7c 1e                	jl     11c2a7 <lwm2m_f64_to_b64+0x134>
			/* handle -e */
			e--;
  11c289:	ff 4d e8             	decl   -0x18(%ebp)
			continue;
  11c28c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  11c293:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  11c29a:	eb aa                	jmp    11c246 <lwm2m_f64_to_b64+0xd3>
		} else if (v >= LWM2M_FLOAT64_DEC_MAX) {
  11c29c:	39 cf                	cmp    %ecx,%edi
  11c29e:	be 00 00 00 00       	mov    $0x0,%esi
  11c2a3:	19 de                	sbb    %ebx,%esi
  11c2a5:	7d 3d                	jge    11c2e4 <lwm2m_f64_to_b64+0x171>
			v -= LWM2M_FLOAT64_DEC_MAX;
  11c2a7:	89 c8                	mov    %ecx,%eax
  11c2a9:	89 da                	mov    %ebx,%edx
  11c2ab:	05 00 36 65 c4       	add    $0xc4653600,%eax
			f |= (int64_t)1 << (51 - i);
  11c2b0:	bf 33 00 00 00       	mov    $0x33,%edi
			v -= LWM2M_FLOAT64_DEC_MAX;
  11c2b5:	83 d2 ff             	adc    $0xffffffff,%edx
			f |= (int64_t)1 << (51 - i);
  11c2b8:	2b 7d e4             	sub    -0x1c(%ebp),%edi
  11c2bb:	89 f9                	mov    %edi,%ecx
  11c2bd:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  11c2c0:	89 cf                	mov    %ecx,%edi
  11c2c2:	c1 ef 05             	shr    $0x5,%edi
  11c2c5:	83 e7 01             	and    $0x1,%edi
  11c2c8:	89 fe                	mov    %edi,%esi
  11c2ca:	83 f6 01             	xor    $0x1,%esi
  11c2cd:	d3 e7                	shl    %cl,%edi
  11c2cf:	d3 e6                	shl    %cl,%esi
  11c2d1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  11c2d4:	09 fb                	or     %edi,%ebx
  11c2d6:	09 f1                	or     %esi,%ecx
		}

		if (v == 0) {
  11c2d8:	89 d7                	mov    %edx,%edi
			f |= (int64_t)1 << (51 - i);
  11c2da:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11c2dd:	89 5d f0             	mov    %ebx,-0x10(%ebp)
		if (v == 0) {
  11c2e0:	09 c7                	or     %eax,%edi
  11c2e2:	74 08                	je     11c2ec <lwm2m_f64_to_b64+0x179>
			break;
		}

		i++;
  11c2e4:	ff 45 e4             	incl   -0x1c(%ebp)
  11c2e7:	e9 5a ff ff ff       	jmp    11c246 <lwm2m_f64_to_b64+0xd3>
	}

	/* adjust exponent for bias */
	e += 1023;

	memset(b64, 0, len);
  11c2ec:	6a 08                	push   $0x8
	e += 1023;
  11c2ee:	8b 5d e8             	mov    -0x18(%ebp),%ebx
	memset(b64, 0, len);
  11c2f1:	6a 00                	push   $0x0
	e += 1023;
  11c2f3:	81 c3 ff 03 00 00    	add    $0x3ff,%ebx
	memset(b64, 0, len);
  11c2f9:	ff 75 0c             	pushl  0xc(%ebp)
  11c2fc:	e8 5a fb fe ff       	call   10be5b <memset>

	/* sign: bit 63 */
	if (f64->val1 == 0) {
  11c301:	8b 45 08             	mov    0x8(%ebp),%eax
  11c304:	8b 75 08             	mov    0x8(%ebp),%esi
  11c307:	8b 40 04             	mov    0x4(%eax),%eax
  11c30a:	89 c7                	mov    %eax,%edi
	memset(b64, 0, len);
  11c30c:	83 c4 0c             	add    $0xc,%esp
	if (f64->val1 == 0) {
  11c30f:	0b 3e                	or     (%esi),%edi
  11c311:	75 06                	jne    11c319 <lwm2m_f64_to_b64+0x1a6>
		b64[0] = f64->val2 < 0 ? 0x80 : 0;
  11c313:	0f be 46 0f          	movsbl 0xf(%esi),%eax
  11c317:	eb 03                	jmp    11c31c <lwm2m_f64_to_b64+0x1a9>
	} else {
		b64[0] = f64->val1 < 0 ? 0x80 : 0;
  11c319:	c1 f8 18             	sar    $0x18,%eax
	}

	/* exponent: bits 62-52 */
	b64[0] |= (e >> 4);
  11c31c:	89 da                	mov    %ebx,%edx
		b64[0] = f64->val1 < 0 ? 0x80 : 0;
  11c31e:	83 e0 80             	and    $0xffffff80,%eax
	b64[0] |= (e >> 4);
  11c321:	c1 fa 04             	sar    $0x4,%edx
	b64[1] = ((e & 0xF) << 4);
  11c324:	c1 e3 04             	shl    $0x4,%ebx
	b64[0] |= (e >> 4);
  11c327:	09 d0                	or     %edx,%eax
  11c329:	8b 55 0c             	mov    0xc(%ebp),%edx
  11c32c:	88 02                	mov    %al,(%edx)

	/* fraction: bits 51-0 */
	/* NOTE: ignore the "hidden" bit 52 in fraction */
	b64[1] |= ((f >> 48) & 0xF);
  11c32e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11c331:	c1 f8 10             	sar    $0x10,%eax
  11c334:	83 e0 0f             	and    $0xf,%eax
  11c337:	09 c3                	or     %eax,%ebx
	b64[2] = (f >> 40) & 0xFF;
  11c339:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11c33c:	88 62 02             	mov    %ah,0x2(%edx)
	b64[3] = (f >> 32) & 0xFF;
  11c33f:	88 42 03             	mov    %al,0x3(%edx)
  11c342:	8b 45 ec             	mov    -0x14(%ebp),%eax
	b64[1] |= ((f >> 48) & 0xF);
  11c345:	88 5a 01             	mov    %bl,0x1(%edx)
	b64[4] = (f >> 24) & 0xFF;
	b64[5] = (f >> 16) & 0xFF;
	b64[6] = (f >> 8) & 0xFF;
	b64[7] = f & 0xFF;
  11c348:	0f c8                	bswap  %eax
	b64[4] = (f >> 24) & 0xFF;
  11c34a:	89 42 04             	mov    %eax,0x4(%edx)

	return 0;
  11c34d:	31 c0                	xor    %eax,%eax
}
  11c34f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11c352:	5b                   	pop    %ebx
  11c353:	5e                   	pop    %esi
  11c354:	5f                   	pop    %edi
  11c355:	5d                   	pop    %ebp
  11c356:	c3                   	ret    

0011c357 <lwm2m_b32_to_f32>:

/* convert from binary32 to float32 */
int lwm2m_b32_to_f32(uint8_t *b32, size_t len, float32_value_t *f32)
{
  11c357:	55                   	push   %ebp
  11c358:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  11c35d:	89 e5                	mov    %esp,%ebp
  11c35f:	57                   	push   %edi
  11c360:	56                   	push   %esi
	int32_t f, k, i, e;
	bool sign = false;

	if (len != 4) {
  11c361:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
{
  11c365:	53                   	push   %ebx
  11c366:	8b 7d 08             	mov    0x8(%ebp),%edi
  11c369:	8b 75 10             	mov    0x10(%ebp),%esi
	if (len != 4) {
  11c36c:	0f 85 ad 00 00 00    	jne    11c41f <lwm2m_b32_to_f32+0xc8>
		return -EINVAL;
	}

	f32->val1 = 0;
  11c372:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	f32->val2 = 0;
  11c378:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
	/* calc sign: bit 31 */
	sign = SHIFT_RIGHT(b32[0], 7, 0x1);

	/* calc exponent: bits 30-23 */
	e  = SHIFT_LEFT(b32[0], 1, 0xFF);
	e += SHIFT_RIGHT(b32[1], 7, 0x1);
  11c37f:	8a 47 01             	mov    0x1(%edi),%al
	sign = SHIFT_RIGHT(b32[0], 7, 0x1);
  11c382:	8a 17                	mov    (%edi),%dl
	e += SHIFT_RIGHT(b32[1], 7, 0x1);
  11c384:	88 c1                	mov    %al,%cl
  11c386:	c0 e9 07             	shr    $0x7,%cl
	e  = SHIFT_LEFT(b32[0], 1, 0xFF);
  11c389:	8d 1c 12             	lea    (%edx,%edx,1),%ebx
  11c38c:	81 e3 fe 00 00 00    	and    $0xfe,%ebx
	e += SHIFT_RIGHT(b32[1], 7, 0x1);
  11c392:	0f b6 c9             	movzbl %cl,%ecx
	e -= 127;

	/* enable "hidden" fraction bit 23 which is always 1 */
	f  = ((int32_t)1 << 22);
	/* calc fraction: bits 22-0 */
	f += ((int32_t)(b32[1] & 0x7F) << 16);
  11c395:	c1 e0 10             	shl    $0x10,%eax
	e -= 127;
  11c398:	8d 5c 0b 81          	lea    -0x7f(%ebx,%ecx,1),%ebx
	f += ((int32_t)(b32[1] & 0x7F) << 16);
  11c39c:	25 00 00 7f 00       	and    $0x7f0000,%eax
	f += ((int32_t)b32[2] << 8);
  11c3a1:	0f b6 4f 02          	movzbl 0x2(%edi),%ecx
	f += b32[3];
  11c3a5:	0f b6 7f 03          	movzbl 0x3(%edi),%edi
	f += ((int32_t)b32[2] << 8);
  11c3a9:	c1 e1 08             	shl    $0x8,%ecx

	/* handle whole number */
	if (e > -1) {
  11c3ac:	85 db                	test   %ebx,%ebx
	f += b32[3];
  11c3ae:	8d 8c 39 00 00 40 00 	lea    0x400000(%ecx,%edi,1),%ecx
  11c3b5:	8d 3c 01             	lea    (%ecx,%eax,1),%edi
	if (e > -1) {
  11c3b8:	78 2f                	js     11c3e9 <lwm2m_b32_to_f32+0x92>
		/* precision overflow */
		if (e > 23) {
  11c3ba:	83 fb 17             	cmp    $0x17,%ebx
  11c3bd:	7e 05                	jle    11c3c4 <lwm2m_b32_to_f32+0x6d>
  11c3bf:	bb 17 00 00 00       	mov    $0x17,%ebx
			e = 23;
		}

		f32->val1 = (f >> (23 - e)) * (sign ? -1 : 1);
  11c3c4:	b9 17 00 00 00       	mov    $0x17,%ecx
  11c3c9:	89 f8                	mov    %edi,%eax
	sign = SHIFT_RIGHT(b32[0], 7, 0x1);
  11c3cb:	c0 ea 07             	shr    $0x7,%dl
		f32->val1 = (f >> (23 - e)) * (sign ? -1 : 1);
  11c3ce:	29 d9                	sub    %ebx,%ecx
  11c3d0:	d3 f8                	sar    %cl,%eax
  11c3d2:	80 fa 01             	cmp    $0x1,%dl
  11c3d5:	89 c1                	mov    %eax,%ecx
  11c3d7:	19 c0                	sbb    %eax,%eax
  11c3d9:	83 e0 02             	and    $0x2,%eax
  11c3dc:	48                   	dec    %eax
  11c3dd:	0f af c1             	imul   %ecx,%eax
  11c3e0:	89 06                	mov    %eax,(%esi)
	}

	/* calculate the rest of the decimal */
	k = LWM2M_FLOAT32_DEC_MAX;
  11c3e2:	b8 40 42 0f 00       	mov    $0xf4240,%eax
  11c3e7:	eb 15                	jmp    11c3fe <lwm2m_b32_to_f32+0xa7>
  11c3e9:	b8 40 42 0f 00       	mov    $0xf4240,%eax

	/* account for -e */
	while (e < -1) {
		k /= 2;
  11c3ee:	b9 02 00 00 00       	mov    $0x2,%ecx
	while (e < -1) {
  11c3f3:	83 fb ff             	cmp    $0xffffffff,%ebx
  11c3f6:	74 06                	je     11c3fe <lwm2m_b32_to_f32+0xa7>
		k /= 2;
  11c3f8:	99                   	cltd   
  11c3f9:	f7 f9                	idiv   %ecx
		e++;
  11c3fb:	43                   	inc    %ebx
  11c3fc:	eb f5                	jmp    11c3f3 <lwm2m_b32_to_f32+0x9c>
	}

	for (i = 22 - e; i >= 0; i--) {
  11c3fe:	b9 16 00 00 00       	mov    $0x16,%ecx
  11c403:	29 d9                	sub    %ebx,%ecx
		k /= 2;
  11c405:	bb 02 00 00 00       	mov    $0x2,%ebx
	for (i = 22 - e; i >= 0; i--) {
  11c40a:	83 f9 ff             	cmp    $0xffffffff,%ecx
  11c40d:	74 0e                	je     11c41d <lwm2m_b32_to_f32+0xc6>
		k /= 2;
  11c40f:	99                   	cltd   
  11c410:	f7 fb                	idiv   %ebx
		if (f & (1 << i)) {
  11c412:	0f a3 cf             	bt     %ecx,%edi
  11c415:	73 03                	jae    11c41a <lwm2m_b32_to_f32+0xc3>
			f32->val2 += k;
  11c417:	01 46 04             	add    %eax,0x4(%esi)
	for (i = 22 - e; i >= 0; i--) {
  11c41a:	49                   	dec    %ecx
  11c41b:	eb ed                	jmp    11c40a <lwm2m_b32_to_f32+0xb3>

		}
	}

	return 0;
  11c41d:	31 c0                	xor    %eax,%eax
}
  11c41f:	5b                   	pop    %ebx
  11c420:	5e                   	pop    %esi
  11c421:	5f                   	pop    %edi
  11c422:	5d                   	pop    %ebp
  11c423:	c3                   	ret    

0011c424 <lwm2m_b64_to_f64>:

/* convert from binary64 to float64 */
int lwm2m_b64_to_f64(uint8_t *b64, size_t len, float64_value_t *f64)
{
  11c424:	55                   	push   %ebp
  11c425:	ba ea ff ff ff       	mov    $0xffffffea,%edx
  11c42a:	89 e5                	mov    %esp,%ebp
  11c42c:	57                   	push   %edi
  11c42d:	56                   	push   %esi
  11c42e:	53                   	push   %ebx
  11c42f:	83 ec 10             	sub    $0x10,%esp
	int64_t f, k;
	int i, e;
	bool sign = false;

	if (len != 8) {
  11c432:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
{
  11c436:	8b 45 08             	mov    0x8(%ebp),%eax
	if (len != 8) {
  11c439:	0f 85 83 01 00 00    	jne    11c5c2 <lwm2m_b64_to_f64+0x19e>
		return -EINVAL;
	}

	f64->val1 = 0LL;
  11c43f:	8b 5d 10             	mov    0x10(%ebp),%ebx
	f += ((int64_t)b64[2] << 40);
	f += ((int64_t)b64[3] << 32);
	f += ((int64_t)b64[4] << 24);
	f += ((int64_t)b64[5] << 16);
	f += ((int64_t)b64[6] << 8);
	f += b64[7];
  11c442:	31 ff                	xor    %edi,%edi
  11c444:	81 c7 00 00 10 00    	add    $0x100000,%edi
	f64->val1 = 0LL;
  11c44a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  11c450:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	f64->val2 = 0LL;
  11c457:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  11c45e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
  11c465:	8a 18                	mov    (%eax),%bl
	e += SHIFT_RIGHT(b64[1], 4, 0xF);
  11c467:	8a 50 01             	mov    0x1(%eax),%dl
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
  11c46a:	88 5d ec             	mov    %bl,-0x14(%ebp)
	e += SHIFT_RIGHT(b64[1], 4, 0xF);
  11c46d:	88 d1                	mov    %dl,%cl
  11c46f:	c0 e9 04             	shr    $0x4,%cl
	e  = SHIFT_LEFT((uint16_t)b64[0], 4, 0x7F0);
  11c472:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  11c475:	c1 e3 04             	shl    $0x4,%ebx
  11c478:	81 e3 f0 07 00 00    	and    $0x7f0,%ebx
	e += SHIFT_RIGHT(b64[1], 4, 0xF);
  11c47e:	0f b6 c9             	movzbl %cl,%ecx
	f += b64[7];
  11c481:	0f b6 70 07          	movzbl 0x7(%eax),%esi
	e -= 1023;
  11c485:	8d 9c 0b 01 fc ff ff 	lea    -0x3ff(%ebx,%ecx,1),%ebx
	f += ((int64_t)b64[2] << 40);
  11c48c:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
	e -= 1023;
  11c490:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	f += ((int64_t)b64[2] << 40);
  11c493:	89 cb                	mov    %ecx,%ebx
  11c495:	c1 e3 08             	shl    $0x8,%ebx
  11c498:	b9 00 00 00 00       	mov    $0x0,%ecx
	f += b64[7];
  11c49d:	01 f1                	add    %esi,%ecx
	f += ((int64_t)b64[3] << 32);
  11c49f:	0f b6 70 03          	movzbl 0x3(%eax),%esi
	f += b64[7];
  11c4a3:	11 fb                	adc    %edi,%ebx
	f += ((int64_t)b64[3] << 32);
  11c4a5:	89 f7                	mov    %esi,%edi
  11c4a7:	be 00 00 00 00       	mov    $0x0,%esi
	f += b64[7];
  11c4ac:	01 f1                	add    %esi,%ecx
	f += ((int64_t)b64[4] << 24);
  11c4ae:	0f b6 70 04          	movzbl 0x4(%eax),%esi
	f += b64[7];
  11c4b2:	11 fb                	adc    %edi,%ebx
	f += ((int64_t)b64[4] << 24);
  11c4b4:	31 ff                	xor    %edi,%edi
  11c4b6:	0f a4 f7 18          	shld   $0x18,%esi,%edi
  11c4ba:	c1 e6 18             	shl    $0x18,%esi
	f += b64[7];
  11c4bd:	01 f1                	add    %esi,%ecx
	f += ((int64_t)b64[5] << 16);
  11c4bf:	0f b6 70 05          	movzbl 0x5(%eax),%esi
	f += b64[7];
  11c4c3:	11 fb                	adc    %edi,%ebx
	f += ((int64_t)b64[5] << 16);
  11c4c5:	31 ff                	xor    %edi,%edi
  11c4c7:	0f a4 f7 10          	shld   $0x10,%esi,%edi
  11c4cb:	c1 e6 10             	shl    $0x10,%esi
	f += b64[7];
  11c4ce:	01 ce                	add    %ecx,%esi
	f += ((int64_t)b64[6] << 8);
  11c4d0:	0f b6 48 06          	movzbl 0x6(%eax),%ecx
	f += b64[7];
  11c4d4:	11 df                	adc    %ebx,%edi
	f += ((int64_t)b64[6] << 8);
  11c4d6:	31 db                	xor    %ebx,%ebx
  11c4d8:	0f a4 cb 08          	shld   $0x8,%ecx,%ebx
  11c4dc:	c1 e1 08             	shl    $0x8,%ecx
	f += b64[7];
  11c4df:	01 ce                	add    %ecx,%esi
  11c4e1:	11 df                	adc    %ebx,%edi
	f += ((int64_t)(b64[1] & 0xF) << 48);
  11c4e3:	31 c9                	xor    %ecx,%ecx
  11c4e5:	c1 e2 10             	shl    $0x10,%edx
  11c4e8:	81 e2 00 00 0f 00    	and    $0xf0000,%edx
	f += b64[7];
  11c4ee:	01 ce                	add    %ecx,%esi
  11c4f0:	11 d7                	adc    %edx,%edi
  11c4f2:	89 75 e4             	mov    %esi,-0x1c(%ebp)

	/* handle whole number */
	if (e > -1) {
  11c4f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
	f += b64[7];
  11c4f9:	89 7d e8             	mov    %edi,-0x18(%ebp)
	if (e > -1) {
  11c4fc:	78 5e                	js     11c55c <lwm2m_b64_to_f64+0x138>
		/* precision overflow */
		if (e > 52) {
  11c4fe:	83 7d f0 34          	cmpl   $0x34,-0x10(%ebp)
  11c502:	7e 07                	jle    11c50b <lwm2m_b64_to_f64+0xe7>
  11c504:	c7 45 f0 34 00 00 00 	movl   $0x34,-0x10(%ebp)
			e = 52;
		}

		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
  11c50b:	b9 34 00 00 00       	mov    $0x34,%ecx
  11c510:	8b 7d e8             	mov    -0x18(%ebp),%edi
  11c513:	2b 4d f0             	sub    -0x10(%ebp),%ecx
  11c516:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  11c519:	0f ad fe             	shrd   %cl,%edi,%esi
  11c51c:	d3 ff                	sar    %cl,%edi
  11c51e:	f6 c1 20             	test   $0x20,%cl
  11c521:	74 05                	je     11c528 <lwm2m_b64_to_f64+0x104>
  11c523:	89 fe                	mov    %edi,%esi
  11c525:	c1 ff 1f             	sar    $0x1f,%edi
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
  11c528:	8a 4d ec             	mov    -0x14(%ebp),%cl
		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
  11c52b:	89 fa                	mov    %edi,%edx
	sign = SHIFT_RIGHT(b64[0], 7, 0x1);
  11c52d:	c0 e9 07             	shr    $0x7,%cl
		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
  11c530:	8b 5d 10             	mov    0x10(%ebp),%ebx
  11c533:	80 f9 01             	cmp    $0x1,%cl
  11c536:	19 c0                	sbb    %eax,%eax
	}

	/* calculate the rest of the decimal */
	k = LWM2M_FLOAT64_DEC_MAX;
  11c538:	31 ff                	xor    %edi,%edi
		f64->val1 = (f >> (52 - e)) * (sign ? -1 : 1);
  11c53a:	c1 e1 1f             	shl    $0x1f,%ecx
  11c53d:	83 e0 02             	and    $0x2,%eax
  11c540:	c1 f9 1f             	sar    $0x1f,%ecx
  11c543:	48                   	dec    %eax
  11c544:	0f af d0             	imul   %eax,%edx
  11c547:	0f af ce             	imul   %esi,%ecx
  11c54a:	01 d1                	add    %edx,%ecx
  11c54c:	f7 e6                	mul    %esi
  11c54e:	01 ca                	add    %ecx,%edx
  11c550:	89 03                	mov    %eax,(%ebx)
  11c552:	89 53 04             	mov    %edx,0x4(%ebx)
	k = LWM2M_FLOAT64_DEC_MAX;
  11c555:	be 00 ca 9a 3b       	mov    $0x3b9aca00,%esi
  11c55a:	eb 23                	jmp    11c57f <lwm2m_b64_to_f64+0x15b>
  11c55c:	be 00 ca 9a 3b       	mov    $0x3b9aca00,%esi
  11c561:	31 ff                	xor    %edi,%edi

	/* account for -e */
	while (e < -1) {
  11c563:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
  11c567:	74 16                	je     11c57f <lwm2m_b64_to_f64+0x15b>
		k /= 2;
  11c569:	89 f8                	mov    %edi,%eax
  11c56b:	31 d2                	xor    %edx,%edx
  11c56d:	c1 e8 1f             	shr    $0x1f,%eax
  11c570:	01 c6                	add    %eax,%esi
  11c572:	11 d7                	adc    %edx,%edi
		e++;
  11c574:	ff 45 f0             	incl   -0x10(%ebp)
		k /= 2;
  11c577:	0f ac fe 01          	shrd   $0x1,%edi,%esi
  11c57b:	d1 ff                	sar    %edi
		e++;
  11c57d:	eb e4                	jmp    11c563 <lwm2m_b64_to_f64+0x13f>
	}

	for (i = 51 - e; i >= 0; i--) {
  11c57f:	b9 33 00 00 00       	mov    $0x33,%ecx
  11c584:	2b 4d f0             	sub    -0x10(%ebp),%ecx
  11c587:	83 f9 ff             	cmp    $0xffffffff,%ecx
  11c58a:	74 34                	je     11c5c0 <lwm2m_b64_to_f64+0x19c>
		k /= 2;
  11c58c:	89 f8                	mov    %edi,%eax
  11c58e:	31 d2                	xor    %edx,%edx
  11c590:	c1 e8 1f             	shr    $0x1f,%eax
  11c593:	01 c6                	add    %eax,%esi
		if (f & ((int64_t)1 << i)) {
  11c595:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		k /= 2;
  11c598:	11 d7                	adc    %edx,%edi
		if (f & ((int64_t)1 << i)) {
  11c59a:	8b 55 e8             	mov    -0x18(%ebp),%edx
		k /= 2;
  11c59d:	0f ac fe 01          	shrd   $0x1,%edi,%esi
		if (f & ((int64_t)1 << i)) {
  11c5a1:	0f ad d0             	shrd   %cl,%edx,%eax
		k /= 2;
  11c5a4:	d1 ff                	sar    %edi
		if (f & ((int64_t)1 << i)) {
  11c5a6:	d3 fa                	sar    %cl,%edx
  11c5a8:	f6 c1 20             	test   $0x20,%cl
  11c5ab:	74 02                	je     11c5af <lwm2m_b64_to_f64+0x18b>
  11c5ad:	89 d0                	mov    %edx,%eax
  11c5af:	83 e0 01             	and    $0x1,%eax
  11c5b2:	74 09                	je     11c5bd <lwm2m_b64_to_f64+0x199>
			f64->val2 += k;
  11c5b4:	8b 45 10             	mov    0x10(%ebp),%eax
  11c5b7:	01 70 08             	add    %esi,0x8(%eax)
  11c5ba:	11 78 0c             	adc    %edi,0xc(%eax)
	for (i = 51 - e; i >= 0; i--) {
  11c5bd:	49                   	dec    %ecx
  11c5be:	eb c7                	jmp    11c587 <lwm2m_b64_to_f64+0x163>

		}
	}

	return 0;
  11c5c0:	31 d2                	xor    %edx,%edx
}
  11c5c2:	83 c4 10             	add    $0x10,%esp
  11c5c5:	89 d0                	mov    %edx,%eax
  11c5c7:	5b                   	pop    %ebx
  11c5c8:	5e                   	pop    %esi
  11c5c9:	5f                   	pop    %edi
  11c5ca:	5d                   	pop    %ebp
  11c5cb:	c3                   	ret    

0011c5cc <set_sm_state>:
{
	enum lwm2m_rd_client_event event = LWM2M_RD_CLIENT_EVENT_NONE;

	/* Determine if a callback to the app is needed */
#if defined(CONFIG_LWM2M_RD_CLIENT_SUPPORT_BOOTSTRAP)
	if (sm_state == ENGINE_BOOTSTRAP_REG_DONE) {
  11c5cc:	3c 04                	cmp    $0x4,%al
  11c5ce:	75 0e                	jne    11c5de <set_sm_state+0x12>
		    client.engine_state <= ENGINE_DEREGISTER_SENT)) {
		event = LWM2M_RD_CLIENT_EVENT_DISCONNECT;
	}

	/* TODO: add locking? */
	client.engine_state = sm_state;
  11c5d0:	c6 05 08 e4 12 00 04 	movb   $0x4,0x12e408
		event = LWM2M_RD_CLIENT_EVENT_BOOTSTRAP_REG_COMPLETE;
  11c5d7:	b8 02 00 00 00       	mov    $0x2,%eax
  11c5dc:	eb 7a                	jmp    11c658 <set_sm_state+0x8c>
	} else if (client.engine_state == ENGINE_BOOTSTRAP_TRANS_DONE &&
  11c5de:	8a 15 08 e4 12 00    	mov    0x12e408,%dl
  11c5e4:	80 fa 05             	cmp    $0x5,%dl
  11c5e7:	75 06                	jne    11c5ef <set_sm_state+0x23>
  11c5e9:	3c 06                	cmp    $0x6,%al
  11c5eb:	75 0b                	jne    11c5f8 <set_sm_state+0x2c>
  11c5ed:	eb 5d                	jmp    11c64c <set_sm_state+0x80>
	if (client.engine_state == ENGINE_UPDATE_SENT &&
  11c5ef:	3c 08                	cmp    $0x8,%al
  11c5f1:	75 09                	jne    11c5fc <set_sm_state+0x30>
  11c5f3:	80 fa 0a             	cmp    $0xa,%dl
  11c5f6:	74 46                	je     11c63e <set_sm_state+0x72>
	} else if (sm_state == ENGINE_REGISTRATION_DONE) {
  11c5f8:	3c 08                	cmp    $0x8,%al
  11c5fa:	74 34                	je     11c630 <set_sm_state+0x64>
	} else if (sm_state == ENGINE_REGISTRATION_DONE_RX_OFF) {
  11c5fc:	3c 09                	cmp    $0x9,%al
  11c5fe:	74 22                	je     11c622 <set_sm_state+0x56>
	} else if ((sm_state == ENGINE_INIT ||
  11c600:	3c 01                	cmp    $0x1,%al
  11c602:	74 04                	je     11c608 <set_sm_state+0x3c>
  11c604:	3c 0e                	cmp    $0xe,%al
  11c606:	75 14                	jne    11c61c <set_sm_state+0x50>
		   (client.engine_state >= ENGINE_DO_REGISTRATION &&
  11c608:	83 ea 06             	sub    $0x6,%edx
		    sm_state == ENGINE_DEREGISTERED) &&
  11c60b:	80 fa 06             	cmp    $0x6,%dl
  11c60e:	77 0c                	ja     11c61c <set_sm_state+0x50>
	client.engine_state = sm_state;
  11c610:	a2 08 e4 12 00       	mov    %al,0x12e408
		event = LWM2M_RD_CLIENT_EVENT_DISCONNECT;
  11c615:	b8 09 00 00 00       	mov    $0x9,%eax
  11c61a:	eb 3c                	jmp    11c658 <set_sm_state+0x8c>
	client.engine_state = sm_state;
  11c61c:	a2 08 e4 12 00       	mov    %al,0x12e408

	if (event > LWM2M_RD_CLIENT_EVENT_NONE && client.event_cb) {
  11c621:	c3                   	ret    
	client.engine_state = sm_state;
  11c622:	c6 05 08 e4 12 00 09 	movb   $0x9,0x12e408
		event = LWM2M_RD_CLIENT_EVENT_QUEUE_MODE_RX_OFF;
  11c629:	b8 0a 00 00 00       	mov    $0xa,%eax
  11c62e:	eb 28                	jmp    11c658 <set_sm_state+0x8c>
	client.engine_state = sm_state;
  11c630:	c6 05 08 e4 12 00 08 	movb   $0x8,0x12e408
		event = LWM2M_RD_CLIENT_EVENT_REGISTRATION_COMPLETE;
  11c637:	b8 05 00 00 00       	mov    $0x5,%eax
  11c63c:	eb 1a                	jmp    11c658 <set_sm_state+0x8c>
	client.engine_state = sm_state;
  11c63e:	c6 05 08 e4 12 00 08 	movb   $0x8,0x12e408
		event = LWM2M_RD_CLIENT_EVENT_REG_UPDATE_COMPLETE;
  11c645:	b8 07 00 00 00       	mov    $0x7,%eax
  11c64a:	eb 0c                	jmp    11c658 <set_sm_state+0x8c>
	client.engine_state = sm_state;
  11c64c:	c6 05 08 e4 12 00 06 	movb   $0x6,0x12e408
		event = LWM2M_RD_CLIENT_EVENT_BOOTSTRAP_TRANSFER_COMPLETE;
  11c653:	b8 03 00 00 00       	mov    $0x3,%eax
	if (event > LWM2M_RD_CLIENT_EVENT_NONE && client.event_cb) {
  11c658:	8b 15 60 e4 12 00    	mov    0x12e460,%edx
  11c65e:	85 d2                	test   %edx,%edx
  11c660:	74 10                	je     11c672 <set_sm_state+0xa6>
{
  11c662:	55                   	push   %ebp
  11c663:	89 e5                	mov    %esp,%ebp
		client.event_cb(client.ctx, event);
  11c665:	50                   	push   %eax
  11c666:	ff 35 04 e4 12 00    	pushl  0x12e404
  11c66c:	ff d2                	call   *%edx
  11c66e:	58                   	pop    %eax
  11c66f:	5a                   	pop    %edx
	}
}
  11c670:	c9                   	leave  
  11c671:	c3                   	ret    
  11c672:	c3                   	ret    

0011c673 <lwm2m_rd_client_init>:

	LOG_INF("Stop LWM2M Client: %s", log_strdup(client.ep_name));
}

static int lwm2m_rd_client_init(const struct device *dev)
{
  11c673:	55                   	push   %ebp
  11c674:	89 e5                	mov    %esp,%ebp
	return lwm2m_engine_add_service(lwm2m_rd_client_service,
  11c676:	68 f4 01 00 00       	push   $0x1f4
  11c67b:	68 56 d0 11 00       	push   $0x11d056
  11c680:	e8 af ca ff ff       	call   119134 <lwm2m_engine_add_service>
  11c685:	5a                   	pop    %edx
  11c686:	59                   	pop    %ecx
					STATE_MACHINE_UPDATE_INTERVAL_MS);

}
  11c687:	c9                   	leave  
  11c688:	c3                   	ret    

0011c689 <do_bootstrap_reply_cb>:
{
  11c689:	55                   	push   %ebp
  11c68a:	89 e5                	mov    %esp,%ebp
	code = coap_header_get_code(response);
  11c68c:	ff 75 08             	pushl  0x8(%ebp)
  11c68f:	e8 e0 c4 fe ff       	call   108b74 <coap_header_get_code>
  11c694:	5a                   	pop    %edx
	if (code == COAP_RESPONSE_CODE_CHANGED) {
  11c695:	3c 44                	cmp    $0x44,%al
  11c697:	8b 15 f4 5b 14 00    	mov    0x145bf4,%edx
  11c69d:	75 32                	jne    11c6d1 <do_bootstrap_reply_cb+0x48>
		LOG_INF("Bootstrap registration done!");
  11c69f:	83 e2 07             	and    $0x7,%edx
  11c6a2:	83 fa 02             	cmp    $0x2,%edx
  11c6a5:	76 20                	jbe    11c6c7 <do_bootstrap_reply_cb+0x3e>
  11c6a7:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c6ac:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c6b1:	c1 e8 03             	shr    $0x3,%eax
  11c6b4:	c1 e0 06             	shl    $0x6,%eax
  11c6b7:	83 c8 03             	or     $0x3,%eax
  11c6ba:	50                   	push   %eax
  11c6bb:	68 cf 7f 12 00       	push   $0x127fcf
  11c6c0:	e8 88 6e fe ff       	call   10354d <log_0>
  11c6c5:	59                   	pop    %ecx
  11c6c6:	58                   	pop    %eax
		set_sm_state(ENGINE_BOOTSTRAP_REG_DONE);
  11c6c7:	b8 04 00 00 00       	mov    $0x4,%eax
  11c6cc:	e9 8d 00 00 00       	jmp    11c75e <do_bootstrap_reply_cb+0xd5>
	} else if (code == COAP_RESPONSE_CODE_NOT_FOUND) {
  11c6d1:	83 e2 07             	and    $0x7,%edx
  11c6d4:	3c 84                	cmp    $0x84,%al
  11c6d6:	75 2b                	jne    11c703 <do_bootstrap_reply_cb+0x7a>
		LOG_ERR("Failed: NOT_FOUND.  Not Retrying.");
  11c6d8:	85 d2                	test   %edx,%edx
  11c6da:	74 20                	je     11c6fc <do_bootstrap_reply_cb+0x73>
  11c6dc:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c6e1:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c6e6:	c1 e8 03             	shr    $0x3,%eax
  11c6e9:	c1 e0 06             	shl    $0x6,%eax
  11c6ec:	83 c8 01             	or     $0x1,%eax
  11c6ef:	50                   	push   %eax
  11c6f0:	68 ec 7f 12 00       	push   $0x127fec
  11c6f5:	e8 53 6e fe ff       	call   10354d <log_0>
  11c6fa:	58                   	pop    %eax
  11c6fb:	5a                   	pop    %edx
		set_sm_state(ENGINE_DO_REGISTRATION);
  11c6fc:	b8 06 00 00 00       	mov    $0x6,%eax
  11c701:	eb 5b                	jmp    11c75e <do_bootstrap_reply_cb+0xd5>
	} else if (code == COAP_RESPONSE_CODE_FORBIDDEN) {
  11c703:	3c 83                	cmp    $0x83,%al
  11c705:	75 1f                	jne    11c726 <do_bootstrap_reply_cb+0x9d>
		LOG_ERR("Failed: 4.03 - Forbidden.  Not Retrying.");
  11c707:	85 d2                	test   %edx,%edx
  11c709:	74 f1                	je     11c6fc <do_bootstrap_reply_cb+0x73>
  11c70b:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c710:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c715:	c1 e8 03             	shr    $0x3,%eax
  11c718:	c1 e0 06             	shl    $0x6,%eax
  11c71b:	83 c8 01             	or     $0x1,%eax
  11c71e:	50                   	push   %eax
  11c71f:	68 0e 80 12 00       	push   $0x12800e
  11c724:	eb cf                	jmp    11c6f5 <do_bootstrap_reply_cb+0x6c>
		LOG_ERR("Failed with code %u.%u. Retrying ...",
  11c726:	85 d2                	test   %edx,%edx
  11c728:	74 2f                	je     11c759 <do_bootstrap_reply_cb+0xd0>
  11c72a:	ba 68 31 12 00       	mov    $0x123168,%edx
  11c72f:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11c735:	c1 ea 03             	shr    $0x3,%edx
  11c738:	c1 e2 06             	shl    $0x6,%edx
  11c73b:	83 ca 01             	or     $0x1,%edx
  11c73e:	52                   	push   %edx
  11c73f:	89 c2                	mov    %eax,%edx
  11c741:	c0 e8 05             	shr    $0x5,%al
  11c744:	83 e2 1f             	and    $0x1f,%edx
  11c747:	52                   	push   %edx
  11c748:	0f b6 c0             	movzbl %al,%eax
  11c74b:	50                   	push   %eax
  11c74c:	68 37 80 12 00       	push   $0x128037
  11c751:	e8 5a 6e fe ff       	call   1035b0 <log_2>
  11c756:	83 c4 10             	add    $0x10,%esp
		set_sm_state(ENGINE_INIT);
  11c759:	b8 01 00 00 00       	mov    $0x1,%eax
  11c75e:	e8 69 fe ff ff       	call   11c5cc <set_sm_state>
}
  11c763:	31 c0                	xor    %eax,%eax
  11c765:	c9                   	leave  
  11c766:	c3                   	ret    

0011c767 <do_update_reply_cb>:
{
  11c767:	55                   	push   %ebp
  11c768:	89 e5                	mov    %esp,%ebp
  11c76a:	53                   	push   %ebx
	code = coap_header_get_code(response);
  11c76b:	ff 75 08             	pushl  0x8(%ebp)
  11c76e:	e8 01 c4 fe ff       	call   108b74 <coap_header_get_code>
  11c773:	88 c3                	mov    %al,%bl
	LOG_INF("Update callback (code:%u.%u)",
  11c775:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
  11c77a:	83 e0 07             	and    $0x7,%eax
	code = coap_header_get_code(response);
  11c77d:	59                   	pop    %ecx
	LOG_INF("Update callback (code:%u.%u)",
  11c77e:	83 f8 02             	cmp    $0x2,%eax
  11c781:	76 30                	jbe    11c7b3 <do_update_reply_cb+0x4c>
  11c783:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c788:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c78d:	c1 e8 03             	shr    $0x3,%eax
  11c790:	c1 e0 06             	shl    $0x6,%eax
  11c793:	83 c8 03             	or     $0x3,%eax
  11c796:	50                   	push   %eax
  11c797:	89 d8                	mov    %ebx,%eax
  11c799:	83 e0 1f             	and    $0x1f,%eax
  11c79c:	50                   	push   %eax
  11c79d:	88 d8                	mov    %bl,%al
  11c79f:	c0 e8 05             	shr    $0x5,%al
  11c7a2:	0f b6 c0             	movzbl %al,%eax
  11c7a5:	50                   	push   %eax
  11c7a6:	68 5c 80 12 00       	push   $0x12805c
  11c7ab:	e8 00 6e fe ff       	call   1035b0 <log_2>
  11c7b0:	83 c4 10             	add    $0x10,%esp
	if ((code == COAP_RESPONSE_CODE_CHANGED) ||
  11c7b3:	80 fb 44             	cmp    $0x44,%bl
  11c7b6:	74 05                	je     11c7bd <do_update_reply_cb+0x56>
  11c7b8:	80 fb 41             	cmp    $0x41,%bl
  11c7bb:	75 39                	jne    11c7f6 <do_update_reply_cb+0x8f>
		set_sm_state(ENGINE_REGISTRATION_DONE);
  11c7bd:	b8 08 00 00 00       	mov    $0x8,%eax
  11c7c2:	e8 05 fe ff ff       	call   11c5cc <set_sm_state>
		LOG_INF("Update Done");
  11c7c7:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
  11c7cc:	83 e0 07             	and    $0x7,%eax
  11c7cf:	83 f8 02             	cmp    $0x2,%eax
  11c7d2:	76 63                	jbe    11c837 <do_update_reply_cb+0xd0>
  11c7d4:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c7d9:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c7de:	c1 e8 03             	shr    $0x3,%eax
  11c7e1:	c1 e0 06             	shl    $0x6,%eax
  11c7e4:	83 c8 03             	or     $0x3,%eax
  11c7e7:	50                   	push   %eax
  11c7e8:	68 79 80 12 00       	push   $0x128079
  11c7ed:	e8 5b 6d fe ff       	call   10354d <log_0>
  11c7f2:	58                   	pop    %eax
  11c7f3:	5a                   	pop    %edx
  11c7f4:	eb 41                	jmp    11c837 <do_update_reply_cb+0xd0>
	LOG_ERR("Failed with code %u.%u. Retrying registration",
  11c7f6:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11c7fd:	74 2e                	je     11c82d <do_update_reply_cb+0xc6>
  11c7ff:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c804:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c809:	c1 e8 03             	shr    $0x3,%eax
  11c80c:	c1 e0 06             	shl    $0x6,%eax
  11c80f:	83 c8 01             	or     $0x1,%eax
  11c812:	50                   	push   %eax
  11c813:	89 d8                	mov    %ebx,%eax
  11c815:	c0 eb 05             	shr    $0x5,%bl
  11c818:	83 e0 1f             	and    $0x1f,%eax
  11c81b:	50                   	push   %eax
  11c81c:	0f b6 db             	movzbl %bl,%ebx
  11c81f:	53                   	push   %ebx
  11c820:	68 85 80 12 00       	push   $0x128085
  11c825:	e8 86 6d fe ff       	call   1035b0 <log_2>
  11c82a:	83 c4 10             	add    $0x10,%esp
	set_sm_state(ENGINE_DO_REGISTRATION);
  11c82d:	b8 06 00 00 00       	mov    $0x6,%eax
  11c832:	e8 95 fd ff ff       	call   11c5cc <set_sm_state>
}
  11c837:	31 c0                	xor    %eax,%eax
  11c839:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11c83c:	c9                   	leave  
  11c83d:	c3                   	ret    

0011c83e <sm_bootstrap_verify>:
{
  11c83e:	55                   	push   %ebp
  11c83f:	89 e5                	mov    %esp,%ebp
  11c841:	56                   	push   %esi
  11c842:	53                   	push   %ebx
  11c843:	89 c3                	mov    %eax,%ebx
  11c845:	83 ec 1c             	sub    $0x1c,%esp
	snprintk(pathstr, sizeof(pathstr), "0/%d/1", sec_obj_inst);
  11c848:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  11c84b:	52                   	push   %edx
  11c84c:	68 b3 80 12 00       	push   $0x1280b3
  11c851:	6a 14                	push   $0x14
  11c853:	56                   	push   %esi
  11c854:	e8 a6 4a fe ff       	call   1012ff <snprintk>
  11c859:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_engine_get_bool(pathstr, &bootstrap);
  11c85c:	8d 45 e3             	lea    -0x1d(%ebp),%eax
  11c85f:	50                   	push   %eax
  11c860:	56                   	push   %esi
  11c861:	e8 dc ba ff ff       	call   118342 <lwm2m_engine_get_bool>
  11c866:	5a                   	pop    %edx
	if (ret < 0) {
  11c867:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_bool(pathstr, &bootstrap);
  11c869:	59                   	pop    %ecx
	if (ret < 0) {
  11c86a:	79 38                	jns    11c8a4 <sm_bootstrap_verify+0x66>
  11c86c:	89 c1                	mov    %eax,%ecx
		return false;
  11c86e:	31 c0                	xor    %eax,%eax
		LOG_WRN("Failed to check bootstrap, err %d", ret);
  11c870:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
  11c877:	74 31                	je     11c8aa <sm_bootstrap_verify+0x6c>
  11c879:	ba 68 31 12 00       	mov    $0x123168,%edx
  11c87e:	88 45 df             	mov    %al,-0x21(%ebp)
  11c881:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11c887:	c1 ea 03             	shr    $0x3,%edx
  11c88a:	c1 e2 06             	shl    $0x6,%edx
  11c88d:	83 ca 02             	or     $0x2,%edx
  11c890:	52                   	push   %edx
  11c891:	51                   	push   %ecx
  11c892:	68 ba 80 12 00       	push   $0x1280ba
  11c897:	e8 da 6c fe ff       	call   103576 <log_1>
  11c89c:	83 c4 0c             	add    $0xc,%esp
  11c89f:	8a 45 df             	mov    -0x21(%ebp),%al
  11c8a2:	eb 06                	jmp    11c8aa <sm_bootstrap_verify+0x6c>
	if (bootstrap == bootstrap_server) {
  11c8a4:	38 5d e3             	cmp    %bl,-0x1d(%ebp)
  11c8a7:	0f 94 c0             	sete   %al
}
  11c8aa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11c8ad:	5b                   	pop    %ebx
  11c8ae:	5e                   	pop    %esi
  11c8af:	5d                   	pop    %ebp
  11c8b0:	c3                   	ret    

0011c8b1 <do_registration_reply_cb>:
{
  11c8b1:	55                   	push   %ebp
  11c8b2:	89 e5                	mov    %esp,%ebp
  11c8b4:	56                   	push   %esi
  11c8b5:	53                   	push   %ebx
  11c8b6:	83 ec 20             	sub    $0x20,%esp
  11c8b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	code = coap_header_get_code(response);
  11c8bc:	53                   	push   %ebx
  11c8bd:	e8 b2 c2 fe ff       	call   108b74 <coap_header_get_code>
  11c8c2:	5e                   	pop    %esi
	if (code == COAP_RESPONSE_CODE_CREATED) {
  11c8c3:	3c 41                	cmp    $0x41,%al
  11c8c5:	0f 85 01 01 00 00    	jne    11c9cc <do_registration_reply_cb+0x11b>
		ret = coap_find_options(response, COAP_OPTION_LOCATION_PATH,
  11c8cb:	6a 02                	push   $0x2
  11c8cd:	8d 45 d8             	lea    -0x28(%ebp),%eax
  11c8d0:	50                   	push   %eax
  11c8d1:	6a 08                	push   $0x8
  11c8d3:	53                   	push   %ebx
  11c8d4:	e8 c1 c1 fe ff       	call   108a9a <coap_find_options>
  11c8d9:	83 c4 10             	add    $0x10,%esp
		if (ret < 2) {
  11c8dc:	48                   	dec    %eax
  11c8dd:	7f 37                	jg     11c916 <do_registration_reply_cb+0x65>
			LOG_ERR("Unexpected endpoint data returned.");
  11c8df:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
			return -EINVAL;
  11c8e6:	be ea ff ff ff       	mov    $0xffffffea,%esi
			LOG_ERR("Unexpected endpoint data returned.");
  11c8eb:	0f 84 75 01 00 00    	je     11ca66 <do_registration_reply_cb+0x1b5>
  11c8f1:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c8f6:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c8fb:	c1 e8 03             	shr    $0x3,%eax
  11c8fe:	c1 e0 06             	shl    $0x6,%eax
  11c901:	83 c8 01             	or     $0x1,%eax
  11c904:	50                   	push   %eax
  11c905:	68 dc 80 12 00       	push   $0x1280dc
  11c90a:	e8 3e 6c fe ff       	call   10354d <log_0>
  11c90f:	59                   	pop    %ecx
  11c910:	5b                   	pop    %ebx
  11c911:	e9 50 01 00 00       	jmp    11ca66 <do_registration_reply_cb+0x1b5>
		if (options[1].len + 1 > sizeof(client.server_ep)) {
  11c916:	0f b6 55 ea          	movzbl -0x16(%ebp),%edx
  11c91a:	8d 42 01             	lea    0x1(%edx),%eax
  11c91d:	83 f8 21             	cmp    $0x21,%eax
  11c920:	7e 3b                	jle    11c95d <do_registration_reply_cb+0xac>
			LOG_ERR("Unexpected length of query: "
  11c922:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
			return -EINVAL;
  11c929:	be ea ff ff ff       	mov    $0xffffffea,%esi
			LOG_ERR("Unexpected length of query: "
  11c92e:	0f 84 32 01 00 00    	je     11ca66 <do_registration_reply_cb+0x1b5>
  11c934:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c939:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c93e:	c1 e8 03             	shr    $0x3,%eax
  11c941:	c1 e0 06             	shl    $0x6,%eax
  11c944:	83 c8 01             	or     $0x1,%eax
  11c947:	50                   	push   %eax
  11c948:	6a 21                	push   $0x21
  11c94a:	52                   	push   %edx
  11c94b:	68 ff 80 12 00       	push   $0x1280ff
  11c950:	e8 5b 6c fe ff       	call   1035b0 <log_2>
  11c955:	83 c4 10             	add    $0x10,%esp
  11c958:	e9 09 01 00 00       	jmp    11ca66 <do_registration_reply_cb+0x1b5>
		memcpy(client.server_ep, options[1].value,
  11c95d:	52                   	push   %edx
  11c95e:	8d 45 eb             	lea    -0x15(%ebp),%eax
  11c961:	50                   	push   %eax
		return 0;
  11c962:	31 f6                	xor    %esi,%esi
		memcpy(client.server_ep, options[1].value,
  11c964:	68 3d e4 12 00       	push   $0x12e43d
  11c969:	e8 7e f4 fe ff       	call   10bdec <memcpy>
		client.server_ep[options[1].len] = '\0';
  11c96e:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
		memcpy(client.server_ep, options[1].value,
  11c972:	83 c4 0c             	add    $0xc,%esp
		client.server_ep[options[1].len] = '\0';
  11c975:	c6 80 3d e4 12 00 00 	movb   $0x0,0x12e43d(%eax)
		set_sm_state(ENGINE_REGISTRATION_DONE);
  11c97c:	b8 08 00 00 00       	mov    $0x8,%eax
  11c981:	e8 46 fc ff ff       	call   11c5cc <set_sm_state>
		LOG_INF("Registration Done (EP='%s')",
  11c986:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
  11c98b:	83 e0 07             	and    $0x7,%eax
  11c98e:	83 f8 02             	cmp    $0x2,%eax
  11c991:	0f 86 cf 00 00 00    	jbe    11ca66 <do_registration_reply_cb+0x1b5>
  11c997:	68 3d e4 12 00       	push   $0x12e43d
  11c99c:	e8 b6 68 fe ff       	call   103257 <log_strdup>
  11c9a1:	bb 68 31 12 00       	mov    $0x123168,%ebx
  11c9a6:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11c9ac:	c1 eb 03             	shr    $0x3,%ebx
  11c9af:	c1 e3 06             	shl    $0x6,%ebx
  11c9b2:	83 cb 03             	or     $0x3,%ebx
  11c9b5:	66 89 1c 24          	mov    %bx,(%esp)
  11c9b9:	50                   	push   %eax
  11c9ba:	68 2e 81 12 00       	push   $0x12812e
  11c9bf:	e8 b2 6b fe ff       	call   103576 <log_1>
  11c9c4:	83 c4 0c             	add    $0xc,%esp
  11c9c7:	e9 9a 00 00 00       	jmp    11ca66 <do_registration_reply_cb+0x1b5>
	} else if (code == COAP_RESPONSE_CODE_NOT_FOUND) {
  11c9cc:	8b 15 f4 5b 14 00    	mov    0x145bf4,%edx
  11c9d2:	83 e2 07             	and    $0x7,%edx
  11c9d5:	3c 84                	cmp    $0x84,%al
  11c9d7:	75 2b                	jne    11ca04 <do_registration_reply_cb+0x153>
		LOG_ERR("Failed: NOT_FOUND.  Not Retrying.");
  11c9d9:	85 d2                	test   %edx,%edx
  11c9db:	74 20                	je     11c9fd <do_registration_reply_cb+0x14c>
  11c9dd:	b8 68 31 12 00       	mov    $0x123168,%eax
  11c9e2:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11c9e7:	c1 e8 03             	shr    $0x3,%eax
  11c9ea:	c1 e0 06             	shl    $0x6,%eax
  11c9ed:	83 c8 01             	or     $0x1,%eax
  11c9f0:	50                   	push   %eax
  11c9f1:	68 ec 7f 12 00       	push   $0x127fec
  11c9f6:	e8 52 6b fe ff       	call   10354d <log_0>
  11c9fb:	58                   	pop    %eax
  11c9fc:	5a                   	pop    %edx
		set_sm_state(ENGINE_REGISTRATION_DONE);
  11c9fd:	b8 08 00 00 00       	mov    $0x8,%eax
  11ca02:	eb 5b                	jmp    11ca5f <do_registration_reply_cb+0x1ae>
	} else if (code == COAP_RESPONSE_CODE_FORBIDDEN) {
  11ca04:	3c 83                	cmp    $0x83,%al
  11ca06:	75 1f                	jne    11ca27 <do_registration_reply_cb+0x176>
		LOG_ERR("Failed: 4.03 - Forbidden.  Not Retrying.");
  11ca08:	85 d2                	test   %edx,%edx
  11ca0a:	74 f1                	je     11c9fd <do_registration_reply_cb+0x14c>
  11ca0c:	b8 68 31 12 00       	mov    $0x123168,%eax
  11ca11:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11ca16:	c1 e8 03             	shr    $0x3,%eax
  11ca19:	c1 e0 06             	shl    $0x6,%eax
  11ca1c:	83 c8 01             	or     $0x1,%eax
  11ca1f:	50                   	push   %eax
  11ca20:	68 0e 80 12 00       	push   $0x12800e
  11ca25:	eb cf                	jmp    11c9f6 <do_registration_reply_cb+0x145>
	LOG_ERR("failed with code %u.%u. Re-init network",
  11ca27:	85 d2                	test   %edx,%edx
  11ca29:	74 2f                	je     11ca5a <do_registration_reply_cb+0x1a9>
  11ca2b:	ba 68 31 12 00       	mov    $0x123168,%edx
  11ca30:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11ca36:	c1 ea 03             	shr    $0x3,%edx
  11ca39:	c1 e2 06             	shl    $0x6,%edx
  11ca3c:	83 ca 01             	or     $0x1,%edx
  11ca3f:	52                   	push   %edx
  11ca40:	89 c2                	mov    %eax,%edx
  11ca42:	c0 e8 05             	shr    $0x5,%al
  11ca45:	83 e2 1f             	and    $0x1f,%edx
  11ca48:	52                   	push   %edx
  11ca49:	0f b6 c0             	movzbl %al,%eax
  11ca4c:	50                   	push   %eax
  11ca4d:	68 4a 81 12 00       	push   $0x12814a
  11ca52:	e8 59 6b fe ff       	call   1035b0 <log_2>
  11ca57:	83 c4 10             	add    $0x10,%esp
	set_sm_state(ENGINE_INIT);
  11ca5a:	b8 01 00 00 00       	mov    $0x1,%eax
  11ca5f:	e8 68 fb ff ff       	call   11c5cc <set_sm_state>
	return 0;
  11ca64:	31 f6                	xor    %esi,%esi
}
  11ca66:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11ca69:	89 f0                	mov    %esi,%eax
  11ca6b:	5b                   	pop    %ebx
  11ca6c:	5e                   	pop    %esi
  11ca6d:	5d                   	pop    %ebp
  11ca6e:	c3                   	ret    

0011ca6f <sm_handle_timeout_state.isra.0>:
static void sm_handle_timeout_state(struct lwm2m_message *msg,
  11ca6f:	55                   	push   %ebp
	if (client.engine_state == ENGINE_BOOTSTRAP_REG_SENT) {
  11ca70:	8a 15 08 e4 12 00    	mov    0x12e408,%dl
static void sm_handle_timeout_state(struct lwm2m_message *msg,
  11ca76:	89 e5                	mov    %esp,%ebp
	if (client.engine_state == ENGINE_BOOTSTRAP_REG_SENT) {
  11ca78:	80 fa 03             	cmp    $0x3,%dl
static void sm_handle_timeout_state(struct lwm2m_message *msg,
  11ca7b:	53                   	push   %ebx
		event = LWM2M_RD_CLIENT_EVENT_BOOTSTRAP_REG_FAILURE;
  11ca7c:	bb 01 00 00 00       	mov    $0x1,%ebx
	if (client.engine_state == ENGINE_BOOTSTRAP_REG_SENT) {
  11ca81:	74 1f                	je     11caa2 <sm_handle_timeout_state.isra.0+0x33>
		event = LWM2M_RD_CLIENT_EVENT_REGISTRATION_FAILURE;
  11ca83:	bb 04 00 00 00       	mov    $0x4,%ebx
	if (client.engine_state == ENGINE_REGISTRATION_SENT) {
  11ca88:	80 fa 07             	cmp    $0x7,%dl
  11ca8b:	74 15                	je     11caa2 <sm_handle_timeout_state.isra.0+0x33>
		event = LWM2M_RD_CLIENT_EVENT_REG_UPDATE_FAILURE;
  11ca8d:	bb 06 00 00 00       	mov    $0x6,%ebx
	} else if (client.engine_state == ENGINE_UPDATE_SENT) {
  11ca92:	80 fa 0a             	cmp    $0xa,%dl
  11ca95:	74 0b                	je     11caa2 <sm_handle_timeout_state.isra.0+0x33>
		event = LWM2M_RD_CLIENT_EVENT_DEREGISTER_FAILURE;
  11ca97:	31 db                	xor    %ebx,%ebx
  11ca99:	80 fa 0c             	cmp    $0xc,%dl
  11ca9c:	0f 94 c3             	sete   %bl
  11ca9f:	c1 e3 03             	shl    $0x3,%ebx
	set_sm_state(sm_state);
  11caa2:	e8 25 fb ff ff       	call   11c5cc <set_sm_state>
	if (event > LWM2M_RD_CLIENT_EVENT_NONE && client.event_cb) {
  11caa7:	85 db                	test   %ebx,%ebx
  11caa9:	74 14                	je     11cabf <sm_handle_timeout_state.isra.0+0x50>
  11caab:	a1 60 e4 12 00       	mov    0x12e460,%eax
  11cab0:	85 c0                	test   %eax,%eax
  11cab2:	74 0b                	je     11cabf <sm_handle_timeout_state.isra.0+0x50>
		client.event_cb(client.ctx, event);
  11cab4:	53                   	push   %ebx
  11cab5:	ff 35 04 e4 12 00    	pushl  0x12e404
  11cabb:	ff d0                	call   *%eax
  11cabd:	58                   	pop    %eax
  11cabe:	5a                   	pop    %edx
}
  11cabf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11cac2:	c9                   	leave  
  11cac3:	c3                   	ret    

0011cac4 <do_bootstrap_reg_timeout_cb>:
	LOG_WRN("Bootstrap Timeout");
  11cac4:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cacb:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("Bootstrap Timeout");
  11cad0:	74 29                	je     11cafb <do_bootstrap_reg_timeout_cb+0x37>
  11cad2:	b8 68 31 12 00       	mov    $0x123168,%eax
{
  11cad7:	55                   	push   %ebp
  11cad8:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cadd:	89 e5                	mov    %esp,%ebp
  11cadf:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("Bootstrap Timeout");
  11cae2:	c1 e0 06             	shl    $0x6,%eax
  11cae5:	83 c8 02             	or     $0x2,%eax
  11cae8:	50                   	push   %eax
  11cae9:	68 72 81 12 00       	push   $0x128172
  11caee:	e8 5a 6a fe ff       	call   10354d <log_0>
  11caf3:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11caf4:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("Bootstrap Timeout");
  11caf9:	5a                   	pop    %edx
}
  11cafa:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cafb:	e9 6f ff ff ff       	jmp    11ca6f <sm_handle_timeout_state.isra.0>

0011cb00 <do_registration_timeout_cb>:
	LOG_WRN("Registration Timeout");
  11cb00:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cb07:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("Registration Timeout");
  11cb0c:	74 29                	je     11cb37 <do_registration_timeout_cb+0x37>
  11cb0e:	b8 68 31 12 00       	mov    $0x123168,%eax
{
  11cb13:	55                   	push   %ebp
  11cb14:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cb19:	89 e5                	mov    %esp,%ebp
  11cb1b:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("Registration Timeout");
  11cb1e:	c1 e0 06             	shl    $0x6,%eax
  11cb21:	83 c8 02             	or     $0x2,%eax
  11cb24:	50                   	push   %eax
  11cb25:	68 a3 81 12 00       	push   $0x1281a3
  11cb2a:	e8 1e 6a fe ff       	call   10354d <log_0>
  11cb2f:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cb30:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("Registration Timeout");
  11cb35:	5a                   	pop    %edx
}
  11cb36:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cb37:	e9 33 ff ff ff       	jmp    11ca6f <sm_handle_timeout_state.isra.0>

0011cb3c <do_update_timeout_cb>:
	LOG_WRN("Registration Update Timeout");
  11cb3c:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
	sm_handle_timeout_state(msg, ENGINE_DO_REGISTRATION);
  11cb43:	b8 06 00 00 00       	mov    $0x6,%eax
	LOG_WRN("Registration Update Timeout");
  11cb48:	74 29                	je     11cb73 <do_update_timeout_cb+0x37>
  11cb4a:	b8 68 31 12 00       	mov    $0x123168,%eax
{
  11cb4f:	55                   	push   %ebp
  11cb50:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cb55:	89 e5                	mov    %esp,%ebp
  11cb57:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("Registration Update Timeout");
  11cb5a:	c1 e0 06             	shl    $0x6,%eax
  11cb5d:	83 c8 02             	or     $0x2,%eax
  11cb60:	50                   	push   %eax
  11cb61:	68 84 81 12 00       	push   $0x128184
  11cb66:	e8 e2 69 fe ff       	call   10354d <log_0>
  11cb6b:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_DO_REGISTRATION);
  11cb6c:	b8 06 00 00 00       	mov    $0x6,%eax
	LOG_WRN("Registration Update Timeout");
  11cb71:	5a                   	pop    %edx
}
  11cb72:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_DO_REGISTRATION);
  11cb73:	e9 f7 fe ff ff       	jmp    11ca6f <sm_handle_timeout_state.isra.0>

0011cb78 <do_deregister_timeout_cb>:
	LOG_WRN("De-Registration Timeout");
  11cb78:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cb7f:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("De-Registration Timeout");
  11cb84:	74 29                	je     11cbaf <do_deregister_timeout_cb+0x37>
  11cb86:	b8 68 31 12 00       	mov    $0x123168,%eax
{
  11cb8b:	55                   	push   %ebp
  11cb8c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cb91:	89 e5                	mov    %esp,%ebp
  11cb93:	c1 e8 03             	shr    $0x3,%eax
	LOG_WRN("De-Registration Timeout");
  11cb96:	c1 e0 06             	shl    $0x6,%eax
  11cb99:	83 c8 02             	or     $0x2,%eax
  11cb9c:	50                   	push   %eax
  11cb9d:	68 a0 81 12 00       	push   $0x1281a0
  11cba2:	e8 a6 69 fe ff       	call   10354d <log_0>
  11cba7:	58                   	pop    %eax
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cba8:	b8 01 00 00 00       	mov    $0x1,%eax
	LOG_WRN("De-Registration Timeout");
  11cbad:	5a                   	pop    %edx
}
  11cbae:	c9                   	leave  
	sm_handle_timeout_state(msg, ENGINE_INIT);
  11cbaf:	e9 bb fe ff ff       	jmp    11ca6f <sm_handle_timeout_state.isra.0>

0011cbb4 <do_deregister_reply_cb>:
{
  11cbb4:	55                   	push   %ebp
  11cbb5:	89 e5                	mov    %esp,%ebp
	code = coap_header_get_code(response);
  11cbb7:	ff 75 08             	pushl  0x8(%ebp)
  11cbba:	e8 b5 bf fe ff       	call   108b74 <coap_header_get_code>
  11cbbf:	5a                   	pop    %edx
	if (code == COAP_RESPONSE_CODE_DELETED) {
  11cbc0:	3c 42                	cmp    $0x42,%al
  11cbc2:	8b 15 f4 5b 14 00    	mov    0x145bf4,%edx
  11cbc8:	75 3b                	jne    11cc05 <do_deregister_reply_cb+0x51>
		LOG_INF("Deregistration success");
  11cbca:	83 e2 07             	and    $0x7,%edx
  11cbcd:	83 fa 02             	cmp    $0x2,%edx
  11cbd0:	76 20                	jbe    11cbf2 <do_deregister_reply_cb+0x3e>
  11cbd2:	b8 68 31 12 00       	mov    $0x123168,%eax
  11cbd7:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cbdc:	c1 e8 03             	shr    $0x3,%eax
  11cbdf:	c1 e0 06             	shl    $0x6,%eax
  11cbe2:	83 c8 03             	or     $0x3,%eax
  11cbe5:	50                   	push   %eax
  11cbe6:	68 b8 81 12 00       	push   $0x1281b8
  11cbeb:	e8 5d 69 fe ff       	call   10354d <log_0>
  11cbf0:	5a                   	pop    %edx
  11cbf1:	59                   	pop    %ecx
		lwm2m_engine_context_close(client.ctx);
  11cbf2:	ff 35 04 e4 12 00    	pushl  0x12e404
  11cbf8:	e8 57 c6 ff ff       	call   119254 <lwm2m_engine_context_close>
  11cbfd:	58                   	pop    %eax
		set_sm_state(ENGINE_DEREGISTERED);
  11cbfe:	b8 0e 00 00 00       	mov    $0xe,%eax
  11cc03:	eb 42                	jmp    11cc47 <do_deregister_reply_cb+0x93>
		LOG_ERR("failed with code %u.%u",
  11cc05:	80 e2 07             	and    $0x7,%dl
  11cc08:	74 2f                	je     11cc39 <do_deregister_reply_cb+0x85>
  11cc0a:	ba 68 31 12 00       	mov    $0x123168,%edx
  11cc0f:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11cc15:	c1 ea 03             	shr    $0x3,%edx
  11cc18:	c1 e2 06             	shl    $0x6,%edx
  11cc1b:	83 ca 01             	or     $0x1,%edx
  11cc1e:	52                   	push   %edx
  11cc1f:	89 c2                	mov    %eax,%edx
  11cc21:	c0 e8 05             	shr    $0x5,%al
  11cc24:	83 e2 1f             	and    $0x1f,%edx
  11cc27:	52                   	push   %edx
  11cc28:	0f b6 c0             	movzbl %al,%eax
  11cc2b:	50                   	push   %eax
  11cc2c:	68 cf 81 12 00       	push   $0x1281cf
  11cc31:	e8 7a 69 fe ff       	call   1035b0 <log_2>
  11cc36:	83 c4 10             	add    $0x10,%esp
		if (get_sm_state() == ENGINE_DEREGISTER_SENT) {
  11cc39:	80 3d 08 e4 12 00 0c 	cmpb   $0xc,0x12e408
  11cc40:	75 0a                	jne    11cc4c <do_deregister_reply_cb+0x98>
			set_sm_state(ENGINE_DEREGISTER_FAILED);
  11cc42:	b8 0d 00 00 00       	mov    $0xd,%eax
  11cc47:	e8 80 f9 ff ff       	call   11c5cc <set_sm_state>
}
  11cc4c:	31 c0                	xor    %eax,%eax
  11cc4e:	c9                   	leave  
  11cc4f:	c3                   	ret    

0011cc50 <sm_select_security_inst>:
{
  11cc50:	55                   	push   %ebp
  11cc51:	89 e5                	mov    %esp,%ebp
  11cc53:	57                   	push   %edi
  11cc54:	56                   	push   %esi
  11cc55:	89 d6                	mov    %edx,%esi
  11cc57:	53                   	push   %ebx
  11cc58:	89 c3                	mov    %eax,%ebx
  11cc5a:	83 ec 0c             	sub    $0xc,%esp
	i = lwm2m_security_inst_id_to_index(*sec_obj_inst);
  11cc5d:	0f b7 02             	movzwl (%edx),%eax
  11cc60:	50                   	push   %eax
  11cc61:	e8 7a cd ff ff       	call   1199e0 <lwm2m_security_inst_id_to_index>
	if (i >= 0 && sm_bootstrap_verify(bootstrap_server, *sec_obj_inst)) {
  11cc66:	0f b6 db             	movzbl %bl,%ebx
	i = lwm2m_security_inst_id_to_index(*sec_obj_inst);
  11cc69:	5f                   	pop    %edi
	if (i >= 0 && sm_bootstrap_verify(bootstrap_server, *sec_obj_inst)) {
  11cc6a:	85 c0                	test   %eax,%eax
  11cc6c:	79 24                	jns    11cc92 <sm_select_security_inst+0x42>
  11cc6e:	b8 68 31 12 00       	mov    $0x123168,%eax
	*sec_obj_inst = -1;
  11cc73:	c7 06 ff ff ff ff    	movl   $0xffffffff,(%esi)
  11cc79:	2d b0 30 12 00       	sub    $0x1230b0,%eax
	for (i = 0; i < CONFIG_LWM2M_SECURITY_INSTANCE_COUNT; i++) {
  11cc7e:	31 ff                	xor    %edi,%edi
  11cc80:	c1 e8 03             	shr    $0x3,%eax
  11cc83:	89 45 f0             	mov    %eax,-0x10(%ebp)
			LOG_WRN("Failed to get inst id for %d", i);
  11cc86:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11cc89:	c1 e0 06             	shl    $0x6,%eax
  11cc8c:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
  11cc90:	eb 38                	jmp    11ccca <sm_select_security_inst+0x7a>
	if (i >= 0 && sm_bootstrap_verify(bootstrap_server, *sec_obj_inst)) {
  11cc92:	8b 16                	mov    (%esi),%edx
  11cc94:	89 d8                	mov    %ebx,%eax
  11cc96:	e8 a3 fb ff ff       	call   11c83e <sm_bootstrap_verify>
		return 0;
  11cc9b:	31 ff                	xor    %edi,%edi
	if (i >= 0 && sm_bootstrap_verify(bootstrap_server, *sec_obj_inst)) {
  11cc9d:	84 c0                	test   %al,%al
  11cc9f:	74 cd                	je     11cc6e <sm_select_security_inst+0x1e>
  11cca1:	eb 6f                	jmp    11cd12 <sm_select_security_inst+0xc2>
			LOG_WRN("Failed to get inst id for %d", i);
  11cca3:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
  11ccaa:	74 16                	je     11ccc2 <sm_select_security_inst+0x72>
  11ccac:	66 8b 45 ee          	mov    -0x12(%ebp),%ax
  11ccb0:	83 c8 02             	or     $0x2,%eax
  11ccb3:	50                   	push   %eax
  11ccb4:	57                   	push   %edi
  11ccb5:	68 e6 81 12 00       	push   $0x1281e6
  11ccba:	e8 b7 68 fe ff       	call   103576 <log_1>
  11ccbf:	83 c4 0c             	add    $0xc,%esp
	for (i = 0; i < CONFIG_LWM2M_SECURITY_INSTANCE_COUNT; i++) {
  11ccc2:	4f                   	dec    %edi
  11ccc3:	74 29                	je     11ccee <sm_select_security_inst+0x9e>
  11ccc5:	bf 01 00 00 00       	mov    $0x1,%edi
		obj_inst_id = lwm2m_security_index_to_inst_id(i);
  11ccca:	57                   	push   %edi
  11cccb:	e8 4a cd ff ff       	call   119a1a <lwm2m_security_index_to_inst_id>
  11ccd0:	59                   	pop    %ecx
  11ccd1:	89 c2                	mov    %eax,%edx
		if (obj_inst_id < 0) {
  11ccd3:	85 c0                	test   %eax,%eax
  11ccd5:	78 cc                	js     11cca3 <sm_select_security_inst+0x53>
		if (sm_bootstrap_verify(bootstrap_server, obj_inst_id)) {
  11ccd7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  11ccda:	89 d8                	mov    %ebx,%eax
  11ccdc:	e8 5d fb ff ff       	call   11c83e <sm_bootstrap_verify>
  11cce1:	8b 55 e8             	mov    -0x18(%ebp),%edx
  11cce4:	84 c0                	test   %al,%al
  11cce6:	74 da                	je     11ccc2 <sm_select_security_inst+0x72>
			*sec_obj_inst = obj_inst_id;
  11cce8:	89 16                	mov    %edx,(%esi)
			return 0;
  11ccea:	31 ff                	xor    %edi,%edi
  11ccec:	eb 24                	jmp    11cd12 <sm_select_security_inst+0xc2>
	LOG_WRN("sec_obj_inst: No matching servers found.");
  11ccee:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
	return -ENOENT;
  11ccf5:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
	LOG_WRN("sec_obj_inst: No matching servers found.");
  11ccfa:	74 16                	je     11cd12 <sm_select_security_inst+0xc2>
  11ccfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ccff:	c1 e0 06             	shl    $0x6,%eax
  11cd02:	83 c8 02             	or     $0x2,%eax
  11cd05:	50                   	push   %eax
  11cd06:	68 03 82 12 00       	push   $0x128203
  11cd0b:	e8 3d 68 fe ff       	call   10354d <log_0>
  11cd10:	58                   	pop    %eax
  11cd11:	5a                   	pop    %edx
}
  11cd12:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11cd15:	89 f8                	mov    %edi,%eax
  11cd17:	5b                   	pop    %ebx
  11cd18:	5e                   	pop    %esi
  11cd19:	5f                   	pop    %edi
  11cd1a:	5d                   	pop    %ebp
  11cd1b:	c3                   	ret    

0011cd1c <sm_update_lifetime.constprop.0>:
static void sm_update_lifetime(int srv_obj_inst, uint32_t *lifetime)
  11cd1c:	55                   	push   %ebp
  11cd1d:	89 e5                	mov    %esp,%ebp
  11cd1f:	53                   	push   %ebx
  11cd20:	83 ec 14             	sub    $0x14,%esp
	snprintk(pathstr, sizeof(pathstr), "1/%d/1", srv_obj_inst);
  11cd23:	8d 5d e8             	lea    -0x18(%ebp),%ebx
  11cd26:	50                   	push   %eax
  11cd27:	68 2c 82 12 00       	push   $0x12822c
  11cd2c:	6a 14                	push   $0x14
  11cd2e:	53                   	push   %ebx
  11cd2f:	e8 cb 45 fe ff       	call   1012ff <snprintk>
  11cd34:	83 c4 10             	add    $0x10,%esp
	if (lwm2m_engine_get_u32(pathstr, lifetime) < 0) {
  11cd37:	68 00 e4 12 00       	push   $0x12e400
  11cd3c:	53                   	push   %ebx
  11cd3d:	e8 d8 b5 ff ff       	call   11831a <lwm2m_engine_get_u32>
  11cd42:	5a                   	pop    %edx
  11cd43:	85 c0                	test   %eax,%eax
  11cd45:	59                   	pop    %ecx
  11cd46:	79 3a                	jns    11cd82 <sm_update_lifetime.constprop.0+0x66>
		LOG_INF("Using default lifetime: %u", *lifetime);
  11cd48:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
		*lifetime = CONFIG_LWM2M_ENGINE_DEFAULT_LIFETIME;
  11cd4d:	c7 05 00 e4 12 00 1e 	movl   $0x1e,0x12e400
  11cd54:	00 00 00 
		LOG_INF("Using default lifetime: %u", *lifetime);
  11cd57:	83 e0 07             	and    $0x7,%eax
  11cd5a:	83 f8 02             	cmp    $0x2,%eax
  11cd5d:	76 23                	jbe    11cd82 <sm_update_lifetime.constprop.0+0x66>
  11cd5f:	b8 68 31 12 00       	mov    $0x123168,%eax
  11cd64:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cd69:	c1 e8 03             	shr    $0x3,%eax
  11cd6c:	c1 e0 06             	shl    $0x6,%eax
  11cd6f:	83 c8 03             	or     $0x3,%eax
  11cd72:	50                   	push   %eax
  11cd73:	6a 1e                	push   $0x1e
  11cd75:	68 33 82 12 00       	push   $0x128233
  11cd7a:	e8 f7 67 fe ff       	call   103576 <log_1>
  11cd7f:	83 c4 0c             	add    $0xc,%esp
}
  11cd82:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11cd85:	c9                   	leave  
  11cd86:	c3                   	ret    

0011cd87 <sm_send_registration>:
{
  11cd87:	55                   	push   %ebp
  11cd88:	89 e5                	mov    %esp,%ebp
  11cd8a:	57                   	push   %edi
  11cd8b:	56                   	push   %esi
  11cd8c:	89 d7                	mov    %edx,%edi
  11cd8e:	53                   	push   %ebx
  11cd8f:	89 ce                	mov    %ecx,%esi
  11cd91:	83 ec 10             	sub    $0x10,%esp
  11cd94:	89 45 ec             	mov    %eax,-0x14(%ebp)
	msg = lwm2m_get_message(client.ctx);
  11cd97:	ff 35 04 e4 12 00    	pushl  0x12e404
  11cd9d:	e8 f6 8e ff ff       	call   115c98 <lwm2m_get_message>
  11cda2:	5a                   	pop    %edx
	if (!msg) {
  11cda3:	85 c0                	test   %eax,%eax
  11cda5:	75 37                	jne    11cdde <sm_send_registration+0x57>
		LOG_ERR("Unable to get a lwm2m message!");
  11cda7:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
		return -ENOMEM;
  11cdae:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
		LOG_ERR("Unable to get a lwm2m message!");
  11cdb3:	0f 84 93 02 00 00    	je     11d04c <sm_send_registration+0x2c5>
  11cdb9:	b8 68 31 12 00       	mov    $0x123168,%eax
  11cdbe:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11cdc3:	c1 e8 03             	shr    $0x3,%eax
  11cdc6:	c1 e0 06             	shl    $0x6,%eax
  11cdc9:	83 c8 01             	or     $0x1,%eax
  11cdcc:	50                   	push   %eax
  11cdcd:	68 a1 7b 12 00       	push   $0x127ba1
  11cdd2:	e8 76 67 fe ff       	call   10354d <log_0>
  11cdd7:	5f                   	pop    %edi
  11cdd8:	58                   	pop    %eax
  11cdd9:	e9 6e 02 00 00       	jmp    11d04c <sm_send_registration+0x2c5>
  11cdde:	89 c3                	mov    %eax,%ebx
  11cde0:	e8 a2 55 00 00       	call   122387 <z_impl_k_uptime_ticks>
	msg->type = COAP_TYPE_CON;
  11cde5:	66 c7 83 86 02 00 00 	movw   $0x200,0x286(%ebx)
  11cdec:	00 02 
  11cdee:	6b ca 0a             	imul   $0xa,%edx,%ecx
  11cdf1:	ba 0a 00 00 00       	mov    $0xa,%edx
  11cdf6:	f7 e2                	mul    %edx
  11cdf8:	01 ca                	add    %ecx,%edx
  11cdfa:	a3 0c e4 12 00       	mov    %eax,0x12e40c
  11cdff:	89 15 10 e4 12 00    	mov    %edx,0x12e410
	msg->mid = coap_next_id();
  11ce05:	e8 50 c3 fe ff       	call   10915a <coap_next_id>
	msg->reply_cb = reply_cb;
  11ce0a:	89 bb 7c 02 00 00    	mov    %edi,0x27c(%ebx)
	msg->message_timeout_cb = timeout_cb;
  11ce10:	89 b3 80 02 00 00    	mov    %esi,0x280(%ebx)
	msg->mid = coap_next_id();
  11ce16:	66 89 83 84 02 00 00 	mov    %ax,0x284(%ebx)
	msg->tkl = LWM2M_MSG_TOKEN_GENERATE_NEW;
  11ce1d:	c6 83 88 02 00 00 ff 	movb   $0xff,0x288(%ebx)
	ret = lwm2m_init_message(msg);
  11ce24:	53                   	push   %ebx
  11ce25:	e8 c6 90 ff ff       	call   115ef0 <lwm2m_init_message>
  11ce2a:	5e                   	pop    %esi
  11ce2b:	89 c7                	mov    %eax,%edi
  11ce2d:	89 c6                	mov    %eax,%esi
	if (ret) {
  11ce2f:	85 c0                	test   %eax,%eax
  11ce31:	0f 85 09 02 00 00    	jne    11d040 <sm_send_registration+0x2b9>
				  strlen(LWM2M_RD_CLIENT_URI));
  11ce37:	68 4e 82 12 00       	push   $0x12824e
  11ce3c:	e8 db ee fe ff       	call   10bd1c <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11ce41:	0f b7 c0             	movzwl %ax,%eax
  11ce44:	89 04 24             	mov    %eax,(%esp)
  11ce47:	68 4e 82 12 00       	push   $0x12824e
  11ce4c:	6a 0b                	push   $0xb
  11ce4e:	8d 7b 30             	lea    0x30(%ebx),%edi
  11ce51:	57                   	push   %edi
  11ce52:	e8 bb b8 fe ff       	call   108712 <coap_packet_append_option>
	return (client.engine_state >= ENGINE_REGISTRATION_DONE &&
  11ce57:	a0 08 e4 12 00       	mov    0x12e408,%al
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11ce5c:	83 c4 10             	add    $0x10,%esp
	return (client.engine_state >= ENGINE_REGISTRATION_DONE &&
  11ce5f:	83 e8 08             	sub    $0x8,%eax
	if (!sm_is_registered()) {
  11ce62:	3c 05                	cmp    $0x5,%al
  11ce64:	76 78                	jbe    11cede <sm_send_registration+0x157>
		coap_append_option_int(&msg->cpkt, COAP_OPTION_CONTENT_FORMAT,
  11ce66:	6a 28                	push   $0x28
  11ce68:	6a 0c                	push   $0xc
  11ce6a:	57                   	push   %edi
  11ce6b:	e8 42 ba fe ff       	call   1088b2 <coap_append_option_int>
  11ce70:	83 c4 0c             	add    $0xc,%esp
		snprintk(query_buffer, sizeof(query_buffer) - 1,
  11ce73:	68 51 82 12 00       	push   $0x128251
  11ce78:	68 55 82 12 00       	push   $0x128255
  11ce7d:	6a 3f                	push   $0x3f
  11ce7f:	68 c0 e3 12 00       	push   $0x12e3c0
  11ce84:	e8 76 44 fe ff       	call   1012ff <snprintk>
  11ce89:	83 c4 10             	add    $0x10,%esp
					  query_buffer, strlen(query_buffer));
  11ce8c:	68 c0 e3 12 00       	push   $0x12e3c0
  11ce91:	e8 86 ee fe ff       	call   10bd1c <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
  11ce96:	0f b7 c0             	movzwl %ax,%eax
  11ce99:	89 04 24             	mov    %eax,(%esp)
  11ce9c:	68 c0 e3 12 00       	push   $0x12e3c0
  11cea1:	6a 0f                	push   $0xf
  11cea3:	57                   	push   %edi
  11cea4:	e8 69 b8 fe ff       	call   108712 <coap_packet_append_option>
  11cea9:	83 c4 10             	add    $0x10,%esp
		snprintk(query_buffer, sizeof(query_buffer) - 1,
  11ceac:	68 1c e4 12 00       	push   $0x12e41c
  11ceb1:	68 5e 82 12 00       	push   $0x12825e
  11ceb6:	6a 3f                	push   $0x3f
  11ceb8:	68 c0 e3 12 00       	push   $0x12e3c0
  11cebd:	e8 3d 44 fe ff       	call   1012ff <snprintk>
  11cec2:	83 c4 10             	add    $0x10,%esp
					  query_buffer, strlen(query_buffer));
  11cec5:	68 c0 e3 12 00       	push   $0x12e3c0
  11ceca:	e8 4d ee fe ff       	call   10bd1c <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
  11cecf:	0f b7 c0             	movzwl %ax,%eax
  11ced2:	89 04 24             	mov    %eax,(%esp)
  11ced5:	68 c0 e3 12 00       	push   $0x12e3c0
  11ceda:	6a 0f                	push   $0xf
  11cedc:	eb 17                	jmp    11cef5 <sm_send_registration+0x16e>
					  strlen(client.server_ep));
  11cede:	68 3d e4 12 00       	push   $0x12e43d
  11cee3:	e8 34 ee fe ff       	call   10bd1c <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11cee8:	0f b7 c0             	movzwl %ax,%eax
  11ceeb:	89 04 24             	mov    %eax,(%esp)
  11ceee:	68 3d e4 12 00       	push   $0x12e43d
  11cef3:	6a 0b                	push   $0xb
  11cef5:	57                   	push   %edi
  11cef6:	e8 17 b8 fe ff       	call   108712 <coap_packet_append_option>
  11cefb:	83 c4 10             	add    $0x10,%esp
	snprintk(query_buffer, sizeof(query_buffer) - 1,
  11cefe:	ff 35 00 e4 12 00    	pushl  0x12e400
  11cf04:	68 64 82 12 00       	push   $0x128264
  11cf09:	6a 3f                	push   $0x3f
  11cf0b:	68 c0 e3 12 00       	push   $0x12e3c0
  11cf10:	e8 ea 43 fe ff       	call   1012ff <snprintk>
  11cf15:	83 c4 10             	add    $0x10,%esp
				  query_buffer, strlen(query_buffer));
  11cf18:	68 c0 e3 12 00       	push   $0x12e3c0
  11cf1d:	e8 fa ed fe ff       	call   10bd1c <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
  11cf22:	0f b7 c0             	movzwl %ax,%eax
  11cf25:	89 04 24             	mov    %eax,(%esp)
  11cf28:	68 c0 e3 12 00       	push   $0x12e3c0
  11cf2d:	6a 0f                	push   $0xf
  11cf2f:	57                   	push   %edi
  11cf30:	e8 dd b7 fe ff       	call   108712 <coap_packet_append_option>
  11cf35:	83 c4 10             	add    $0x10,%esp
	lwm2m_engine_get_binding(binding);
  11cf38:	8d 55 f0             	lea    -0x10(%ebp),%edx
  11cf3b:	52                   	push   %edx
  11cf3c:	e8 8e b4 ff ff       	call   1183cf <lwm2m_engine_get_binding>
	if (strcmp(binding, "U") != 0) {
  11cf41:	8d 55 f0             	lea    -0x10(%ebp),%edx
  11cf44:	c7 04 24 87 7c 12 00 	movl   $0x127c87,(%esp)
  11cf4b:	52                   	push   %edx
  11cf4c:	e8 de ed fe ff       	call   10bd2f <strcmp>
  11cf51:	5a                   	pop    %edx
  11cf52:	85 c0                	test   %eax,%eax
  11cf54:	59                   	pop    %ecx
  11cf55:	8d 55 f0             	lea    -0x10(%ebp),%edx
  11cf58:	74 35                	je     11cf8f <sm_send_registration+0x208>
		snprintk(query_buffer, sizeof(query_buffer) - 1,
  11cf5a:	52                   	push   %edx
  11cf5b:	68 6a 82 12 00       	push   $0x12826a
  11cf60:	6a 3f                	push   $0x3f
  11cf62:	68 c0 e3 12 00       	push   $0x12e3c0
  11cf67:	e8 93 43 fe ff       	call   1012ff <snprintk>
  11cf6c:	83 c4 10             	add    $0x10,%esp
					  query_buffer, strlen(query_buffer));
  11cf6f:	68 c0 e3 12 00       	push   $0x12e3c0
  11cf74:	e8 a3 ed fe ff       	call   10bd1c <strlen>
		coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
  11cf79:	0f b7 c0             	movzwl %ax,%eax
  11cf7c:	89 04 24             	mov    %eax,(%esp)
  11cf7f:	68 c0 e3 12 00       	push   $0x12e3c0
  11cf84:	6a 0f                	push   $0xf
  11cf86:	57                   	push   %edi
  11cf87:	e8 86 b7 fe ff       	call   108712 <coap_packet_append_option>
  11cf8c:	83 c4 10             	add    $0x10,%esp
	if (send_obj_support_data) {
  11cf8f:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
  11cf93:	74 65                	je     11cffa <sm_send_registration+0x273>
		ret = coap_packet_append_payload_marker(&msg->cpkt);
  11cf95:	57                   	push   %edi
  11cf96:	e8 d4 b9 fe ff       	call   10896f <coap_packet_append_payload_marker>
  11cf9b:	59                   	pop    %ecx
  11cf9c:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
  11cf9e:	85 c0                	test   %eax,%eax
  11cfa0:	0f 88 9a 00 00 00    	js     11d040 <sm_send_registration+0x2b9>
		client_data_len = lwm2m_get_rd_data(client_data,
  11cfa6:	68 00 01 00 00       	push   $0x100
  11cfab:	68 c0 e2 12 00       	push   $0x12e2c0
  11cfb0:	e8 2f b0 ff ff       	call   117fe4 <lwm2m_get_rd_data>
  11cfb5:	0f b7 c8             	movzwl %ax,%ecx
		ret = buf_append(CPKT_BUF_WRITE(&msg->cpkt), client_data,
  11cfb8:	0f b7 43 36          	movzwl 0x36(%ebx),%eax
		client_data_len = lwm2m_get_rd_data(client_data,
  11cfbc:	5f                   	pop    %edi
  11cfbd:	89 cf                	mov    %ecx,%edi
  11cfbf:	5a                   	pop    %edx
		ret = buf_append(CPKT_BUF_WRITE(&msg->cpkt), client_data,
  11cfc0:	89 c2                	mov    %eax,%edx
  11cfc2:	8b 43 30             	mov    0x30(%ebx),%eax
  11cfc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!dst || !src) {
  11cfc8:	85 c0                	test   %eax,%eax
  11cfca:	74 68                	je     11d034 <sm_send_registration+0x2ad>
	if (*dst_len + src_len > dst_size) {
  11cfcc:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  11cfd0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  11cfd3:	01 c8                	add    %ecx,%eax
  11cfd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  11cfd8:	89 d0                	mov    %edx,%eax
  11cfda:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  11cfdd:	39 d0                	cmp    %edx,%eax
  11cfdf:	7c 5a                	jl     11d03b <sm_send_registration+0x2b4>
	memcpy(dst + *dst_len, src, src_len);
  11cfe1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11cfe4:	51                   	push   %ecx
  11cfe5:	03 45 e8             	add    -0x18(%ebp),%eax
  11cfe8:	68 c0 e2 12 00       	push   $0x12e2c0
  11cfed:	50                   	push   %eax
  11cfee:	e8 f9 ed fe ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11cff3:	66 01 7b 34          	add    %di,0x34(%ebx)
	memcpy(dst + *dst_len, src, src_len);
  11cff7:	83 c4 0c             	add    $0xc,%esp
	ret = lwm2m_send_message(msg);
  11cffa:	53                   	push   %ebx
  11cffb:	e8 38 ac ff ff       	call   117c38 <lwm2m_send_message>
  11d000:	59                   	pop    %ecx
  11d001:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
  11d003:	85 c0                	test   %eax,%eax
  11d005:	79 45                	jns    11d04c <sm_send_registration+0x2c5>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
  11d007:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d00e:	74 30                	je     11d040 <sm_send_registration+0x2b9>
  11d010:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d015:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d01a:	c1 e8 03             	shr    $0x3,%eax
  11d01d:	c1 e0 06             	shl    $0x6,%eax
  11d020:	83 c8 01             	or     $0x1,%eax
  11d023:	50                   	push   %eax
  11d024:	57                   	push   %edi
  11d025:	68 2f 7c 12 00       	push   $0x127c2f
  11d02a:	e8 47 65 fe ff       	call   103576 <log_1>
  11d02f:	83 c4 0c             	add    $0xc,%esp
  11d032:	eb 0c                	jmp    11d040 <sm_send_registration+0x2b9>
		return -EINVAL;
  11d034:	bf ea ff ff ff       	mov    $0xffffffea,%edi
  11d039:	eb 05                	jmp    11d040 <sm_send_registration+0x2b9>
		return -ENOMEM;
  11d03b:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
	lwm2m_reset_message(msg, true);
  11d040:	6a 01                	push   $0x1
	return ret;
  11d042:	89 fe                	mov    %edi,%esi
	lwm2m_reset_message(msg, true);
  11d044:	53                   	push   %ebx
  11d045:	e8 7c 8c ff ff       	call   115cc6 <lwm2m_reset_message>
  11d04a:	58                   	pop    %eax
  11d04b:	5a                   	pop    %edx
}
  11d04c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11d04f:	89 f0                	mov    %esi,%eax
  11d051:	5b                   	pop    %ebx
  11d052:	5e                   	pop    %esi
  11d053:	5f                   	pop    %edi
  11d054:	5d                   	pop    %ebp
  11d055:	c3                   	ret    

0011d056 <lwm2m_rd_client_service>:
	if (client.ctx) {
  11d056:	a1 04 e4 12 00       	mov    0x12e404,%eax
  11d05b:	85 c0                	test   %eax,%eax
  11d05d:	0f 84 8f 06 00 00    	je     11d6f2 <lwm2m_rd_client_service+0x69c>
{
  11d063:	55                   	push   %ebp
  11d064:	89 e5                	mov    %esp,%ebp
  11d066:	57                   	push   %edi
  11d067:	56                   	push   %esi
  11d068:	53                   	push   %ebx
  11d069:	83 ec 18             	sub    $0x18,%esp
	return client.engine_state;
  11d06c:	0f b6 15 08 e4 12 00 	movzbl 0x12e408,%edx
  11d073:	80 fa 0e             	cmp    $0xe,%dl
  11d076:	0f 87 43 06 00 00    	ja     11d6bf <lwm2m_rd_client_service+0x669>
  11d07c:	ff 24 95 a0 45 12 00 	jmp    *0x1245a0(,%edx,4)
	client.ctx->sec_obj_inst = -1;
  11d083:	c7 80 50 01 00 00 ff 	movl   $0xffffffff,0x150(%eax)
  11d08a:	ff ff ff 
	client.ctx->srv_obj_inst = -1;
  11d08d:	c7 80 54 01 00 00 ff 	movl   $0xffffffff,0x154(%eax)
  11d094:	ff ff ff 
	if (client.use_bootstrap) {
  11d097:	80 3d 09 e4 12 00 00 	cmpb   $0x0,0x12e409
	client.trigger_update = 0U;
  11d09e:	c6 05 0a e4 12 00 00 	movb   $0x0,0x12e40a
	client.lifetime = 0U;
  11d0a5:	c7 05 00 e4 12 00 00 	movl   $0x0,0x12e400
  11d0ac:	00 00 00 
		set_sm_state(ENGINE_DO_BOOTSTRAP_REG);
  11d0af:	b8 02 00 00 00       	mov    $0x2,%eax
	if (client.use_bootstrap) {
  11d0b4:	0f 85 fe 05 00 00    	jne    11d6b8 <lwm2m_rd_client_service+0x662>
  11d0ba:	e9 f4 04 00 00       	jmp    11d5b3 <lwm2m_rd_client_service+0x55d>
	if (client.ctx->sock_fd > -1) {
  11d0bf:	83 b8 5c 01 00 00 00 	cmpl   $0x0,0x15c(%eax)
  11d0c6:	78 07                	js     11d0cf <lwm2m_rd_client_service+0x79>
		lwm2m_engine_context_close(client.ctx);
  11d0c8:	50                   	push   %eax
  11d0c9:	e8 86 c1 ff ff       	call   119254 <lwm2m_engine_context_close>
  11d0ce:	58                   	pop    %eax
	client.ctx->bootstrap_mode = true;
  11d0cf:	8b 15 04 e4 12 00    	mov    0x12e404,%edx
	ret = sm_select_security_inst(client.ctx->bootstrap_mode,
  11d0d5:	b8 01 00 00 00       	mov    $0x1,%eax
  11d0da:	81 c2 50 01 00 00    	add    $0x150,%edx
	client.ctx->bootstrap_mode = true;
  11d0e0:	c6 42 08 01          	movb   $0x1,0x8(%edx)
	ret = sm_select_security_inst(client.ctx->bootstrap_mode,
  11d0e4:	e8 67 fb ff ff       	call   11cc50 <sm_select_security_inst>
	if (ret < 0) {
  11d0e9:	85 c0                	test   %eax,%eax
  11d0eb:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
  11d0f0:	79 2d                	jns    11d11f <lwm2m_rd_client_service+0xc9>
		LOG_WRN("Bootstrap server not found! Try normal registration.");
  11d0f2:	a8 06                	test   $0x6,%al
  11d0f4:	0f 84 b9 04 00 00    	je     11d5b3 <lwm2m_rd_client_service+0x55d>
  11d0fa:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d0ff:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d104:	c1 e8 03             	shr    $0x3,%eax
  11d107:	c1 e0 06             	shl    $0x6,%eax
  11d10a:	83 c8 02             	or     $0x2,%eax
  11d10d:	50                   	push   %eax
  11d10e:	68 6f 82 12 00       	push   $0x12826f
  11d113:	e8 35 64 fe ff       	call   10354d <log_0>
  11d118:	5f                   	pop    %edi
  11d119:	58                   	pop    %eax
  11d11a:	e9 94 04 00 00       	jmp    11d5b3 <lwm2m_rd_client_service+0x55d>
	LOG_INF("Bootstrap started with endpoint '%s' with client lifetime %d",
  11d11f:	83 e0 07             	and    $0x7,%eax
  11d122:	83 f8 02             	cmp    $0x2,%eax
  11d125:	76 37                	jbe    11d15e <lwm2m_rd_client_service+0x108>
  11d127:	68 1c e4 12 00       	push   $0x12e41c
  11d12c:	8b 35 00 e4 12 00    	mov    0x12e400,%esi
  11d132:	e8 20 61 fe ff       	call   103257 <log_strdup>
  11d137:	bb 68 31 12 00       	mov    $0x123168,%ebx
  11d13c:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11d142:	c1 eb 03             	shr    $0x3,%ebx
  11d145:	c1 e3 06             	shl    $0x6,%ebx
  11d148:	83 cb 03             	or     $0x3,%ebx
  11d14b:	66 89 1c 24          	mov    %bx,(%esp)
  11d14f:	56                   	push   %esi
  11d150:	50                   	push   %eax
  11d151:	68 a4 82 12 00       	push   $0x1282a4
  11d156:	e8 55 64 fe ff       	call   1035b0 <log_2>
  11d15b:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_engine_start(client.ctx);
  11d15e:	ff 35 04 e4 12 00    	pushl  0x12e404
  11d164:	e8 da c3 ff ff       	call   119543 <lwm2m_engine_start>
  11d169:	5e                   	pop    %esi
	if (ret < 0) {
  11d16a:	85 c0                	test   %eax,%eax
  11d16c:	0f 88 f0 02 00 00    	js     11d462 <lwm2m_rd_client_service+0x40c>
	msg = lwm2m_get_message(client.ctx);
  11d172:	ff 35 04 e4 12 00    	pushl  0x12e404
  11d178:	e8 1b 8b ff ff       	call   115c98 <lwm2m_get_message>
  11d17d:	5b                   	pop    %ebx
	if (!msg) {
  11d17e:	85 c0                	test   %eax,%eax
	msg = lwm2m_get_message(client.ctx);
  11d180:	89 c3                	mov    %eax,%ebx
	if (!msg) {
  11d182:	75 30                	jne    11d1b4 <lwm2m_rd_client_service+0x15e>
		LOG_ERR("Unable to get a lwm2m message!");
  11d184:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d18b:	0f 84 4c 03 00 00    	je     11d4dd <lwm2m_rd_client_service+0x487>
  11d191:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d196:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d19b:	c1 e8 03             	shr    $0x3,%eax
  11d19e:	c1 e0 06             	shl    $0x6,%eax
  11d1a1:	83 c8 01             	or     $0x1,%eax
  11d1a4:	50                   	push   %eax
  11d1a5:	68 a1 7b 12 00       	push   $0x127ba1
  11d1aa:	e8 9e 63 fe ff       	call   10354d <log_0>
  11d1af:	e9 0c 01 00 00       	jmp    11d2c0 <lwm2m_rd_client_service+0x26a>
	msg->type = COAP_TYPE_CON;
  11d1b4:	66 c7 80 86 02 00 00 	movw   $0x200,0x286(%eax)
  11d1bb:	00 02 
	msg->mid = coap_next_id();
  11d1bd:	e8 98 bf fe ff       	call   10915a <coap_next_id>
	msg->tkl = LWM2M_MSG_TOKEN_GENERATE_NEW;
  11d1c2:	c6 83 88 02 00 00 ff 	movb   $0xff,0x288(%ebx)
	msg->mid = coap_next_id();
  11d1c9:	66 89 83 84 02 00 00 	mov    %ax,0x284(%ebx)
	msg->reply_cb = do_bootstrap_reply_cb;
  11d1d0:	c7 83 7c 02 00 00 89 	movl   $0x11c689,0x27c(%ebx)
  11d1d7:	c6 11 00 
	msg->message_timeout_cb = do_bootstrap_reg_timeout_cb;
  11d1da:	c7 83 80 02 00 00 c4 	movl   $0x11cac4,0x280(%ebx)
  11d1e1:	ca 11 00 
	ret = lwm2m_init_message(msg);
  11d1e4:	53                   	push   %ebx
  11d1e5:	e8 06 8d ff ff       	call   115ef0 <lwm2m_init_message>
  11d1ea:	59                   	pop    %ecx
	if (ret) {
  11d1eb:	85 c0                	test   %eax,%eax
  11d1ed:	0f 85 c5 00 00 00    	jne    11d2b8 <lwm2m_rd_client_service+0x262>
				  "bs", strlen("bs"));
  11d1f3:	68 f9 78 12 00       	push   $0x1278f9
  11d1f8:	e8 1f eb fe ff       	call   10bd1c <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11d1fd:	0f b7 c0             	movzwl %ax,%eax
  11d200:	89 04 24             	mov    %eax,(%esp)
  11d203:	68 f9 78 12 00       	push   $0x1278f9
  11d208:	6a 0b                	push   $0xb
  11d20a:	8d 73 30             	lea    0x30(%ebx),%esi
  11d20d:	56                   	push   %esi
  11d20e:	e8 ff b4 fe ff       	call   108712 <coap_packet_append_option>
  11d213:	83 c4 10             	add    $0x10,%esp
	snprintk(query_buffer, sizeof(query_buffer) - 1, "ep=%s",
  11d216:	68 1c e4 12 00       	push   $0x12e41c
  11d21b:	68 5e 82 12 00       	push   $0x12825e
  11d220:	6a 3f                	push   $0x3f
  11d222:	68 c0 e3 12 00       	push   $0x12e3c0
  11d227:	e8 d3 40 fe ff       	call   1012ff <snprintk>
  11d22c:	83 c4 10             	add    $0x10,%esp
				  query_buffer, strlen(query_buffer));
  11d22f:	68 c0 e3 12 00       	push   $0x12e3c0
  11d234:	e8 e3 ea fe ff       	call   10bd1c <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_QUERY,
  11d239:	0f b7 c0             	movzwl %ax,%eax
  11d23c:	89 04 24             	mov    %eax,(%esp)
  11d23f:	68 c0 e3 12 00       	push   $0x12e3c0
  11d244:	6a 0f                	push   $0xf
  11d246:	56                   	push   %esi
  11d247:	e8 c6 b4 fe ff       	call   108712 <coap_packet_append_option>
  11d24c:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_send_message(msg);
  11d24f:	53                   	push   %ebx
  11d250:	e8 e3 a9 ff ff       	call   117c38 <lwm2m_send_message>
  11d255:	5a                   	pop    %edx
	if (ret < 0) {
  11d256:	85 c0                	test   %eax,%eax
  11d258:	0f 88 1c 04 00 00    	js     11d67a <lwm2m_rd_client_service+0x624>
	set_sm_state(ENGINE_BOOTSTRAP_REG_SENT);
  11d25e:	b8 03 00 00 00       	mov    $0x3,%eax
  11d263:	e9 50 04 00 00       	jmp    11d6b8 <lwm2m_rd_client_service+0x662>
	msg = lwm2m_get_message(client.ctx);
  11d268:	50                   	push   %eax
  11d269:	e8 2a 8a ff ff       	call   115c98 <lwm2m_get_message>
  11d26e:	5f                   	pop    %edi
  11d26f:	89 c3                	mov    %eax,%ebx
	if (!msg) {
  11d271:	85 c0                	test   %eax,%eax
  11d273:	0f 84 44 03 00 00    	je     11d5bd <lwm2m_rd_client_service+0x567>
	msg->type = COAP_TYPE_CON;
  11d279:	66 c7 80 86 02 00 00 	movw   $0x400,0x286(%eax)
  11d280:	00 04 
	msg->mid = coap_next_id();
  11d282:	e8 d3 be fe ff       	call   10915a <coap_next_id>
	msg->tkl = LWM2M_MSG_TOKEN_GENERATE_NEW;
  11d287:	c6 83 88 02 00 00 ff 	movb   $0xff,0x288(%ebx)
	msg->mid = coap_next_id();
  11d28e:	66 89 83 84 02 00 00 	mov    %ax,0x284(%ebx)
	msg->reply_cb = do_deregister_reply_cb;
  11d295:	c7 83 7c 02 00 00 b4 	movl   $0x11cbb4,0x27c(%ebx)
  11d29c:	cb 11 00 
	msg->message_timeout_cb = do_deregister_timeout_cb;
  11d29f:	c7 83 80 02 00 00 78 	movl   $0x11cb78,0x280(%ebx)
  11d2a6:	cb 11 00 
	ret = lwm2m_init_message(msg);
  11d2a9:	53                   	push   %ebx
  11d2aa:	e8 41 8c ff ff       	call   115ef0 <lwm2m_init_message>
  11d2af:	59                   	pop    %ecx
	if (ret) {
  11d2b0:	85 c0                	test   %eax,%eax
  11d2b2:	0f 84 37 03 00 00    	je     11d5ef <lwm2m_rd_client_service+0x599>
	lwm2m_reset_message(msg, true);
  11d2b8:	6a 01                	push   $0x1
  11d2ba:	53                   	push   %ebx
  11d2bb:	e8 06 8a ff ff       	call   115cc6 <lwm2m_reset_message>
  11d2c0:	5e                   	pop    %esi
  11d2c1:	5f                   	pop    %edi
  11d2c2:	e9 16 02 00 00       	jmp    11d4dd <lwm2m_rd_client_service+0x487>
	lwm2m_engine_context_close(client.ctx);
  11d2c7:	50                   	push   %eax
  11d2c8:	e8 87 bf ff ff       	call   119254 <lwm2m_engine_context_close>
	client.ctx->sec_obj_inst = -1;
  11d2cd:	a1 04 e4 12 00       	mov    0x12e404,%eax
	lwm2m_engine_context_close(client.ctx);
  11d2d2:	5b                   	pop    %ebx
	client.ctx->sec_obj_inst = -1;
  11d2d3:	c7 80 50 01 00 00 ff 	movl   $0xffffffff,0x150(%eax)
  11d2da:	ff ff ff 
	set_sm_state(ENGINE_DO_REGISTRATION);
  11d2dd:	e9 d1 02 00 00       	jmp    11d5b3 <lwm2m_rd_client_service+0x55d>
	if (client.ctx->sock_fd > -1) {
  11d2e2:	83 b8 5c 01 00 00 00 	cmpl   $0x0,0x15c(%eax)
  11d2e9:	78 07                	js     11d2f2 <lwm2m_rd_client_service+0x29c>
		lwm2m_engine_context_close(client.ctx);
  11d2eb:	50                   	push   %eax
  11d2ec:	e8 63 bf ff ff       	call   119254 <lwm2m_engine_context_close>
  11d2f1:	59                   	pop    %ecx
	client.ctx->bootstrap_mode = false;
  11d2f2:	8b 15 04 e4 12 00    	mov    0x12e404,%edx
	ret = sm_select_security_inst(client.ctx->bootstrap_mode,
  11d2f8:	31 c0                	xor    %eax,%eax
  11d2fa:	81 c2 50 01 00 00    	add    $0x150,%edx
	client.ctx->bootstrap_mode = false;
  11d300:	c6 42 08 00          	movb   $0x0,0x8(%edx)
	ret = sm_select_security_inst(client.ctx->bootstrap_mode,
  11d304:	e8 47 f9 ff ff       	call   11cc50 <sm_select_security_inst>
	if (ret < 0) {
  11d309:	85 c0                	test   %eax,%eax
  11d30b:	79 33                	jns    11d340 <lwm2m_rd_client_service+0x2ea>
		LOG_ERR("Unable to find a valid security instance.");
  11d30d:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d314:	74 20                	je     11d336 <lwm2m_rd_client_service+0x2e0>
  11d316:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d31b:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d320:	c1 e8 03             	shr    $0x3,%eax
  11d323:	c1 e0 06             	shl    $0x6,%eax
  11d326:	83 c8 01             	or     $0x1,%eax
  11d329:	50                   	push   %eax
  11d32a:	68 ff 82 12 00       	push   $0x1282ff
  11d32f:	e8 19 62 fe ff       	call   10354d <log_0>
  11d334:	58                   	pop    %eax
  11d335:	5a                   	pop    %edx
		set_sm_state(ENGINE_INIT);
  11d336:	b8 01 00 00 00       	mov    $0x1,%eax
  11d33b:	e9 78 03 00 00       	jmp    11d6b8 <lwm2m_rd_client_service+0x662>
				    &client.ctx->srv_obj_inst,
  11d340:	8b 1d 04 e4 12 00    	mov    0x12e404,%ebx
	snprintk(pathstr, sizeof(pathstr), "0/%d/10", sec_obj_inst);
  11d346:	8d 75 e0             	lea    -0x20(%ebp),%esi
  11d349:	ff b3 50 01 00 00    	pushl  0x150(%ebx)
  11d34f:	68 29 83 12 00       	push   $0x128329
  11d354:	6a 14                	push   $0x14
  11d356:	56                   	push   %esi
  11d357:	e8 a3 3f fe ff       	call   1012ff <snprintk>
  11d35c:	83 c4 10             	add    $0x10,%esp
	ret = lwm2m_engine_get_u16(pathstr, &server_id);
  11d35f:	8d 45 de             	lea    -0x22(%ebp),%eax
  11d362:	50                   	push   %eax
  11d363:	56                   	push   %esi
  11d364:	e8 9d af ff ff       	call   118306 <lwm2m_engine_get_u16>
  11d369:	5e                   	pop    %esi
	if (ret < 0) {
  11d36a:	85 c0                	test   %eax,%eax
	ret = lwm2m_engine_get_u16(pathstr, &server_id);
  11d36c:	5f                   	pop    %edi
	if (ret < 0) {
  11d36d:	79 2a                	jns    11d399 <lwm2m_rd_client_service+0x343>
		LOG_WRN("Failed to obtain Short Server ID, err %d", ret);
  11d36f:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
  11d376:	0f 84 ab 00 00 00    	je     11d427 <lwm2m_rd_client_service+0x3d1>
  11d37c:	ba 68 31 12 00       	mov    $0x123168,%edx
  11d381:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11d387:	c1 ea 03             	shr    $0x3,%edx
  11d38a:	c1 e2 06             	shl    $0x6,%edx
  11d38d:	83 ca 02             	or     $0x2,%edx
  11d390:	52                   	push   %edx
  11d391:	50                   	push   %eax
  11d392:	68 31 83 12 00       	push   $0x128331
  11d397:	eb 33                	jmp    11d3cc <lwm2m_rd_client_service+0x376>
	obj_inst_id = lwm2m_server_short_id_to_inst(server_id);
  11d399:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  11d39d:	50                   	push   %eax
  11d39e:	e8 27 cc ff ff       	call   119fca <lwm2m_server_short_id_to_inst>
  11d3a3:	59                   	pop    %ecx
	if (obj_inst_id < 0) {
  11d3a4:	85 c0                	test   %eax,%eax
  11d3a6:	79 2e                	jns    11d3d6 <lwm2m_rd_client_service+0x380>
		LOG_WRN("Failed to obtain Server Object instance, err %d",
  11d3a8:	f6 05 f4 5b 14 00 06 	testb  $0x6,0x145bf4
  11d3af:	74 76                	je     11d427 <lwm2m_rd_client_service+0x3d1>
  11d3b1:	ba 68 31 12 00       	mov    $0x123168,%edx
  11d3b6:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11d3bc:	c1 ea 03             	shr    $0x3,%edx
  11d3bf:	c1 e2 06             	shl    $0x6,%edx
  11d3c2:	83 ca 02             	or     $0x2,%edx
  11d3c5:	52                   	push   %edx
  11d3c6:	50                   	push   %eax
  11d3c7:	68 5a 83 12 00       	push   $0x12835a
  11d3cc:	e8 a5 61 fe ff       	call   103576 <log_1>
  11d3d1:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
  11d3d4:	eb 51                	jmp    11d427 <lwm2m_rd_client_service+0x3d1>
	*srv_obj_inst = obj_inst_id;
  11d3d6:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
	sm_update_lifetime(*srv_obj_inst, lifetime);
  11d3dc:	e8 3b f9 ff ff       	call   11cd1c <sm_update_lifetime.constprop.0>
	LOG_INF("RD Client started with endpoint '%s' with client lifetime %d",
  11d3e1:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
  11d3e6:	83 e0 07             	and    $0x7,%eax
  11d3e9:	83 f8 02             	cmp    $0x2,%eax
  11d3ec:	76 64                	jbe    11d452 <lwm2m_rd_client_service+0x3fc>
  11d3ee:	68 1c e4 12 00       	push   $0x12e41c
  11d3f3:	8b 35 00 e4 12 00    	mov    0x12e400,%esi
  11d3f9:	e8 59 5e fe ff       	call   103257 <log_strdup>
  11d3fe:	bb 68 31 12 00       	mov    $0x123168,%ebx
  11d403:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11d409:	c1 eb 03             	shr    $0x3,%ebx
  11d40c:	c1 e3 06             	shl    $0x6,%ebx
  11d40f:	83 cb 03             	or     $0x3,%ebx
  11d412:	66 89 1c 24          	mov    %bx,(%esp)
  11d416:	56                   	push   %esi
  11d417:	50                   	push   %eax
  11d418:	68 b2 83 12 00       	push   $0x1283b2
  11d41d:	e8 8e 61 fe ff       	call   1035b0 <log_2>
  11d422:	83 c4 10             	add    $0x10,%esp
  11d425:	eb 2b                	jmp    11d452 <lwm2m_rd_client_service+0x3fc>
		LOG_ERR("Unable to find a valid server instance.");
  11d427:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d42e:	0f 84 02 ff ff ff    	je     11d336 <lwm2m_rd_client_service+0x2e0>
  11d434:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d439:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d43e:	c1 e8 03             	shr    $0x3,%eax
  11d441:	c1 e0 06             	shl    $0x6,%eax
  11d444:	83 c8 01             	or     $0x1,%eax
  11d447:	50                   	push   %eax
  11d448:	68 8a 83 12 00       	push   $0x12838a
  11d44d:	e9 dd fe ff ff       	jmp    11d32f <lwm2m_rd_client_service+0x2d9>
	ret = lwm2m_engine_start(client.ctx);
  11d452:	ff 35 04 e4 12 00    	pushl  0x12e404
  11d458:	e8 e6 c0 ff ff       	call   119543 <lwm2m_engine_start>
  11d45d:	5a                   	pop    %edx
	if (ret < 0) {
  11d45e:	85 c0                	test   %eax,%eax
  11d460:	79 2d                	jns    11d48f <lwm2m_rd_client_service+0x439>
		LOG_ERR("Cannot init LWM2M engine (%d)", ret);
  11d462:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d469:	0f 84 7b 02 00 00    	je     11d6ea <lwm2m_rd_client_service+0x694>
  11d46f:	ba 68 31 12 00       	mov    $0x123168,%edx
  11d474:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11d47a:	c1 ea 03             	shr    $0x3,%edx
  11d47d:	c1 e2 06             	shl    $0x6,%edx
  11d480:	83 ca 01             	or     $0x1,%edx
  11d483:	52                   	push   %edx
  11d484:	50                   	push   %eax
  11d485:	68 e1 82 12 00       	push   $0x1282e1
  11d48a:	e9 53 02 00 00       	jmp    11d6e2 <lwm2m_rd_client_service+0x68c>
	ret = sm_send_registration(true,
  11d48f:	b9 00 cb 11 00       	mov    $0x11cb00,%ecx
  11d494:	ba b1 c8 11 00       	mov    $0x11c8b1,%edx
  11d499:	b8 01 00 00 00       	mov    $0x1,%eax
  11d49e:	e8 e4 f8 ff ff       	call   11cd87 <sm_send_registration>
	if (!ret) {
  11d4a3:	85 c0                	test   %eax,%eax
  11d4a5:	75 0a                	jne    11d4b1 <lwm2m_rd_client_service+0x45b>
		set_sm_state(ENGINE_REGISTRATION_SENT);
  11d4a7:	b8 07 00 00 00       	mov    $0x7,%eax
  11d4ac:	e9 07 02 00 00       	jmp    11d6b8 <lwm2m_rd_client_service+0x662>
		LOG_ERR("Registration err: %d", ret);
  11d4b1:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d4b8:	74 23                	je     11d4dd <lwm2m_rd_client_service+0x487>
  11d4ba:	ba 68 31 12 00       	mov    $0x123168,%edx
  11d4bf:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11d4c5:	c1 ea 03             	shr    $0x3,%edx
  11d4c8:	c1 e2 06             	shl    $0x6,%edx
  11d4cb:	83 ca 01             	or     $0x1,%edx
  11d4ce:	52                   	push   %edx
  11d4cf:	50                   	push   %eax
  11d4d0:	68 ef 83 12 00       	push   $0x1283ef
  11d4d5:	e8 9c 60 fe ff       	call   103576 <log_1>
  11d4da:	83 c4 0c             	add    $0xc,%esp
		lwm2m_engine_context_close(client.ctx);
  11d4dd:	ff 35 04 e4 12 00    	pushl  0x12e404
  11d4e3:	e8 6c bd ff ff       	call   119254 <lwm2m_engine_context_close>
  11d4e8:	58                   	pop    %eax
  11d4e9:	e9 fc 01 00 00       	jmp    11d6ea <lwm2m_rd_client_service+0x694>
	if (sm_is_registered() &&
  11d4ee:	80 3d 0a e4 12 00 00 	cmpb   $0x0,0x12e40a
  11d4f5:	74 41                	je     11d538 <lwm2m_rd_client_service+0x4e2>
		sm_update_lifetime(client.ctx->srv_obj_inst, &client.lifetime);
  11d4f7:	a1 04 e4 12 00       	mov    0x12e404,%eax
		forced_update = client.trigger_update;
  11d4fc:	80 3d 0a e4 12 00 00 	cmpb   $0x0,0x12e40a
		sm_update_lifetime(client.ctx->srv_obj_inst, &client.lifetime);
  11d503:	8b 80 54 01 00 00    	mov    0x154(%eax),%eax
		client.trigger_update = 0U;
  11d509:	c6 05 0a e4 12 00 00 	movb   $0x0,0x12e40a
		forced_update = client.trigger_update;
  11d510:	0f 95 c3             	setne  %bl
		sm_update_lifetime(client.ctx->srv_obj_inst, &client.lifetime);
  11d513:	e8 04 f8 ff ff       	call   11cd1c <sm_update_lifetime.constprop.0>
		ret = sm_send_registration(forced_update,
  11d518:	b9 3c cb 11 00       	mov    $0x11cb3c,%ecx
  11d51d:	0f b6 c3             	movzbl %bl,%eax
  11d520:	ba 67 c7 11 00       	mov    $0x11c767,%edx
  11d525:	e8 5d f8 ff ff       	call   11cd87 <sm_send_registration>
		if (!ret) {
  11d52a:	85 c0                	test   %eax,%eax
  11d52c:	75 4d                	jne    11d57b <lwm2m_rd_client_service+0x525>
			set_sm_state(ENGINE_UPDATE_SENT);
  11d52e:	b8 0a 00 00 00       	mov    $0xa,%eax
  11d533:	e9 80 01 00 00       	jmp    11d6b8 <lwm2m_rd_client_service+0x662>
	     ((client.lifetime - SECONDS_TO_UPDATE_EARLY) <=
  11d538:	a1 00 e4 12 00       	mov    0x12e400,%eax
  11d53d:	31 ff                	xor    %edi,%edi
  11d53f:	8d 58 fa             	lea    -0x6(%eax),%ebx
  11d542:	e8 40 4e 00 00       	call   122387 <z_impl_k_uptime_ticks>
	      (k_uptime_get() - client.last_update) / 1000))) {
  11d547:	6a 00                	push   $0x0
  11d549:	6b ca 0a             	imul   $0xa,%edx,%ecx
  11d54c:	ba 0a 00 00 00       	mov    $0xa,%edx
  11d551:	68 e8 03 00 00       	push   $0x3e8
  11d556:	f7 e2                	mul    %edx
  11d558:	01 ca                	add    %ecx,%edx
  11d55a:	2b 05 0c e4 12 00    	sub    0x12e40c,%eax
  11d560:	1b 15 10 e4 12 00    	sbb    0x12e410,%edx
  11d566:	52                   	push   %edx
  11d567:	50                   	push   %eax
  11d568:	e8 73 2b fe ff       	call   1000e0 <__divdi3>
  11d56d:	83 c4 10             	add    $0x10,%esp
	    (client.trigger_update ||
  11d570:	39 d8                	cmp    %ebx,%eax
  11d572:	19 fa                	sbb    %edi,%edx
  11d574:	7d 81                	jge    11d4f7 <lwm2m_rd_client_service+0x4a1>
  11d576:	e9 6f 01 00 00       	jmp    11d6ea <lwm2m_rd_client_service+0x694>
			LOG_ERR("Registration update err: %d", ret);
  11d57b:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d582:	74 23                	je     11d5a7 <lwm2m_rd_client_service+0x551>
  11d584:	ba 68 31 12 00       	mov    $0x123168,%edx
  11d589:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11d58f:	c1 ea 03             	shr    $0x3,%edx
  11d592:	c1 e2 06             	shl    $0x6,%edx
  11d595:	83 ca 01             	or     $0x1,%edx
  11d598:	52                   	push   %edx
  11d599:	50                   	push   %eax
  11d59a:	68 04 84 12 00       	push   $0x128404
  11d59f:	e8 d2 5f fe ff       	call   103576 <log_1>
  11d5a4:	83 c4 0c             	add    $0xc,%esp
			lwm2m_engine_context_close(client.ctx);
  11d5a7:	ff 35 04 e4 12 00    	pushl  0x12e404
  11d5ad:	e8 a2 bc ff ff       	call   119254 <lwm2m_engine_context_close>
  11d5b2:	58                   	pop    %eax
			set_sm_state(ENGINE_DO_REGISTRATION);
  11d5b3:	b8 06 00 00 00       	mov    $0x6,%eax
  11d5b8:	e9 fb 00 00 00       	jmp    11d6b8 <lwm2m_rd_client_service+0x662>
		LOG_ERR("Unable to get a lwm2m message!");
  11d5bd:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d5c4:	0f 84 20 01 00 00    	je     11d6ea <lwm2m_rd_client_service+0x694>
  11d5ca:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d5cf:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d5d4:	c1 e8 03             	shr    $0x3,%eax
  11d5d7:	c1 e0 06             	shl    $0x6,%eax
  11d5da:	83 c8 01             	or     $0x1,%eax
  11d5dd:	50                   	push   %eax
  11d5de:	68 a1 7b 12 00       	push   $0x127ba1
  11d5e3:	e8 65 5f fe ff       	call   10354d <log_0>
  11d5e8:	5b                   	pop    %ebx
  11d5e9:	5e                   	pop    %esi
  11d5ea:	e9 fb 00 00 00       	jmp    11d6ea <lwm2m_rd_client_service+0x694>
				  strlen(LWM2M_RD_CLIENT_URI));
  11d5ef:	68 4e 82 12 00       	push   $0x12824e
  11d5f4:	e8 23 e7 fe ff       	call   10bd1c <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11d5f9:	0f b7 c0             	movzwl %ax,%eax
  11d5fc:	89 04 24             	mov    %eax,(%esp)
  11d5ff:	68 4e 82 12 00       	push   $0x12824e
  11d604:	6a 0b                	push   $0xb
  11d606:	8d 73 30             	lea    0x30(%ebx),%esi
  11d609:	56                   	push   %esi
  11d60a:	e8 03 b1 fe ff       	call   108712 <coap_packet_append_option>
  11d60f:	83 c4 10             	add    $0x10,%esp
				  strlen(client.server_ep));
  11d612:	68 3d e4 12 00       	push   $0x12e43d
  11d617:	e8 00 e7 fe ff       	call   10bd1c <strlen>
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11d61c:	0f b7 c0             	movzwl %ax,%eax
  11d61f:	89 04 24             	mov    %eax,(%esp)
  11d622:	68 3d e4 12 00       	push   $0x12e43d
  11d627:	6a 0b                	push   $0xb
  11d629:	56                   	push   %esi
  11d62a:	e8 e3 b0 fe ff       	call   108712 <coap_packet_append_option>
	LOG_INF("Deregister from '%s'", log_strdup(client.server_ep));
  11d62f:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
	coap_packet_append_option(&msg->cpkt, COAP_OPTION_URI_PATH,
  11d634:	83 c4 10             	add    $0x10,%esp
	LOG_INF("Deregister from '%s'", log_strdup(client.server_ep));
  11d637:	83 e0 07             	and    $0x7,%eax
  11d63a:	83 f8 02             	cmp    $0x2,%eax
  11d63d:	76 30                	jbe    11d66f <lwm2m_rd_client_service+0x619>
  11d63f:	68 3d e4 12 00       	push   $0x12e43d
  11d644:	e8 0e 5c fe ff       	call   103257 <log_strdup>
  11d649:	be 68 31 12 00       	mov    $0x123168,%esi
  11d64e:	81 ee b0 30 12 00    	sub    $0x1230b0,%esi
  11d654:	c1 ee 03             	shr    $0x3,%esi
  11d657:	c1 e6 06             	shl    $0x6,%esi
  11d65a:	83 ce 03             	or     $0x3,%esi
  11d65d:	66 89 34 24          	mov    %si,(%esp)
  11d661:	50                   	push   %eax
  11d662:	68 20 84 12 00       	push   $0x128420
  11d667:	e8 0a 5f fe ff       	call   103576 <log_1>
  11d66c:	83 c4 0c             	add    $0xc,%esp
	ret = lwm2m_send_message(msg);
  11d66f:	53                   	push   %ebx
  11d670:	e8 c3 a5 ff ff       	call   117c38 <lwm2m_send_message>
  11d675:	5a                   	pop    %edx
	if (ret < 0) {
  11d676:	85 c0                	test   %eax,%eax
  11d678:	79 35                	jns    11d6af <lwm2m_rd_client_service+0x659>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
  11d67a:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d681:	0f 84 31 fc ff ff    	je     11d2b8 <lwm2m_rd_client_service+0x262>
  11d687:	ba 68 31 12 00       	mov    $0x123168,%edx
  11d68c:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11d692:	c1 ea 03             	shr    $0x3,%edx
  11d695:	c1 e2 06             	shl    $0x6,%edx
  11d698:	83 ca 01             	or     $0x1,%edx
  11d69b:	52                   	push   %edx
  11d69c:	50                   	push   %eax
  11d69d:	68 2f 7c 12 00       	push   $0x127c2f
  11d6a2:	e8 cf 5e fe ff       	call   103576 <log_1>
  11d6a7:	83 c4 0c             	add    $0xc,%esp
  11d6aa:	e9 09 fc ff ff       	jmp    11d2b8 <lwm2m_rd_client_service+0x262>
	set_sm_state(ENGINE_DEREGISTER_SENT);
  11d6af:	b8 0c 00 00 00       	mov    $0xc,%eax
  11d6b4:	eb 02                	jmp    11d6b8 <lwm2m_rd_client_service+0x662>
			set_sm_state(ENGINE_IDLE);
  11d6b6:	31 c0                	xor    %eax,%eax
  11d6b8:	e8 0f ef ff ff       	call   11c5cc <set_sm_state>
			break;
  11d6bd:	eb 2b                	jmp    11d6ea <lwm2m_rd_client_service+0x694>
			LOG_ERR("Unhandled state: %d", get_sm_state());
  11d6bf:	f6 05 f4 5b 14 00 07 	testb  $0x7,0x145bf4
  11d6c6:	74 22                	je     11d6ea <lwm2m_rd_client_service+0x694>
  11d6c8:	b8 68 31 12 00       	mov    $0x123168,%eax
  11d6cd:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d6d2:	c1 e8 03             	shr    $0x3,%eax
  11d6d5:	c1 e0 06             	shl    $0x6,%eax
  11d6d8:	83 c8 01             	or     $0x1,%eax
  11d6db:	50                   	push   %eax
  11d6dc:	52                   	push   %edx
  11d6dd:	68 35 84 12 00       	push   $0x128435
  11d6e2:	e8 8f 5e fe ff       	call   103576 <log_1>
  11d6e7:	83 c4 0c             	add    $0xc,%esp
}
  11d6ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11d6ed:	5b                   	pop    %ebx
  11d6ee:	5e                   	pop    %esi
  11d6ef:	5f                   	pop    %edi
  11d6f0:	5d                   	pop    %ebp
  11d6f1:	c3                   	ret    
  11d6f2:	c3                   	ret    

0011d6f3 <engine_trigger_restart>:
{
  11d6f3:	55                   	push   %ebp
  11d6f4:	89 e5                	mov    %esp,%ebp
	lwm2m_engine_context_close(client.ctx);
  11d6f6:	ff 35 04 e4 12 00    	pushl  0x12e404
  11d6fc:	e8 53 bb ff ff       	call   119254 <lwm2m_engine_context_close>
  11d701:	58                   	pop    %eax
	client.ctx->sec_obj_inst = -1;
  11d702:	a1 04 e4 12 00       	mov    0x12e404,%eax
  11d707:	c7 80 50 01 00 00 ff 	movl   $0xffffffff,0x150(%eax)
  11d70e:	ff ff ff 
	set_sm_state(ENGINE_DO_REGISTRATION);
  11d711:	b8 06 00 00 00       	mov    $0x6,%eax
}
  11d716:	c9                   	leave  
	set_sm_state(ENGINE_DO_REGISTRATION);
  11d717:	e9 b0 ee ff ff       	jmp    11c5cc <set_sm_state>

0011d71c <engine_trigger_update>:
	client.trigger_update = 1U;
  11d71c:	c6 05 0a e4 12 00 01 	movb   $0x1,0x12e40a
}
  11d723:	c3                   	ret    

0011d724 <engine_bootstrap_finish>:
	LOG_INF("Bootstrap data transfer done!");
  11d724:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
  11d729:	83 e0 07             	and    $0x7,%eax
  11d72c:	83 f8 02             	cmp    $0x2,%eax
  11d72f:	76 2b                	jbe    11d75c <engine_bootstrap_finish+0x38>
  11d731:	b8 68 31 12 00       	mov    $0x123168,%eax
{
  11d736:	55                   	push   %ebp
  11d737:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11d73c:	89 e5                	mov    %esp,%ebp
  11d73e:	c1 e8 03             	shr    $0x3,%eax
	LOG_INF("Bootstrap data transfer done!");
  11d741:	c1 e0 06             	shl    $0x6,%eax
  11d744:	83 c8 03             	or     $0x3,%eax
  11d747:	50                   	push   %eax
  11d748:	68 49 84 12 00       	push   $0x128449
  11d74d:	e8 fb 5d fe ff       	call   10354d <log_0>
  11d752:	58                   	pop    %eax
	set_sm_state(ENGINE_BOOTSTRAP_TRANS_DONE);
  11d753:	b8 05 00 00 00       	mov    $0x5,%eax
	LOG_INF("Bootstrap data transfer done!");
  11d758:	5a                   	pop    %edx
}
  11d759:	c9                   	leave  
  11d75a:	eb 05                	jmp    11d761 <engine_bootstrap_finish+0x3d>
	set_sm_state(ENGINE_BOOTSTRAP_TRANS_DONE);
  11d75c:	b8 05 00 00 00       	mov    $0x5,%eax
  11d761:	e9 66 ee ff ff       	jmp    11c5cc <set_sm_state>

0011d766 <lwm2m_rd_client_start>:
{
  11d766:	55                   	push   %ebp
  11d767:	89 e5                	mov    %esp,%ebp
  11d769:	53                   	push   %ebx
  11d76a:	8b 45 08             	mov    0x8(%ebp),%eax
  11d76d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	client.ctx = client_ctx;
  11d770:	a3 04 e4 12 00       	mov    %eax,0x12e404
	client.ctx->sock_fd = -1;
  11d775:	c7 80 5c 01 00 00 ff 	movl   $0xffffffff,0x15c(%eax)
  11d77c:	ff ff ff 
	client.event_cb = event_cb;
  11d77f:	8b 45 14             	mov    0x14(%ebp),%eax
  11d782:	a3 60 e4 12 00       	mov    %eax,0x12e460
	client.use_bootstrap = flags & LWM2M_RD_CLIENT_FLAG_BOOTSTRAP;
  11d787:	8a 45 10             	mov    0x10(%ebp),%al
  11d78a:	83 e0 01             	and    $0x1,%eax
  11d78d:	a2 09 e4 12 00       	mov    %al,0x12e409
	set_sm_state(ENGINE_INIT);
  11d792:	b8 01 00 00 00       	mov    $0x1,%eax
  11d797:	e8 30 ee ff ff       	call   11c5cc <set_sm_state>
	strncpy(client.ep_name, ep_name, CLIENT_EP_LEN - 1);
  11d79c:	6a 20                	push   $0x20
  11d79e:	53                   	push   %ebx
  11d79f:	68 1c e4 12 00       	push   $0x12e41c
  11d7a4:	e8 fc e4 fe ff       	call   10bca5 <strncpy>
	LOG_INF("Start LWM2M Client: %s", log_strdup(client.ep_name));
  11d7a9:	a1 f4 5b 14 00       	mov    0x145bf4,%eax
	strncpy(client.ep_name, ep_name, CLIENT_EP_LEN - 1);
  11d7ae:	83 c4 0c             	add    $0xc,%esp
	LOG_INF("Start LWM2M Client: %s", log_strdup(client.ep_name));
  11d7b1:	83 e0 07             	and    $0x7,%eax
  11d7b4:	83 f8 02             	cmp    $0x2,%eax
  11d7b7:	76 36                	jbe    11d7ef <lwm2m_rd_client_start+0x89>
  11d7b9:	68 1c e4 12 00       	push   $0x12e41c
  11d7be:	e8 94 5a fe ff       	call   103257 <log_strdup>
  11d7c3:	bb 68 31 12 00       	mov    $0x123168,%ebx
  11d7c8:	5a                   	pop    %edx
  11d7c9:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11d7cf:	89 45 0c             	mov    %eax,0xc(%ebp)
  11d7d2:	c1 eb 03             	shr    $0x3,%ebx
  11d7d5:	c7 45 08 67 84 12 00 	movl   $0x128467,0x8(%ebp)
  11d7dc:	c1 e3 06             	shl    $0x6,%ebx
  11d7df:	83 cb 03             	or     $0x3,%ebx
  11d7e2:	66 89 5d 10          	mov    %bx,0x10(%ebp)
}
  11d7e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11d7e9:	c9                   	leave  
	LOG_INF("Start LWM2M Client: %s", log_strdup(client.ep_name));
  11d7ea:	e9 87 5d fe ff       	jmp    103576 <log_1>
}
  11d7ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11d7f2:	c9                   	leave  
  11d7f3:	c3                   	ret    

0011d7f4 <lwm2m_firmware_init>:
	LOG_DBG("Create LWM2M firmware instance: %d", obj_inst_id);
	return &inst;
}

static int lwm2m_firmware_init(const struct device *dev)
{
  11d7f4:	55                   	push   %ebp
  11d7f5:	89 e5                	mov    %esp,%ebp
  11d7f7:	50                   	push   %eax
	firmware.obj_id = LWM2M_OBJECT_FIRMWARE_ID;
	firmware.fields = fields;
	firmware.field_count = ARRAY_SIZE(fields);
	firmware.max_instance_count = 1U;
	firmware.create_cb = firmware_create;
	lwm2m_register_obj(&firmware);
  11d7f8:	68 00 e6 12 00       	push   $0x12e600
	package_uri[0] = '\0';
  11d7fd:	c6 05 20 e6 12 00 00 	movb   $0x0,0x12e620
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11d804:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	update_state = STATE_IDLE;
  11d80b:	c6 05 81 ed 12 00 00 	movb   $0x0,0x12ed81
	update_result = RESULT_DEFAULT;
  11d812:	c6 05 80 ed 12 00 00 	movb   $0x0,0x12ed80
	delivery_method = DELIVERY_METHOD_BOTH;
  11d819:	c6 05 7f ed 12 00 02 	movb   $0x2,0x12ed7f
	firmware.fields = fields;
  11d820:	c7 05 04 e6 12 00 e0 	movl   $0x1458e0,0x12e604
  11d827:	58 14 00 
	firmware.obj_id = LWM2M_OBJECT_FIRMWARE_ID;
  11d82a:	c7 05 18 e6 12 00 05 	movl   $0x90005,0x12e618
  11d831:	00 09 00 
	firmware.max_instance_count = 1U;
  11d834:	66 c7 05 1e e6 12 00 	movw   $0x1,0x12e61e
  11d83b:	01 00 
	firmware.create_cb = firmware_create;
  11d83d:	c7 05 08 e6 12 00 60 	movl   $0x11d860,0x12e608
  11d844:	d8 11 00 
	lwm2m_register_obj(&firmware);
  11d847:	e8 a0 7a ff ff       	call   1152ec <lwm2m_register_obj>

	/* auto create the only instance */
	ret = lwm2m_create_obj_inst(LWM2M_OBJECT_FIRMWARE_ID, 0, &obj_inst);
  11d84c:	8d 45 fc             	lea    -0x4(%ebp),%eax
  11d84f:	89 04 24             	mov    %eax,(%esp)
  11d852:	6a 00                	push   $0x0
  11d854:	6a 05                	push   $0x5
  11d856:	e8 b6 82 ff ff       	call   115b11 <lwm2m_create_obj_inst>
  11d85b:	83 c4 0c             	add    $0xc,%esp
	if (ret < 0) {
		LOG_DBG("Create LWM2M instance 0 error: %d", ret);
	}

	return ret;
}
  11d85e:	c9                   	leave  
  11d85f:	c3                   	ret    

0011d860 <firmware_create>:
{
  11d860:	55                   	push   %ebp
  11d861:	89 e5                	mov    %esp,%ebp
	memset(ri, 0, sizeof(*ri) * ri_len);
  11d863:	6a 6c                	push   $0x6c
  11d865:	6a 00                	push   $0x0
  11d867:	68 80 e4 12 00       	push   $0x12e480
  11d86c:	e8 ea e5 fe ff       	call   10be5b <memset>
  11d871:	83 c4 0c             	add    $0xc,%esp
		ri[i].res_inst_id = RES_INSTANCE_NOT_CREATED;
  11d874:	66 c7 05 c4 e4 12 00 	movw   $0xffff,0x12e4c4
  11d87b:	ff ff 
  11d87d:	66 c7 05 d0 e4 12 00 	movw   $0xffff,0x12e4d0
  11d884:	ff ff 
  11d886:	66 c7 05 dc e4 12 00 	movw   $0xffff,0x12e4dc
  11d88d:	ff ff 
  11d88f:	66 c7 05 e8 e4 12 00 	movw   $0xffff,0x12e4e8
  11d896:	ff ff 
	INIT_OBJ_RES_OPT(FIRMWARE_PACKAGE_ID, res, i, res_inst, j, 1, true,
  11d898:	66 c7 05 14 e5 12 00 	movw   $0x0,0x12e514
  11d89f:	00 00 
  11d8a1:	c7 05 10 e5 12 00 80 	movl   $0x12e480,0x12e510
  11d8a8:	e4 12 00 
  11d8ab:	c6 05 16 e5 12 00 01 	movb   $0x1,0x12e516
  11d8b2:	c7 05 00 e5 12 00 00 	movl   $0x0,0x12e500
  11d8b9:	00 00 00 
  11d8bc:	c7 05 04 e5 12 00 00 	movl   $0x0,0x12e504
  11d8c3:	00 00 00 
  11d8c6:	c7 05 08 e5 12 00 ac 	movl   $0x11dcac,0x12e508
  11d8cd:	dc 11 00 
  11d8d0:	c7 05 0c e5 12 00 00 	movl   $0x0,0x12e50c
  11d8d7:	00 00 00 
  11d8da:	c7 05 80 e4 12 00 00 	movl   $0x0,0x12e480
  11d8e1:	00 00 00 
  11d8e4:	c7 05 84 e4 12 00 00 	movl   $0x0,0x12e484
  11d8eb:	00 00 00 
  11d8ee:	66 c7 05 88 e4 12 00 	movw   $0x0,0x12e488
  11d8f5:	00 00 
	INIT_OBJ_RES(FIRMWARE_PACKAGE_URI_ID, res, i, res_inst, j, 1, true,
  11d8f7:	66 c7 05 2c e5 12 00 	movw   $0x1,0x12e52c
  11d8fe:	01 00 
  11d900:	c7 05 28 e5 12 00 8c 	movl   $0x12e48c,0x12e528
  11d907:	e4 12 00 
  11d90a:	c6 05 2e e5 12 00 01 	movb   $0x1,0x12e52e
  11d911:	c7 05 18 e5 12 00 00 	movl   $0x0,0x12e518
  11d918:	00 00 00 
  11d91b:	c7 05 1c e5 12 00 00 	movl   $0x0,0x12e51c
  11d922:	00 00 00 
  11d925:	c7 05 20 e5 12 00 6b 	movl   $0x11dc6b,0x12e520
  11d92c:	dc 11 00 
  11d92f:	c7 05 24 e5 12 00 00 	movl   $0x0,0x12e524
  11d936:	00 00 00 
  11d939:	c7 05 8c e4 12 00 20 	movl   $0x12e620,0x12e48c
  11d940:	e6 12 00 
  11d943:	c7 05 90 e4 12 00 ff 	movl   $0xff00ff,0x12e490
  11d94a:	00 ff 00 
  11d94d:	66 c7 05 94 e4 12 00 	movw   $0x0,0x12e494
  11d954:	00 00 
	INIT_OBJ_RES_EXECUTE(FIRMWARE_UPDATE_ID, res, i, firmware_update_cb);
  11d956:	66 c7 05 44 e5 12 00 	movw   $0x2,0x12e544
  11d95d:	02 00 
  11d95f:	c7 05 40 e5 12 00 00 	movl   $0x0,0x12e540
  11d966:	00 00 00 
  11d969:	c6 05 46 e5 12 00 00 	movb   $0x0,0x12e546
  11d970:	c7 05 30 e5 12 00 00 	movl   $0x0,0x12e530
  11d977:	00 00 00 
  11d97a:	c7 05 34 e5 12 00 00 	movl   $0x0,0x12e534
  11d981:	00 00 00 
  11d984:	c7 05 38 e5 12 00 00 	movl   $0x0,0x12e538
  11d98b:	00 00 00 
  11d98e:	c7 05 3c e5 12 00 80 	movl   $0x11dd80,0x12e53c
  11d995:	dd 11 00 
	INIT_OBJ_RES_DATA(FIRMWARE_STATE_ID, res, i, res_inst, j,
  11d998:	66 c7 05 5c e5 12 00 	movw   $0x3,0x12e55c
  11d99f:	03 00 
}
  11d9a1:	b8 24 ed 12 00       	mov    $0x12ed24,%eax
	INIT_OBJ_RES_DATA(FIRMWARE_STATE_ID, res, i, res_inst, j,
  11d9a6:	c7 05 58 e5 12 00 98 	movl   $0x12e498,0x12e558
  11d9ad:	e4 12 00 
  11d9b0:	c6 05 5e e5 12 00 01 	movb   $0x1,0x12e55e
  11d9b7:	c7 05 48 e5 12 00 00 	movl   $0x0,0x12e548
  11d9be:	00 00 00 
  11d9c1:	c7 05 4c e5 12 00 00 	movl   $0x0,0x12e54c
  11d9c8:	00 00 00 
  11d9cb:	c7 05 50 e5 12 00 00 	movl   $0x0,0x12e550
  11d9d2:	00 00 00 
  11d9d5:	c7 05 54 e5 12 00 00 	movl   $0x0,0x12e554
  11d9dc:	00 00 00 
  11d9df:	c7 05 98 e4 12 00 81 	movl   $0x12ed81,0x12e498
  11d9e6:	ed 12 00 
  11d9e9:	c7 05 9c e4 12 00 01 	movl   $0x10001,0x12e49c
  11d9f0:	00 01 00 
  11d9f3:	66 c7 05 a0 e4 12 00 	movw   $0x0,0x12e4a0
  11d9fa:	00 00 
	INIT_OBJ_RES_DATA(FIRMWARE_UPDATE_RESULT_ID, res, i, res_inst, j,
  11d9fc:	66 c7 05 74 e5 12 00 	movw   $0x5,0x12e574
  11da03:	05 00 
  11da05:	c7 05 70 e5 12 00 a4 	movl   $0x12e4a4,0x12e570
  11da0c:	e4 12 00 
  11da0f:	c6 05 76 e5 12 00 01 	movb   $0x1,0x12e576
  11da16:	c7 05 60 e5 12 00 00 	movl   $0x0,0x12e560
  11da1d:	00 00 00 
  11da20:	c7 05 64 e5 12 00 00 	movl   $0x0,0x12e564
  11da27:	00 00 00 
  11da2a:	c7 05 68 e5 12 00 00 	movl   $0x0,0x12e568
  11da31:	00 00 00 
  11da34:	c7 05 6c e5 12 00 00 	movl   $0x0,0x12e56c
  11da3b:	00 00 00 
  11da3e:	c7 05 a4 e4 12 00 80 	movl   $0x12ed80,0x12e4a4
  11da45:	ed 12 00 
  11da48:	c7 05 a8 e4 12 00 01 	movl   $0x10001,0x12e4a8
  11da4f:	00 01 00 
  11da52:	66 c7 05 ac e4 12 00 	movw   $0x0,0x12e4ac
  11da59:	00 00 
	INIT_OBJ_RES_DATA(FIRMWARE_UPDATE_DELIV_METHOD_ID, res, i, res_inst, j,
  11da5b:	66 c7 05 8c e5 12 00 	movw   $0x9,0x12e58c
  11da62:	09 00 
  11da64:	c7 05 88 e5 12 00 b0 	movl   $0x12e4b0,0x12e588
  11da6b:	e4 12 00 
  11da6e:	c6 05 8e e5 12 00 01 	movb   $0x1,0x12e58e
  11da75:	c7 05 78 e5 12 00 00 	movl   $0x0,0x12e578
  11da7c:	00 00 00 
  11da7f:	c7 05 7c e5 12 00 00 	movl   $0x0,0x12e57c
  11da86:	00 00 00 
  11da89:	c7 05 80 e5 12 00 00 	movl   $0x0,0x12e580
  11da90:	00 00 00 
  11da93:	c7 05 84 e5 12 00 00 	movl   $0x0,0x12e584
  11da9a:	00 00 00 
  11da9d:	c7 05 b0 e4 12 00 7f 	movl   $0x12ed7f,0x12e4b0
  11daa4:	ed 12 00 
  11daa7:	c7 05 b4 e4 12 00 01 	movl   $0x10001,0x12e4b4
  11daae:	00 01 00 
  11dab1:	66 c7 05 b8 e4 12 00 	movw   $0x0,0x12e4b8
  11dab8:	00 00 
	inst.resources = res;
  11daba:	c7 05 2c ed 12 00 00 	movl   $0x12e500,0x12ed2c
  11dac1:	e5 12 00 
	inst.resource_count = i;
  11dac4:	66 c7 05 32 ed 12 00 	movw   $0x6,0x12ed32
  11dacb:	06 00 
}
  11dacd:	c9                   	leave  
  11dace:	c3                   	ret    

0011dacf <lwm2m_firmware_set_update_state>:
{
  11dacf:	55                   	push   %ebp
  11dad0:	89 e5                	mov    %esp,%ebp
  11dad2:	53                   	push   %ebx
  11dad3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	switch (state) {
  11dad6:	80 fb 02             	cmp    $0x2,%bl
  11dad9:	74 21                	je     11dafc <lwm2m_firmware_set_update_state+0x2d>
  11dadb:	77 11                	ja     11daee <lwm2m_firmware_set_update_state+0x1f>
  11dadd:	84 db                	test   %bl,%bl
  11dadf:	0f 84 88 00 00 00    	je     11db6d <lwm2m_firmware_set_update_state+0x9e>
		if (update_state != STATE_IDLE) {
  11dae5:	80 3d 81 ed 12 00 00 	cmpb   $0x0,0x12ed81
  11daec:	eb 18                	jmp    11db06 <lwm2m_firmware_set_update_state+0x37>
	switch (state) {
  11daee:	80 fb 03             	cmp    $0x3,%bl
  11daf1:	75 17                	jne    11db0a <lwm2m_firmware_set_update_state+0x3b>
		if (update_state != STATE_DOWNLOADED) {
  11daf3:	80 3d 81 ed 12 00 02 	cmpb   $0x2,0x12ed81
  11dafa:	eb 0a                	jmp    11db06 <lwm2m_firmware_set_update_state+0x37>
		if (update_state != STATE_DOWNLOADING &&
  11dafc:	a0 81 ed 12 00       	mov    0x12ed81,%al
  11db01:	83 e0 fd             	and    $0xfffffffd,%eax
  11db04:	fe c8                	dec    %al
		if (update_state != STATE_DOWNLOADED) {
  11db06:	75 2f                	jne    11db37 <lwm2m_firmware_set_update_state+0x68>
  11db08:	eb 63                	jmp    11db6d <lwm2m_firmware_set_update_state+0x9e>
		LOG_ERR("Unhandled state: %u", state);
  11db0a:	f6 05 dc 5b 14 00 07 	testb  $0x7,0x145bdc
  11db11:	74 6e                	je     11db81 <lwm2m_firmware_set_update_state+0xb2>
  11db13:	b8 38 31 12 00       	mov    $0x123138,%eax
  11db18:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11db1d:	c1 e8 03             	shr    $0x3,%eax
  11db20:	c1 e0 06             	shl    $0x6,%eax
  11db23:	83 c8 01             	or     $0x1,%eax
  11db26:	50                   	push   %eax
  11db27:	0f b6 db             	movzbl %bl,%ebx
  11db2a:	53                   	push   %ebx
  11db2b:	68 92 84 12 00       	push   $0x128492
  11db30:	e8 41 5a fe ff       	call   103576 <log_1>
  11db35:	eb 47                	jmp    11db7e <lwm2m_firmware_set_update_state+0xaf>
		LOG_ERR("Invalid state transition: %u -> %u",
  11db37:	f6 05 dc 5b 14 00 07 	testb  $0x7,0x145bdc
  11db3e:	74 2d                	je     11db6d <lwm2m_firmware_set_update_state+0x9e>
  11db40:	b8 38 31 12 00       	mov    $0x123138,%eax
  11db45:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11db4a:	c1 e8 03             	shr    $0x3,%eax
  11db4d:	c1 e0 06             	shl    $0x6,%eax
  11db50:	83 c8 01             	or     $0x1,%eax
  11db53:	50                   	push   %eax
  11db54:	0f b6 c3             	movzbl %bl,%eax
  11db57:	50                   	push   %eax
  11db58:	0f b6 05 81 ed 12 00 	movzbl 0x12ed81,%eax
  11db5f:	50                   	push   %eax
  11db60:	68 a6 84 12 00       	push   $0x1284a6
  11db65:	e8 46 5a fe ff       	call   1035b0 <log_2>
  11db6a:	83 c4 10             	add    $0x10,%esp
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_STATE_ID);
  11db6d:	6a 03                	push   $0x3
	update_state = state;
  11db6f:	88 1d 81 ed 12 00    	mov    %bl,0x12ed81
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_STATE_ID);
  11db75:	6a 00                	push   $0x0
  11db77:	6a 05                	push   $0x5
  11db79:	e8 f3 76 ff ff       	call   115271 <lwm2m_notify_observer>
  11db7e:	83 c4 0c             	add    $0xc,%esp
}
  11db81:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11db84:	c9                   	leave  
  11db85:	c3                   	ret    

0011db86 <lwm2m_firmware_set_update_result>:
{
  11db86:	55                   	push   %ebp
  11db87:	89 e5                	mov    %esp,%ebp
  11db89:	57                   	push   %edi
  11db8a:	56                   	push   %esi
  11db8b:	53                   	push   %ebx
  11db8c:	51                   	push   %ecx
  11db8d:	8b 45 08             	mov    0x8(%ebp),%eax
  11db90:	89 45 f0             	mov    %eax,-0x10(%ebp)
  11db93:	80 7d f0 09          	cmpb   $0x9,-0x10(%ebp)
  11db97:	77 55                	ja     11dbee <lwm2m_firmware_set_update_result+0x68>
  11db99:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
  11db9d:	ff 24 bd dc 45 12 00 	jmp    *0x1245dc(,%edi,4)
		lwm2m_firmware_set_update_state(STATE_IDLE);
  11dba4:	6a 00                	push   $0x0
  11dba6:	e8 24 ff ff ff       	call   11dacf <lwm2m_firmware_set_update_state>
  11dbab:	5a                   	pop    %edx
	if (error) {
  11dbac:	e9 9c 00 00 00       	jmp    11dc4d <lwm2m_firmware_set_update_result+0xc7>
		if (update_state != STATE_UPDATING) {
  11dbb1:	8a 15 81 ed 12 00    	mov    0x12ed81,%dl
	bool error = false;
  11dbb7:	31 db                	xor    %ebx,%ebx
		if (update_state != STATE_UPDATING) {
  11dbb9:	80 fa 03             	cmp    $0x3,%dl
  11dbbc:	eb 1c                	jmp    11dbda <lwm2m_firmware_set_update_result+0x54>
		if (update_state != STATE_DOWNLOADING) {
  11dbbe:	8a 15 81 ed 12 00    	mov    0x12ed81,%dl
	bool error = false;
  11dbc4:	31 db                	xor    %ebx,%ebx
		if (update_state != STATE_DOWNLOADING) {
  11dbc6:	80 fa 01             	cmp    $0x1,%dl
  11dbc9:	eb 0f                	jmp    11dbda <lwm2m_firmware_set_update_result+0x54>
		if (update_state != STATE_DOWNLOADING &&
  11dbcb:	8a 15 81 ed 12 00    	mov    0x12ed81,%dl
	bool error = false;
  11dbd1:	31 db                	xor    %ebx,%ebx
		if (update_state != STATE_DOWNLOADING &&
  11dbd3:	88 d1                	mov    %dl,%cl
  11dbd5:	83 e1 fd             	and    $0xfffffffd,%ecx
  11dbd8:	fe c9                	dec    %cl
  11dbda:	74 04                	je     11dbe0 <lwm2m_firmware_set_update_result+0x5a>
  11dbdc:	89 d6                	mov    %edx,%esi
			error = true;
  11dbde:	b3 01                	mov    $0x1,%bl
		lwm2m_firmware_set_update_state(STATE_IDLE);
  11dbe0:	6a 00                	push   $0x0
  11dbe2:	e8 e8 fe ff ff       	call   11dacf <lwm2m_firmware_set_update_state>
  11dbe7:	58                   	pop    %eax
	if (error) {
  11dbe8:	84 db                	test   %bl,%bl
  11dbea:	74 61                	je     11dc4d <lwm2m_firmware_set_update_result+0xc7>
  11dbec:	eb 2e                	jmp    11dc1c <lwm2m_firmware_set_update_result+0x96>
		LOG_ERR("Unhandled result: %u", result);
  11dbee:	f6 05 dc 5b 14 00 07 	testb  $0x7,0x145bdc
  11dbf5:	74 6c                	je     11dc63 <lwm2m_firmware_set_update_result+0xdd>
  11dbf7:	b8 38 31 12 00       	mov    $0x123138,%eax
  11dbfc:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11dc01:	c1 e8 03             	shr    $0x3,%eax
  11dc04:	c1 e0 06             	shl    $0x6,%eax
  11dc07:	0f b6 5d f0          	movzbl -0x10(%ebp),%ebx
  11dc0b:	83 c8 01             	or     $0x1,%eax
  11dc0e:	50                   	push   %eax
  11dc0f:	53                   	push   %ebx
  11dc10:	68 c9 84 12 00       	push   $0x1284c9
  11dc15:	e8 5c 59 fe ff       	call   103576 <log_1>
  11dc1a:	eb 44                	jmp    11dc60 <lwm2m_firmware_set_update_result+0xda>
		LOG_ERR("Unexpected result(%u) set while state is %u",
  11dc1c:	f6 05 dc 5b 14 00 07 	testb  $0x7,0x145bdc
  11dc23:	74 28                	je     11dc4d <lwm2m_firmware_set_update_result+0xc7>
  11dc25:	b8 38 31 12 00       	mov    $0x123138,%eax
  11dc2a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11dc2f:	c1 e8 03             	shr    $0x3,%eax
  11dc32:	c1 e0 06             	shl    $0x6,%eax
  11dc35:	83 c8 01             	or     $0x1,%eax
  11dc38:	50                   	push   %eax
  11dc39:	89 f0                	mov    %esi,%eax
  11dc3b:	0f b6 f0             	movzbl %al,%esi
  11dc3e:	56                   	push   %esi
  11dc3f:	57                   	push   %edi
  11dc40:	68 de 84 12 00       	push   $0x1284de
  11dc45:	e8 66 59 fe ff       	call   1035b0 <log_2>
  11dc4a:	83 c4 10             	add    $0x10,%esp
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_UPDATE_RESULT_ID);
  11dc4d:	6a 05                	push   $0x5
	update_result = result;
  11dc4f:	8a 45 f0             	mov    -0x10(%ebp),%al
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_UPDATE_RESULT_ID);
  11dc52:	6a 00                	push   $0x0
	update_result = result;
  11dc54:	a2 80 ed 12 00       	mov    %al,0x12ed80
	NOTIFY_OBSERVER(LWM2M_OBJECT_FIRMWARE_ID, 0, FIRMWARE_UPDATE_RESULT_ID);
  11dc59:	6a 05                	push   $0x5
  11dc5b:	e8 11 76 ff ff       	call   115271 <lwm2m_notify_observer>
  11dc60:	83 c4 0c             	add    $0xc,%esp
}
  11dc63:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11dc66:	5b                   	pop    %ebx
  11dc67:	5e                   	pop    %esi
  11dc68:	5f                   	pop    %edi
  11dc69:	5d                   	pop    %ebp
  11dc6a:	c3                   	ret    

0011dc6b <package_uri_write_cb>:
{
  11dc6b:	55                   	push   %ebp
	return update_state;
  11dc6c:	a0 81 ed 12 00       	mov    0x12ed81,%al
{
  11dc71:	89 e5                	mov    %esp,%ebp
	if (state == STATE_IDLE) {
  11dc73:	84 c0                	test   %al,%al
{
  11dc75:	53                   	push   %ebx
  11dc76:	8b 5d 18             	mov    0x18(%ebp),%ebx
	if (state == STATE_IDLE) {
  11dc79:	75 19                	jne    11dc94 <package_uri_write_cb+0x29>
		lwm2m_firmware_set_update_result(RESULT_DEFAULT);
  11dc7b:	6a 00                	push   $0x0
  11dc7d:	e8 04 ff ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
		if (data_len > 0) {
  11dc82:	66 85 db             	test   %bx,%bx
		lwm2m_firmware_set_update_result(RESULT_DEFAULT);
  11dc85:	5a                   	pop    %edx
		if (data_len > 0) {
  11dc86:	74 1d                	je     11dca5 <package_uri_write_cb+0x3a>
			lwm2m_firmware_start_transfer(package_uri);
  11dc88:	68 20 e6 12 00       	push   $0x12e620
  11dc8d:	e8 be 09 00 00       	call   11e650 <lwm2m_firmware_start_transfer>
  11dc92:	eb 10                	jmp    11dca4 <package_uri_write_cb+0x39>
	} else if (state == STATE_DOWNLOADED && data_len == 0U) {
  11dc94:	3c 02                	cmp    $0x2,%al
  11dc96:	75 0d                	jne    11dca5 <package_uri_write_cb+0x3a>
  11dc98:	66 85 db             	test   %bx,%bx
  11dc9b:	75 08                	jne    11dca5 <package_uri_write_cb+0x3a>
		lwm2m_firmware_set_update_result(RESULT_DEFAULT);
  11dc9d:	6a 00                	push   $0x0
  11dc9f:	e8 e2 fe ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11dca4:	58                   	pop    %eax
}
  11dca5:	31 c0                	xor    %eax,%eax
  11dca7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11dcaa:	c9                   	leave  
  11dcab:	c3                   	ret    

0011dcac <package_write_cb>:
{
  11dcac:	55                   	push   %ebp
  11dcad:	89 e5                	mov    %esp,%ebp
  11dcaf:	57                   	push   %edi
  11dcb0:	56                   	push   %esi
  11dcb1:	53                   	push   %ebx
  11dcb2:	83 ec 08             	sub    $0x8,%esp
  11dcb5:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
	return update_state;
  11dcb8:	8a 15 81 ed 12 00    	mov    0x12ed81,%dl
{
  11dcbe:	8b 7d 08             	mov    0x8(%ebp),%edi
  11dcc1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  11dcc4:	8b 75 10             	mov    0x10(%ebp),%esi
  11dcc7:	8b 45 18             	mov    0x18(%ebp),%eax
  11dcca:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	if (state == STATE_IDLE) {
  11dccd:	84 d2                	test   %dl,%dl
  11dccf:	75 10                	jne    11dce1 <package_write_cb+0x35>
		lwm2m_firmware_set_update_state(STATE_DOWNLOADING);
  11dcd1:	6a 01                	push   $0x1
  11dcd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  11dcd6:	e8 f4 fd ff ff       	call   11dacf <lwm2m_firmware_set_update_state>
  11dcdb:	58                   	pop    %eax
  11dcdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11dcdf:	eb 1c                	jmp    11dcfd <package_write_cb+0x51>
	} else if (state != STATE_DOWNLOADING) {
  11dce1:	80 fa 01             	cmp    $0x1,%dl
  11dce4:	74 17                	je     11dcfd <package_write_cb+0x51>
		if (data_len == 0U && state == STATE_DOWNLOADED) {
  11dce6:	66 85 c0             	test   %ax,%ax
  11dce9:	0f 85 84 00 00 00    	jne    11dd73 <package_write_cb+0xc7>
  11dcef:	80 fa 02             	cmp    $0x2,%dl
  11dcf2:	75 7f                	jne    11dd73 <package_write_cb+0xc7>
			lwm2m_firmware_set_update_result(RESULT_DEFAULT);
  11dcf4:	6a 00                	push   $0x0
  11dcf6:	e8 8b fe ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11dcfb:	eb 41                	jmp    11dd3e <package_write_cb+0x92>
	ret = write_cb ? write_cb(obj_inst_id, res_id, res_inst_id,
  11dcfd:	8b 15 20 ed 12 00    	mov    0x12ed20,%edx
  11dd03:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  11dd07:	0f b7 ff             	movzwl %di,%edi
  11dd0a:	0f b7 db             	movzwl %bx,%ebx
  11dd0d:	0f b7 f6             	movzwl %si,%esi
  11dd10:	0f b7 c0             	movzwl %ax,%eax
				  last_block, total_size) : 0;
  11dd13:	85 d2                	test   %edx,%edx
  11dd15:	75 0f                	jne    11dd26 <package_write_cb+0x7a>
		if (last_block) {
  11dd17:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
  11dd1b:	74 22                	je     11dd3f <package_write_cb+0x93>
			lwm2m_firmware_set_update_state(STATE_DOWNLOADED);
  11dd1d:	6a 02                	push   $0x2
  11dd1f:	e8 ab fd ff ff       	call   11dacf <lwm2m_firmware_set_update_state>
  11dd24:	eb 18                	jmp    11dd3e <package_write_cb+0x92>
	ret = write_cb ? write_cb(obj_inst_id, res_id, res_inst_id,
  11dd26:	ff 75 20             	pushl  0x20(%ebp)
  11dd29:	51                   	push   %ecx
  11dd2a:	50                   	push   %eax
  11dd2b:	ff 75 14             	pushl  0x14(%ebp)
  11dd2e:	56                   	push   %esi
  11dd2f:	53                   	push   %ebx
  11dd30:	57                   	push   %edi
  11dd31:	ff d2                	call   *%edx
  11dd33:	83 c4 1c             	add    $0x1c,%esp
  11dd36:	89 c3                	mov    %eax,%ebx
	if (ret >= 0) {
  11dd38:	85 c0                	test   %eax,%eax
  11dd3a:	78 07                	js     11dd43 <package_write_cb+0x97>
  11dd3c:	eb d9                	jmp    11dd17 <package_write_cb+0x6b>
			lwm2m_firmware_set_update_state(STATE_DOWNLOADED);
  11dd3e:	59                   	pop    %ecx
		return 0;
  11dd3f:	31 db                	xor    %ebx,%ebx
  11dd41:	eb 33                	jmp    11dd76 <package_write_cb+0xca>
	} else if (ret == -ENOMEM) {
  11dd43:	83 f8 f4             	cmp    $0xfffffff4,%eax
  11dd46:	75 04                	jne    11dd4c <package_write_cb+0xa0>
		lwm2m_firmware_set_update_result(RESULT_OUT_OF_MEM);
  11dd48:	6a 03                	push   $0x3
  11dd4a:	eb 1f                	jmp    11dd6b <package_write_cb+0xbf>
	} else if (ret == -ENOSPC) {
  11dd4c:	83 f8 e4             	cmp    $0xffffffe4,%eax
  11dd4f:	75 0f                	jne    11dd60 <package_write_cb+0xb4>
		lwm2m_firmware_set_update_result(RESULT_NO_STORAGE);
  11dd51:	6a 02                	push   $0x2
		ret = -EFBIG;
  11dd53:	bb e5 ff ff ff       	mov    $0xffffffe5,%ebx
		lwm2m_firmware_set_update_result(RESULT_NO_STORAGE);
  11dd58:	e8 29 fe ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11dd5d:	5a                   	pop    %edx
		ret = -EFBIG;
  11dd5e:	eb 16                	jmp    11dd76 <package_write_cb+0xca>
	} else if (ret == -EFAULT) {
  11dd60:	83 f8 f2             	cmp    $0xfffffff2,%eax
  11dd63:	75 04                	jne    11dd69 <package_write_cb+0xbd>
		lwm2m_firmware_set_update_result(RESULT_INTEGRITY_FAILED);
  11dd65:	6a 05                	push   $0x5
  11dd67:	eb 02                	jmp    11dd6b <package_write_cb+0xbf>
		lwm2m_firmware_set_update_result(RESULT_UPDATE_FAILED);
  11dd69:	6a 08                	push   $0x8
  11dd6b:	e8 16 fe ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11dd70:	58                   	pop    %eax
  11dd71:	eb 03                	jmp    11dd76 <package_write_cb+0xca>
		return -EPERM;
  11dd73:	83 cb ff             	or     $0xffffffff,%ebx
}
  11dd76:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11dd79:	89 d8                	mov    %ebx,%eax
  11dd7b:	5b                   	pop    %ebx
  11dd7c:	5e                   	pop    %esi
  11dd7d:	5f                   	pop    %edi
  11dd7e:	5d                   	pop    %ebp
  11dd7f:	c3                   	ret    

0011dd80 <firmware_update_cb>:
{
  11dd80:	55                   	push   %ebp
  11dd81:	89 e5                	mov    %esp,%ebp
  11dd83:	53                   	push   %ebx
	return update_state;
  11dd84:	0f b6 15 81 ed 12 00 	movzbl 0x12ed81,%edx
{
  11dd8b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (state != STATE_DOWNLOADED) {
  11dd8e:	80 fa 02             	cmp    $0x2,%dl
  11dd91:	74 34                	je     11ddc7 <firmware_update_cb+0x47>
		return -EPERM;
  11dd93:	83 cb ff             	or     $0xffffffff,%ebx
		LOG_ERR("State other than downloaded: %d", state);
  11dd96:	f6 05 dc 5b 14 00 07 	testb  $0x7,0x145bdc
  11dd9d:	0f 84 83 00 00 00    	je     11de26 <firmware_update_cb+0xa6>
  11dda3:	b8 38 31 12 00       	mov    $0x123138,%eax
  11dda8:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11ddad:	c1 e8 03             	shr    $0x3,%eax
  11ddb0:	c1 e0 06             	shl    $0x6,%eax
  11ddb3:	83 c8 01             	or     $0x1,%eax
  11ddb6:	50                   	push   %eax
  11ddb7:	52                   	push   %edx
  11ddb8:	68 0a 85 12 00       	push   $0x12850a
  11ddbd:	e8 b4 57 fe ff       	call   103576 <log_1>
  11ddc2:	83 c4 0c             	add    $0xc,%esp
  11ddc5:	eb 5f                	jmp    11de26 <firmware_update_cb+0xa6>
	lwm2m_firmware_set_update_state(STATE_UPDATING);
  11ddc7:	6a 03                	push   $0x3
  11ddc9:	e8 01 fd ff ff       	call   11dacf <lwm2m_firmware_set_update_state>
	return update_cb;
  11ddce:	a1 1c ed 12 00       	mov    0x12ed1c,%eax
	lwm2m_firmware_set_update_state(STATE_UPDATING);
  11ddd3:	59                   	pop    %ecx
	if (callback) {
  11ddd4:	85 c0                	test   %eax,%eax
  11ddd6:	74 4c                	je     11de24 <firmware_update_cb+0xa4>
		ret = callback(obj_inst_id);
  11ddd8:	0f b7 db             	movzwl %bx,%ebx
  11dddb:	53                   	push   %ebx
  11dddc:	ff d0                	call   *%eax
  11ddde:	5a                   	pop    %edx
  11dddf:	89 c3                	mov    %eax,%ebx
		if (ret < 0) {
  11dde1:	85 c0                	test   %eax,%eax
  11dde3:	79 3f                	jns    11de24 <firmware_update_cb+0xa4>
			LOG_ERR("Failed to update firmware: %d", ret);
  11dde5:	f6 05 dc 5b 14 00 07 	testb  $0x7,0x145bdc
  11ddec:	74 23                	je     11de11 <firmware_update_cb+0x91>
  11ddee:	ba 38 31 12 00       	mov    $0x123138,%edx
  11ddf3:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11ddf9:	c1 ea 03             	shr    $0x3,%edx
  11ddfc:	c1 e2 06             	shl    $0x6,%edx
  11ddff:	83 ca 01             	or     $0x1,%edx
  11de02:	52                   	push   %edx
  11de03:	50                   	push   %eax
  11de04:	68 2a 85 12 00       	push   $0x12852a
  11de09:	e8 68 57 fe ff       	call   103576 <log_1>
  11de0e:	83 c4 0c             	add    $0xc,%esp
			lwm2m_firmware_set_update_result(
  11de11:	31 c0                	xor    %eax,%eax
  11de13:	83 fb ea             	cmp    $0xffffffea,%ebx
  11de16:	0f 95 c0             	setne  %al
  11de19:	8d 44 40 05          	lea    0x5(%eax,%eax,2),%eax
  11de1d:	50                   	push   %eax
  11de1e:	e8 63 fd ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11de23:	58                   	pop    %eax
			return 0;
  11de24:	31 db                	xor    %ebx,%ebx
}
  11de26:	89 d8                	mov    %ebx,%eax
  11de28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11de2b:	c9                   	leave  
  11de2c:	c3                   	ret    

0011de2d <lwm2m_firmware_get_write_cb>:
}
  11de2d:	a1 20 ed 12 00       	mov    0x12ed20,%eax
  11de32:	c3                   	ret    

0011de33 <set_update_result_from_error>:
#endif

static void do_transmit_timeout_cb(struct lwm2m_message *msg);

static void set_update_result_from_error(int error_code)
{
  11de33:	55                   	push   %ebp
	if (error_code == -ENOMEM) {
  11de34:	83 f8 f4             	cmp    $0xfffffff4,%eax
{
  11de37:	89 e5                	mov    %esp,%ebp
	if (error_code == -ENOMEM) {
  11de39:	75 04                	jne    11de3f <set_update_result_from_error+0xc>
		lwm2m_firmware_set_update_result(RESULT_OUT_OF_MEM);
  11de3b:	6a 03                	push   $0x3
  11de3d:	eb 2f                	jmp    11de6e <set_update_result_from_error+0x3b>
	} else if (error_code == -ENOSPC) {
  11de3f:	83 f8 e4             	cmp    $0xffffffe4,%eax
  11de42:	75 04                	jne    11de48 <set_update_result_from_error+0x15>
		lwm2m_firmware_set_update_result(RESULT_NO_STORAGE);
  11de44:	6a 02                	push   $0x2
  11de46:	eb 26                	jmp    11de6e <set_update_result_from_error+0x3b>
	} else if (error_code == -EFAULT) {
  11de48:	83 f8 f2             	cmp    $0xfffffff2,%eax
  11de4b:	75 04                	jne    11de51 <set_update_result_from_error+0x1e>
		lwm2m_firmware_set_update_result(RESULT_INTEGRITY_FAILED);
  11de4d:	6a 05                	push   $0x5
  11de4f:	eb 1d                	jmp    11de6e <set_update_result_from_error+0x3b>
	} else if (error_code == -ENOMSG) {
  11de51:	83 f8 b0             	cmp    $0xffffffb0,%eax
  11de54:	75 04                	jne    11de5a <set_update_result_from_error+0x27>
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
  11de56:	6a 04                	push   $0x4
  11de58:	eb 14                	jmp    11de6e <set_update_result_from_error+0x3b>
	} else if (error_code == -ENOTSUP) {
  11de5a:	83 f8 dd             	cmp    $0xffffffdd,%eax
  11de5d:	75 04                	jne    11de63 <set_update_result_from_error+0x30>
		lwm2m_firmware_set_update_result(RESULT_INVALID_URI);
  11de5f:	6a 07                	push   $0x7
  11de61:	eb 0b                	jmp    11de6e <set_update_result_from_error+0x3b>
	} else if (error_code == -EPROTONOSUPPORT) {
  11de63:	83 f8 d5             	cmp    $0xffffffd5,%eax
  11de66:	75 04                	jne    11de6c <set_update_result_from_error+0x39>
		lwm2m_firmware_set_update_result(RESULT_UNSUP_PROTO);
  11de68:	6a 09                	push   $0x9
  11de6a:	eb 02                	jmp    11de6e <set_update_result_from_error+0x3b>
	} else {
		lwm2m_firmware_set_update_result(RESULT_UPDATE_FAILED);
  11de6c:	6a 08                	push   $0x8
  11de6e:	e8 13 fd ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11de73:	58                   	pop    %eax
	}
}
  11de74:	c9                   	leave  
  11de75:	c3                   	ret    

0011de76 <transfer_request.constprop.0>:

static int transfer_request(struct coap_block_context *ctx,
  11de76:	55                   	push   %ebp
  11de77:	89 e5                	mov    %esp,%ebp
  11de79:	57                   	push   %edi
  11de7a:	56                   	push   %esi
  11de7b:	89 c7                	mov    %eax,%edi
  11de7d:	53                   	push   %ebx
  11de7e:	89 d3                	mov    %edx,%ebx
  11de80:	83 ec 2c             	sub    $0x2c,%esp
	struct http_parser_url parser;
	uint16_t off, len;
	char *next_slash;
#endif

	msg = lwm2m_get_message(&firmware_ctx);
  11de83:	68 20 59 14 00       	push   $0x145920
  11de88:	e8 0b 7e ff ff       	call   115c98 <lwm2m_get_message>
  11de8d:	59                   	pop    %ecx
	if (!msg) {
  11de8e:	85 c0                	test   %eax,%eax
  11de90:	75 35                	jne    11dec7 <transfer_request.constprop.0+0x51>
		LOG_ERR("Unable to get a lwm2m message!");
  11de92:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
		return -ENOMEM;
  11de99:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
		LOG_ERR("Unable to get a lwm2m message!");
  11de9e:	0f 84 6a 02 00 00    	je     11e10e <transfer_request.constprop.0+0x298>
  11dea4:	b8 40 31 12 00       	mov    $0x123140,%eax
  11dea9:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11deae:	c1 e8 03             	shr    $0x3,%eax
  11deb1:	c1 e0 06             	shl    $0x6,%eax
  11deb4:	83 c8 01             	or     $0x1,%eax
  11deb7:	50                   	push   %eax
  11deb8:	68 a1 7b 12 00       	push   $0x127ba1
  11debd:	e8 8b 56 fe ff       	call   10354d <log_0>
  11dec2:	e9 41 02 00 00       	jmp    11e108 <transfer_request.constprop.0+0x292>
	}

	msg->type = COAP_TYPE_CON;
  11dec7:	66 c7 80 86 02 00 00 	movw   $0x100,0x286(%eax)
  11dece:	00 01 
  11ded0:	89 c6                	mov    %eax,%esi
	msg->code = COAP_METHOD_GET;
	msg->mid = coap_next_id();
  11ded2:	e8 83 b2 fe ff       	call   10915a <coap_next_id>
	msg->token = token;
	msg->tkl = tkl;
  11ded7:	88 9e 88 02 00 00    	mov    %bl,0x288(%esi)
	msg->mid = coap_next_id();
  11dedd:	66 89 86 84 02 00 00 	mov    %ax,0x284(%esi)
	msg->token = token;
  11dee4:	89 be 78 02 00 00    	mov    %edi,0x278(%esi)
	msg->reply_cb = reply_cb;
  11deea:	c7 86 7c 02 00 00 bf 	movl   $0x11e1bf,0x27c(%esi)
  11def1:	e1 11 00 
	msg->message_timeout_cb = do_transmit_timeout_cb;
  11def4:	c7 86 80 02 00 00 18 	movl   $0x11e118,0x280(%esi)
  11defb:	e1 11 00 

	ret = lwm2m_init_message(msg);
  11defe:	56                   	push   %esi
  11deff:	e8 ec 7f ff ff       	call   115ef0 <lwm2m_init_message>
  11df04:	5a                   	pop    %edx
  11df05:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  11df07:	85 c0                	test   %eax,%eax
  11df09:	79 2b                	jns    11df36 <transfer_request.constprop.0+0xc0>
		LOG_ERR("Error setting up lwm2m message");
  11df0b:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11df12:	0f 84 e8 01 00 00    	je     11e100 <transfer_request.constprop.0+0x28a>
  11df18:	b8 40 31 12 00       	mov    $0x123140,%eax
  11df1d:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11df22:	c1 e8 03             	shr    $0x3,%eax
  11df25:	c1 e0 06             	shl    $0x6,%eax
  11df28:	83 c8 01             	or     $0x1,%eax
  11df2b:	50                   	push   %eax
  11df2c:	68 5f 85 12 00       	push   $0x12855f
  11df31:	e9 fa 00 00 00       	jmp    11e030 <transfer_request.constprop.0+0x1ba>
	if (ret < 0) {
		LOG_ERR("Error adding URI_PATH '%s'", log_strdup(cursor));
		goto cleanup;
	}
#else
	http_parser_url_init(&parser);
  11df36:	8d 5d d4             	lea    -0x2c(%ebp),%ebx
  11df39:	53                   	push   %ebx
  11df3a:	e8 52 1c 00 00       	call   11fb91 <http_parser_url_init>
	ret = http_parser_parse_url(firmware_uri, strlen(firmware_uri), 0,
  11df3f:	c7 04 24 20 e7 12 00 	movl   $0x12e720,(%esp)
  11df46:	e8 d1 dd fe ff       	call   10bd1c <strlen>
  11df4b:	89 1c 24             	mov    %ebx,(%esp)
  11df4e:	6a 00                	push   $0x0
  11df50:	50                   	push   %eax
  11df51:	68 20 e7 12 00       	push   $0x12e720
  11df56:	e8 4a 1c 00 00       	call   11fba5 <http_parser_parse_url>
  11df5b:	83 c4 10             	add    $0x10,%esp
				    &parser);
	if (ret < 0) {
  11df5e:	85 c0                	test   %eax,%eax
  11df60:	79 3f                	jns    11dfa1 <transfer_request.constprop.0+0x12b>
		LOG_ERR("Invalid firmware url: %s", log_strdup(firmware_uri));
  11df62:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
		ret = -ENOTSUP;
  11df69:	bb dd ff ff ff       	mov    $0xffffffdd,%ebx
		LOG_ERR("Invalid firmware url: %s", log_strdup(firmware_uri));
  11df6e:	0f 84 8c 01 00 00    	je     11e100 <transfer_request.constprop.0+0x28a>
  11df74:	68 20 e7 12 00       	push   $0x12e720
  11df79:	e8 d9 52 fe ff       	call   103257 <log_strdup>
  11df7e:	bf 40 31 12 00       	mov    $0x123140,%edi
  11df83:	81 ef b0 30 12 00    	sub    $0x1230b0,%edi
  11df89:	c1 ef 03             	shr    $0x3,%edi
  11df8c:	c1 e7 06             	shl    $0x6,%edi
  11df8f:	83 cf 01             	or     $0x1,%edi
  11df92:	66 89 3c 24          	mov    %di,(%esp)
  11df96:	50                   	push   %eax
  11df97:	68 7e 85 12 00       	push   $0x12857e
  11df9c:	e9 57 01 00 00       	jmp    11e0f8 <transfer_request.constprop.0+0x282>
	}

	/* if path is not available, off/len will be zero */
	off = parser.field_data[UF_PATH].off;
	len = parser.field_data[UF_PATH].len;
	cursor = firmware_uri + off;
  11dfa1:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
	len = parser.field_data[UF_PATH].len;
  11dfa5:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
	cursor = firmware_uri + off;
  11dfa9:	81 c3 20 e7 12 00    	add    $0x12e720,%ebx
	len = parser.field_data[UF_PATH].len;
  11dfaf:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)

	/* add path portions (separated by slashes) */
	while (len > 0 && (next_slash = strchr(cursor, '/')) != NULL) {
  11dfb3:	eb 0f                	jmp    11dfc4 <transfer_request.constprop.0+0x14e>
				goto cleanup;
			}
		}

		/* skip slash */
		len -= (next_slash - cursor) + 1;
  11dfb5:	66 8b 45 d2          	mov    -0x2e(%ebp),%ax
		cursor = next_slash + 1;
  11dfb9:	8d 5a 01             	lea    0x1(%edx),%ebx
		len -= (next_slash - cursor) + 1;
  11dfbc:	48                   	dec    %eax
  11dfbd:	2b 45 cc             	sub    -0x34(%ebp),%eax
  11dfc0:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
	while (len > 0 && (next_slash = strchr(cursor, '/')) != NULL) {
  11dfc4:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%ebp)
  11dfc9:	8d 7e 30             	lea    0x30(%esi),%edi
  11dfcc:	0f 84 81 00 00 00    	je     11e053 <transfer_request.constprop.0+0x1dd>
  11dfd2:	6a 2f                	push   $0x2f
  11dfd4:	53                   	push   %ebx
  11dfd5:	e8 08 dd fe ff       	call   10bce2 <strchr>
  11dfda:	59                   	pop    %ecx
  11dfdb:	85 c0                	test   %eax,%eax
  11dfdd:	5a                   	pop    %edx
  11dfde:	89 c2                	mov    %eax,%edx
  11dfe0:	74 5a                	je     11e03c <transfer_request.constprop.0+0x1c6>
		if (next_slash != cursor) {
  11dfe2:	89 d0                	mov    %edx,%eax
  11dfe4:	29 d8                	sub    %ebx,%eax
  11dfe6:	39 d3                	cmp    %edx,%ebx
  11dfe8:	89 45 cc             	mov    %eax,-0x34(%ebp)
  11dfeb:	74 c8                	je     11dfb5 <transfer_request.constprop.0+0x13f>
			ret = coap_packet_append_option(&msg->cpkt,
  11dfed:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
  11dff1:	50                   	push   %eax
  11dff2:	89 55 c8             	mov    %edx,-0x38(%ebp)
  11dff5:	53                   	push   %ebx
  11dff6:	6a 0b                	push   $0xb
  11dff8:	57                   	push   %edi
  11dff9:	e8 14 a7 fe ff       	call   108712 <coap_packet_append_option>
  11dffe:	83 c4 10             	add    $0x10,%esp
  11e001:	89 c3                	mov    %eax,%ebx
			if (ret < 0) {
  11e003:	85 c0                	test   %eax,%eax
  11e005:	8b 55 c8             	mov    -0x38(%ebp),%edx
  11e008:	79 ab                	jns    11dfb5 <transfer_request.constprop.0+0x13f>
				LOG_ERR("Error adding URI_PATH");
  11e00a:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e011:	0f 84 e9 00 00 00    	je     11e100 <transfer_request.constprop.0+0x28a>
  11e017:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e01c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e021:	c1 e8 03             	shr    $0x3,%eax
  11e024:	c1 e0 06             	shl    $0x6,%eax
  11e027:	83 c8 01             	or     $0x1,%eax
  11e02a:	50                   	push   %eax
  11e02b:	68 97 85 12 00       	push   $0x128597
  11e030:	e8 18 55 fe ff       	call   10354d <log_0>
  11e035:	59                   	pop    %ecx
  11e036:	5f                   	pop    %edi
  11e037:	e9 c4 00 00 00       	jmp    11e100 <transfer_request.constprop.0+0x28a>
	}

	if (len > 0) {
		/* flush the rest */
		ret = coap_packet_append_option(&msg->cpkt,
  11e03c:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  11e040:	50                   	push   %eax
  11e041:	53                   	push   %ebx
  11e042:	6a 0b                	push   $0xb
  11e044:	57                   	push   %edi
  11e045:	e8 c8 a6 fe ff       	call   108712 <coap_packet_append_option>
  11e04a:	83 c4 10             	add    $0x10,%esp
  11e04d:	89 c3                	mov    %eax,%ebx
						COAP_OPTION_URI_PATH,
						cursor, len);
		if (ret < 0) {
  11e04f:	85 c0                	test   %eax,%eax
  11e051:	78 b7                	js     11e00a <transfer_request.constprop.0+0x194>
			goto cleanup;
		}
	}
#endif

	ret = coap_append_block2_option(&msg->cpkt, ctx);
  11e053:	68 34 ed 12 00       	push   $0x12ed34
  11e058:	57                   	push   %edi
  11e059:	e8 5e ac fe ff       	call   108cbc <coap_append_block2_option>
  11e05e:	5b                   	pop    %ebx
	if (ret < 0) {
  11e05f:	85 c0                	test   %eax,%eax
	ret = coap_append_block2_option(&msg->cpkt, ctx);
  11e061:	5a                   	pop    %edx
  11e062:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  11e064:	79 28                	jns    11e08e <transfer_request.constprop.0+0x218>
		LOG_ERR("Unable to add block2 option.");
  11e066:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e06d:	0f 84 8d 00 00 00    	je     11e100 <transfer_request.constprop.0+0x28a>
  11e073:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e078:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e07d:	c1 e8 03             	shr    $0x3,%eax
  11e080:	c1 e0 06             	shl    $0x6,%eax
  11e083:	83 c8 01             	or     $0x1,%eax
  11e086:	50                   	push   %eax
  11e087:	68 ad 85 12 00       	push   $0x1285ad
  11e08c:	eb a2                	jmp    11e030 <transfer_request.constprop.0+0x1ba>
			log_strdup(firmware_uri));
		goto cleanup;
	}
#else
	/* Ask the server to provide a size estimate */
	ret = coap_append_option_int(&msg->cpkt, COAP_OPTION_SIZE2, 0);
  11e08e:	6a 00                	push   $0x0
  11e090:	6a 1c                	push   $0x1c
  11e092:	57                   	push   %edi
  11e093:	e8 1a a8 fe ff       	call   1088b2 <coap_append_option_int>
  11e098:	83 c4 0c             	add    $0xc,%esp
  11e09b:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  11e09d:	85 c0                	test   %eax,%eax
  11e09f:	79 27                	jns    11e0c8 <transfer_request.constprop.0+0x252>
		LOG_ERR("Unable to add size2 option.");
  11e0a1:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e0a8:	74 56                	je     11e100 <transfer_request.constprop.0+0x28a>
  11e0aa:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e0af:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e0b4:	c1 e8 03             	shr    $0x3,%eax
  11e0b7:	c1 e0 06             	shl    $0x6,%eax
  11e0ba:	83 c8 01             	or     $0x1,%eax
  11e0bd:	50                   	push   %eax
  11e0be:	68 ca 85 12 00       	push   $0x1285ca
  11e0c3:	e9 68 ff ff ff       	jmp    11e030 <transfer_request.constprop.0+0x1ba>
		goto cleanup;
	}
#endif

	/* send request */
	ret = lwm2m_send_message(msg);
  11e0c8:	56                   	push   %esi
  11e0c9:	e8 6a 9b ff ff       	call   117c38 <lwm2m_send_message>
  11e0ce:	59                   	pop    %ecx
  11e0cf:	89 c3                	mov    %eax,%ebx
	if (ret < 0) {
  11e0d1:	85 c0                	test   %eax,%eax
  11e0d3:	79 37                	jns    11e10c <transfer_request.constprop.0+0x296>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
  11e0d5:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e0dc:	74 22                	je     11e100 <transfer_request.constprop.0+0x28a>
  11e0de:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e0e3:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e0e8:	c1 e8 03             	shr    $0x3,%eax
  11e0eb:	c1 e0 06             	shl    $0x6,%eax
  11e0ee:	83 c8 01             	or     $0x1,%eax
  11e0f1:	50                   	push   %eax
  11e0f2:	53                   	push   %ebx
  11e0f3:	68 2f 7c 12 00       	push   $0x127c2f
  11e0f8:	e8 79 54 fe ff       	call   103576 <log_1>
  11e0fd:	83 c4 0c             	add    $0xc,%esp
	}

	return 0;

cleanup:
	lwm2m_reset_message(msg, true);
  11e100:	6a 01                	push   $0x1
  11e102:	56                   	push   %esi
  11e103:	e8 be 7b ff ff       	call   115cc6 <lwm2m_reset_message>
  11e108:	58                   	pop    %eax
  11e109:	5a                   	pop    %edx
	return ret;
  11e10a:	eb 02                	jmp    11e10e <transfer_request.constprop.0+0x298>
	return 0;
  11e10c:	31 db                	xor    %ebx,%ebx
}
  11e10e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11e111:	89 d8                	mov    %ebx,%eax
  11e113:	5b                   	pop    %ebx
  11e114:	5e                   	pop    %esi
  11e115:	5f                   	pop    %edi
  11e116:	5d                   	pop    %ebp
  11e117:	c3                   	ret    

0011e118 <do_transmit_timeout_cb>:
	lwm2m_engine_context_close(&firmware_ctx);
	return ret;
}

static void do_transmit_timeout_cb(struct lwm2m_message *msg)
{
  11e118:	55                   	push   %ebp
  11e119:	a1 e0 5b 14 00       	mov    0x145be0,%eax
  11e11e:	89 e5                	mov    %esp,%ebp
  11e120:	53                   	push   %ebx
	int ret;

	if (firmware_retry < PACKET_TRANSFER_RETRY_MAX) {
  11e121:	83 3d 40 ed 12 00 02 	cmpl   $0x2,0x12ed40
{
  11e128:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (firmware_retry < PACKET_TRANSFER_RETRY_MAX) {
  11e12b:	7f 56                	jg     11e183 <do_transmit_timeout_cb+0x6b>
		/* retry block */
		LOG_WRN("TIMEOUT - Sending a retry packet!");
  11e12d:	a8 06                	test   $0x6,%al
  11e12f:	74 20                	je     11e151 <do_transmit_timeout_cb+0x39>
  11e131:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e136:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e13b:	c1 e8 03             	shr    $0x3,%eax
  11e13e:	c1 e0 06             	shl    $0x6,%eax
  11e141:	83 c8 02             	or     $0x2,%eax
  11e144:	50                   	push   %eax
  11e145:	68 e6 85 12 00       	push   $0x1285e6
  11e14a:	e8 fe 53 fe ff       	call   10354d <log_0>
  11e14f:	58                   	pop    %eax
  11e150:	5a                   	pop    %edx

		ret = transfer_request(&firmware_block_ctx,
  11e151:	0f b6 93 88 02 00 00 	movzbl 0x288(%ebx),%edx
  11e158:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
  11e15e:	e8 13 fd ff ff       	call   11de76 <transfer_request.constprop.0>
				       msg->token, msg->tkl,
				       do_firmware_transfer_reply_cb);
		if (ret < 0) {
  11e163:	85 c0                	test   %eax,%eax
  11e165:	79 11                	jns    11e178 <do_transmit_timeout_cb+0x60>
			/* abort retries / transfer */
			set_update_result_from_error(ret);
  11e167:	e8 c7 fc ff ff       	call   11de33 <set_update_result_from_error>
			firmware_retry = PACKET_TRANSFER_RETRY_MAX;
  11e16c:	c7 05 40 ed 12 00 03 	movl   $0x3,0x12ed40
  11e173:	00 00 00 
			lwm2m_engine_context_close(&firmware_ctx);
  11e176:	eb 37                	jmp    11e1af <do_transmit_timeout_cb+0x97>
			return;
		}

		firmware_retry++;
  11e178:	ff 05 40 ed 12 00    	incl   0x12ed40
		LOG_ERR("TIMEOUT - Too many retry packet attempts! "
			"Aborting firmware download.");
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
		lwm2m_engine_context_close(&firmware_ctx);
	}
}
  11e17e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11e181:	c9                   	leave  
  11e182:	c3                   	ret    
		LOG_ERR("TIMEOUT - Too many retry packet attempts! "
  11e183:	a8 07                	test   $0x7,%al
  11e185:	74 20                	je     11e1a7 <do_transmit_timeout_cb+0x8f>
  11e187:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e18c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e191:	c1 e8 03             	shr    $0x3,%eax
  11e194:	c1 e0 06             	shl    $0x6,%eax
  11e197:	83 c8 01             	or     $0x1,%eax
  11e19a:	50                   	push   %eax
  11e19b:	68 08 86 12 00       	push   $0x128608
  11e1a0:	e8 a8 53 fe ff       	call   10354d <log_0>
  11e1a5:	5a                   	pop    %edx
  11e1a6:	59                   	pop    %ecx
		lwm2m_firmware_set_update_result(RESULT_CONNECTION_LOST);
  11e1a7:	6a 04                	push   $0x4
  11e1a9:	e8 d8 f9 ff ff       	call   11db86 <lwm2m_firmware_set_update_result>
  11e1ae:	58                   	pop    %eax
}
  11e1af:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		lwm2m_engine_context_close(&firmware_ctx);
  11e1b2:	c7 45 08 20 59 14 00 	movl   $0x145920,0x8(%ebp)
}
  11e1b9:	c9                   	leave  
		lwm2m_engine_context_close(&firmware_ctx);
  11e1ba:	e9 95 b0 ff ff       	jmp    119254 <lwm2m_engine_context_close>

0011e1bf <do_firmware_transfer_reply_cb>:
{
  11e1bf:	55                   	push   %ebp
  11e1c0:	89 e5                	mov    %esp,%ebp
  11e1c2:	57                   	push   %edi
  11e1c3:	56                   	push   %esi
  11e1c4:	53                   	push   %ebx
	tkl = coap_header_get_token(check_response, token);
  11e1c5:	8d 45 e0             	lea    -0x20(%ebp),%eax
{
  11e1c8:	83 ec 34             	sub    $0x34,%esp
	struct lwm2m_engine_res *res = NULL;
  11e1cb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
{
  11e1d2:	8b 75 08             	mov    0x8(%ebp),%esi
	tkl = coap_header_get_token(check_response, token);
  11e1d5:	50                   	push   %eax
  11e1d6:	56                   	push   %esi
  11e1d7:	e8 64 a9 fe ff       	call   108b40 <coap_header_get_token>
  11e1dc:	5a                   	pop    %edx
  11e1dd:	88 45 cb             	mov    %al,-0x35(%ebp)
  11e1e0:	59                   	pop    %ecx
	if (!tkl && coap_header_get_type(response) == COAP_TYPE_ACK) {
  11e1e1:	84 c0                	test   %al,%al
  11e1e3:	74 10                	je     11e1f5 <do_firmware_transfer_reply_cb+0x36>
	} else if (coap_header_get_type(response) == COAP_TYPE_CON) {
  11e1e5:	56                   	push   %esi
  11e1e6:	e8 38 a9 fe ff       	call   108b23 <coap_header_get_type>
  11e1eb:	5f                   	pop    %edi
  11e1ec:	84 c0                	test   %al,%al
  11e1ee:	74 15                	je     11e205 <do_firmware_transfer_reply_cb+0x46>
  11e1f0:	e9 f4 00 00 00       	jmp    11e2e9 <do_firmware_transfer_reply_cb+0x12a>
	if (!tkl && coap_header_get_type(response) == COAP_TYPE_ACK) {
  11e1f5:	56                   	push   %esi
  11e1f6:	e8 28 a9 fe ff       	call   108b23 <coap_header_get_type>
  11e1fb:	5b                   	pop    %ebx
  11e1fc:	3c 02                	cmp    $0x2,%al
  11e1fe:	75 e5                	jne    11e1e5 <do_firmware_transfer_reply_cb+0x26>
  11e200:	e9 31 03 00 00       	jmp    11e536 <do_firmware_transfer_reply_cb+0x377>
		ret = transfer_empty_ack(coap_header_get_id(check_response));
  11e205:	56                   	push   %esi
  11e206:	e8 c9 a9 fe ff       	call   108bd4 <coap_header_get_id>
	msg = lwm2m_get_message(&firmware_ctx);
  11e20b:	c7 04 24 20 59 14 00 	movl   $0x145920,(%esp)
		ret = transfer_empty_ack(coap_header_get_id(check_response));
  11e212:	89 c7                	mov    %eax,%edi
	msg = lwm2m_get_message(&firmware_ctx);
  11e214:	e8 7f 7a ff ff       	call   115c98 <lwm2m_get_message>
  11e219:	59                   	pop    %ecx
  11e21a:	89 c3                	mov    %eax,%ebx
	if (!msg) {
  11e21c:	85 c0                	test   %eax,%eax
  11e21e:	75 34                	jne    11e254 <do_firmware_transfer_reply_cb+0x95>
		LOG_ERR("Unable to get a lwm2m message!");
  11e220:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
		return -ENOMEM;
  11e227:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
		LOG_ERR("Unable to get a lwm2m message!");
  11e22c:	0f 84 85 00 00 00    	je     11e2b7 <do_firmware_transfer_reply_cb+0xf8>
  11e232:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e237:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e23c:	c1 e8 03             	shr    $0x3,%eax
  11e23f:	c1 e0 06             	shl    $0x6,%eax
  11e242:	83 c8 01             	or     $0x1,%eax
  11e245:	50                   	push   %eax
  11e246:	68 a1 7b 12 00       	push   $0x127ba1
  11e24b:	e8 fd 52 fe ff       	call   10354d <log_0>
  11e250:	58                   	pop    %eax
  11e251:	5a                   	pop    %edx
		if (ret < 0) {
  11e252:	eb 63                	jmp    11e2b7 <do_firmware_transfer_reply_cb+0xf8>
	msg->mid = mid;
  11e254:	66 89 b8 84 02 00 00 	mov    %di,0x284(%eax)
	msg->type = COAP_TYPE_ACK;
  11e25b:	66 c7 80 86 02 00 00 	movw   $0x2,0x286(%eax)
  11e262:	02 00 
	ret = lwm2m_init_message(msg);
  11e264:	50                   	push   %eax
  11e265:	e8 86 7c ff ff       	call   115ef0 <lwm2m_init_message>
  11e26a:	5f                   	pop    %edi
	if (ret) {
  11e26b:	85 c0                	test   %eax,%eax
	ret = lwm2m_init_message(msg);
  11e26d:	89 c7                	mov    %eax,%edi
	if (ret) {
  11e26f:	75 38                	jne    11e2a9 <do_firmware_transfer_reply_cb+0xea>
	ret = lwm2m_send_message(msg);
  11e271:	53                   	push   %ebx
  11e272:	e8 c1 99 ff ff       	call   117c38 <lwm2m_send_message>
  11e277:	59                   	pop    %ecx
  11e278:	89 c7                	mov    %eax,%edi
	if (ret < 0) {
  11e27a:	85 c0                	test   %eax,%eax
  11e27c:	79 6b                	jns    11e2e9 <do_firmware_transfer_reply_cb+0x12a>
		LOG_ERR("Error sending LWM2M packet (err:%d).", ret);
  11e27e:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e285:	74 22                	je     11e2a9 <do_firmware_transfer_reply_cb+0xea>
  11e287:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e28c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e291:	c1 e8 03             	shr    $0x3,%eax
  11e294:	c1 e0 06             	shl    $0x6,%eax
  11e297:	83 c8 01             	or     $0x1,%eax
  11e29a:	50                   	push   %eax
  11e29b:	57                   	push   %edi
  11e29c:	68 2f 7c 12 00       	push   $0x127c2f
  11e2a1:	e8 d0 52 fe ff       	call   103576 <log_1>
  11e2a6:	83 c4 0c             	add    $0xc,%esp
	lwm2m_reset_message(msg, true);
  11e2a9:	6a 01                	push   $0x1
  11e2ab:	53                   	push   %ebx
  11e2ac:	e8 15 7a ff ff       	call   115cc6 <lwm2m_reset_message>
  11e2b1:	58                   	pop    %eax
		if (ret < 0) {
  11e2b2:	85 ff                	test   %edi,%edi
	lwm2m_reset_message(msg, true);
  11e2b4:	5a                   	pop    %edx
		if (ret < 0) {
  11e2b5:	79 32                	jns    11e2e9 <do_firmware_transfer_reply_cb+0x12a>
			LOG_ERR("Error transmitting ACK");
  11e2b7:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e2be:	0f 84 76 02 00 00    	je     11e53a <do_firmware_transfer_reply_cb+0x37b>
  11e2c4:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e2c9:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e2ce:	c1 e8 03             	shr    $0x3,%eax
  11e2d1:	c1 e0 06             	shl    $0x6,%eax
  11e2d4:	83 c8 01             	or     $0x1,%eax
  11e2d7:	50                   	push   %eax
  11e2d8:	68 4e 86 12 00       	push   $0x12864e
  11e2dd:	e8 6b 52 fe ff       	call   10354d <log_0>
  11e2e2:	59                   	pop    %ecx
  11e2e3:	5b                   	pop    %ebx
  11e2e4:	e9 51 02 00 00       	jmp    11e53a <do_firmware_transfer_reply_cb+0x37b>
	resp_code = coap_header_get_code(check_response);
  11e2e9:	56                   	push   %esi
  11e2ea:	e8 85 a8 fe ff       	call   108b74 <coap_header_get_code>
  11e2ef:	5a                   	pop    %edx
	if (resp_code != COAP_RESPONSE_CODE_CONTENT) {
  11e2f0:	3c 45                	cmp    $0x45,%al
  11e2f2:	74 46                	je     11e33a <do_firmware_transfer_reply_cb+0x17b>
		LOG_ERR("Unexpected response from server: %d.%d",
  11e2f4:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
		ret = -ENOMSG;
  11e2fb:	bf b0 ff ff ff       	mov    $0xffffffb0,%edi
		LOG_ERR("Unexpected response from server: %d.%d",
  11e300:	0f 84 34 02 00 00    	je     11e53a <do_firmware_transfer_reply_cb+0x37b>
  11e306:	b9 40 31 12 00       	mov    $0x123140,%ecx
  11e30b:	81 e9 b0 30 12 00    	sub    $0x1230b0,%ecx
  11e311:	c1 e9 03             	shr    $0x3,%ecx
  11e314:	c1 e1 06             	shl    $0x6,%ecx
  11e317:	83 c9 01             	or     $0x1,%ecx
  11e31a:	51                   	push   %ecx
  11e31b:	89 c1                	mov    %eax,%ecx
  11e31d:	c0 e8 05             	shr    $0x5,%al
  11e320:	83 e1 1f             	and    $0x1f,%ecx
  11e323:	51                   	push   %ecx
  11e324:	0f b6 c0             	movzbl %al,%eax
  11e327:	50                   	push   %eax
  11e328:	68 65 86 12 00       	push   $0x128665
  11e32d:	e8 7e 52 fe ff       	call   1035b0 <log_2>
  11e332:	83 c4 10             	add    $0x10,%esp
  11e335:	e9 00 02 00 00       	jmp    11e53a <do_firmware_transfer_reply_cb+0x37b>
	memcpy(&received_block_ctx, &firmware_block_ctx,
  11e33a:	6a 0c                	push   $0xc
  11e33c:	8d 5d e8             	lea    -0x18(%ebp),%ebx
  11e33f:	68 34 ed 12 00       	push   $0x12ed34
  11e344:	53                   	push   %ebx
  11e345:	e8 a2 da fe ff       	call   10bdec <memcpy>
  11e34a:	83 c4 0c             	add    $0xc,%esp
	ret = coap_update_from_block(check_response, &firmware_block_ctx);
  11e34d:	68 34 ed 12 00       	push   $0x12ed34
  11e352:	56                   	push   %esi
  11e353:	e8 07 aa fe ff       	call   108d5f <coap_update_from_block>
  11e358:	59                   	pop    %ecx
	if (ret < 0) {
  11e359:	85 c0                	test   %eax,%eax
	ret = coap_update_from_block(check_response, &firmware_block_ctx);
  11e35b:	5f                   	pop    %edi
	if (ret < 0) {
  11e35c:	79 36                	jns    11e394 <do_firmware_transfer_reply_cb+0x1d5>
		LOG_ERR("Error from block update: %d", ret);
  11e35e:	f6 05 e0 5b 14 00 07 	testb  $0x7,0x145be0
  11e365:	74 23                	je     11e38a <do_firmware_transfer_reply_cb+0x1cb>
  11e367:	ba 40 31 12 00       	mov    $0x123140,%edx
  11e36c:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11e372:	c1 ea 03             	shr    $0x3,%edx
  11e375:	c1 e2 06             	shl    $0x6,%edx
  11e378:	83 ca 01             	or     $0x1,%edx
  11e37b:	52                   	push   %edx
  11e37c:	50                   	push   %eax
  11e37d:	68 7e 79 12 00       	push   $0x12797e
  11e382:	e8 ef 51 fe ff       	call   103576 <log_1>
  11e387:	83 c4 0c             	add    $0xc,%esp
		ret = -EFAULT;
  11e38a:	bf f2 ff ff ff       	mov    $0xfffffff2,%edi
  11e38f:	e9 a6 01 00 00       	jmp    11e53a <do_firmware_transfer_reply_cb+0x37b>
	if (firmware_block_ctx.current < received_block_ctx.current) {
  11e394:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11e397:	39 05 38 ed 12 00    	cmp    %eax,0x12ed38
  11e39d:	73 48                	jae    11e3e7 <do_firmware_transfer_reply_cb+0x228>
		LOG_WRN("Duplicate packet ignored");
  11e39f:	f6 05 e0 5b 14 00 06 	testb  $0x6,0x145be0
  11e3a6:	74 20                	je     11e3c8 <do_firmware_transfer_reply_cb+0x209>
  11e3a8:	b8 40 31 12 00       	mov    $0x123140,%eax
  11e3ad:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11e3b2:	c1 e8 03             	shr    $0x3,%eax
  11e3b5:	c1 e0 06             	shl    $0x6,%eax
  11e3b8:	83 c8 02             	or     $0x2,%eax
  11e3bb:	50                   	push   %eax
  11e3bc:	68 8c 86 12 00       	push   $0x12868c
  11e3c1:	e8 87 51 fe ff       	call   10354d <log_0>
  11e3c6:	58                   	pop    %eax
  11e3c7:	5a                   	pop    %edx
		memcpy(&firmware_block_ctx, &received_block_ctx,
  11e3c8:	6a 0c                	push   $0xc
  11e3ca:	53                   	push   %ebx
  11e3cb:	68 34 ed 12 00       	push   $0x12ed34
  11e3d0:	e8 17 da fe ff       	call   10bdec <memcpy>
		reply->user_data = (void *)COAP_REPLY_STATUS_ERROR;
  11e3d5:	8b 45 0c             	mov    0xc(%ebp),%eax
		memcpy(&firmware_block_ctx, &received_block_ctx,
  11e3d8:	83 c4 0c             	add    $0xc,%esp
		reply->user_data = (void *)COAP_REPLY_STATUS_ERROR;
  11e3db:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		return 0;
  11e3e2:	e9 4f 01 00 00       	jmp    11e536 <do_firmware_transfer_reply_cb+0x377>
	last_block = !coap_next_block(check_response, &firmware_block_ctx);
  11e3e7:	68 34 ed 12 00       	push   $0x12ed34
  11e3ec:	56                   	push   %esi
  11e3ed:	e8 52 aa fe ff       	call   108e44 <coap_next_block>
  11e3f2:	5a                   	pop    %edx
  11e3f3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	payload_offset = response->hdr_len + response->opt_len;
  11e3f6:	66 8b 46 0a          	mov    0xa(%esi),%ax
	last_block = !coap_next_block(check_response, &firmware_block_ctx);
  11e3fa:	59                   	pop    %ecx
	payload_offset = response->hdr_len + response->opt_len;
  11e3fb:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
	coap_packet_get_payload(response, &payload_len);
  11e3ff:	8d 45 d6             	lea    -0x2a(%ebp),%eax
	payload_offset = response->hdr_len + response->opt_len;
  11e402:	0f b6 5e 08          	movzbl 0x8(%esi),%ebx
	coap_packet_get_payload(response, &payload_len);
  11e406:	50                   	push   %eax
  11e407:	56                   	push   %esi
  11e408:	e8 ea a7 fe ff       	call   108bf7 <coap_packet_get_payload>
  11e40d:	5f                   	pop    %edi
	if (payload_len > 0) {
  11e40e:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
	coap_packet_get_payload(response, &payload_len);
  11e413:	58                   	pop    %eax
	if (payload_len > 0) {
  11e414:	75 0f                	jne    11e425 <do_firmware_transfer_reply_cb+0x266>
	if (!last_block) {
  11e416:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  11e41a:	0f 85 ee 00 00 00    	jne    11e50e <do_firmware_transfer_reply_cb+0x34f>
  11e420:	e9 fd 00 00 00       	jmp    11e522 <do_firmware_transfer_reply_cb+0x363>
		ret = lwm2m_engine_get_resource("5/0/0", &res);
  11e425:	8d 45 d8             	lea    -0x28(%ebp),%eax
  11e428:	50                   	push   %eax
  11e429:	68 a5 86 12 00       	push   $0x1286a5
  11e42e:	e8 35 9f ff ff       	call   118368 <lwm2m_engine_get_resource>
  11e433:	59                   	pop    %ecx
		if (ret < 0) {
  11e434:	85 c0                	test   %eax,%eax
		ret = lwm2m_engine_get_resource("5/0/0", &res);
  11e436:	5f                   	pop    %edi
  11e437:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
  11e439:	0f 88 fb 00 00 00    	js     11e53a <do_firmware_transfer_reply_cb+0x37b>
		write_buf = res->res_instances->data_ptr;
  11e43f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  11e442:	8b 50 10             	mov    0x10(%eax),%edx
		if (res->pre_write_cb) {
  11e445:	8b 40 04             	mov    0x4(%eax),%eax
  11e448:	85 c0                	test   %eax,%eax
		write_buf = res->res_instances->data_ptr;
  11e44a:	8b 0a                	mov    (%edx),%ecx
		write_buflen = res->res_instances->max_data_len;
  11e44c:	0f b7 52 04          	movzwl 0x4(%edx),%edx
		write_buf = res->res_instances->data_ptr;
  11e450:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		write_buflen = res->res_instances->max_data_len;
  11e453:	89 55 dc             	mov    %edx,-0x24(%ebp)
		if (res->pre_write_cb) {
  11e456:	74 12                	je     11e46a <do_firmware_transfer_reply_cb+0x2ab>
			write_buf = res->pre_write_cb(0, 0, 0, &write_buflen);
  11e458:	8d 55 dc             	lea    -0x24(%ebp),%edx
  11e45b:	52                   	push   %edx
  11e45c:	6a 00                	push   $0x0
  11e45e:	6a 00                	push   $0x0
  11e460:	6a 00                	push   $0x0
  11e462:	ff d0                	call   *%eax
  11e464:	83 c4 10             	add    $0x10,%esp
  11e467:	89 45 d0             	mov    %eax,-0x30(%ebp)
		write_cb = lwm2m_firmware_get_write_cb();
  11e46a:	e8 be f9 ff ff       	call   11de2d <lwm2m_firmware_get_write_cb>
  11e46f:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (write_cb) {
  11e472:	85 c0                	test   %eax,%eax
  11e474:	74 a0                	je     11e416 <do_firmware_transfer_reply_cb+0x257>
	payload_offset = response->hdr_len + response->opt_len;
  11e476:	03 5d c8             	add    -0x38(%ebp),%ebx
  11e479:	66 89 5d c8          	mov    %bx,-0x38(%ebp)
			while (payload_len > 0) {
  11e47d:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
  11e481:	66 85 c0             	test   %ax,%ax
  11e484:	74 90                	je     11e416 <do_firmware_transfer_reply_cb+0x257>
				       write_buflen : payload_len;
  11e486:	0f b7 d0             	movzwl %ax,%edx
  11e489:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  11e48c:	39 d3                	cmp    %edx,%ebx
  11e48e:	76 02                	jbe    11e492 <do_firmware_transfer_reply_cb+0x2d3>
  11e490:	89 d3                	mov    %edx,%ebx
				payload_len -= len;
  11e492:	29 d8                	sub    %ebx,%eax
				len = (payload_len > write_buflen) ?
  11e494:	66 89 5d c2          	mov    %bx,-0x3e(%ebp)
				payload_len -= len;
  11e498:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
				if (buf_read(write_buf, len,
  11e49c:	8b 06                	mov    (%esi),%eax
  11e49e:	0f b7 7e 06          	movzwl 0x6(%esi),%edi
	if (!src) {
  11e4a2:	85 c0                	test   %eax,%eax
  11e4a4:	0f 84 e0 fe ff ff    	je     11e38a <do_firmware_transfer_reply_cb+0x1cb>
	if (*offset + len > src_len) {
  11e4aa:	0f b7 55 c8          	movzwl -0x38(%ebp),%edx
  11e4ae:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  11e4b1:	39 cf                	cmp    %ecx,%edi
  11e4b3:	0f 8c d1 fe ff ff    	jl     11e38a <do_firmware_transfer_reply_cb+0x1cb>
	if (dst) {
  11e4b9:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  11e4bd:	74 0f                	je     11e4ce <do_firmware_transfer_reply_cb+0x30f>
		memcpy(dst, src + *offset, len);
  11e4bf:	53                   	push   %ebx
  11e4c0:	01 d0                	add    %edx,%eax
  11e4c2:	50                   	push   %eax
  11e4c3:	ff 75 d0             	pushl  -0x30(%ebp)
  11e4c6:	e8 21 d9 fe ff       	call   10bdec <memcpy>
  11e4cb:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
  11e4ce:	66 8b 4d c2          	mov    -0x3e(%ebp),%cx
					       last_block &&
  11e4d2:	31 c0                	xor    %eax,%eax
  11e4d4:	66 01 4d c8          	add    %cx,-0x38(%ebp)
				ret = write_cb(0, 0, 0,
  11e4d8:	8b 15 34 ed 12 00    	mov    0x12ed34,%edx
					       last_block &&
  11e4de:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  11e4e2:	75 0a                	jne    11e4ee <do_firmware_transfer_reply_cb+0x32f>
  11e4e4:	31 c0                	xor    %eax,%eax
  11e4e6:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  11e4eb:	0f 94 c0             	sete   %al
				ret = write_cb(0, 0, 0,
  11e4ee:	52                   	push   %edx
  11e4ef:	50                   	push   %eax
  11e4f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  11e4f3:	53                   	push   %ebx
  11e4f4:	ff 75 d0             	pushl  -0x30(%ebp)
  11e4f7:	6a 00                	push   $0x0
  11e4f9:	6a 00                	push   $0x0
  11e4fb:	6a 00                	push   $0x0
  11e4fd:	ff d0                	call   *%eax
  11e4ff:	83 c4 1c             	add    $0x1c,%esp
  11e502:	89 c7                	mov    %eax,%edi
				if (ret < 0) {
  11e504:	85 c0                	test   %eax,%eax
  11e506:	0f 89 71 ff ff ff    	jns    11e47d <do_firmware_transfer_reply_cb+0x2be>
  11e50c:	eb 2c                	jmp    11e53a <do_firmware_transfer_reply_cb+0x37b>
		ret = transfer_request(&firmware_block_ctx, token, tkl,
  11e50e:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
  11e512:	8d 45 e0             	lea    -0x20(%ebp),%eax
  11e515:	e8 5c f9 ff ff       	call   11de76 <transfer_request.constprop.0>
  11e51a:	89 c7                	mov    %eax,%edi
		if (ret < 0) {
  11e51c:	85 c0                	test   %eax,%eax
  11e51e:	79 16                	jns    11e536 <do_firmware_transfer_reply_cb+0x377>
  11e520:	eb 18                	jmp    11e53a <do_firmware_transfer_reply_cb+0x37b>
		lwm2m_firmware_set_update_state(STATE_DOWNLOADED);
  11e522:	6a 02                	push   $0x2
  11e524:	e8 a6 f5 ff ff       	call   11dacf <lwm2m_firmware_set_update_state>
		lwm2m_engine_context_close(&firmware_ctx);
  11e529:	c7 04 24 20 59 14 00 	movl   $0x145920,(%esp)
  11e530:	e8 1f ad ff ff       	call   119254 <lwm2m_engine_context_close>
  11e535:	5a                   	pop    %edx
	return 0;
  11e536:	31 ff                	xor    %edi,%edi
  11e538:	eb 12                	jmp    11e54c <do_firmware_transfer_reply_cb+0x38d>
	set_update_result_from_error(ret);
  11e53a:	89 f8                	mov    %edi,%eax
  11e53c:	e8 f2 f8 ff ff       	call   11de33 <set_update_result_from_error>
	lwm2m_engine_context_close(&firmware_ctx);
  11e541:	68 20 59 14 00       	push   $0x145920
  11e546:	e8 09 ad ff ff       	call   119254 <lwm2m_engine_context_close>
  11e54b:	58                   	pop    %eax
}
  11e54c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11e54f:	89 f8                	mov    %edi,%eax
  11e551:	5b                   	pop    %ebx
  11e552:	5e                   	pop    %esi
  11e553:	5f                   	pop    %edi
  11e554:	5d                   	pop    %ebp
  11e555:	c3                   	ret    

0011e556 <firmware_transfer>:

static void firmware_transfer(struct k_work *work)
{
  11e556:	55                   	push   %ebp
  11e557:	89 e5                	mov    %esp,%ebp
  11e559:	53                   	push   %ebx
  11e55a:	51                   	push   %ecx
	server_addr = proxy_uri;
#else
	server_addr = firmware_uri;
#endif

	ret = lwm2m_parse_peerinfo(server_addr, &firmware_ctx.remote_addr,
  11e55b:	68 6c 5a 14 00       	push   $0x145a6c
  11e560:	68 20 59 14 00       	push   $0x145920
  11e565:	68 20 e7 12 00       	push   $0x12e720
  11e56a:	e8 6e ae ff ff       	call   1193dd <lwm2m_parse_peerinfo>
  11e56f:	83 c4 0c             	add    $0xc,%esp
				   &firmware_ctx.use_dtls);
	if (ret < 0) {
  11e572:	85 c0                	test   %eax,%eax
  11e574:	0f 88 bc 00 00 00    	js     11e636 <firmware_transfer+0xe0>
		goto error;
	}

	lwm2m_engine_context_init(&firmware_ctx);
  11e57a:	68 20 59 14 00       	push   $0x145920
  11e57f:	e8 fb ab ff ff       	call   11917f <lwm2m_engine_context_init>
	firmware_ctx.handle_separate_response = true;
	ret = lwm2m_socket_start(&firmware_ctx);
  11e584:	c7 04 24 20 59 14 00 	movl   $0x145920,(%esp)
	firmware_ctx.handle_separate_response = true;
  11e58b:	c6 05 79 5a 14 00 01 	movb   $0x1,0x145a79
	ret = lwm2m_socket_start(&firmware_ctx);
  11e592:	e8 8c ad ff ff       	call   119323 <lwm2m_socket_start>
  11e597:	5a                   	pop    %edx
	if (ret < 0) {
  11e598:	85 c0                	test   %eax,%eax
  11e59a:	8b 15 e0 5b 14 00    	mov    0x145be0,%edx
  11e5a0:	79 34                	jns    11e5d6 <firmware_transfer+0x80>
		LOG_ERR("Cannot start a firmware-pull connection:%d", ret);
  11e5a2:	80 e2 07             	and    $0x7,%dl
  11e5a5:	0f 84 8b 00 00 00    	je     11e636 <firmware_transfer+0xe0>
  11e5ab:	ba 40 31 12 00       	mov    $0x123140,%edx
  11e5b0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  11e5b3:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11e5b9:	c1 ea 03             	shr    $0x3,%edx
  11e5bc:	c1 e2 06             	shl    $0x6,%edx
  11e5bf:	83 ca 01             	or     $0x1,%edx
  11e5c2:	52                   	push   %edx
  11e5c3:	50                   	push   %eax
  11e5c4:	68 ab 86 12 00       	push   $0x1286ab
  11e5c9:	e8 a8 4f fe ff       	call   103576 <log_1>
  11e5ce:	83 c4 0c             	add    $0xc,%esp
  11e5d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  11e5d4:	eb 60                	jmp    11e636 <firmware_transfer+0xe0>
		goto error;
	}

	LOG_INF("Connecting to server %s", log_strdup(firmware_uri));
  11e5d6:	83 e2 07             	and    $0x7,%edx
  11e5d9:	83 fa 02             	cmp    $0x2,%edx
  11e5dc:	76 30                	jbe    11e60e <firmware_transfer+0xb8>
  11e5de:	68 20 e7 12 00       	push   $0x12e720
  11e5e3:	e8 6f 4c fe ff       	call   103257 <log_strdup>
  11e5e8:	bb 40 31 12 00       	mov    $0x123140,%ebx
  11e5ed:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11e5f3:	c1 eb 03             	shr    $0x3,%ebx
  11e5f6:	c1 e3 06             	shl    $0x6,%ebx
  11e5f9:	83 cb 03             	or     $0x3,%ebx
  11e5fc:	66 89 1c 24          	mov    %bx,(%esp)
  11e600:	50                   	push   %eax
  11e601:	68 d6 86 12 00       	push   $0x1286d6
  11e606:	e8 6b 4f fe ff       	call   103576 <log_1>
  11e60b:	83 c4 0c             	add    $0xc,%esp

	/* reset block transfer context */
	coap_block_transfer_init(&firmware_block_ctx,
  11e60e:	e8 58 6c ff ff       	call   11526b <lwm2m_default_block_size>
  11e613:	6a 00                	push   $0x0
  11e615:	50                   	push   %eax
  11e616:	68 34 ed 12 00       	push   $0x12ed34
  11e61b:	e8 1b a6 fe ff       	call   108c3b <coap_block_transfer_init>
  11e620:	83 c4 0c             	add    $0xc,%esp
				 lwm2m_default_block_size(), 0);
	ret = transfer_request(&firmware_block_ctx, coap_next_token(), 8,
  11e623:	e8 60 a3 fe ff       	call   108988 <coap_next_token>
  11e628:	ba 08 00 00 00       	mov    $0x8,%edx
  11e62d:	e8 44 f8 ff ff       	call   11de76 <transfer_request.constprop.0>
			       do_firmware_transfer_reply_cb);
	if (ret < 0) {
  11e632:	85 c0                	test   %eax,%eax
  11e634:	79 15                	jns    11e64b <firmware_transfer+0xf5>
	}

	return;

error:
	set_update_result_from_error(ret);
  11e636:	e8 f8 f7 ff ff       	call   11de33 <set_update_result_from_error>
	lwm2m_engine_context_close(&firmware_ctx);
}
  11e63b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	lwm2m_engine_context_close(&firmware_ctx);
  11e63e:	c7 45 08 20 59 14 00 	movl   $0x145920,0x8(%ebp)
}
  11e645:	c9                   	leave  
	lwm2m_engine_context_close(&firmware_ctx);
  11e646:	e9 09 ac ff ff       	jmp    119254 <lwm2m_engine_context_close>
}
  11e64b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11e64e:	c9                   	leave  
  11e64f:	c3                   	ret    

0011e650 <lwm2m_firmware_start_transfer>:
{
	return 0;
}

int lwm2m_firmware_start_transfer(char *package_uri)
{
  11e650:	55                   	push   %ebp
	/* close old socket */
	if (firmware_ctx.sock_fd > -1) {
  11e651:	83 3d 7c 5a 14 00 00 	cmpl   $0x0,0x145a7c
{
  11e658:	89 e5                	mov    %esp,%ebp
	if (firmware_ctx.sock_fd > -1) {
  11e65a:	78 0b                	js     11e667 <lwm2m_firmware_start_transfer+0x17>
		lwm2m_engine_context_close(&firmware_ctx);
  11e65c:	68 20 59 14 00       	push   $0x145920
  11e661:	e8 ee ab ff ff       	call   119254 <lwm2m_engine_context_close>
  11e666:	59                   	pop    %ecx
	}

	(void)memset(&firmware_ctx, 0, sizeof(struct lwm2m_ctx));
  11e667:	68 60 01 00 00       	push   $0x160
  11e66c:	6a 00                	push   $0x0
  11e66e:	68 20 59 14 00       	push   $0x145920
  11e673:	e8 e3 d7 fe ff       	call   10be5b <memset>
  11e678:	83 c4 0c             	add    $0xc,%esp
	firmware_retry = 0;
  11e67b:	c7 05 40 ed 12 00 00 	movl   $0x0,0x12ed40
  11e682:	00 00 00 
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  11e685:	c7 05 44 ed 12 00 00 	movl   $0x0,0x12ed44
  11e68c:	00 00 00 
  11e68f:	c7 05 48 ed 12 00 56 	movl   $0x11e556,0x12ed48
  11e696:	e5 11 00 
	k_work_init(&firmware_work, firmware_transfer);
	lwm2m_firmware_set_update_state(STATE_DOWNLOADING);
  11e699:	6a 01                	push   $0x1
  11e69b:	c7 05 4c ed 12 00 00 	movl   $0x0,0x12ed4c
  11e6a2:	00 00 00 
  11e6a5:	e8 25 f4 ff ff       	call   11dacf <lwm2m_firmware_set_update_state>

	/* start file transfer work */
	strncpy(firmware_uri, package_uri, URI_LEN - 1);
  11e6aa:	c7 04 24 fe 00 00 00 	movl   $0xfe,(%esp)
  11e6b1:	ff 75 08             	pushl  0x8(%ebp)
  11e6b4:	68 20 e7 12 00       	push   $0x12e720
  11e6b9:	e8 e7 d5 fe ff       	call   10bca5 <strncpy>
  11e6be:	83 c4 0c             	add    $0xc,%esp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  11e6c1:	a1 4c ed 12 00       	mov    0x12ed4c,%eax
  11e6c6:	89 c1                	mov    %eax,%ecx
  11e6c8:	89 c2                	mov    %eax,%edx
  11e6ca:	83 c9 01             	or     $0x1,%ecx
  11e6cd:	f0 0f b1 0d 4c ed 12 	lock cmpxchg %ecx,0x12ed4c
  11e6d4:	00 
  11e6d5:	75 ef                	jne    11e6c6 <lwm2m_firmware_start_transfer+0x76>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
  11e6d7:	80 e2 01             	and    $0x1,%dl
  11e6da:	75 11                	jne    11e6ed <lwm2m_firmware_start_transfer+0x9d>
		k_queue_append(&work_q->queue, work);
  11e6dc:	68 44 ed 12 00       	push   $0x12ed44
  11e6e1:	68 00 ea 12 00       	push   $0x12ea00
  11e6e6:	e8 2e 28 00 00       	call   120f19 <k_queue_append>
  11e6eb:	58                   	pop    %eax
  11e6ec:	5a                   	pop    %edx
	k_work_submit(&firmware_work);

	return 0;
}
  11e6ed:	31 c0                	xor    %eax,%eax
  11e6ef:	c9                   	leave  
  11e6f0:	c3                   	ret    

0011e6f1 <put_begin_ri>:
	return 2;
}

static size_t put_begin_ri(struct lwm2m_output_context *out,
			   struct lwm2m_obj_path *path)
{
  11e6f1:	55                   	push   %ebp
  11e6f2:	89 e5                	mov    %esp,%ebp
	struct json_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
  11e6f4:	8b 45 08             	mov    0x8(%ebp),%eax
  11e6f7:	8b 40 08             	mov    0x8(%eax),%eax
	if (!fd) {
  11e6fa:	85 c0                	test   %eax,%eax
  11e6fc:	74 04                	je     11e702 <put_begin_ri+0x11>
		return 0;
	}

	fd->writer_flags |= WRITER_RESOURCE_INSTANCE;
  11e6fe:	80 48 02 02          	orb    $0x2,0x2(%eax)
	return 0;
}
  11e702:	31 c0                	xor    %eax,%eax
  11e704:	5d                   	pop    %ebp
  11e705:	c3                   	ret    

0011e706 <put_end_ri>:

static size_t put_end_ri(struct lwm2m_output_context *out,
			 struct lwm2m_obj_path *path)
{
  11e706:	55                   	push   %ebp
  11e707:	89 e5                	mov    %esp,%ebp
	struct json_out_formatter_data *fd;

	fd = engine_get_out_user_data(out);
  11e709:	8b 45 08             	mov    0x8(%ebp),%eax
  11e70c:	8b 40 08             	mov    0x8(%eax),%eax
	if (!fd) {
  11e70f:	85 c0                	test   %eax,%eax
  11e711:	74 04                	je     11e717 <put_end_ri+0x11>
		return 0;
	}

	fd->writer_flags &= ~WRITER_RESOURCE_INSTANCE;
  11e713:	80 60 02 fd          	andb   $0xfd,0x2(%eax)
	return 0;
}
  11e717:	31 c0                	xor    %eax,%eax
  11e719:	5d                   	pop    %ebp
  11e71a:	c3                   	ret    

0011e71b <read_number>:
}

static size_t read_number(struct lwm2m_input_context *in,
			  int64_t *value1, int64_t *value2,
			  bool accept_sign, bool accept_dot)
{
  11e71b:	55                   	push   %ebp
  11e71c:	89 e5                	mov    %esp,%ebp
  11e71e:	57                   	push   %edi
  11e71f:	56                   	push   %esi
  11e720:	53                   	push   %ebx
  11e721:	83 ec 14             	sub    $0x14,%esp
  11e724:	89 55 e8             	mov    %edx,-0x18(%ebp)
  11e727:	8a 5d 08             	mov    0x8(%ebp),%bl
  11e72a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  11e72d:	88 5d e5             	mov    %bl,-0x1b(%ebp)
  11e730:	8a 5d 0c             	mov    0xc(%ebp),%bl
  11e733:	88 5d e4             	mov    %bl,-0x1c(%ebp)
	bool neg = false;
	bool dot_found = false;
	char c;

	/* initialize values to 0 */
	*value1 = 0;
  11e736:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  11e73c:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	if (value2) {
  11e743:	85 c9                	test   %ecx,%ecx
  11e745:	74 0d                	je     11e754 <read_number+0x39>
		*value2 = 0;
  11e747:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
  11e74d:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
	}

	fd = engine_get_in_user_data(in);
  11e754:	8b 70 10             	mov    0x10(%eax),%esi
  11e757:	89 75 ec             	mov    %esi,-0x14(%ebp)
	if (!fd) {
		return 0;
  11e75a:	31 f6                	xor    %esi,%esi
	if (!fd) {
  11e75c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  11e760:	0f 84 a8 00 00 00    	je     11e80e <read_number+0xf3>
	}

	buf = in->in_cpkt->data + fd->value_offset;
  11e766:	8b 50 04             	mov    0x4(%eax),%edx
  11e769:	8b 45 ec             	mov    -0x14(%ebp),%eax
	while (*(buf + i) && i < fd->value_len) {
  11e76c:	8b 7d e8             	mov    -0x18(%ebp),%edi
	bool dot_found = false;
  11e76f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
	buf = in->in_cpkt->data + fd->value_offset;
  11e773:	0f b7 40 04          	movzwl 0x4(%eax),%eax
	while (*(buf + i) && i < fd->value_len) {
  11e777:	03 02                	add    (%edx),%eax
	bool neg = false;
  11e779:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	while (*(buf + i) && i < fd->value_len) {
  11e77d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  11e780:	8b 45 e0             	mov    -0x20(%ebp),%eax
  11e783:	0f be 0c 30          	movsbl (%eax,%esi,1),%ecx
  11e787:	84 c9                	test   %cl,%cl
  11e789:	75 14                	jne    11e79f <read_number+0x84>
		}

		i++;
	}

	if (neg) {
  11e78b:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  11e78f:	74 7d                	je     11e80e <read_number+0xf3>
		*value1 = -*value1;
  11e791:	8b 45 e8             	mov    -0x18(%ebp),%eax
  11e794:	f7 18                	negl   (%eax)
  11e796:	83 50 04 00          	adcl   $0x0,0x4(%eax)
  11e79a:	f7 58 04             	negl   0x4(%eax)
  11e79d:	eb 6f                	jmp    11e80e <read_number+0xf3>
	while (*(buf + i) && i < fd->value_len) {
  11e79f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11e7a2:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  11e7a6:	39 f0                	cmp    %esi,%eax
  11e7a8:	76 e1                	jbe    11e78b <read_number+0x70>
		if (c == '-' && accept_sign && i == 0) {
  11e7aa:	80 f9 2d             	cmp    $0x2d,%cl
  11e7ad:	0f 94 c0             	sete   %al
  11e7b0:	22 45 e5             	and    -0x1b(%ebp),%al
  11e7b3:	74 06                	je     11e7bb <read_number+0xa0>
  11e7b5:	85 f6                	test   %esi,%esi
  11e7b7:	74 44                	je     11e7fd <read_number+0xe2>
  11e7b9:	eb 1d                	jmp    11e7d8 <read_number+0xbd>
		} else if (c == '.' && i > 0 && accept_dot && !dot_found &&
  11e7bb:	80 f9 2e             	cmp    $0x2e,%cl
  11e7be:	75 18                	jne    11e7d8 <read_number+0xbd>
  11e7c0:	85 f6                	test   %esi,%esi
  11e7c2:	74 14                	je     11e7d8 <read_number+0xbd>
  11e7c4:	8a 55 e6             	mov    -0x1a(%ebp),%dl
  11e7c7:	83 f2 01             	xor    $0x1,%edx
  11e7ca:	23 55 e4             	and    -0x1c(%ebp),%edx
  11e7cd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  11e7d1:	0f 95 c0             	setne  %al
  11e7d4:	20 d0                	and    %dl,%al
  11e7d6:	75 2a                	jne    11e802 <read_number+0xe7>
  11e7d8:	83 e9 30             	sub    $0x30,%ecx
		} else if (isdigit(c)) {
  11e7db:	83 f9 09             	cmp    $0x9,%ecx
  11e7de:	77 ab                	ja     11e78b <read_number+0x70>
			*counter = *counter * 10 + (c - '0');
  11e7e0:	b8 0a 00 00 00       	mov    $0xa,%eax
  11e7e5:	6b 5f 04 0a          	imul   $0xa,0x4(%edi),%ebx
  11e7e9:	f7 27                	mull   (%edi)
  11e7eb:	01 da                	add    %ebx,%edx
  11e7ed:	89 cb                	mov    %ecx,%ebx
  11e7ef:	c1 fb 1f             	sar    $0x1f,%ebx
  11e7f2:	01 c8                	add    %ecx,%eax
  11e7f4:	11 da                	adc    %ebx,%edx
  11e7f6:	89 07                	mov    %eax,(%edi)
  11e7f8:	89 57 04             	mov    %edx,0x4(%edi)
  11e7fb:	eb 0b                	jmp    11e808 <read_number+0xed>
			neg = true;
  11e7fd:	88 45 e7             	mov    %al,-0x19(%ebp)
  11e800:	eb 06                	jmp    11e808 <read_number+0xed>
			dot_found = true;
  11e802:	88 45 e6             	mov    %al,-0x1a(%ebp)
  11e805:	8b 7d f0             	mov    -0x10(%ebp),%edi
		i++;
  11e808:	46                   	inc    %esi
  11e809:	e9 72 ff ff ff       	jmp    11e780 <read_number+0x65>
	}

	return i;
}
  11e80e:	83 c4 14             	add    $0x14,%esp
  11e811:	89 f0                	mov    %esi,%eax
  11e813:	5b                   	pop    %ebx
  11e814:	5e                   	pop    %esi
  11e815:	5f                   	pop    %edi
  11e816:	5d                   	pop    %ebp
  11e817:	c3                   	ret    

0011e818 <get_s64>:

static size_t get_s64(struct lwm2m_input_context *in, int64_t *value)
{
  11e818:	55                   	push   %ebp
	return read_number(in, value, NULL, true, true);
  11e819:	31 c9                	xor    %ecx,%ecx
{
  11e81b:	89 e5                	mov    %esp,%ebp
  11e81d:	8b 45 08             	mov    0x8(%ebp),%eax
  11e820:	8b 55 0c             	mov    0xc(%ebp),%edx
	return read_number(in, value, NULL, true, true);
  11e823:	c7 45 08 01 00 00 00 	movl   $0x1,0x8(%ebp)
  11e82a:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
}
  11e831:	5d                   	pop    %ebp
	return read_number(in, value, NULL, true, true);
  11e832:	e9 e4 fe ff ff       	jmp    11e71b <read_number>

0011e837 <get_s32>:

static size_t get_s32(struct lwm2m_input_context *in, int32_t *value)
{
  11e837:	55                   	push   %ebp
	int64_t tmp = 0;
	size_t len = 0;

	len = read_number(in, &tmp, NULL, true, true);
  11e838:	31 c9                	xor    %ecx,%ecx
{
  11e83a:	89 e5                	mov    %esp,%ebp
  11e83c:	83 ec 08             	sub    $0x8,%esp
	len = read_number(in, &tmp, NULL, true, true);
  11e83f:	8d 55 f8             	lea    -0x8(%ebp),%edx
  11e842:	6a 01                	push   $0x1
  11e844:	8b 45 08             	mov    0x8(%ebp),%eax
  11e847:	6a 01                	push   $0x1
	int64_t tmp = 0;
  11e849:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  11e850:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	len = read_number(in, &tmp, NULL, true, true);
  11e857:	e8 bf fe ff ff       	call   11e71b <read_number>
  11e85c:	5a                   	pop    %edx
  11e85d:	59                   	pop    %ecx
	if (len > 0) {
  11e85e:	85 c0                	test   %eax,%eax
  11e860:	74 08                	je     11e86a <get_s32+0x33>
		*value = (int32_t)tmp;
  11e862:	8b 55 0c             	mov    0xc(%ebp),%edx
  11e865:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11e868:	89 0a                	mov    %ecx,(%edx)
	}

	return len;
}
  11e86a:	c9                   	leave  
  11e86b:	c3                   	ret    

0011e86c <get_float32fix>:
	return fd->value_len;
}

static size_t get_float32fix(struct lwm2m_input_context *in,
			     float32_value_t *value)
{
  11e86c:	55                   	push   %ebp
  11e86d:	89 e5                	mov    %esp,%ebp
  11e86f:	53                   	push   %ebx
  11e870:	83 ec 10             	sub    $0x10,%esp
	int64_t tmp1, tmp2;
	size_t len;

	len = read_number(in, &tmp1, &tmp2, true, true);
  11e873:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  11e876:	8d 55 ec             	lea    -0x14(%ebp),%edx
  11e879:	6a 01                	push   $0x1
  11e87b:	8b 45 08             	mov    0x8(%ebp),%eax
  11e87e:	6a 01                	push   $0x1
{
  11e880:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len = read_number(in, &tmp1, &tmp2, true, true);
  11e883:	e8 93 fe ff ff       	call   11e71b <read_number>
  11e888:	5a                   	pop    %edx
  11e889:	59                   	pop    %ecx
	if (len > 0) {
  11e88a:	85 c0                	test   %eax,%eax
  11e88c:	74 0b                	je     11e899 <get_float32fix+0x2d>
		value->val1 = (int32_t)tmp1;
  11e88e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  11e891:	89 13                	mov    %edx,(%ebx)
		value->val2 = (int32_t)tmp2;
  11e893:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11e896:	89 53 04             	mov    %edx,0x4(%ebx)
	}

	return len;
}
  11e899:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11e89c:	c9                   	leave  
  11e89d:	c3                   	ret    

0011e89e <get_float64fix>:

static size_t get_float64fix(struct lwm2m_input_context *in,
			     float64_value_t *value)
{
  11e89e:	55                   	push   %ebp
  11e89f:	89 e5                	mov    %esp,%ebp
  11e8a1:	53                   	push   %ebx
  11e8a2:	83 ec 10             	sub    $0x10,%esp
	int64_t tmp1, tmp2;
	size_t len;

	len = read_number(in, &tmp1, &tmp2, true, true);
  11e8a5:	8d 4d f4             	lea    -0xc(%ebp),%ecx
  11e8a8:	8d 55 ec             	lea    -0x14(%ebp),%edx
  11e8ab:	6a 01                	push   $0x1
  11e8ad:	8b 45 08             	mov    0x8(%ebp),%eax
  11e8b0:	6a 01                	push   $0x1
{
  11e8b2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len = read_number(in, &tmp1, &tmp2, true, true);
  11e8b5:	e8 61 fe ff ff       	call   11e71b <read_number>
  11e8ba:	5a                   	pop    %edx
  11e8bb:	59                   	pop    %ecx
	if (len > 0) {
  11e8bc:	85 c0                	test   %eax,%eax
  11e8be:	74 17                	je     11e8d7 <get_float64fix+0x39>
		value->val1 = tmp1;
  11e8c0:	8b 55 ec             	mov    -0x14(%ebp),%edx
  11e8c3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  11e8c6:	89 13                	mov    %edx,(%ebx)
  11e8c8:	89 4b 04             	mov    %ecx,0x4(%ebx)
		value->val2 = tmp2;
  11e8cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  11e8ce:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  11e8d1:	89 53 08             	mov    %edx,0x8(%ebx)
  11e8d4:	89 4b 0c             	mov    %ecx,0xc(%ebx)
	}

	return len;
}
  11e8d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11e8da:	c9                   	leave  
  11e8db:	c3                   	ret    

0011e8dc <get_opaque>:
			 struct lwm2m_opaque_context *opaque,
			 bool *last_block)
{
	/* TODO */
	return 0;
}
  11e8dc:	31 c0                	xor    %eax,%eax
  11e8de:	c3                   	ret    

0011e8df <get_objlnk>:

static size_t get_objlnk(struct lwm2m_input_context *in,
			 struct lwm2m_objlnk *value)
{
  11e8df:	55                   	push   %ebp
  11e8e0:	89 e5                	mov    %esp,%ebp
  11e8e2:	57                   	push   %edi
  11e8e3:	56                   	push   %esi
  11e8e4:	53                   	push   %ebx
  11e8e5:	83 ec 08             	sub    $0x8,%esp
	int64_t tmp;
	size_t len;
	uint16_t value_offset;
	struct json_in_formatter_data *fd;

	fd = engine_get_in_user_data(in);
  11e8e8:	8b 45 08             	mov    0x8(%ebp),%eax
  11e8eb:	8b 70 10             	mov    0x10(%eax),%esi
	if (!fd) {
  11e8ee:	31 c0                	xor    %eax,%eax
  11e8f0:	85 f6                	test   %esi,%esi
  11e8f2:	74 4a                	je     11e93e <get_objlnk+0x5f>
		return 0;
	}

	/* Store the original value offset. */
	value_offset = fd->value_offset;
  11e8f4:	66 8b 7e 04          	mov    0x4(%esi),%di

	len = read_number(in, &tmp, NULL, false, false);
  11e8f8:	31 c9                	xor    %ecx,%ecx
  11e8fa:	6a 00                	push   $0x0
  11e8fc:	8d 55 ec             	lea    -0x14(%ebp),%edx
  11e8ff:	8b 45 08             	mov    0x8(%ebp),%eax
  11e902:	6a 00                	push   $0x0
  11e904:	e8 12 fe ff ff       	call   11e71b <read_number>
  11e909:	5a                   	pop    %edx
  11e90a:	59                   	pop    %ecx
	value->obj_id = (uint16_t)tmp;
  11e90b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  11e90e:	8b 55 ec             	mov    -0x14(%ebp),%edx

	len++;  /* +1 for ':' delimeter. */
  11e911:	8d 58 01             	lea    0x1(%eax),%ebx
	value->obj_id = (uint16_t)tmp;
  11e914:	66 89 11             	mov    %dx,(%ecx)
	fd->value_offset += len;

	len += read_number(in, &tmp, NULL, false, false);
  11e917:	8b 45 08             	mov    0x8(%ebp),%eax
	fd->value_offset += len;
  11e91a:	66 01 5e 04          	add    %bx,0x4(%esi)
	len += read_number(in, &tmp, NULL, false, false);
  11e91e:	31 c9                	xor    %ecx,%ecx
  11e920:	6a 00                	push   $0x0
  11e922:	8d 55 ec             	lea    -0x14(%ebp),%edx
  11e925:	6a 00                	push   $0x0
  11e927:	e8 ef fd ff ff       	call   11e71b <read_number>
  11e92c:	01 d8                	add    %ebx,%eax
	value->obj_inst = (uint16_t)tmp;
  11e92e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	len += read_number(in, &tmp, NULL, false, false);
  11e931:	5a                   	pop    %edx
	value->obj_inst = (uint16_t)tmp;
  11e932:	8b 55 ec             	mov    -0x14(%ebp),%edx
	len += read_number(in, &tmp, NULL, false, false);
  11e935:	59                   	pop    %ecx
	value->obj_inst = (uint16_t)tmp;
  11e936:	66 89 53 02          	mov    %dx,0x2(%ebx)

	/* Restore the original value offset. */
	fd->value_offset = value_offset;
  11e93a:	66 89 7e 04          	mov    %di,0x4(%esi)

	return len;
}
  11e93e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11e941:	5b                   	pop    %ebx
  11e942:	5e                   	pop    %esi
  11e943:	5f                   	pop    %edi
  11e944:	5d                   	pop    %ebp
  11e945:	c3                   	ret    

0011e946 <buf_append>:
{
  11e946:	55                   	push   %ebp
  11e947:	89 e5                	mov    %esp,%ebp
  11e949:	57                   	push   %edi
  11e94a:	56                   	push   %esi
  11e94b:	53                   	push   %ebx
  11e94c:	83 ec 08             	sub    $0x8,%esp
	if (!dst || !src) {
  11e94f:	85 c0                	test   %eax,%eax
{
  11e951:	8b 75 0c             	mov    0xc(%ebp),%esi
  11e954:	89 75 f0             	mov    %esi,-0x10(%ebp)
	if (!dst || !src) {
  11e957:	74 35                	je     11e98e <buf_append+0x48>
	if (*dst_len + src_len > dst_size) {
  11e959:	0f b7 32             	movzwl (%edx),%esi
  11e95c:	0f b7 7d f0          	movzwl -0x10(%ebp),%edi
  11e960:	89 d3                	mov    %edx,%ebx
  11e962:	8d 14 3e             	lea    (%esi,%edi,1),%edx
  11e965:	89 55 ec             	mov    %edx,-0x14(%ebp)
		return -ENOMEM;
  11e968:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (*dst_len + src_len > dst_size) {
  11e96d:	0f b7 c9             	movzwl %cx,%ecx
  11e970:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
  11e973:	7f 1e                	jg     11e993 <buf_append+0x4d>
	memcpy(dst + *dst_len, src, src_len);
  11e975:	57                   	push   %edi
  11e976:	01 f0                	add    %esi,%eax
  11e978:	ff 75 08             	pushl  0x8(%ebp)
  11e97b:	50                   	push   %eax
  11e97c:	e8 6b d4 fe ff       	call   10bdec <memcpy>
	*dst_len += src_len;
  11e981:	8b 45 f0             	mov    -0x10(%ebp),%eax
	memcpy(dst + *dst_len, src, src_len);
  11e984:	83 c4 0c             	add    $0xc,%esp
	*dst_len += src_len;
  11e987:	66 01 03             	add    %ax,(%ebx)
	return 0;
  11e98a:	31 d2                	xor    %edx,%edx
  11e98c:	eb 05                	jmp    11e993 <buf_append+0x4d>
		return -EINVAL;
  11e98e:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  11e993:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11e996:	89 d0                	mov    %edx,%eax
  11e998:	5b                   	pop    %ebx
  11e999:	5e                   	pop    %esi
  11e99a:	5f                   	pop    %edi
  11e99b:	5d                   	pop    %ebp
  11e99c:	c3                   	ret    

0011e99d <put_json_prefix>:
{
  11e99d:	55                   	push   %ebp
  11e99e:	89 e5                	mov    %esp,%ebp
  11e9a0:	57                   	push   %edi
  11e9a1:	56                   	push   %esi
  11e9a2:	53                   	push   %ebx
  11e9a3:	53                   	push   %ebx
  11e9a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	fd = engine_get_out_user_data(out);
  11e9a7:	8b 78 08             	mov    0x8(%eax),%edi
	if (!fd) {
  11e9aa:	85 ff                	test   %edi,%edi
  11e9ac:	75 07                	jne    11e9b5 <put_json_prefix+0x18>
		return 0;
  11e9ae:	31 c0                	xor    %eax,%eax
  11e9b0:	e9 bd 00 00 00       	jmp    11ea72 <put_json_prefix+0xd5>
	sep = SEPARATOR(fd->writer_flags);
  11e9b5:	0f b6 77 02          	movzbl 0x2(%edi),%esi
  11e9b9:	b8 eb 78 12 00       	mov    $0x1278eb,%eax
  11e9be:	f7 c6 01 00 00 00    	test   $0x1,%esi
  11e9c4:	75 05                	jne    11e9cb <put_json_prefix+0x2e>
  11e9c6:	b8 02 4e 12 00       	mov    $0x124e02,%eax
	if (fd->path_level >= 2U) {
  11e9cb:	89 f3                	mov    %esi,%ebx
  11e9cd:	83 e3 02             	and    $0x2,%ebx
  11e9d0:	0f b7 72 04          	movzwl 0x4(%edx),%esi
  11e9d4:	80 7f 03 01          	cmpb   $0x1,0x3(%edi)
  11e9d8:	76 26                	jbe    11ea00 <put_json_prefix+0x63>
		if (fd->writer_flags & WRITER_RESOURCE_INSTANCE) {
  11e9da:	84 db                	test   %bl,%bl
  11e9dc:	74 09                	je     11e9e7 <put_json_prefix+0x4a>
			len = snprintk(json_buffer, sizeof(json_buffer),
  11e9de:	0f b7 52 06          	movzwl 0x6(%edx),%edx
  11e9e2:	51                   	push   %ecx
  11e9e3:	52                   	push   %edx
  11e9e4:	56                   	push   %esi
  11e9e5:	eb 43                	jmp    11ea2a <put_json_prefix+0x8d>
			len = snprintk(json_buffer, sizeof(json_buffer),
  11e9e7:	51                   	push   %ecx
  11e9e8:	56                   	push   %esi
  11e9e9:	50                   	push   %eax
  11e9ea:	68 1d 87 12 00       	push   $0x12871d
  11e9ef:	6a 40                	push   $0x40
  11e9f1:	68 20 e8 12 00       	push   $0x12e820
  11e9f6:	e8 04 29 fe ff       	call   1012ff <snprintk>
  11e9fb:	83 c4 18             	add    $0x18,%esp
  11e9fe:	eb 3f                	jmp    11ea3f <put_json_prefix+0xa2>
		if (fd->writer_flags & WRITER_RESOURCE_INSTANCE) {
  11ea00:	0f b7 7a 02          	movzwl 0x2(%edx),%edi
  11ea04:	84 db                	test   %bl,%bl
  11ea06:	74 1f                	je     11ea27 <put_json_prefix+0x8a>
			len = snprintk(json_buffer, sizeof(json_buffer),
  11ea08:	0f b7 52 06          	movzwl 0x6(%edx),%edx
  11ea0c:	51                   	push   %ecx
  11ea0d:	52                   	push   %edx
  11ea0e:	56                   	push   %esi
  11ea0f:	57                   	push   %edi
  11ea10:	50                   	push   %eax
  11ea11:	68 2d 87 12 00       	push   $0x12872d
  11ea16:	6a 40                	push   $0x40
  11ea18:	68 20 e8 12 00       	push   $0x12e820
  11ea1d:	e8 dd 28 fe ff       	call   1012ff <snprintk>
  11ea22:	83 c4 20             	add    $0x20,%esp
  11ea25:	eb 18                	jmp    11ea3f <put_json_prefix+0xa2>
			len = snprintk(json_buffer, sizeof(json_buffer),
  11ea27:	51                   	push   %ecx
  11ea28:	56                   	push   %esi
  11ea29:	57                   	push   %edi
  11ea2a:	50                   	push   %eax
  11ea2b:	68 0a 87 12 00       	push   $0x12870a
  11ea30:	6a 40                	push   $0x40
  11ea32:	68 20 e8 12 00       	push   $0x12e820
  11ea37:	e8 c3 28 fe ff       	call   1012ff <snprintk>
  11ea3c:	83 c4 1c             	add    $0x1c,%esp
  11ea3f:	89 c6                	mov    %eax,%esi
	if (len < 0) {
  11ea41:	85 c0                	test   %eax,%eax
  11ea43:	0f 88 65 ff ff ff    	js     11e9ae <put_json_prefix+0x11>
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), json_buffer, len) < 0) {
  11ea49:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ea4c:	0f b7 de             	movzwl %si,%ebx
  11ea4f:	8b 40 04             	mov    0x4(%eax),%eax
  11ea52:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ea56:	8d 50 04             	lea    0x4(%eax),%edx
  11ea59:	53                   	push   %ebx
  11ea5a:	8b 00                	mov    (%eax),%eax
  11ea5c:	68 20 e8 12 00       	push   $0x12e820
  11ea61:	e8 e0 fe ff ff       	call   11e946 <buf_append>
  11ea66:	5a                   	pop    %edx
  11ea67:	59                   	pop    %ecx
  11ea68:	85 c0                	test   %eax,%eax
  11ea6a:	0f 88 3e ff ff ff    	js     11e9ae <put_json_prefix+0x11>
	return len;
  11ea70:	89 f0                	mov    %esi,%eax
}
  11ea72:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11ea75:	5b                   	pop    %ebx
  11ea76:	5e                   	pop    %esi
  11ea77:	5f                   	pop    %edi
  11ea78:	5d                   	pop    %ebp
  11ea79:	c3                   	ret    

0011ea7a <put_char>:
{
  11ea7a:	55                   	push   %ebp
  11ea7b:	89 e5                	mov    %esp,%ebp
  11ea7d:	53                   	push   %ebx
  11ea7e:	51                   	push   %ecx
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), &c, sizeof(c)) < 0) {
  11ea7f:	8b 40 04             	mov    0x4(%eax),%eax
{
  11ea82:	88 55 f8             	mov    %dl,-0x8(%ebp)
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), &c, sizeof(c)) < 0) {
  11ea85:	8d 5d f8             	lea    -0x8(%ebp),%ebx
  11ea88:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ea8c:	8d 50 04             	lea    0x4(%eax),%edx
  11ea8f:	6a 01                	push   $0x1
  11ea91:	8b 00                	mov    (%eax),%eax
  11ea93:	53                   	push   %ebx
  11ea94:	e8 ad fe ff ff       	call   11e946 <buf_append>
  11ea99:	5b                   	pop    %ebx
  11ea9a:	f7 d0                	not    %eax
  11ea9c:	5a                   	pop    %edx
}
  11ea9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), &c, sizeof(c)) < 0) {
  11eaa0:	c1 e8 1f             	shr    $0x1f,%eax
}
  11eaa3:	c9                   	leave  
  11eaa4:	c3                   	ret    

0011eaa5 <put_json_postfix>:
{
  11eaa5:	55                   	push   %ebp
  11eaa6:	89 e5                	mov    %esp,%ebp
  11eaa8:	53                   	push   %ebx
	fd = engine_get_out_user_data(out);
  11eaa9:	8b 58 08             	mov    0x8(%eax),%ebx
	if (!fd) {
  11eaac:	85 db                	test   %ebx,%ebx
  11eaae:	75 04                	jne    11eab4 <put_json_postfix+0xf>
		return 0;
  11eab0:	31 c0                	xor    %eax,%eax
  11eab2:	eb 17                	jmp    11eacb <put_json_postfix+0x26>
	if (put_char(out, '}') < 1) {
  11eab4:	ba 7d 00 00 00       	mov    $0x7d,%edx
  11eab9:	e8 bc ff ff ff       	call   11ea7a <put_char>
  11eabe:	85 c0                	test   %eax,%eax
  11eac0:	74 ee                	je     11eab0 <put_json_postfix+0xb>
	fd->writer_flags |= WRITER_OUTPUT_VALUE;
  11eac2:	80 4b 02 01          	orb    $0x1,0x2(%ebx)
	return 1;
  11eac6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  11eacb:	5b                   	pop    %ebx
  11eacc:	5d                   	pop    %ebp
  11eacd:	c3                   	ret    

0011eace <put_objlnk>:
{
  11eace:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"ov\"");
  11eacf:	b9 43 87 12 00       	mov    $0x128743,%ecx
{
  11ead4:	89 e5                	mov    %esp,%ebp
  11ead6:	56                   	push   %esi
  11ead7:	53                   	push   %ebx
	len = put_json_prefix(out, path, "\"ov\"");
  11ead8:	8b 55 0c             	mov    0xc(%ebp),%edx
  11eadb:	8b 45 08             	mov    0x8(%ebp),%eax
{
  11eade:	8b 75 10             	mov    0x10(%ebp),%esi
	len = put_json_prefix(out, path, "\"ov\"");
  11eae1:	e8 b7 fe ff ff       	call   11e99d <put_json_prefix>
  11eae6:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "\"%u:%u\"", value->obj_id,
  11eae8:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  11eaec:	50                   	push   %eax
  11eaed:	0f b7 06             	movzwl (%esi),%eax
  11eaf0:	50                   	push   %eax
  11eaf1:	68 48 87 12 00       	push   $0x128748
  11eaf6:	ff 75 08             	pushl  0x8(%ebp)
  11eaf9:	e8 3f c3 ff ff       	call   11ae3d <plain_text_put_format>
  11eafe:	83 c4 10             	add    $0x10,%esp
  11eb01:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
  11eb03:	8b 45 08             	mov    0x8(%ebp),%eax
  11eb06:	e8 9a ff ff ff       	call   11eaa5 <put_json_postfix>
}
  11eb0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
	len += put_json_postfix(out);
  11eb0e:	01 d8                	add    %ebx,%eax
}
  11eb10:	5b                   	pop    %ebx
  11eb11:	5e                   	pop    %esi
  11eb12:	5d                   	pop    %ebp
  11eb13:	c3                   	ret    

0011eb14 <put_bool>:
{
  11eb14:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"bv\"");
  11eb15:	b9 5b 87 12 00       	mov    $0x12875b,%ecx
{
  11eb1a:	89 e5                	mov    %esp,%ebp
  11eb1c:	56                   	push   %esi
  11eb1d:	53                   	push   %ebx
	len = put_json_prefix(out, path, "\"bv\"");
  11eb1e:	8b 55 0c             	mov    0xc(%ebp),%edx
  11eb21:	8b 45 08             	mov    0x8(%ebp),%eax
{
  11eb24:	8b 5d 10             	mov    0x10(%ebp),%ebx
	len = put_json_prefix(out, path, "\"bv\"");
  11eb27:	e8 71 fe ff ff       	call   11e99d <put_json_prefix>
	len += plain_text_put_format(out, "%s", value ? "true" : "false");
  11eb2c:	84 db                	test   %bl,%bl
	len = put_json_prefix(out, path, "\"bv\"");
  11eb2e:	89 c6                	mov    %eax,%esi
	len += plain_text_put_format(out, "%s", value ? "true" : "false");
  11eb30:	b8 55 87 12 00       	mov    $0x128755,%eax
  11eb35:	74 05                	je     11eb3c <put_bool+0x28>
  11eb37:	b8 50 87 12 00       	mov    $0x128750,%eax
  11eb3c:	50                   	push   %eax
  11eb3d:	68 f8 4e 12 00       	push   $0x124ef8
  11eb42:	ff 75 08             	pushl  0x8(%ebp)
  11eb45:	e8 f3 c2 ff ff       	call   11ae3d <plain_text_put_format>
  11eb4a:	83 c4 0c             	add    $0xc,%esp
  11eb4d:	89 c3                	mov    %eax,%ebx
	len += put_json_postfix(out);
  11eb4f:	8b 45 08             	mov    0x8(%ebp),%eax
  11eb52:	e8 4e ff ff ff       	call   11eaa5 <put_json_postfix>
}
  11eb57:	8d 65 f8             	lea    -0x8(%ebp),%esp
	len += put_json_postfix(out);
  11eb5a:	01 d8                	add    %ebx,%eax
}
  11eb5c:	5b                   	pop    %ebx
	len += put_json_postfix(out);
  11eb5d:	01 f0                	add    %esi,%eax
}
  11eb5f:	5e                   	pop    %esi
  11eb60:	5d                   	pop    %ebp
  11eb61:	c3                   	ret    

0011eb62 <put_s64>:
{
  11eb62:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
  11eb63:	b9 60 87 12 00       	mov    $0x128760,%ecx
{
  11eb68:	89 e5                	mov    %esp,%ebp
  11eb6a:	53                   	push   %ebx
	len = put_json_prefix(out, path, "\"v\"");
  11eb6b:	8b 55 0c             	mov    0xc(%ebp),%edx
  11eb6e:	8b 45 08             	mov    0x8(%ebp),%eax
  11eb71:	e8 27 fe ff ff       	call   11e99d <put_json_prefix>
	len += plain_text_put_format(out, "%lld", value);
  11eb76:	ff 75 14             	pushl  0x14(%ebp)
  11eb79:	ff 75 10             	pushl  0x10(%ebp)
	len = put_json_prefix(out, path, "\"v\"");
  11eb7c:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "%lld", value);
  11eb7e:	68 e4 7e 12 00       	push   $0x127ee4
  11eb83:	ff 75 08             	pushl  0x8(%ebp)
  11eb86:	e8 b2 c2 ff ff       	call   11ae3d <plain_text_put_format>
  11eb8b:	83 c4 10             	add    $0x10,%esp
  11eb8e:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
  11eb90:	8b 45 08             	mov    0x8(%ebp),%eax
  11eb93:	e8 0d ff ff ff       	call   11eaa5 <put_json_postfix>
  11eb98:	01 d8                	add    %ebx,%eax
}
  11eb9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11eb9d:	c9                   	leave  
  11eb9e:	c3                   	ret    

0011eb9f <put_s32>:
{
  11eb9f:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
  11eba0:	b9 60 87 12 00       	mov    $0x128760,%ecx
{
  11eba5:	89 e5                	mov    %esp,%ebp
  11eba7:	53                   	push   %ebx
	len = put_json_prefix(out, path, "\"v\"");
  11eba8:	8b 55 0c             	mov    0xc(%ebp),%edx
  11ebab:	8b 45 08             	mov    0x8(%ebp),%eax
  11ebae:	e8 ea fd ff ff       	call   11e99d <put_json_prefix>
	len += plain_text_put_format(out, "%d", value);
  11ebb3:	ff 75 10             	pushl  0x10(%ebp)
	len = put_json_prefix(out, path, "\"v\"");
  11ebb6:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_format(out, "%d", value);
  11ebb8:	68 62 61 12 00       	push   $0x126162
  11ebbd:	ff 75 08             	pushl  0x8(%ebp)
  11ebc0:	e8 78 c2 ff ff       	call   11ae3d <plain_text_put_format>
  11ebc5:	83 c4 0c             	add    $0xc,%esp
  11ebc8:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
  11ebca:	8b 45 08             	mov    0x8(%ebp),%eax
  11ebcd:	e8 d3 fe ff ff       	call   11eaa5 <put_json_postfix>
  11ebd2:	01 d8                	add    %ebx,%eax
}
  11ebd4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11ebd7:	c9                   	leave  
  11ebd8:	c3                   	ret    

0011ebd9 <put_s16>:
{
  11ebd9:	55                   	push   %ebp
  11ebda:	89 e5                	mov    %esp,%ebp
	return put_s32(out, path, (int32_t)value);
  11ebdc:	0f bf 45 10          	movswl 0x10(%ebp),%eax
  11ebe0:	89 45 10             	mov    %eax,0x10(%ebp)
}
  11ebe3:	5d                   	pop    %ebp
	return put_s32(out, path, (int32_t)value);
  11ebe4:	e9 b6 ff ff ff       	jmp    11eb9f <put_s32>

0011ebe9 <put_s8>:
{
  11ebe9:	55                   	push   %ebp
  11ebea:	89 e5                	mov    %esp,%ebp
	return put_s32(out, path, (int32_t)value);
  11ebec:	0f be 45 10          	movsbl 0x10(%ebp),%eax
  11ebf0:	89 45 10             	mov    %eax,0x10(%ebp)
}
  11ebf3:	5d                   	pop    %ebp
	return put_s32(out, path, (int32_t)value);
  11ebf4:	e9 a6 ff ff ff       	jmp    11eb9f <put_s32>

0011ebf9 <put_string>:
{
  11ebf9:	55                   	push   %ebp
	res = put_json_prefix(out, path, "\"sv\"");
  11ebfa:	b9 64 87 12 00       	mov    $0x128764,%ecx
{
  11ebff:	89 e5                	mov    %esp,%ebp
  11ec01:	57                   	push   %edi
  11ec02:	56                   	push   %esi
  11ec03:	53                   	push   %ebx
  11ec04:	53                   	push   %ebx
	res = put_json_prefix(out, path, "\"sv\"");
  11ec05:	8b 55 0c             	mov    0xc(%ebp),%edx
  11ec08:	8b 45 08             	mov    0x8(%ebp),%eax
  11ec0b:	e8 8d fd ff ff       	call   11e99d <put_json_prefix>
	res += put_char(out, '"');
  11ec10:	ba 22 00 00 00       	mov    $0x22,%edx
	res = put_json_prefix(out, path, "\"sv\"");
  11ec15:	89 c3                	mov    %eax,%ebx
	res += put_char(out, '"');
  11ec17:	8b 45 08             	mov    0x8(%ebp),%eax
  11ec1a:	e8 5b fe ff ff       	call   11ea7a <put_char>
	if (res < 0) {
  11ec1f:	01 c3                	add    %eax,%ebx
  11ec21:	79 07                	jns    11ec2a <put_string+0x31>
		return 0;
  11ec23:	31 c0                	xor    %eax,%eax
  11ec25:	e9 a1 00 00 00       	jmp    11eccb <put_string+0xd2>
  11ec2a:	8b 75 10             	mov    0x10(%ebp),%esi
  11ec2d:	8b 45 14             	mov    0x14(%ebp),%eax
  11ec30:	01 f0                	add    %esi,%eax
  11ec32:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (i = 0; i < buflen; ++i) {
  11ec35:	39 75 f0             	cmp    %esi,-0x10(%ebp)
  11ec38:	74 70                	je     11ecaa <put_string+0xb1>
		if (buf[i] < '\x20') {
  11ec3a:	0f be 06             	movsbl (%esi),%eax
  11ec3d:	3c 1f                	cmp    $0x1f,%al
  11ec3f:	7f 42                	jg     11ec83 <put_string+0x8a>
			res = snprintk(json_buffer, sizeof(json_buffer),
  11ec41:	50                   	push   %eax
  11ec42:	68 69 87 12 00       	push   $0x128769
  11ec47:	6a 40                	push   $0x40
  11ec49:	68 20 e8 12 00       	push   $0x12e820
  11ec4e:	e8 ac 26 fe ff       	call   1012ff <snprintk>
  11ec53:	83 c4 10             	add    $0x10,%esp
  11ec56:	89 c7                	mov    %eax,%edi
			if (res < 0) {
  11ec58:	85 c0                	test   %eax,%eax
  11ec5a:	78 c7                	js     11ec23 <put_string+0x2a>
			if (buf_append(CPKT_BUF_WRITE(out->out_cpkt),
  11ec5c:	8b 45 08             	mov    0x8(%ebp),%eax
  11ec5f:	0f b7 d7             	movzwl %di,%edx
  11ec62:	8b 40 04             	mov    0x4(%eax),%eax
  11ec65:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ec69:	52                   	push   %edx
  11ec6a:	8d 50 04             	lea    0x4(%eax),%edx
  11ec6d:	8b 00                	mov    (%eax),%eax
  11ec6f:	68 20 e8 12 00       	push   $0x12e820
  11ec74:	e8 cd fc ff ff       	call   11e946 <buf_append>
  11ec79:	5a                   	pop    %edx
  11ec7a:	59                   	pop    %ecx
  11ec7b:	85 c0                	test   %eax,%eax
  11ec7d:	78 a4                	js     11ec23 <put_string+0x2a>
			len += res;
  11ec7f:	01 fb                	add    %edi,%ebx
			continue;
  11ec81:	eb 24                	jmp    11eca7 <put_string+0xae>
		} else if (buf[i] == '"' || buf[i] == '\\') {
  11ec83:	3c 22                	cmp    $0x22,%al
  11ec85:	74 04                	je     11ec8b <put_string+0x92>
  11ec87:	3c 5c                	cmp    $0x5c,%al
  11ec89:	75 0f                	jne    11ec9a <put_string+0xa1>
			len += put_char(out, '\\');
  11ec8b:	ba 5c 00 00 00       	mov    $0x5c,%edx
  11ec90:	8b 45 08             	mov    0x8(%ebp),%eax
  11ec93:	e8 e2 fd ff ff       	call   11ea7a <put_char>
  11ec98:	01 c3                	add    %eax,%ebx
		len += put_char(out, buf[i]);
  11ec9a:	0f be 16             	movsbl (%esi),%edx
  11ec9d:	8b 45 08             	mov    0x8(%ebp),%eax
  11eca0:	e8 d5 fd ff ff       	call   11ea7a <put_char>
  11eca5:	01 c3                	add    %eax,%ebx
	for (i = 0; i < buflen; ++i) {
  11eca7:	46                   	inc    %esi
  11eca8:	eb 8b                	jmp    11ec35 <put_string+0x3c>
	res = put_char(out, '"');
  11ecaa:	ba 22 00 00 00       	mov    $0x22,%edx
  11ecaf:	8b 45 08             	mov    0x8(%ebp),%eax
  11ecb2:	e8 c3 fd ff ff       	call   11ea7a <put_char>
	if (res < 0) {
  11ecb7:	85 c0                	test   %eax,%eax
  11ecb9:	0f 88 64 ff ff ff    	js     11ec23 <put_string+0x2a>
	len += res;
  11ecbf:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
  11ecc1:	8b 45 08             	mov    0x8(%ebp),%eax
  11ecc4:	e8 dc fd ff ff       	call   11eaa5 <put_json_postfix>
  11ecc9:	01 d8                	add    %ebx,%eax
}
  11eccb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11ecce:	5b                   	pop    %ebx
  11eccf:	5e                   	pop    %esi
  11ecd0:	5f                   	pop    %edi
  11ecd1:	5d                   	pop    %ebp
  11ecd2:	c3                   	ret    

0011ecd3 <put_end>:
{
  11ecd3:	55                   	push   %ebp
  11ecd4:	89 e5                	mov    %esp,%ebp
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), "]}", 2) < 0) {
  11ecd6:	8b 45 08             	mov    0x8(%ebp),%eax
  11ecd9:	8b 40 04             	mov    0x4(%eax),%eax
  11ecdc:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ece0:	8d 50 04             	lea    0x4(%eax),%edx
  11ece3:	6a 02                	push   $0x2
  11ece5:	8b 00                	mov    (%eax),%eax
  11ece7:	68 6e 87 12 00       	push   $0x12876e
  11ecec:	e8 55 fc ff ff       	call   11e946 <buf_append>
  11ecf1:	5a                   	pop    %edx
		return 0;
  11ecf2:	f7 d0                	not    %eax
  11ecf4:	c1 e8 1f             	shr    $0x1f,%eax
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), "]}", 2) < 0) {
  11ecf7:	59                   	pop    %ecx
		return 0;
  11ecf8:	01 c0                	add    %eax,%eax
}
  11ecfa:	c9                   	leave  
  11ecfb:	c3                   	ret    

0011ecfc <put_begin>:
{
  11ecfc:	55                   	push   %ebp
  11ecfd:	89 e5                	mov    %esp,%ebp
  11ecff:	56                   	push   %esi
  11ed00:	53                   	push   %ebx
  11ed01:	8b 45 0c             	mov    0xc(%ebp),%eax
  11ed04:	0f b7 10             	movzwl (%eax),%edx
	if (path->level >= 2U) {
  11ed07:	80 78 08 01          	cmpb   $0x1,0x8(%eax)
  11ed0b:	76 1c                	jbe    11ed29 <put_begin+0x2d>
		len = snprintk(json_buffer, sizeof(json_buffer),
  11ed0d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  11ed11:	50                   	push   %eax
  11ed12:	52                   	push   %edx
  11ed13:	68 71 87 12 00       	push   $0x128771
  11ed18:	6a 40                	push   $0x40
  11ed1a:	68 20 e8 12 00       	push   $0x12e820
  11ed1f:	e8 db 25 fe ff       	call   1012ff <snprintk>
  11ed24:	83 c4 14             	add    $0x14,%esp
  11ed27:	eb 15                	jmp    11ed3e <put_begin+0x42>
		len = snprintk(json_buffer, sizeof(json_buffer),
  11ed29:	52                   	push   %edx
  11ed2a:	68 87 87 12 00       	push   $0x128787
  11ed2f:	6a 40                	push   $0x40
  11ed31:	68 20 e8 12 00       	push   $0x12e820
  11ed36:	e8 c4 25 fe ff       	call   1012ff <snprintk>
  11ed3b:	83 c4 10             	add    $0x10,%esp
  11ed3e:	89 c3                	mov    %eax,%ebx
	if (len < 0) {
  11ed40:	85 c0                	test   %eax,%eax
  11ed42:	79 04                	jns    11ed48 <put_begin+0x4c>
		return 0;
  11ed44:	31 c0                	xor    %eax,%eax
  11ed46:	eb 25                	jmp    11ed6d <put_begin+0x71>
	if (buf_append(CPKT_BUF_WRITE(out->out_cpkt), json_buffer, len) < 0) {
  11ed48:	8b 45 08             	mov    0x8(%ebp),%eax
  11ed4b:	0f b7 f3             	movzwl %bx,%esi
  11ed4e:	8b 40 04             	mov    0x4(%eax),%eax
  11ed51:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ed55:	8d 50 04             	lea    0x4(%eax),%edx
  11ed58:	56                   	push   %esi
  11ed59:	8b 00                	mov    (%eax),%eax
  11ed5b:	68 20 e8 12 00       	push   $0x12e820
  11ed60:	e8 e1 fb ff ff       	call   11e946 <buf_append>
  11ed65:	5a                   	pop    %edx
  11ed66:	59                   	pop    %ecx
  11ed67:	85 c0                	test   %eax,%eax
  11ed69:	78 d9                	js     11ed44 <put_begin+0x48>
	return (size_t)len;
  11ed6b:	89 d8                	mov    %ebx,%eax
}
  11ed6d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11ed70:	5b                   	pop    %ebx
  11ed71:	5e                   	pop    %esi
  11ed72:	5d                   	pop    %ebp
  11ed73:	c3                   	ret    

0011ed74 <buf_read>:
{
  11ed74:	55                   	push   %ebp
  11ed75:	89 e5                	mov    %esp,%ebp
  11ed77:	57                   	push   %edi
  11ed78:	56                   	push   %esi
  11ed79:	53                   	push   %ebx
  11ed7a:	83 ec 08             	sub    $0x8,%esp
	if (!src) {
  11ed7d:	85 c9                	test   %ecx,%ecx
{
  11ed7f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (!src) {
  11ed82:	74 3f                	je     11edc3 <buf_read+0x4f>
	if (*offset + len > src_len) {
  11ed84:	8b 75 0c             	mov    0xc(%ebp),%esi
  11ed87:	89 d7                	mov    %edx,%edi
  11ed89:	0f b7 db             	movzwl %bx,%ebx
  11ed8c:	0f b7 36             	movzwl (%esi),%esi
  11ed8f:	89 75 f0             	mov    %esi,-0x10(%ebp)
  11ed92:	0f b7 f2             	movzwl %dx,%esi
  11ed95:	8b 55 f0             	mov    -0x10(%ebp),%edx
  11ed98:	01 f2                	add    %esi,%edx
  11ed9a:	89 55 ec             	mov    %edx,-0x14(%ebp)
		return -ENOMEM;
  11ed9d:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
	if (*offset + len > src_len) {
  11eda2:	39 5d ec             	cmp    %ebx,-0x14(%ebp)
  11eda5:	7f 21                	jg     11edc8 <buf_read+0x54>
	if (dst) {
  11eda7:	85 c0                	test   %eax,%eax
  11eda9:	74 0e                	je     11edb9 <buf_read+0x45>
		memcpy(dst, src + *offset, len);
  11edab:	03 4d f0             	add    -0x10(%ebp),%ecx
  11edae:	56                   	push   %esi
  11edaf:	51                   	push   %ecx
  11edb0:	50                   	push   %eax
  11edb1:	e8 36 d0 fe ff       	call   10bdec <memcpy>
  11edb6:	83 c4 0c             	add    $0xc,%esp
	*offset += len;
  11edb9:	8b 45 0c             	mov    0xc(%ebp),%eax
	return 0;
  11edbc:	31 d2                	xor    %edx,%edx
	*offset += len;
  11edbe:	66 01 38             	add    %di,(%eax)
	return 0;
  11edc1:	eb 05                	jmp    11edc8 <buf_read+0x54>
		return -EINVAL;
  11edc3:	ba ea ff ff ff       	mov    $0xffffffea,%edx
}
  11edc8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11edcb:	89 d0                	mov    %edx,%eax
  11edcd:	5b                   	pop    %ebx
  11edce:	5e                   	pop    %esi
  11edcf:	5f                   	pop    %edi
  11edd0:	5d                   	pop    %ebp
  11edd1:	c3                   	ret    

0011edd2 <get_string>:
{
  11edd2:	55                   	push   %ebp
  11edd3:	89 e5                	mov    %esp,%ebp
  11edd5:	53                   	push   %ebx
  11edd6:	8b 55 08             	mov    0x8(%ebp),%edx
  11edd9:	8b 45 10             	mov    0x10(%ebp),%eax
	fd = engine_get_in_user_data(in);
  11eddc:	8b 5a 10             	mov    0x10(%edx),%ebx
	if (!fd) {
  11eddf:	85 db                	test   %ebx,%ebx
  11ede1:	75 04                	jne    11ede7 <get_string+0x15>
		return 0;
  11ede3:	31 c0                	xor    %eax,%eax
  11ede5:	eb 31                	jmp    11ee18 <get_string+0x46>
	if (fd->value_len > buflen) {
  11ede7:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
  11edeb:	39 c1                	cmp    %eax,%ecx
  11eded:	76 05                	jbe    11edf4 <get_string+0x22>
		fd->value_len = buflen - 1;
  11edef:	48                   	dec    %eax
  11edf0:	66 89 43 06          	mov    %ax,0x6(%ebx)
	ret = buf_read(buf, fd->value_len, CPKT_BUF_READ(in->in_cpkt),
  11edf4:	8b 42 04             	mov    0x4(%edx),%eax
  11edf7:	8d 4b 04             	lea    0x4(%ebx),%ecx
  11edfa:	0f b7 53 06          	movzwl 0x6(%ebx),%edx
  11edfe:	51                   	push   %ecx
  11edff:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11ee03:	51                   	push   %ecx
  11ee04:	8b 08                	mov    (%eax),%ecx
  11ee06:	8b 45 0c             	mov    0xc(%ebp),%eax
  11ee09:	e8 66 ff ff ff       	call   11ed74 <buf_read>
  11ee0e:	5a                   	pop    %edx
  11ee0f:	59                   	pop    %ecx
	if (ret < 0) {
  11ee10:	85 c0                	test   %eax,%eax
  11ee12:	78 cf                	js     11ede3 <get_string+0x11>
	return fd->value_len;
  11ee14:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
}
  11ee18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  11ee1b:	c9                   	leave  
  11ee1c:	c3                   	ret    

0011ee1d <put_float64fix>:
{
  11ee1d:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
  11ee1e:	b9 60 87 12 00       	mov    $0x128760,%ecx
{
  11ee23:	89 e5                	mov    %esp,%ebp
  11ee25:	56                   	push   %esi
  11ee26:	53                   	push   %ebx
  11ee27:	8b 75 0c             	mov    0xc(%ebp),%esi
	len = put_json_prefix(out, path, "\"v\"");
  11ee2a:	8b 45 08             	mov    0x8(%ebp),%eax
  11ee2d:	89 f2                	mov    %esi,%edx
  11ee2f:	e8 69 fb ff ff       	call   11e99d <put_json_prefix>
	len += plain_text_put_float64fix(out, path, value);
  11ee34:	ff 75 10             	pushl  0x10(%ebp)
	len = put_json_prefix(out, path, "\"v\"");
  11ee37:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_float64fix(out, path, value);
  11ee39:	56                   	push   %esi
  11ee3a:	ff 75 08             	pushl  0x8(%ebp)
  11ee3d:	e8 fa c0 ff ff       	call   11af3c <plain_text_put_float64fix>
  11ee42:	83 c4 0c             	add    $0xc,%esp
  11ee45:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
  11ee47:	8b 45 08             	mov    0x8(%ebp),%eax
  11ee4a:	e8 56 fc ff ff       	call   11eaa5 <put_json_postfix>
}
  11ee4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
	len += put_json_postfix(out);
  11ee52:	01 d8                	add    %ebx,%eax
}
  11ee54:	5b                   	pop    %ebx
  11ee55:	5e                   	pop    %esi
  11ee56:	5d                   	pop    %ebp
  11ee57:	c3                   	ret    

0011ee58 <put_float32fix>:
{
  11ee58:	55                   	push   %ebp
	len = put_json_prefix(out, path, "\"v\"");
  11ee59:	b9 60 87 12 00       	mov    $0x128760,%ecx
{
  11ee5e:	89 e5                	mov    %esp,%ebp
  11ee60:	56                   	push   %esi
  11ee61:	53                   	push   %ebx
  11ee62:	8b 75 0c             	mov    0xc(%ebp),%esi
	len = put_json_prefix(out, path, "\"v\"");
  11ee65:	8b 45 08             	mov    0x8(%ebp),%eax
  11ee68:	89 f2                	mov    %esi,%edx
  11ee6a:	e8 2e fb ff ff       	call   11e99d <put_json_prefix>
	len += plain_text_put_float32fix(out, path, value);
  11ee6f:	ff 75 10             	pushl  0x10(%ebp)
	len = put_json_prefix(out, path, "\"v\"");
  11ee72:	89 c3                	mov    %eax,%ebx
	len += plain_text_put_float32fix(out, path, value);
  11ee74:	56                   	push   %esi
  11ee75:	ff 75 08             	pushl  0x8(%ebp)
  11ee78:	e8 3d c0 ff ff       	call   11aeba <plain_text_put_float32fix>
  11ee7d:	83 c4 0c             	add    $0xc,%esp
  11ee80:	01 c3                	add    %eax,%ebx
	len += put_json_postfix(out);
  11ee82:	8b 45 08             	mov    0x8(%ebp),%eax
  11ee85:	e8 1b fc ff ff       	call   11eaa5 <put_json_postfix>
}
  11ee8a:	8d 65 f8             	lea    -0x8(%ebp),%esp
	len += put_json_postfix(out);
  11ee8d:	01 d8                	add    %ebx,%eax
}
  11ee8f:	5b                   	pop    %ebx
  11ee90:	5e                   	pop    %esi
  11ee91:	5d                   	pop    %ebp
  11ee92:	c3                   	ret    

0011ee93 <get_bool>:
{
  11ee93:	55                   	push   %ebp
  11ee94:	31 c0                	xor    %eax,%eax
  11ee96:	89 e5                	mov    %esp,%ebp
  11ee98:	57                   	push   %edi
  11ee99:	56                   	push   %esi
  11ee9a:	8b 7d 08             	mov    0x8(%ebp),%edi
  11ee9d:	53                   	push   %ebx
  11ee9e:	8b 75 0c             	mov    0xc(%ebp),%esi
	fd = engine_get_in_user_data(in);
  11eea1:	8b 5f 10             	mov    0x10(%edi),%ebx
	if (!fd) {
  11eea4:	85 db                	test   %ebx,%ebx
  11eea6:	74 46                	je     11eeee <get_bool+0x5b>
	if (strncmp(in->in_cpkt->data + fd->value_offset,
  11eea8:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  11eeac:	8b 57 04             	mov    0x4(%edi),%edx
  11eeaf:	6a 04                	push   $0x4
  11eeb1:	68 50 87 12 00       	push   $0x128750
  11eeb6:	03 02                	add    (%edx),%eax
  11eeb8:	50                   	push   %eax
  11eeb9:	e8 91 ce fe ff       	call   10bd4f <strncmp>
  11eebe:	83 c4 0c             	add    $0xc,%esp
  11eec1:	85 c0                	test   %eax,%eax
  11eec3:	75 05                	jne    11eeca <get_bool+0x37>
		*value = true;
  11eec5:	c6 06 01             	movb   $0x1,(%esi)
  11eec8:	eb 20                	jmp    11eeea <get_bool+0x57>
	} else if (strncmp(in->in_cpkt->data + fd->value_offset,
  11eeca:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  11eece:	8b 57 04             	mov    0x4(%edi),%edx
  11eed1:	6a 05                	push   $0x5
  11eed3:	68 55 87 12 00       	push   $0x128755
  11eed8:	03 02                	add    (%edx),%eax
  11eeda:	50                   	push   %eax
  11eedb:	e8 6f ce fe ff       	call   10bd4f <strncmp>
  11eee0:	83 c4 0c             	add    $0xc,%esp
  11eee3:	85 c0                	test   %eax,%eax
  11eee5:	75 03                	jne    11eeea <get_bool+0x57>
		*value = false;
  11eee7:	c6 06 00             	movb   $0x0,(%esi)
	return fd->value_len;
  11eeea:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
}
  11eeee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11eef1:	5b                   	pop    %ebx
  11eef2:	5e                   	pop    %esi
  11eef3:	5f                   	pop    %edi
  11eef4:	5d                   	pop    %ebp
  11eef5:	c3                   	ret    

0011eef6 <json_add_char.isra.0>:
	if ((fd->json_flags & T_VALUE) ||
  11eef6:	8a 50 0a             	mov    0xa(%eax),%dl
  11eef9:	f6 c2 10             	test   $0x10,%dl
  11eefc:	75 0a                	jne    11ef08 <json_add_char.isra.0+0x12>
  11eefe:	83 e2 0c             	and    $0xc,%edx
  11ef01:	80 fa 04             	cmp    $0x4,%dl
  11ef04:	75 30                	jne    11ef36 <json_add_char.isra.0+0x40>
  11ef06:	eb 18                	jmp    11ef20 <json_add_char.isra.0+0x2a>
			fd->value_len++;
  11ef08:	66 8b 48 06          	mov    0x6(%eax),%cx
  11ef0c:	8d 51 01             	lea    0x1(%ecx),%edx
  11ef0f:	66 89 50 06          	mov    %dx,0x6(%eax)
			if (fd->value_len == 1U) {
  11ef13:	66 4a                	dec    %dx
  11ef15:	75 1f                	jne    11ef36 <json_add_char.isra.0+0x40>
				fd->value_offset = fd->offset;
  11ef17:	66 8b 50 08          	mov    0x8(%eax),%dx
  11ef1b:	66 89 50 04          	mov    %dx,0x4(%eax)
  11ef1f:	c3                   	ret    
			fd->name_len++;
  11ef20:	66 8b 48 02          	mov    0x2(%eax),%cx
  11ef24:	8d 51 01             	lea    0x1(%ecx),%edx
  11ef27:	66 89 50 02          	mov    %dx,0x2(%eax)
			if (fd->name_len == 1U) {
  11ef2b:	66 4a                	dec    %dx
  11ef2d:	75 07                	jne    11ef36 <json_add_char.isra.0+0x40>
				fd->name_offset = fd->offset;
  11ef2f:	66 8b 50 08          	mov    0x8(%eax),%dx
  11ef33:	66 89 10             	mov    %dx,(%eax)
}
  11ef36:	c3                   	ret    

0011ef37 <json_next_token>:
{
  11ef37:	55                   	push   %ebp
  11ef38:	89 e5                	mov    %esp,%ebp
  11ef3a:	57                   	push   %edi
  11ef3b:	56                   	push   %esi
	cont = 1U;
  11ef3c:	bf 01 00 00 00       	mov    $0x1,%edi
{
  11ef41:	53                   	push   %ebx
	bool escape = false;
  11ef42:	31 f6                	xor    %esi,%esi
{
  11ef44:	83 ec 08             	sub    $0x8,%esp
  11ef47:	89 d3                	mov    %edx,%ebx
  11ef49:	89 45 ec             	mov    %eax,-0x14(%ebp)
	(void)memset(fd, 0, sizeof(*fd));
  11ef4c:	6a 0c                	push   $0xc
  11ef4e:	6a 00                	push   $0x0
  11ef50:	52                   	push   %edx
  11ef51:	e8 05 cf fe ff       	call   10be5b <memset>
  11ef56:	83 c4 0c             	add    $0xc,%esp
	while (in->offset < in->in_cpkt->offset && cont) {
  11ef59:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11ef5c:	8b 50 08             	mov    0x8(%eax),%edx
  11ef5f:	8b 40 04             	mov    0x4(%eax),%eax
  11ef62:	66 3b 50 04          	cmp    0x4(%eax),%dx
  11ef66:	0f 83 0f 01 00 00    	jae    11f07b <json_next_token+0x144>
  11ef6c:	89 f9                	mov    %edi,%ecx
  11ef6e:	84 c9                	test   %cl,%cl
  11ef70:	0f 84 05 01 00 00    	je     11f07b <json_next_token+0x144>
		if (buf_read_u8(&c, CPKT_BUF_READ(in->in_cpkt),
  11ef76:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		fd->offset = in->offset;
  11ef79:	66 89 53 08          	mov    %dx,0x8(%ebx)
		if (buf_read_u8(&c, CPKT_BUF_READ(in->in_cpkt),
  11ef7d:	8d 51 08             	lea    0x8(%ecx),%edx
	return buf_read(value, sizeof(uint8_t), src, src_len, offset);
  11ef80:	8b 08                	mov    (%eax),%ecx
  11ef82:	52                   	push   %edx
  11ef83:	0f b7 50 06          	movzwl 0x6(%eax),%edx
  11ef87:	8d 45 f3             	lea    -0xd(%ebp),%eax
  11ef8a:	52                   	push   %edx
  11ef8b:	ba 01 00 00 00       	mov    $0x1,%edx
  11ef90:	e8 df fd ff ff       	call   11ed74 <buf_read>
  11ef95:	5a                   	pop    %edx
  11ef96:	59                   	pop    %ecx
  11ef97:	85 c0                	test   %eax,%eax
  11ef99:	0f 88 dc 00 00 00    	js     11f07b <json_next_token+0x144>
		if (c == '\\') {
  11ef9f:	8a 45 f3             	mov    -0xd(%ebp),%al
  11efa2:	3c 5c                	cmp    $0x5c,%al
  11efa4:	75 0e                	jne    11efb4 <json_next_token+0x7d>
			json_add_char(in, fd);
  11efa6:	89 d8                	mov    %ebx,%eax
			escape = true;
  11efa8:	be 01 00 00 00       	mov    $0x1,%esi
			json_add_char(in, fd);
  11efad:	e8 44 ff ff ff       	call   11eef6 <json_add_char.isra.0>
			continue;
  11efb2:	eb a5                	jmp    11ef59 <json_next_token+0x22>
		switch (c) {
  11efb4:	3c 5b                	cmp    $0x5b,%al
  11efb6:	74 41                	je     11eff9 <json_next_token+0xc2>
  11efb8:	77 31                	ja     11efeb <json_next_token+0xb4>
  11efba:	3c 22                	cmp    $0x22,%al
  11efbc:	74 6f                	je     11f02d <json_next_token+0xf6>
  11efbe:	77 1e                	ja     11efde <json_next_token+0xa7>
  11efc0:	3c 0a                	cmp    $0xa,%al
  11efc2:	77 0d                	ja     11efd1 <json_next_token+0x9a>
  11efc4:	3c 08                	cmp    $0x8,%al
  11efc6:	0f 86 a1 00 00 00    	jbe    11f06d <json_next_token+0x136>
  11efcc:	e9 90 00 00 00       	jmp    11f061 <json_next_token+0x12a>
  11efd1:	3c 20                	cmp    $0x20,%al
  11efd3:	0f 84 88 00 00 00    	je     11f061 <json_next_token+0x12a>
  11efd9:	e9 8f 00 00 00       	jmp    11f06d <json_next_token+0x136>
  11efde:	3c 2c                	cmp    $0x2c,%al
  11efe0:	74 43                	je     11f025 <json_next_token+0xee>
  11efe2:	3c 3a                	cmp    $0x3a,%al
  11efe4:	74 64                	je     11f04a <json_next_token+0x113>
  11efe6:	e9 82 00 00 00       	jmp    11f06d <json_next_token+0x136>
  11efeb:	3c 7b                	cmp    $0x7b,%al
  11efed:	74 27                	je     11f016 <json_next_token+0xdf>
  11efef:	3c 7d                	cmp    $0x7d,%al
  11eff1:	74 32                	je     11f025 <json_next_token+0xee>
  11eff3:	3c 5d                	cmp    $0x5d,%al
  11eff5:	74 0e                	je     11f005 <json_next_token+0xce>
  11eff7:	eb 74                	jmp    11f06d <json_next_token+0x136>
			if (!escape) {
  11eff9:	89 f0                	mov    %esi,%eax
  11effb:	84 c0                	test   %al,%al
  11effd:	75 6e                	jne    11f06d <json_next_token+0x136>
				fd->json_flags |= T_OBJECT_BEGIN;
  11efff:	80 4b 0a 01          	orb    $0x1,0xa(%ebx)
				cont = 0U;
  11f003:	eb 0a                	jmp    11f00f <json_next_token+0xd8>
			if (!escape) {
  11f005:	89 f0                	mov    %esi,%eax
  11f007:	84 c0                	test   %al,%al
  11f009:	75 62                	jne    11f06d <json_next_token+0x136>
				fd->json_flags |= T_OBJECT_END;
  11f00b:	80 4b 0a 02          	orb    $0x2,0xa(%ebx)
				cont = 0U;
  11f00f:	31 ff                	xor    %edi,%edi
  11f011:	e9 43 ff ff ff       	jmp    11ef59 <json_next_token+0x22>
			if (!escape) {
  11f016:	89 f0                	mov    %esi,%eax
  11f018:	84 c0                	test   %al,%al
  11f01a:	75 51                	jne    11f06d <json_next_token+0x136>
				fd->json_flags |= T_OBJECT_BEGIN;
  11f01c:	80 4b 0a 01          	orb    $0x1,0xa(%ebx)
  11f020:	e9 34 ff ff ff       	jmp    11ef59 <json_next_token+0x22>
			if (!escape) {
  11f025:	89 f0                	mov    %esi,%eax
  11f027:	84 c0                	test   %al,%al
  11f029:	74 e4                	je     11f00f <json_next_token+0xd8>
  11f02b:	eb 40                	jmp    11f06d <json_next_token+0x136>
			if (!escape) {
  11f02d:	89 f0                	mov    %esi,%eax
  11f02f:	84 c0                	test   %al,%al
  11f031:	75 3a                	jne    11f06d <json_next_token+0x136>
				if (fd->json_flags & T_STRING_BEGIN) {
  11f033:	8a 43 0a             	mov    0xa(%ebx),%al
  11f036:	a8 04                	test   $0x4,%al
  11f038:	74 08                	je     11f042 <json_next_token+0x10b>
					fd->json_flags &= ~T_STRING_BEGIN;
  11f03a:	83 e0 fb             	and    $0xfffffffb,%eax
					fd->json_flags |= T_STRING_END;
  11f03d:	83 c8 08             	or     $0x8,%eax
  11f040:	eb 17                	jmp    11f059 <json_next_token+0x122>
					fd->json_flags &= ~T_STRING_END;
  11f042:	83 e0 f7             	and    $0xfffffff7,%eax
					fd->json_flags |= T_STRING_BEGIN;
  11f045:	83 c8 04             	or     $0x4,%eax
  11f048:	eb 0f                	jmp    11f059 <json_next_token+0x122>
			if (!escape) {
  11f04a:	89 f0                	mov    %esi,%eax
  11f04c:	84 c0                	test   %al,%al
  11f04e:	75 1d                	jne    11f06d <json_next_token+0x136>
				fd->json_flags &= ~T_STRING_END;
  11f050:	8a 43 0a             	mov    0xa(%ebx),%al
  11f053:	83 e0 f7             	and    $0xfffffff7,%eax
				fd->json_flags |= T_VALUE;
  11f056:	83 c8 10             	or     $0x10,%eax
  11f059:	88 43 0a             	mov    %al,0xa(%ebx)
  11f05c:	e9 f8 fe ff ff       	jmp    11ef59 <json_next_token+0x22>
		if (escape) {
  11f061:	31 f6                	xor    %esi,%esi
			if (!(fd->json_flags & T_STRING_BEGIN)) {
  11f063:	f6 43 0a 04          	testb  $0x4,0xa(%ebx)
  11f067:	0f 84 ec fe ff ff    	je     11ef59 <json_next_token+0x22>
			json_add_char(in, fd);
  11f06d:	89 d8                	mov    %ebx,%eax
  11f06f:	31 f6                	xor    %esi,%esi
  11f071:	e8 80 fe ff ff       	call   11eef6 <json_add_char.isra.0>
  11f076:	e9 de fe ff ff       	jmp    11ef59 <json_next_token+0x22>
}
  11f07b:	8d 65 f4             	lea    -0xc(%ebp),%esp
	return (cont == 0U);
  11f07e:	89 f8                	mov    %edi,%eax
  11f080:	83 f0 01             	xor    $0x1,%eax
}
  11f083:	5b                   	pop    %ebx
  11f084:	5e                   	pop    %esi
  11f085:	5f                   	pop    %edi
	return (cont == 0U);
  11f086:	0f b6 c0             	movzbl %al,%eax
}
  11f089:	5d                   	pop    %ebp
  11f08a:	c3                   	ret    

0011f08b <do_read_op_json>:
	.get_opaque = get_opaque,
	.get_objlnk = get_objlnk,
};

int do_read_op_json(struct lwm2m_message *msg, int content_format)
{
  11f08b:	55                   	push   %ebp
  11f08c:	89 e5                	mov    %esp,%ebp
  11f08e:	56                   	push   %esi
  11f08f:	53                   	push   %ebx
  11f090:	50                   	push   %eax
	struct json_out_formatter_data fd;
	int ret;

	(void)memset(&fd, 0, sizeof(fd));
  11f091:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  11f094:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void)memset(&fd, 0, sizeof(fd));
  11f097:	6a 04                	push   $0x4
  11f099:	6a 00                	push   $0x0
  11f09b:	56                   	push   %esi
  11f09c:	e8 ba cd fe ff       	call   10be5b <memset>
	engine_set_out_user_data(&msg->out, &fd);
	/* save the level for output processing */
	fd.path_level = msg->path.level;
  11f0a1:	8a 43 2c             	mov    0x2c(%ebx),%al
	(void)memset(&fd, 0, sizeof(fd));
  11f0a4:	83 c4 0c             	add    $0xc,%esp
	fd.path_level = msg->path.level;
  11f0a7:	88 45 f7             	mov    %al,-0x9(%ebp)
	out->user_data = user_data;
  11f0aa:	89 73 20             	mov    %esi,0x20(%ebx)
	ret = lwm2m_perform_read_op(msg, content_format);
  11f0ad:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  11f0b1:	50                   	push   %eax
  11f0b2:	53                   	push   %ebx
  11f0b3:	e8 19 97 ff ff       	call   1187d1 <lwm2m_perform_read_op>
  11f0b8:	5a                   	pop    %edx
  11f0b9:	59                   	pop    %ecx
	out->user_data = NULL;
  11f0ba:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
	engine_clear_out_user_data(&msg->out);

	return ret;
}
  11f0c1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11f0c4:	5b                   	pop    %ebx
  11f0c5:	5e                   	pop    %esi
  11f0c6:	5d                   	pop    %ebp
  11f0c7:	c3                   	ret    

0011f0c8 <do_write_op_json>:

	return ret;
}

int do_write_op_json(struct lwm2m_message *msg)
{
  11f0c8:	55                   	push   %ebp
  11f0c9:	89 e5                	mov    %esp,%ebp
  11f0cb:	57                   	push   %edi
  11f0cc:	56                   	push   %esi
  11f0cd:	53                   	push   %ebx
	uint8_t value[TOKEN_BUF_LEN];
	uint8_t base_name[MAX_RESOURCE_LEN];
	uint8_t full_name[MAX_RESOURCE_LEN];
	uint8_t created;

	(void)memset(&fd, 0, sizeof(fd));
  11f0ce:	8d 5d 80             	lea    -0x80(%ebp),%ebx
{
  11f0d1:	81 ec a4 00 00 00    	sub    $0xa4,%esp
	struct lwm2m_engine_obj_inst *obj_inst = NULL;
  11f0d7:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
  11f0de:	00 00 00 
{
  11f0e1:	8b 75 08             	mov    0x8(%ebp),%esi
	(void)memset(&fd, 0, sizeof(fd));
  11f0e4:	6a 0c                	push   $0xc
  11f0e6:	6a 00                	push   $0x0
  11f0e8:	53                   	push   %ebx
  11f0e9:	e8 6d cd fe ff       	call   10be5b <memset>
  11f0ee:	83 c4 0c             	add    $0xc,%esp
	in->user_data = user_data;
  11f0f1:	89 5e 14             	mov    %ebx,0x14(%esi)
	engine_set_in_user_data(&msg->in, &fd);

	/* store a copy of the original path */
	memcpy(&orig_path, &msg->path, sizeof(msg->path));
  11f0f4:	8d 46 24             	lea    0x24(%esi),%eax
  11f0f7:	6a 0a                	push   $0xa
  11f0f9:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  11f0ff:	50                   	push   %eax
  11f100:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  11f106:	50                   	push   %eax
  11f107:	e8 e0 cc fe ff       	call   10bdec <memcpy>
  11f10c:	83 c4 0c             	add    $0xc,%esp

	/* PARSE base name "bn" */
	json_next_token(&msg->in, &fd);
  11f10f:	8d 46 04             	lea    0x4(%esi),%eax
  11f112:	89 da                	mov    %ebx,%edx
  11f114:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  11f11a:	e8 18 fe ff ff       	call   11ef37 <json_next_token>
	/* TODO: validate name == "bn" */
	if (buf_read(base_name, fd.value_len,
		     CPKT_BUF_READ(msg->in.in_cpkt),
  11f11f:	8b 46 08             	mov    0x8(%esi),%eax
	if (buf_read(base_name, fd.value_len,
  11f122:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
  11f125:	51                   	push   %ecx
  11f126:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11f12a:	0f b7 55 86          	movzwl -0x7a(%ebp),%edx
  11f12e:	51                   	push   %ecx
  11f12f:	8b 08                	mov    (%eax),%ecx
  11f131:	8d 45 8c             	lea    -0x74(%ebp),%eax
  11f134:	e8 3b fc ff ff       	call   11ed74 <buf_read>
  11f139:	5a                   	pop    %edx
  11f13a:	59                   	pop    %ecx
  11f13b:	85 c0                	test   %eax,%eax
  11f13d:	79 37                	jns    11f176 <do_write_op_json+0xae>
		     &fd.value_offset) < 0) {
		LOG_ERR("Error parsing base name!");
  11f13f:	f6 05 d4 5b 14 00 07 	testb  $0x7,0x145bd4
		return -EINVAL;
  11f146:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
		LOG_ERR("Error parsing base name!");
  11f14b:	0f 84 64 03 00 00    	je     11f4b5 <do_write_op_json+0x3ed>
  11f151:	b8 28 31 12 00       	mov    $0x123128,%eax
  11f156:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11f15b:	c1 e8 03             	shr    $0x3,%eax
  11f15e:	c1 e0 06             	shl    $0x6,%eax
  11f161:	83 c8 01             	or     $0x1,%eax
  11f164:	50                   	push   %eax
  11f165:	68 9a 87 12 00       	push   $0x12879a
  11f16a:	e8 de 43 fe ff       	call   10354d <log_0>
  11f16f:	5e                   	pop    %esi
  11f170:	5f                   	pop    %edi
  11f171:	e9 3f 03 00 00       	jmp    11f4b5 <do_write_op_json+0x3ed>
	}

	/* skip to elements */
	json_next_token(&msg->in, &fd);
  11f176:	89 da                	mov    %ebx,%edx
  11f178:	8d 46 04             	lea    0x4(%esi),%eax
  11f17b:	e8 b7 fd ff ff       	call   11ef37 <json_next_token>
  11f180:	b8 28 31 12 00       	mov    $0x123128,%eax
  11f185:	2d b0 30 12 00       	sub    $0x1230b0,%eax
	int ret = 0, index;
  11f18a:	31 db                	xor    %ebx,%ebx
  11f18c:	c1 e8 03             	shr    $0x3,%eax
	struct lwm2m_engine_res_inst *res_inst = NULL;
  11f18f:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
  11f196:	00 00 00 
  11f199:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
	struct lwm2m_engine_res *res = NULL;
  11f19f:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
  11f1a6:	00 00 00 

			/* get value for relative path */
			if (buf_read(value, fd.value_len,
				     CPKT_BUF_READ(msg->in.in_cpkt),
				     &fd.value_offset) < 0) {
				LOG_ERR("Error parsing relative path!");
  11f1a9:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
	struct lwm2m_engine_obj_field *obj_field = NULL;
  11f1af:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
  11f1b6:	00 00 00 
				LOG_ERR("Error parsing relative path!");
  11f1b9:	c1 e0 06             	shl    $0x6,%eax
  11f1bc:	66 89 85 56 ff ff ff 	mov    %ax,-0xaa(%ebp)
	while (json_next_token(&msg->in, &fd)) {
  11f1c3:	8d 55 80             	lea    -0x80(%ebp),%edx
  11f1c6:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
  11f1cc:	e8 66 fd ff ff       	call   11ef37 <json_next_token>
  11f1d1:	8d 55 80             	lea    -0x80(%ebp),%edx
  11f1d4:	85 c0                	test   %eax,%eax
  11f1d6:	0f 84 d2 02 00 00    	je     11f4ae <do_write_op_json+0x3e6>
		if (!(fd.json_flags & T_VALUE)) {
  11f1dc:	f6 45 8a 10          	testb  $0x10,-0x76(%ebp)
  11f1e0:	74 e1                	je     11f1c3 <do_write_op_json+0xfb>
			     CPKT_BUF_READ(msg->in.in_cpkt),
  11f1e2:	8b 4e 08             	mov    0x8(%esi),%ecx
		if (buf_read(value, fd.name_len,
  11f1e5:	52                   	push   %edx
  11f1e6:	0f b7 45 82          	movzwl -0x7e(%ebp),%eax
  11f1ea:	0f b7 51 06          	movzwl 0x6(%ecx),%edx
  11f1ee:	8d 7d b4             	lea    -0x4c(%ebp),%edi
  11f1f1:	52                   	push   %edx
  11f1f2:	8b 09                	mov    (%ecx),%ecx
  11f1f4:	89 c2                	mov    %eax,%edx
  11f1f6:	89 f8                	mov    %edi,%eax
  11f1f8:	e8 77 fb ff ff       	call   11ed74 <buf_read>
  11f1fd:	5a                   	pop    %edx
  11f1fe:	59                   	pop    %ecx
  11f1ff:	85 c0                	test   %eax,%eax
  11f201:	79 1b                	jns    11f21e <do_write_op_json+0x156>
			LOG_ERR("Error parsing name!");
  11f203:	f6 05 d4 5b 14 00 07 	testb  $0x7,0x145bd4
  11f20a:	74 b7                	je     11f1c3 <do_write_op_json+0xfb>
  11f20c:	66 8b 85 56 ff ff ff 	mov    -0xaa(%ebp),%ax
  11f213:	83 c8 01             	or     $0x1,%eax
  11f216:	50                   	push   %eax
  11f217:	68 b3 87 12 00       	push   $0x1287b3
  11f21c:	eb 4d                	jmp    11f26b <do_write_op_json+0x1a3>
		if (value[0] == 'n') {
  11f21e:	80 7d b4 6e          	cmpb   $0x6e,-0x4c(%ebp)
  11f222:	0f 85 1b 02 00 00    	jne    11f443 <do_write_op_json+0x37b>
				     CPKT_BUF_READ(msg->in.in_cpkt),
  11f228:	8b 46 08             	mov    0x8(%esi),%eax
			if (buf_read(value, fd.value_len,
  11f22b:	8d 4d 84             	lea    -0x7c(%ebp),%ecx
  11f22e:	51                   	push   %ecx
			created = 0U;
  11f22f:	c6 85 6f ff ff ff 00 	movb   $0x0,-0x91(%ebp)
			if (buf_read(value, fd.value_len,
  11f236:	0f b7 48 06          	movzwl 0x6(%eax),%ecx
  11f23a:	0f b7 55 86          	movzwl -0x7a(%ebp),%edx
  11f23e:	51                   	push   %ecx
  11f23f:	8b 08                	mov    (%eax),%ecx
  11f241:	89 f8                	mov    %edi,%eax
  11f243:	e8 2c fb ff ff       	call   11ed74 <buf_read>
  11f248:	5a                   	pop    %edx
  11f249:	59                   	pop    %ecx
  11f24a:	85 c0                	test   %eax,%eax
  11f24c:	79 29                	jns    11f277 <do_write_op_json+0x1af>
				LOG_ERR("Error parsing relative path!");
  11f24e:	f6 05 d4 5b 14 00 07 	testb  $0x7,0x145bd4
  11f255:	0f 84 68 ff ff ff    	je     11f1c3 <do_write_op_json+0xfb>
  11f25b:	66 8b 85 56 ff ff ff 	mov    -0xaa(%ebp),%ax
  11f262:	83 c8 01             	or     $0x1,%eax
  11f265:	50                   	push   %eax
  11f266:	68 c7 87 12 00       	push   $0x1287c7
  11f26b:	e8 dd 42 fe ff       	call   10354d <log_0>
  11f270:	5f                   	pop    %edi
  11f271:	58                   	pop    %eax
  11f272:	e9 4c ff ff ff       	jmp    11f1c3 <do_write_op_json+0xfb>
				continue;
			}

			/* combine base_name + name */
			snprintk(full_name, sizeof(full_name), "%s%s",
  11f277:	57                   	push   %edi
  11f278:	8d 45 8c             	lea    -0x74(%ebp),%eax
  11f27b:	50                   	push   %eax
  11f27c:	8d 5d a0             	lea    -0x60(%ebp),%ebx
  11f27f:	68 a3 50 12 00       	push   $0x1250a3
  11f284:	6a 14                	push   $0x14
  11f286:	53                   	push   %ebx
  11f287:	e8 73 20 fe ff       	call   1012ff <snprintk>
  11f28c:	83 c4 14             	add    $0x14,%esp
				 base_name, value);

			/* parse full_name into path */
			ret = parse_path(full_name, strlen(full_name),
  11f28f:	53                   	push   %ebx
  11f290:	e8 87 ca fe ff       	call   10bd1c <strlen>
	(void)memset(path, 0, sizeof(*path));
  11f295:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  11f29c:	6a 00                	push   $0x0
  11f29e:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
			ret = parse_path(full_name, strlen(full_name),
  11f2a4:	0f b7 c0             	movzwl %ax,%eax
  11f2a7:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
	int ret = 0;
  11f2ad:	31 db                	xor    %ebx,%ebx
	(void)memset(path, 0, sizeof(*path));
  11f2af:	e8 a7 cb fe ff       	call   10be5b <memset>
  11f2b4:	83 c4 0c             	add    $0xc,%esp
	int pos = 0;
  11f2b7:	31 c0                	xor    %eax,%eax
		c = buf[pos];
  11f2b9:	0f b6 54 05 a0       	movzbl -0x60(%ebp,%eax,1),%edx
		val = 0U;
  11f2be:	31 ff                	xor    %edi,%edi
		while (pos < buflen && isdigit(c)) {
  11f2c0:	39 85 60 ff ff ff    	cmp    %eax,-0xa0(%ebp)
  11f2c6:	7e 1a                	jle    11f2e2 <do_write_op_json+0x21a>
  11f2c8:	0f b6 ca             	movzbl %dl,%ecx
  11f2cb:	83 e9 30             	sub    $0x30,%ecx
  11f2ce:	83 f9 09             	cmp    $0x9,%ecx
  11f2d1:	77 0f                	ja     11f2e2 <do_write_op_json+0x21a>
			val = val * 10U + (c - '0');
  11f2d3:	6b ff 0a             	imul   $0xa,%edi,%edi
			c = buf[++pos];
  11f2d6:	40                   	inc    %eax
			val = val * 10U + (c - '0');
  11f2d7:	8d 7c 17 d0          	lea    -0x30(%edi,%edx,1),%edi
			c = buf[++pos];
  11f2db:	0f b6 54 05 a0       	movzbl -0x60(%ebp,%eax,1),%edx
  11f2e0:	eb de                	jmp    11f2c0 <do_write_op_json+0x1f8>
		if (pos == 0 && c == '/') {
  11f2e2:	80 fa 2f             	cmp    $0x2f,%dl
  11f2e5:	0f 94 c1             	sete   %cl
  11f2e8:	85 c0                	test   %eax,%eax
  11f2ea:	75 04                	jne    11f2f0 <do_write_op_json+0x228>
  11f2ec:	84 c9                	test   %cl,%cl
  11f2ee:	75 66                	jne    11f356 <do_write_op_json+0x28e>
		} else if (c == '/' || pos == buflen) {
  11f2f0:	39 85 60 ff ff ff    	cmp    %eax,-0xa0(%ebp)
  11f2f6:	74 04                	je     11f2fc <do_write_op_json+0x234>
  11f2f8:	84 c9                	test   %cl,%cl
  11f2fa:	74 2d                	je     11f329 <do_write_op_json+0x261>
			if (ret == 0) {
  11f2fc:	85 db                	test   %ebx,%ebx
  11f2fe:	75 06                	jne    11f306 <do_write_op_json+0x23e>
				path->obj_id = val;
  11f300:	66 89 7e 24          	mov    %di,0x24(%esi)
  11f304:	eb 1f                	jmp    11f325 <do_write_op_json+0x25d>
			} else if (ret == 1) {
  11f306:	83 fb 01             	cmp    $0x1,%ebx
  11f309:	75 06                	jne    11f311 <do_write_op_json+0x249>
				path->obj_inst_id = val;
  11f30b:	66 89 7e 26          	mov    %di,0x26(%esi)
  11f30f:	eb 14                	jmp    11f325 <do_write_op_json+0x25d>
			} else if (ret == 2) {
  11f311:	83 fb 02             	cmp    $0x2,%ebx
  11f314:	75 06                	jne    11f31c <do_write_op_json+0x254>
				path->res_id = val;
  11f316:	66 89 7e 28          	mov    %di,0x28(%esi)
  11f31a:	eb 09                	jmp    11f325 <do_write_op_json+0x25d>
			} else if (ret == 3) {
  11f31c:	83 fb 03             	cmp    $0x3,%ebx
  11f31f:	75 04                	jne    11f325 <do_write_op_json+0x25d>
				path->res_inst_id = val;
  11f321:	66 89 7e 2a          	mov    %di,0x2a(%esi)
			ret++;
  11f325:	43                   	inc    %ebx
			pos++;
  11f326:	40                   	inc    %eax
  11f327:	eb 32                	jmp    11f35b <do_write_op_json+0x293>
			LOG_ERR("Error: illegal char '%c' at pos:%d",
  11f329:	f6 05 d4 5b 14 00 07 	testb  $0x7,0x145bd4
  11f330:	74 1c                	je     11f34e <do_write_op_json+0x286>
  11f332:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  11f338:	c1 e1 06             	shl    $0x6,%ecx
  11f33b:	83 c9 01             	or     $0x1,%ecx
  11f33e:	51                   	push   %ecx
  11f33f:	50                   	push   %eax
  11f340:	52                   	push   %edx
  11f341:	68 e4 87 12 00       	push   $0x1287e4
  11f346:	e8 65 42 fe ff       	call   1035b0 <log_2>
  11f34b:	83 c4 10             	add    $0x10,%esp
			return -1;
  11f34e:	83 cb ff             	or     $0xffffffff,%ebx
  11f351:	e9 58 01 00 00       	jmp    11f4ae <do_write_op_json+0x3e6>
			pos++;
  11f356:	b8 01 00 00 00       	mov    $0x1,%eax
	} while (pos < buflen);
  11f35b:	39 85 60 ff ff ff    	cmp    %eax,-0xa0(%ebp)
  11f361:	0f 8f 52 ff ff ff    	jg     11f2b9 <do_write_op_json+0x1f1>
					 &msg->path);
			if (ret < 0) {
  11f367:	85 db                	test   %ebx,%ebx
  11f369:	0f 88 3f 01 00 00    	js     11f4ae <do_write_op_json+0x3e6>
			}

			/* if valid, use the return value as level */
			msg->path.level = ret;

			ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst,
  11f36f:	8d 85 6f ff ff ff    	lea    -0x91(%ebp),%eax
			msg->path.level = ret;
  11f375:	88 5e 2c             	mov    %bl,0x2c(%esi)
			ret = lwm2m_get_or_create_engine_obj(msg, &obj_inst,
  11f378:	50                   	push   %eax
  11f379:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
  11f37f:	50                   	push   %eax
  11f380:	56                   	push   %esi
  11f381:	e8 d6 98 ff ff       	call   118c5c <lwm2m_get_or_create_engine_obj>
  11f386:	83 c4 0c             	add    $0xc,%esp
  11f389:	89 c3                	mov    %eax,%ebx
							     &created);
			if (ret < 0) {
  11f38b:	85 c0                	test   %eax,%eax
  11f38d:	0f 88 1b 01 00 00    	js     11f4ae <do_write_op_json+0x3e6>
				break;
			}

			obj_field = lwm2m_get_engine_obj_field(
  11f393:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  11f397:	50                   	push   %eax
  11f398:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
  11f39e:	ff 70 04             	pushl  0x4(%eax)
  11f3a1:	e8 57 5f ff ff       	call   1152fd <lwm2m_get_engine_obj_field>
  11f3a6:	5a                   	pop    %edx
  11f3a7:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
  11f3ad:	59                   	pop    %ecx
							msg->path.res_id);
			/*
			 * if obj_field is not found,
			 * treat as an optional resource
			 */
			if (!obj_field) {
  11f3ae:	85 c0                	test   %eax,%eax
  11f3b0:	0f 84 f3 00 00 00    	je     11f4a9 <do_write_op_json+0x3e1>
			/*
			 * TODO: support BOOTSTRAP WRITE where optional
			 * resources are ignored
			 */

			if (!LWM2M_HAS_PERM(obj_field, LWM2M_PERM_W)) {
  11f3b6:	8a 40 02             	mov    0x2(%eax),%al
  11f3b9:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
  11f3bf:	83 e0 06             	and    $0x6,%eax
  11f3c2:	3c 06                	cmp    $0x6,%al
  11f3c4:	75 88                	jne    11f34e <do_write_op_json+0x286>
				ret = -EPERM;
				break;
			}

			if (!obj_inst->resources ||
  11f3c6:	8b 95 70 ff ff ff    	mov    -0x90(%ebp),%edx
  11f3cc:	8b 42 08             	mov    0x8(%edx),%eax
  11f3cf:	85 c0                	test   %eax,%eax
  11f3d1:	0f 84 cb 00 00 00    	je     11f4a2 <do_write_op_json+0x3da>
			    obj_inst->resource_count == 0U) {
  11f3d7:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
			if (!obj_inst->resources ||
  11f3db:	66 85 d2             	test   %dx,%dx
  11f3de:	0f 84 be 00 00 00    	je     11f4a2 <do_write_op_json+0x3da>
			}

			for (index = 0; index < obj_inst->resource_count;
			     index++) {
				if (obj_inst->resources[index].res_id ==
				    msg->path.res_id) {
  11f3e4:	8b 7e 28             	mov    0x28(%esi),%edi
			for (index = 0; index < obj_inst->resource_count;
  11f3e7:	31 c9                	xor    %ecx,%ecx
				if (obj_inst->resources[index].res_id ==
  11f3e9:	66 39 78 14          	cmp    %di,0x14(%eax)
  11f3ed:	74 16                	je     11f405 <do_write_op_json+0x33d>
			     index++) {
  11f3ef:	41                   	inc    %ecx
			for (index = 0; index < obj_inst->resource_count;
  11f3f0:	83 c0 18             	add    $0x18,%eax
  11f3f3:	39 ca                	cmp    %ecx,%edx
  11f3f5:	7f f2                	jg     11f3e9 <do_write_op_json+0x321>
					res = &obj_inst->resources[index];
					break;
				}
			}

			if (!res) {
  11f3f7:	83 bd 68 ff ff ff 00 	cmpl   $0x0,-0x98(%ebp)
  11f3fe:	75 0b                	jne    11f40b <do_write_op_json+0x343>
  11f400:	e9 a4 00 00 00       	jmp    11f4a9 <do_write_op_json+0x3e1>
				if (obj_inst->resources[index].res_id ==
  11f405:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
				ret = -ENOENT;
				break;
			}

			for (index = 0; index < res->res_inst_count; index++) {
  11f40b:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
  11f411:	31 d2                	xor    %edx,%edx
  11f413:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  11f417:	39 ca                	cmp    %ecx,%edx
  11f419:	7d 19                	jge    11f434 <do_write_op_json+0x36c>
				if (res->res_instances[index].res_inst_id ==
  11f41b:	6b c2 0c             	imul   $0xc,%edx,%eax
  11f41e:	8b bd 68 ff ff ff    	mov    -0x98(%ebp),%edi
  11f424:	03 47 10             	add    0x10(%edi),%eax
  11f427:	66 8b 7e 2a          	mov    0x2a(%esi),%di
  11f42b:	66 39 78 08          	cmp    %di,0x8(%eax)
  11f42f:	74 66                	je     11f497 <do_write_op_json+0x3cf>
			for (index = 0; index < res->res_inst_count; index++) {
  11f431:	42                   	inc    %edx
  11f432:	eb e3                	jmp    11f417 <do_write_op_json+0x34f>
					res_inst = &res->res_instances[index];
					break;
				}
			}

			if (!res_inst) {
  11f434:	83 bd 64 ff ff ff 00 	cmpl   $0x0,-0x9c(%ebp)
  11f43b:	0f 85 82 fd ff ff    	jne    11f1c3 <do_write_op_json+0xfb>
  11f441:	eb 66                	jmp    11f4a9 <do_write_op_json+0x3e1>
				ret = -ENOENT;
				break;
			}
		} else if (res && res_inst) {
  11f443:	83 bd 68 ff ff ff 00 	cmpl   $0x0,-0x98(%ebp)
  11f44a:	0f 84 73 fd ff ff    	je     11f1c3 <do_write_op_json+0xfb>
  11f450:	83 bd 64 ff ff ff 00 	cmpl   $0x0,-0x9c(%ebp)
  11f457:	0f 84 66 fd ff ff    	je     11f1c3 <do_write_op_json+0xfb>
			/* handle value assignment */
			ret = lwm2m_write_handler(obj_inst, res, res_inst,
  11f45d:	56                   	push   %esi
  11f45e:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
  11f464:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
  11f46a:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
  11f470:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
  11f476:	e8 28 90 ff ff       	call   1184a3 <lwm2m_write_handler>
  11f47b:	83 c4 14             	add    $0x14,%esp
  11f47e:	89 c3                	mov    %eax,%ebx
						  obj_field, msg);
			if (orig_path.level >= 3U && ret < 0) {
  11f480:	80 bd 7e ff ff ff 02 	cmpb   $0x2,-0x82(%ebp)
  11f487:	0f 86 36 fd ff ff    	jbe    11f1c3 <do_write_op_json+0xfb>
  11f48d:	85 c0                	test   %eax,%eax
  11f48f:	0f 89 2e fd ff ff    	jns    11f1c3 <do_write_op_json+0xfb>
  11f495:	eb 17                	jmp    11f4ae <do_write_op_json+0x3e6>
				if (res->res_instances[index].res_inst_id ==
  11f497:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  11f49d:	e9 21 fd ff ff       	jmp    11f1c3 <do_write_op_json+0xfb>
				ret = -EINVAL;
  11f4a2:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
  11f4a7:	eb 05                	jmp    11f4ae <do_write_op_json+0x3e6>
				ret = -ENOENT;
  11f4a9:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	in->user_data = NULL;
  11f4ae:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
	}

	engine_clear_in_user_data(&msg->in);

	return ret;
}
  11f4b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11f4b8:	89 d8                	mov    %ebx,%eax
  11f4ba:	5b                   	pop    %ebx
  11f4bb:	5e                   	pop    %esi
  11f4bc:	5f                   	pop    %edi
  11f4bd:	5d                   	pop    %ebp
  11f4be:	c3                   	ret    

0011f4bf <iface_up_handler>:
#endif /* CONFIG_NET_IPV6 */

#if defined(CONFIG_NET_NATIVE)
static void iface_up_handler(struct net_mgmt_event_callback *cb,
			     uint32_t mgmt_event, struct net_if *iface)
{
  11f4bf:	55                   	push   %ebp
  11f4c0:	89 e5                	mov    %esp,%ebp
  11f4c2:	56                   	push   %esi
  11f4c3:	53                   	push   %ebx
	if (mgmt_event == NET_EVENT_IF_UP) {
  11f4c4:	81 7d 0c 02 00 01 d0 	cmpl   $0xd0010002,0xc(%ebp)
{
  11f4cb:	8b 75 10             	mov    0x10(%ebp),%esi
	if (mgmt_event == NET_EVENT_IF_UP) {
  11f4ce:	75 56                	jne    11f526 <iface_up_handler+0x67>
		NET_INFO("Interface %d (%p) coming up",
  11f4d0:	a1 b0 5b 14 00       	mov    0x145bb0,%eax
  11f4d5:	83 e0 07             	and    $0x7,%eax
  11f4d8:	83 f8 02             	cmp    $0x2,%eax
  11f4db:	76 2d                	jbe    11f50a <iface_up_handler+0x4b>
  11f4dd:	56                   	push   %esi
  11f4de:	e8 13 e7 fe ff       	call   10dbf6 <net_if_get_by_iface>
  11f4e3:	bb e0 30 12 00       	mov    $0x1230e0,%ebx
  11f4e8:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11f4ee:	c1 eb 03             	shr    $0x3,%ebx
  11f4f1:	c1 e3 06             	shl    $0x6,%ebx
  11f4f4:	83 cb 03             	or     $0x3,%ebx
  11f4f7:	66 89 1c 24          	mov    %bx,(%esp)
  11f4fb:	56                   	push   %esi
  11f4fc:	50                   	push   %eax
  11f4fd:	68 16 88 12 00       	push   $0x128816
  11f502:	e8 a9 40 fe ff       	call   1035b0 <log_2>
  11f507:	83 c4 10             	add    $0x10,%esp
	sem->count = 0U;
  11f50a:	c7 05 70 e8 12 00 00 	movl   $0x0,0x12e870
  11f511:	00 00 00 
	z_impl_k_sem_give(sem);
  11f514:	c7 45 08 b8 5d 14 00 	movl   $0x145db8,0x8(%ebp)
			 net_if_get_by_iface(iface), iface);

		k_sem_reset(&counter);
		k_sem_give(&waiter);
	}
}
  11f51b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11f51e:	5b                   	pop    %ebx
  11f51f:	5e                   	pop    %esi
  11f520:	5d                   	pop    %ebp
  11f521:	e9 73 23 00 00       	jmp    121899 <z_impl_k_sem_give>
  11f526:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11f529:	5b                   	pop    %ebx
  11f52a:	5e                   	pop    %esi
  11f52b:	5d                   	pop    %ebp
  11f52c:	c3                   	ret    

0011f52d <net_config_init_by_iface>:
}
#endif

int net_config_init_by_iface(struct net_if *iface, const char *app_info,
			     uint32_t flags, int32_t timeout)
{
  11f52d:	55                   	push   %ebp
  11f52e:	89 e5                	mov    %esp,%ebp
  11f530:	57                   	push   %edi
  11f531:	56                   	push   %esi
  11f532:	53                   	push   %ebx
#define LOOP_DIVIDER 10
	int loop = timeout / LOOP_DIVIDER;
  11f533:	bb 0a 00 00 00       	mov    $0xa,%ebx
{
  11f538:	83 ec 20             	sub    $0x20,%esp
	int loop = timeout / LOOP_DIVIDER;
  11f53b:	8b 45 14             	mov    0x14(%ebp),%eax
{
  11f53e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	int loop = timeout / LOOP_DIVIDER;
  11f541:	99                   	cltd   
  11f542:	f7 fb                	idiv   %ebx
{
  11f544:	8b 75 08             	mov    0x8(%ebp),%esi
	int loop = timeout / LOOP_DIVIDER;
  11f547:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int count;

	if (app_info) {
  11f54a:	85 c9                	test   %ecx,%ecx
  11f54c:	74 39                	je     11f587 <net_config_init_by_iface+0x5a>
		NET_INFO("%s", log_strdup(app_info));
  11f54e:	a1 b0 5b 14 00       	mov    0x145bb0,%eax
  11f553:	83 e0 07             	and    $0x7,%eax
  11f556:	83 f8 02             	cmp    $0x2,%eax
  11f559:	76 2c                	jbe    11f587 <net_config_init_by_iface+0x5a>
  11f55b:	51                   	push   %ecx
  11f55c:	e8 f6 3c fe ff       	call   103257 <log_strdup>
  11f561:	bb e0 30 12 00       	mov    $0x1230e0,%ebx
  11f566:	81 eb b0 30 12 00    	sub    $0x1230b0,%ebx
  11f56c:	c1 eb 03             	shr    $0x3,%ebx
  11f56f:	c1 e3 06             	shl    $0x6,%ebx
  11f572:	83 cb 03             	or     $0x3,%ebx
  11f575:	66 89 1c 24          	mov    %bx,(%esp)
  11f579:	50                   	push   %eax
  11f57a:	68 f8 4e 12 00       	push   $0x124ef8
  11f57f:	e8 f2 3f fe ff       	call   103576 <log_1>
  11f584:	83 c4 0c             	add    $0xc,%esp
	}

	if (!iface) {
  11f587:	85 f6                	test   %esi,%esi
  11f589:	75 07                	jne    11f592 <net_config_init_by_iface+0x65>
		iface = net_if_get_default();
  11f58b:	e8 c8 e0 fe ff       	call   10d658 <net_if_get_default>
  11f590:	89 c6                	mov    %eax,%esi
	}

	if (timeout < 0) {
		count = -1;
  11f592:	83 cb ff             	or     $0xffffffff,%ebx
	if (timeout < 0) {
  11f595:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  11f599:	78 15                	js     11f5b0 <net_config_init_by_iface+0x83>
	} else if (timeout == 0) {
		count = 0;
  11f59b:	bb 00 00 00 00       	mov    $0x0,%ebx
	} else if (timeout == 0) {
  11f5a0:	74 0e                	je     11f5b0 <net_config_init_by_iface+0x83>
	} else {
		count = timeout / 1000 + 1;
  11f5a2:	8b 45 14             	mov    0x14(%ebp),%eax
  11f5a5:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
  11f5aa:	99                   	cltd   
  11f5ab:	f7 f9                	idiv   %ecx
  11f5ad:	8d 58 01             	lea    0x1(%eax),%ebx
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  11f5b0:	8b 06                	mov    (%esi),%eax
  11f5b2:	8b 40 0c             	mov    0xc(%eax),%eax
	if (net_if_is_up(iface)) {
  11f5b5:	a8 01                	test   $0x1,%al
  11f5b7:	74 1a                	je     11f5d3 <net_config_init_by_iface+0xa6>
  11f5b9:	c7 05 70 e8 12 00 00 	movl   $0x0,0x12e870
  11f5c0:	00 00 00 
  11f5c3:	68 b8 5d 14 00       	push   $0x145db8
  11f5c8:	e8 cc 22 00 00       	call   121899 <z_impl_k_sem_give>
  11f5cd:	58                   	pop    %eax
  11f5ce:	e9 0b 01 00 00       	jmp    11f6de <net_config_init_by_iface+0x1b1>
	NET_INFO("Waiting interface %d (%p) to be up...",
  11f5d3:	a1 b0 5b 14 00       	mov    0x145bb0,%eax
  11f5d8:	83 e0 07             	and    $0x7,%eax
  11f5db:	83 f8 02             	cmp    $0x2,%eax
  11f5de:	76 2d                	jbe    11f60d <net_config_init_by_iface+0xe0>
  11f5e0:	56                   	push   %esi
  11f5e1:	e8 10 e6 fe ff       	call   10dbf6 <net_if_get_by_iface>
  11f5e6:	bf e0 30 12 00       	mov    $0x1230e0,%edi
  11f5eb:	81 ef b0 30 12 00    	sub    $0x1230b0,%edi
  11f5f1:	c1 ef 03             	shr    $0x3,%edi
  11f5f4:	c1 e7 06             	shl    $0x6,%edi
  11f5f7:	83 cf 03             	or     $0x3,%edi
  11f5fa:	66 89 3c 24          	mov    %di,(%esp)
  11f5fe:	56                   	push   %esi
  11f5ff:	50                   	push   %eax
  11f600:	68 32 88 12 00       	push   $0x128832
  11f605:	e8 a6 3f fe ff       	call   1035b0 <log_2>
  11f60a:	83 c4 10             	add    $0x10,%esp
	net_mgmt_add_event_callback(&mgmt_iface_cb);
  11f60d:	68 50 ed 12 00       	push   $0x12ed50
	cb->handler = handler;
  11f612:	c7 05 54 ed 12 00 bf 	movl   $0x11f4bf,0x12ed54
  11f619:	f4 11 00 
	cb->event_mask = mgmt_event_mask;
  11f61c:	c7 05 58 ed 12 00 02 	movl   $0xd0010002,0x12ed58
  11f623:	00 01 d0 
  11f626:	e8 e0 f0 fe ff       	call   10e70b <net_mgmt_add_event_callback>
	return z_impl_k_sem_init(sem, initial_count, limit);
  11f62b:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  11f632:	6a 01                	push   $0x1
  11f634:	68 60 e8 12 00       	push   $0x12e860
  11f639:	e8 19 22 00 00       	call   121857 <z_impl_k_sem_init>
		while (count-- > 0) {
			if (!k_sem_count_get(&counter)) {
				break;
			}

			if (k_sem_take(&waiter, K_MSEC(loop))) {
  11f63e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11f641:	83 c4 0c             	add    $0xc,%esp
  11f644:	85 c0                	test   %eax,%eax
  11f646:	79 02                	jns    11f64a <net_config_init_by_iface+0x11d>
  11f648:	31 c0                	xor    %eax,%eax
			return t / (from_hz / to_hz);
  11f64a:	6a 00                	push   $0x0
  11f64c:	99                   	cltd   
		t += off;
  11f64d:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  11f650:	6a 0a                	push   $0xa
		t += off;
  11f652:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  11f655:	52                   	push   %edx
  11f656:	50                   	push   %eax
  11f657:	e8 c4 0b fe ff       	call   100220 <__udivdi3>
  11f65c:	83 c4 10             	add    $0x10,%esp
  11f65f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  11f662:	89 55 d8             	mov    %edx,-0x28(%ebp)
		while (count-- > 0) {
  11f665:	89 d8                	mov    %ebx,%eax
  11f667:	4b                   	dec    %ebx
  11f668:	85 c0                	test   %eax,%eax
  11f66a:	7e 09                	jle    11f675 <net_config_init_by_iface+0x148>
			if (!k_sem_count_get(&counter)) {
  11f66c:	83 3d 70 e8 12 00 00 	cmpl   $0x0,0x12e870
  11f673:	75 17                	jne    11f68c <net_config_init_by_iface+0x15f>
				}
			}
		}

#if defined(CONFIG_NET_NATIVE)
		net_mgmt_del_event_callback(&mgmt_iface_cb);
  11f675:	68 50 ed 12 00       	push   $0x12ed50
  11f67a:	e8 d3 f0 fe ff       	call   10e752 <net_mgmt_del_event_callback>
#endif

		/* Network interface did not come up. We will not try
		 * to setup things in that case.
		 */
		if (timeout > 0 && count < 0) {
  11f67f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
		net_mgmt_del_event_callback(&mgmt_iface_cb);
  11f683:	5f                   	pop    %edi
		if (timeout > 0 && count < 0) {
  11f684:	7e 58                	jle    11f6de <net_config_init_by_iface+0x1b1>
  11f686:	85 db                	test   %ebx,%ebx
  11f688:	79 54                	jns    11f6de <net_config_init_by_iface+0x1b1>
  11f68a:	eb 22                	jmp    11f6ae <net_config_init_by_iface+0x181>
	return z_impl_k_sem_take(sem, timeout);
  11f68c:	ff 75 d8             	pushl  -0x28(%ebp)
  11f68f:	ff 75 d4             	pushl  -0x2c(%ebp)
  11f692:	68 b8 5d 14 00       	push   $0x145db8
  11f697:	e8 56 22 00 00       	call   1218f2 <z_impl_k_sem_take>
  11f69c:	83 c4 0c             	add    $0xc,%esp
			if (k_sem_take(&waiter, K_MSEC(loop))) {
  11f69f:	85 c0                	test   %eax,%eax
  11f6a1:	74 c2                	je     11f665 <net_config_init_by_iface+0x138>
				if (!k_sem_count_get(&counter)) {
  11f6a3:	83 3d 70 e8 12 00 00 	cmpl   $0x0,0x12e870
  11f6aa:	75 b9                	jne    11f665 <net_config_init_by_iface+0x138>
  11f6ac:	eb c7                	jmp    11f675 <net_config_init_by_iface+0x148>
			NET_ERR("Timeout while waiting network %s",
  11f6ae:	f6 05 b0 5b 14 00 07 	testb  $0x7,0x145bb0
				"interface");
			return -ENETDOWN;
  11f6b5:	bb c2 ff ff ff       	mov    $0xffffffc2,%ebx
			NET_ERR("Timeout while waiting network %s",
  11f6ba:	0f 84 c1 01 00 00    	je     11f881 <net_config_init_by_iface+0x354>
  11f6c0:	b8 e0 30 12 00       	mov    $0x1230e0,%eax
  11f6c5:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11f6ca:	c1 e8 03             	shr    $0x3,%eax
  11f6cd:	c1 e0 06             	shl    $0x6,%eax
  11f6d0:	83 c8 01             	or     $0x1,%eax
  11f6d3:	50                   	push   %eax
  11f6d4:	68 05 6e 12 00       	push   $0x126e05
  11f6d9:	e9 92 01 00 00       	jmp    11f870 <net_config_init_by_iface+0x343>
  11f6de:	8d 55 e0             	lea    -0x20(%ebp),%edx
  11f6e1:	52                   	push   %edx
  11f6e2:	68 79 88 12 00       	push   $0x128879
  11f6e7:	6a 01                	push   $0x1
  11f6e9:	e8 ef ea fe ff       	call   10e1dd <z_impl_net_addr_pton>
  11f6ee:	83 c4 0c             	add    $0xc,%esp
	if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &addr)) {
  11f6f1:	8d 55 e0             	lea    -0x20(%ebp),%edx
  11f6f4:	85 c0                	test   %eax,%eax
  11f6f6:	74 38                	je     11f730 <net_config_init_by_iface+0x203>
		NET_ERR("Invalid address: %s", CONFIG_NET_CONFIG_MY_IPV4_ADDR);
  11f6f8:	f6 05 b0 5b 14 00 07 	testb  $0x7,0x145bb0
  11f6ff:	0f 84 ea 00 00 00    	je     11f7ef <net_config_init_by_iface+0x2c2>
  11f705:	b8 e0 30 12 00       	mov    $0x1230e0,%eax
  11f70a:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11f70f:	c1 e8 03             	shr    $0x3,%eax
  11f712:	c1 e0 06             	shl    $0x6,%eax
  11f715:	83 c8 01             	or     $0x1,%eax
  11f718:	50                   	push   %eax
  11f719:	68 79 88 12 00       	push   $0x128879
  11f71e:	68 83 88 12 00       	push   $0x128883
  11f723:	e8 4e 3e fe ff       	call   103576 <log_1>
  11f728:	83 c4 0c             	add    $0xc,%esp
		return;
  11f72b:	e9 bf 00 00 00       	jmp    11f7ef <net_config_init_by_iface+0x2c2>
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
  11f730:	6a 00                	push   $0x0
  11f732:	6a 03                	push   $0x3
  11f734:	52                   	push   %edx
  11f735:	56                   	push   %esi
  11f736:	e8 a2 e1 fe ff       	call   10d8dd <net_if_ipv4_addr_add>
	NET_INFO("IPv4 address: %s",
  11f73b:	a1 b0 5b 14 00       	mov    0x145bb0,%eax
	net_if_ipv4_addr_add(iface, &addr, NET_ADDR_MANUAL, 0);
  11f740:	83 c4 10             	add    $0x10,%esp
	NET_INFO("IPv4 address: %s",
  11f743:	83 e0 07             	and    $0x7,%eax
  11f746:	8d 55 e0             	lea    -0x20(%ebp),%edx
  11f749:	83 f8 02             	cmp    $0x2,%eax
  11f74c:	76 3d                	jbe    11f78b <net_config_init_by_iface+0x25e>
  11f74e:	bf e0 30 12 00       	mov    $0x1230e0,%edi
  11f753:	81 ef b0 30 12 00    	sub    $0x1230b0,%edi
  11f759:	c1 ef 03             	shr    $0x3,%edi
  11f75c:	c1 e7 06             	shl    $0x6,%edi
  11f75f:	83 cf 03             	or     $0x3,%edi
	return z_impl_net_addr_ntop(family, src, dst, size);
  11f762:	6a 10                	push   $0x10
  11f764:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  11f767:	50                   	push   %eax
  11f768:	52                   	push   %edx
  11f769:	6a 01                	push   $0x1
  11f76b:	e8 dd e7 fe ff       	call   10df4d <z_impl_net_addr_ntop>
  11f770:	83 c4 10             	add    $0x10,%esp
  11f773:	50                   	push   %eax
  11f774:	e8 de 3a fe ff       	call   103257 <log_strdup>
  11f779:	66 89 3c 24          	mov    %di,(%esp)
  11f77d:	50                   	push   %eax
  11f77e:	68 97 88 12 00       	push   $0x128897
  11f783:	e8 ee 3d fe ff       	call   103576 <log_1>
  11f788:	83 c4 0c             	add    $0xc,%esp
	return z_impl_net_addr_pton(family, src, dst);
  11f78b:	8d 7d e0             	lea    -0x20(%ebp),%edi
  11f78e:	57                   	push   %edi
  11f78f:	68 a8 88 12 00       	push   $0x1288a8
  11f794:	6a 01                	push   $0x1
  11f796:	e8 42 ea fe ff       	call   10e1dd <z_impl_net_addr_pton>
  11f79b:	83 c4 0c             	add    $0xc,%esp
		if (net_addr_pton(AF_INET, CONFIG_NET_CONFIG_MY_IPV4_NETMASK,
  11f79e:	85 c0                	test   %eax,%eax
  11f7a0:	74 31                	je     11f7d3 <net_config_init_by_iface+0x2a6>
			NET_ERR("Invalid netmask: %s",
  11f7a2:	f6 05 b0 5b 14 00 07 	testb  $0x7,0x145bb0
  11f7a9:	74 31                	je     11f7dc <net_config_init_by_iface+0x2af>
  11f7ab:	b8 e0 30 12 00       	mov    $0x1230e0,%eax
  11f7b0:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11f7b5:	c1 e8 03             	shr    $0x3,%eax
  11f7b8:	c1 e0 06             	shl    $0x6,%eax
  11f7bb:	83 c8 01             	or     $0x1,%eax
  11f7be:	50                   	push   %eax
  11f7bf:	68 a8 88 12 00       	push   $0x1288a8
  11f7c4:	68 b6 88 12 00       	push   $0x1288b6
  11f7c9:	e8 a8 3d fe ff       	call   103576 <log_1>
  11f7ce:	83 c4 0c             	add    $0xc,%esp
  11f7d1:	eb 09                	jmp    11f7dc <net_config_init_by_iface+0x2af>
			net_if_ipv4_set_netmask(iface, &addr);
  11f7d3:	57                   	push   %edi
  11f7d4:	56                   	push   %esi
  11f7d5:	e8 da e0 fe ff       	call   10d8b4 <net_if_ipv4_set_netmask>
  11f7da:	5a                   	pop    %edx
  11f7db:	59                   	pop    %ecx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  11f7dc:	f0 83 0d 5c ed 12 00 	lock orl $0x4,0x12ed5c
  11f7e3:	04 
	z_impl_k_sem_give(sem);
  11f7e4:	68 b8 5d 14 00       	push   $0x145db8
  11f7e9:	e8 ab 20 00 00       	call   121899 <z_impl_k_sem_give>
  11f7ee:	58                   	pop    %eax

	/* Loop here until we are ready to continue. As we might need
	 * to wait multiple events, sleep smaller amounts of data.
	 */
	while (!services_are_ready(flags) && count-- > 0) {
		k_sem_take(&waiter, K_MSEC(loop));
  11f7ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
  11f7f2:	85 c0                	test   %eax,%eax
  11f7f4:	79 02                	jns    11f7f8 <net_config_init_by_iface+0x2cb>
  11f7f6:	31 c0                	xor    %eax,%eax
  11f7f8:	6a 00                	push   $0x0
  11f7fa:	99                   	cltd   
		t += off;
  11f7fb:	83 c0 09             	add    $0x9,%eax
			return t / (from_hz / to_hz);
  11f7fe:	6a 0a                	push   $0xa
		t += off;
  11f800:	83 d2 00             	adc    $0x0,%edx
			return t / (from_hz / to_hz);
  11f803:	52                   	push   %edx
  11f804:	50                   	push   %eax
  11f805:	e8 16 0a fe ff       	call   100220 <__udivdi3>
  11f80a:	83 c4 10             	add    $0x10,%esp
  11f80d:	89 c6                	mov    %eax,%esi
  11f80f:	89 d7                	mov    %edx,%edi
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  11f811:	a1 5c ed 12 00       	mov    0x12ed5c,%eax
	return (atomic_get(&services_flags) & flags) == flags;
  11f816:	23 45 10             	and    0x10(%ebp),%eax
	while (!services_are_ready(flags) && count-- > 0) {
  11f819:	39 45 10             	cmp    %eax,0x10(%ebp)
  11f81c:	74 22                	je     11f840 <net_config_init_by_iface+0x313>
  11f81e:	8d 53 ff             	lea    -0x1(%ebx),%edx
  11f821:	85 db                	test   %ebx,%ebx
  11f823:	7e 19                	jle    11f83e <net_config_init_by_iface+0x311>
  11f825:	89 55 dc             	mov    %edx,-0x24(%ebp)
	return z_impl_k_sem_take(sem, timeout);
  11f828:	57                   	push   %edi
  11f829:	56                   	push   %esi
  11f82a:	68 b8 5d 14 00       	push   $0x145db8
  11f82f:	e8 be 20 00 00       	call   1218f2 <z_impl_k_sem_take>
  11f834:	8b 55 dc             	mov    -0x24(%ebp),%edx
  11f837:	83 c4 0c             	add    $0xc,%esp
  11f83a:	89 d3                	mov    %edx,%ebx
  11f83c:	eb d3                	jmp    11f811 <net_config_init_by_iface+0x2e4>
  11f83e:	89 d3                	mov    %edx,%ebx
	}

	if (count == -1 && timeout > 0) {
  11f840:	43                   	inc    %ebx
  11f841:	75 3c                	jne    11f87f <net_config_init_by_iface+0x352>
  11f843:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  11f847:	7e 36                	jle    11f87f <net_config_init_by_iface+0x352>
		NET_ERR("Timeout while waiting network %s", "setup");
  11f849:	f6 05 b0 5b 14 00 07 	testb  $0x7,0x145bb0
		return -ETIMEDOUT;
  11f850:	bb c4 ff ff ff       	mov    $0xffffffc4,%ebx
		NET_ERR("Timeout while waiting network %s", "setup");
  11f855:	74 2a                	je     11f881 <net_config_init_by_iface+0x354>
  11f857:	b8 e0 30 12 00       	mov    $0x1230e0,%eax
  11f85c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  11f861:	c1 e8 03             	shr    $0x3,%eax
  11f864:	c1 e0 06             	shl    $0x6,%eax
  11f867:	83 c8 01             	or     $0x1,%eax
  11f86a:	50                   	push   %eax
  11f86b:	68 ca 88 12 00       	push   $0x1288ca
  11f870:	68 58 88 12 00       	push   $0x128858
  11f875:	e8 fc 3c fe ff       	call   103576 <log_1>
  11f87a:	83 c4 0c             	add    $0xc,%esp
  11f87d:	eb 02                	jmp    11f881 <net_config_init_by_iface+0x354>
	}

	return 0;
  11f87f:	31 db                	xor    %ebx,%ebx
}
  11f881:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11f884:	89 d8                	mov    %ebx,%eax
  11f886:	5b                   	pop    %ebx
  11f887:	5e                   	pop    %esi
  11f888:	5f                   	pop    %edi
  11f889:	5d                   	pop    %ebp
  11f88a:	c3                   	ret    

0011f88b <net_config_init_app>:
{
	return net_config_init_by_iface(NULL, app_info, flags, timeout);
}

int net_config_init_app(const struct device *dev, const char *app_info)
{
  11f88b:	55                   	push   %ebp
  11f88c:	89 e5                	mov    %esp,%ebp
  11f88e:	56                   	push   %esi
  11f88f:	53                   	push   %ebx
  11f890:	51                   	push   %ecx
  11f891:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct net_if *iface = NULL;
	uint32_t flags = 0U;
	int ret;

	if (dev) {
  11f894:	85 db                	test   %ebx,%ebx
  11f896:	75 04                	jne    11f89c <net_config_init_app+0x11>
	struct net_if *iface = NULL;
  11f898:	31 f6                	xor    %esi,%esi
  11f89a:	eb 39                	jmp    11f8d5 <net_config_init_app+0x4a>
		iface = net_if_lookup_by_dev(dev);
  11f89c:	53                   	push   %ebx
  11f89d:	e8 95 dd fe ff       	call   10d637 <net_if_lookup_by_dev>
  11f8a2:	5a                   	pop    %edx
  11f8a3:	89 c6                	mov    %eax,%esi
		if (iface == NULL) {
  11f8a5:	85 c0                	test   %eax,%eax
  11f8a7:	75 2c                	jne    11f8d5 <net_config_init_app+0x4a>
			NET_WARN("No interface for device %p, using default",
  11f8a9:	f6 05 b0 5b 14 00 06 	testb  $0x6,0x145bb0
  11f8b0:	74 e6                	je     11f898 <net_config_init_app+0xd>
  11f8b2:	ba e0 30 12 00       	mov    $0x1230e0,%edx
  11f8b7:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11f8bd:	c1 ea 03             	shr    $0x3,%edx
  11f8c0:	c1 e2 06             	shl    $0x6,%edx
  11f8c3:	83 ca 02             	or     $0x2,%edx
  11f8c6:	52                   	push   %edx
  11f8c7:	53                   	push   %ebx
  11f8c8:	68 d0 88 12 00       	push   $0x1288d0
  11f8cd:	e8 a4 3c fe ff       	call   103576 <log_1>
  11f8d2:	83 c4 0c             	add    $0xc,%esp
	if (IS_ENABLED(CONFIG_NET_CONFIG_NEED_IPV4)) {
		flags |= NET_CONFIG_NEED_IPV4;
	}

	/* Initialize the application automatically if needed */
	ret = net_config_init_by_iface(iface, app_info, flags,
  11f8d5:	68 30 75 00 00       	push   $0x7530
  11f8da:	6a 00                	push   $0x0
  11f8dc:	ff 75 0c             	pushl  0xc(%ebp)
  11f8df:	56                   	push   %esi
  11f8e0:	e8 48 fc ff ff       	call   11f52d <net_config_init_by_iface>
  11f8e5:	83 c4 10             	add    $0x10,%esp
				CONFIG_NET_CONFIG_INIT_TIMEOUT * MSEC_PER_SEC);
	if (ret < 0) {
  11f8e8:	85 c0                	test   %eax,%eax
  11f8ea:	79 32                	jns    11f91e <net_config_init_app+0x93>
		NET_ERR("Network initialization failed (%d)", ret);
  11f8ec:	f6 05 b0 5b 14 00 07 	testb  $0x7,0x145bb0
  11f8f3:	74 29                	je     11f91e <net_config_init_app+0x93>
  11f8f5:	ba e0 30 12 00       	mov    $0x1230e0,%edx
  11f8fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  11f8fd:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  11f903:	c1 ea 03             	shr    $0x3,%edx
  11f906:	c1 e2 06             	shl    $0x6,%edx
  11f909:	83 ca 01             	or     $0x1,%edx
  11f90c:	52                   	push   %edx
  11f90d:	50                   	push   %eax
  11f90e:	68 fa 88 12 00       	push   $0x1288fa
  11f913:	e8 5e 3c fe ff       	call   103576 <log_1>
  11f918:	83 c4 0c             	add    $0xc,%esp
  11f91b:	8b 45 f4             	mov    -0xc(%ebp),%eax
			log_backend_activate(backend, NULL);
		}
	}

	return ret;
}
  11f91e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  11f921:	5b                   	pop    %ebx
  11f922:	5e                   	pop    %esi
  11f923:	5d                   	pop    %ebp
  11f924:	c3                   	ret    

0011f925 <init_app>:

#if defined(CONFIG_NET_CONFIG_AUTO_INIT)
static int init_app(const struct device *dev)
{
  11f925:	55                   	push   %ebp
  11f926:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	(void)net_config_init_app(NULL, "Initializing network");
  11f928:	68 1d 89 12 00       	push   $0x12891d
  11f92d:	6a 00                	push   $0x0
  11f92f:	e8 57 ff ff ff       	call   11f88b <net_config_init_app>
  11f934:	58                   	pop    %eax

	return 0;
}
  11f935:	31 c0                	xor    %eax,%eax
	(void)net_config_init_app(NULL, "Initializing network");
  11f937:	5a                   	pop    %edx
}
  11f938:	c9                   	leave  
  11f939:	c3                   	ret    

0011f93a <parse_url_char>:
 * This function should only be invoked with non-space characters. It is
 * assumed that the caller cares about (and can detect) the transition between
 * URL and non-URL states by looking for these.
 */
enum state parse_url_char(enum state s, const char ch)
{
  11f93a:	55                   	push   %ebp
  11f93b:	89 e5                	mov    %esp,%ebp
  11f93d:	53                   	push   %ebx
  11f93e:	8b 55 0c             	mov    0xc(%ebp),%edx
  11f941:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ch == ' ' || ch == '\r' || ch == '\n') {
  11f944:	8d 4a f6             	lea    -0xa(%edx),%ecx
  11f947:	80 f9 16             	cmp    $0x16,%cl
  11f94a:	77 0e                	ja     11f95a <parse_url_char+0x20>
  11f94c:	bb 09 00 40 00       	mov    $0x400009,%ebx
  11f951:	0f a3 cb             	bt     %ecx,%ebx
  11f954:	0f 82 2f 02 00 00    	jb     11fb89 <parse_url_char+0x24f>
	if (ch == '\t' || ch == '\f') {
		return s_dead;
	}
#endif

	switch (s) {
  11f95a:	8d 48 ec             	lea    -0x14(%eax),%ecx
  11f95d:	83 f9 0b             	cmp    $0xb,%ecx
  11f960:	0f 87 23 02 00 00    	ja     11fb89 <parse_url_char+0x24f>
  11f966:	ff 24 8d 04 46 12 00 	jmp    *0x124604(,%ecx,4)
		/* Proxied requests are followed by scheme of an absolute URI
		 * (alpha).
		 * All methods except CONNECT are followed by '/' or '*'.
		 */

		if (ch == '/' || ch == '*') {
  11f96d:	80 fa 2f             	cmp    $0x2f,%dl
  11f970:	0f 84 fe 01 00 00    	je     11fb74 <parse_url_char+0x23a>
  11f976:	80 fa 2a             	cmp    $0x2a,%dl
  11f979:	0f 84 f5 01 00 00    	je     11fb74 <parse_url_char+0x23a>
			return s_req_path;
		}

		if (IS_ALPHA(ch)) {
  11f97f:	83 ca 20             	or     $0x20,%edx
  11f982:	83 ea 61             	sub    $0x61,%edx
			return s_req_schema;
  11f985:	80 fa 1a             	cmp    $0x1a,%dl
  11f988:	19 c0                	sbb    %eax,%eax
  11f98a:	83 e0 14             	and    $0x14,%eax
  11f98d:	40                   	inc    %eax
  11f98e:	e9 fb 01 00 00       	jmp    11fb8e <parse_url_char+0x254>
		}

		break;

	case s_req_schema:
		if (IS_ALPHA(ch)) {
  11f993:	88 d1                	mov    %dl,%cl
  11f995:	83 c9 20             	or     $0x20,%ecx
  11f998:	83 e9 61             	sub    $0x61,%ecx
  11f99b:	80 f9 19             	cmp    $0x19,%cl
  11f99e:	0f 86 ea 01 00 00    	jbe    11fb8e <parse_url_char+0x254>
			return s;
		}

		if (ch == ':') {
			return s_req_schema_slash;
  11f9a4:	31 c0                	xor    %eax,%eax
  11f9a6:	80 fa 3a             	cmp    $0x3a,%dl
  11f9a9:	0f 94 c0             	sete   %al
  11f9ac:	48                   	dec    %eax
  11f9ad:	83 e0 eb             	and    $0xffffffeb,%eax
  11f9b0:	83 c0 16             	add    $0x16,%eax
  11f9b3:	e9 d6 01 00 00       	jmp    11fb8e <parse_url_char+0x254>

		break;

	case s_req_schema_slash:
		if (ch == '/') {
			return s_req_schema_slash_slash;
  11f9b8:	31 c0                	xor    %eax,%eax
  11f9ba:	80 fa 2f             	cmp    $0x2f,%dl
  11f9bd:	0f 94 c0             	sete   %al
  11f9c0:	48                   	dec    %eax
  11f9c1:	83 e0 ea             	and    $0xffffffea,%eax
  11f9c4:	83 c0 17             	add    $0x17,%eax
  11f9c7:	e9 c2 01 00 00       	jmp    11fb8e <parse_url_char+0x254>

		break;

	case s_req_schema_slash_slash:
		if (ch == '/') {
			return s_req_server_start;
  11f9cc:	31 c0                	xor    %eax,%eax
  11f9ce:	80 fa 2f             	cmp    $0x2f,%dl
  11f9d1:	0f 94 c0             	sete   %al
  11f9d4:	48                   	dec    %eax
  11f9d5:	83 e0 e9             	and    $0xffffffe9,%eax
  11f9d8:	83 c0 18             	add    $0x18,%eax
  11f9db:	e9 ae 01 00 00       	jmp    11fb8e <parse_url_char+0x254>
		return s_dead;
  11f9e0:	b8 01 00 00 00       	mov    $0x1,%eax
		}

		break;

	case s_req_server_with_at:
		if (ch == '@') {
  11f9e5:	80 fa 40             	cmp    $0x40,%dl
  11f9e8:	0f 84 a0 01 00 00    	je     11fb8e <parse_url_char+0x254>
			return s_req_path;
  11f9ee:	b8 1b 00 00 00       	mov    $0x1b,%eax
		}

		__fallthrough;
	case s_req_server_start:
	case s_req_server:
		if (ch == '/') {
  11f9f3:	80 fa 2f             	cmp    $0x2f,%dl
  11f9f6:	0f 84 92 01 00 00    	je     11fb8e <parse_url_char+0x254>
			return s_req_path;
		}

		if (ch == '?') {
			return s_req_query_string_start;
  11f9fc:	b8 1c 00 00 00       	mov    $0x1c,%eax
		if (ch == '?') {
  11fa01:	80 fa 3f             	cmp    $0x3f,%dl
  11fa04:	0f 84 84 01 00 00    	je     11fb8e <parse_url_char+0x254>
		}

		if (ch == '@') {
			return s_req_server_with_at;
  11fa0a:	b8 1a 00 00 00       	mov    $0x1a,%eax
		if (ch == '@') {
  11fa0f:	80 fa 40             	cmp    $0x40,%dl
  11fa12:	0f 84 76 01 00 00    	je     11fb8e <parse_url_char+0x254>
		}

		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
  11fa18:	88 d1                	mov    %dl,%cl
			return s_req_server;
  11fa1a:	b8 19 00 00 00       	mov    $0x19,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
  11fa1f:	83 c9 20             	or     $0x20,%ecx
  11fa22:	83 e9 61             	sub    $0x61,%ecx
  11fa25:	80 f9 19             	cmp    $0x19,%cl
  11fa28:	0f 86 60 01 00 00    	jbe    11fb8e <parse_url_char+0x254>
  11fa2e:	8d 4a d0             	lea    -0x30(%edx),%ecx
  11fa31:	80 f9 09             	cmp    $0x9,%cl
  11fa34:	0f 86 54 01 00 00    	jbe    11fb8e <parse_url_char+0x254>
  11fa3a:	8d 4a df             	lea    -0x21(%edx),%ecx
  11fa3d:	80 f9 1a             	cmp    $0x1a,%cl
  11fa40:	77 0e                	ja     11fa50 <parse_url_char+0x116>
  11fa42:	bb 39 3f 00 06       	mov    $0x6003f39,%ebx
  11fa47:	0f a3 cb             	bt     %ecx,%ebx
  11fa4a:	0f 82 3e 01 00 00    	jb     11fb8e <parse_url_char+0x254>
			return s_req_server;
  11fa50:	b8 19 00 00 00       	mov    $0x19,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
  11fa55:	80 fa 7e             	cmp    $0x7e,%dl
  11fa58:	0f 84 30 01 00 00    	je     11fb8e <parse_url_char+0x254>
  11fa5e:	8d 4a d9             	lea    -0x27(%edx),%ecx
  11fa61:	80 f9 01             	cmp    $0x1,%cl
  11fa64:	0f 86 24 01 00 00    	jbe    11fb8e <parse_url_char+0x254>
  11fa6a:	8d 4a c3             	lea    -0x3d(%edx),%ecx
  11fa6d:	80 e1 df             	and    $0xdf,%cl
  11fa70:	0f 84 18 01 00 00    	je     11fb8e <parse_url_char+0x254>
			return s_req_server;
  11fa76:	31 c0                	xor    %eax,%eax
		if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
  11fa78:	83 e2 fb             	and    $0xfffffffb,%edx
			return s_req_server;
  11fa7b:	80 fa 5b             	cmp    $0x5b,%dl
  11fa7e:	0f 94 c0             	sete   %al
  11fa81:	48                   	dec    %eax
  11fa82:	83 e0 e8             	and    $0xffffffe8,%eax
  11fa85:	83 c0 19             	add    $0x19,%eax
  11fa88:	e9 01 01 00 00       	jmp    11fb8e <parse_url_char+0x254>
		}

		break;

	case s_req_path:
		if (IS_URL_CHAR(ch)) {
  11fa8d:	88 d1                	mov    %dl,%cl
  11fa8f:	c0 e9 03             	shr    $0x3,%cl
  11fa92:	0f b6 c9             	movzbl %cl,%ecx
  11fa95:	0f b6 99 e0 3d 12 00 	movzbl 0x123de0(%ecx),%ebx
  11fa9c:	88 d1                	mov    %dl,%cl
  11fa9e:	83 e1 07             	and    $0x7,%ecx
  11faa1:	0f a3 cb             	bt     %ecx,%ebx
  11faa4:	0f 82 e4 00 00 00    	jb     11fb8e <parse_url_char+0x254>
  11faaa:	84 d2                	test   %dl,%dl
  11faac:	0f 88 dc 00 00 00    	js     11fb8e <parse_url_char+0x254>
		switch (ch) {
		case '?':
			return s_req_query_string_start;

		case '#':
			return s_req_fragment_start;
  11fab2:	b8 1e 00 00 00       	mov    $0x1e,%eax
  11fab7:	80 fa 23             	cmp    $0x23,%dl
  11faba:	0f 84 ce 00 00 00    	je     11fb8e <parse_url_char+0x254>
  11fac0:	31 c0                	xor    %eax,%eax
  11fac2:	80 fa 3f             	cmp    $0x3f,%dl
  11fac5:	0f 94 c0             	sete   %al
  11fac8:	48                   	dec    %eax
  11fac9:	83 e0 e5             	and    $0xffffffe5,%eax
  11facc:	83 c0 1c             	add    $0x1c,%eax
  11facf:	e9 ba 00 00 00       	jmp    11fb8e <parse_url_char+0x254>

		break;

	case s_req_query_string_start:
	case s_req_query_string:
		if (IS_URL_CHAR(ch)) {
  11fad4:	88 d0                	mov    %dl,%al
  11fad6:	c0 e8 03             	shr    $0x3,%al
  11fad9:	0f b6 c0             	movzbl %al,%eax
  11fadc:	0f b6 88 e0 3d 12 00 	movzbl 0x123de0(%eax),%ecx
  11fae3:	88 d0                	mov    %dl,%al
  11fae5:	83 e0 07             	and    $0x7,%eax
  11fae8:	0f a3 c1             	bt     %eax,%ecx
  11faeb:	0f 82 8a 00 00 00    	jb     11fb7b <parse_url_char+0x241>
  11faf1:	84 d2                	test   %dl,%dl
  11faf3:	0f 88 82 00 00 00    	js     11fb7b <parse_url_char+0x241>
			return s_req_fragment_start;
  11faf9:	b8 1e 00 00 00       	mov    $0x1e,%eax
  11fafe:	80 fa 23             	cmp    $0x23,%dl
  11fb01:	0f 84 87 00 00 00    	je     11fb8e <parse_url_char+0x254>
  11fb07:	31 c0                	xor    %eax,%eax
  11fb09:	80 fa 3f             	cmp    $0x3f,%dl
  11fb0c:	0f 94 c0             	sete   %al
  11fb0f:	48                   	dec    %eax
  11fb10:	83 e0 e4             	and    $0xffffffe4,%eax
  11fb13:	83 c0 1d             	add    $0x1d,%eax
  11fb16:	eb 76                	jmp    11fb8e <parse_url_char+0x254>
		}

		break;

	case s_req_fragment_start:
		if (IS_URL_CHAR(ch)) {
  11fb18:	88 d1                	mov    %dl,%cl
  11fb1a:	c0 e9 03             	shr    $0x3,%cl
  11fb1d:	0f b6 c9             	movzbl %cl,%ecx
  11fb20:	0f b6 99 e0 3d 12 00 	movzbl 0x123de0(%ecx),%ebx
  11fb27:	88 d1                	mov    %dl,%cl
  11fb29:	83 e1 07             	and    $0x7,%ecx
  11fb2c:	0f a3 cb             	bt     %ecx,%ebx
  11fb2f:	72 51                	jb     11fb82 <parse_url_char+0x248>
  11fb31:	84 d2                	test   %dl,%dl
  11fb33:	78 4d                	js     11fb82 <parse_url_char+0x248>
			return s_req_fragment;
		}

		switch (ch) {
  11fb35:	80 fa 23             	cmp    $0x23,%dl
  11fb38:	74 54                	je     11fb8e <parse_url_char+0x254>
		case '?':
			return s_req_fragment;
  11fb3a:	31 c0                	xor    %eax,%eax
  11fb3c:	80 fa 3f             	cmp    $0x3f,%dl
  11fb3f:	0f 94 c0             	sete   %al
  11fb42:	48                   	dec    %eax
  11fb43:	83 e0 e2             	and    $0xffffffe2,%eax
  11fb46:	83 c0 1f             	add    $0x1f,%eax
  11fb49:	eb 43                	jmp    11fb8e <parse_url_char+0x254>
		}

		break;

	case s_req_fragment:
		if (IS_URL_CHAR(ch)) {
  11fb4b:	88 d1                	mov    %dl,%cl
  11fb4d:	c0 e9 03             	shr    $0x3,%cl
  11fb50:	0f b6 c9             	movzbl %cl,%ecx
  11fb53:	0f b6 99 e0 3d 12 00 	movzbl 0x123de0(%ecx),%ebx
  11fb5a:	88 d1                	mov    %dl,%cl
  11fb5c:	83 e1 07             	and    $0x7,%ecx
  11fb5f:	0f a3 cb             	bt     %ecx,%ebx
  11fb62:	72 2a                	jb     11fb8e <parse_url_char+0x254>
  11fb64:	84 d2                	test   %dl,%dl
  11fb66:	78 26                	js     11fb8e <parse_url_char+0x254>
			return s;
		}

		switch (ch) {
  11fb68:	80 fa 23             	cmp    $0x23,%dl
  11fb6b:	74 21                	je     11fb8e <parse_url_char+0x254>
  11fb6d:	80 fa 3f             	cmp    $0x3f,%dl
  11fb70:	75 17                	jne    11fb89 <parse_url_char+0x24f>
  11fb72:	eb 1a                	jmp    11fb8e <parse_url_char+0x254>
			return s_req_path;
  11fb74:	b8 1b 00 00 00       	mov    $0x1b,%eax
  11fb79:	eb 13                	jmp    11fb8e <parse_url_char+0x254>
			return s_req_query_string;
  11fb7b:	b8 1d 00 00 00       	mov    $0x1d,%eax
  11fb80:	eb 0c                	jmp    11fb8e <parse_url_char+0x254>
			return s_req_fragment;
  11fb82:	b8 1f 00 00 00       	mov    $0x1f,%eax
  11fb87:	eb 05                	jmp    11fb8e <parse_url_char+0x254>
  11fb89:	b8 01 00 00 00       	mov    $0x1,%eax

	/* We should never fall out of the switch above unless there's
	 * an error
	 */
	return s_dead;
}
  11fb8e:	5b                   	pop    %ebx
  11fb8f:	5d                   	pop    %ebp
  11fb90:	c3                   	ret    

0011fb91 <http_parser_url_init>:
	return 0;
}

void
http_parser_url_init(struct http_parser_url *u)
{
  11fb91:	55                   	push   %ebp
  11fb92:	89 e5                	mov    %esp,%ebp
	(void)memset(u, 0, sizeof(*u));
  11fb94:	6a 20                	push   $0x20
  11fb96:	6a 00                	push   $0x0
  11fb98:	ff 75 08             	pushl  0x8(%ebp)
  11fb9b:	e8 bb c2 fe ff       	call   10be5b <memset>
  11fba0:	83 c4 0c             	add    $0xc,%esp
}
  11fba3:	c9                   	leave  
  11fba4:	c3                   	ret    

0011fba5 <http_parser_parse_url>:

int
http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
		      struct http_parser_url *u)
{
  11fba5:	55                   	push   %ebp
  11fba6:	89 e5                	mov    %esp,%ebp
  11fba8:	57                   	push   %edi
  11fba9:	56                   	push   %esi
		}

		u->field_data[uf].off = p - buf;
		u->field_data[uf].len = 1U;

		u->field_set |= (1 << uf);
  11fbaa:	bf 07 00 00 00       	mov    $0x7,%edi
{
  11fbaf:	53                   	push   %ebx
  11fbb0:	83 ec 08             	sub    $0x8,%esp
		u->field_set |= (1 << uf);
  11fbb3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  11fbba:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
{
  11fbbe:	8b 5d 14             	mov    0x14(%ebp),%ebx
		u->field_set |= (1 << uf);
  11fbc1:	8b 75 08             	mov    0x8(%ebp),%esi
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  11fbc4:	19 c0                	sbb    %eax,%eax
	for (p = buf; p < buf + buflen; p++) {
  11fbc6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  11fbc9:	83 e0 fc             	and    $0xfffffffc,%eax
	for (p = buf; p < buf + buflen; p++) {
  11fbcc:	01 f1                	add    %esi,%ecx
	u->port = u->field_set = 0U;
  11fbce:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  11fbd4:	83 c0 18             	add    $0x18,%eax
	for (p = buf; p < buf + buflen; p++) {
  11fbd7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  11fbda:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  11fbdd:	73 6c                	jae    11fc4b <http_parser_parse_url+0xa6>
		s = parse_url_char(s, *p);
  11fbdf:	0f be 16             	movsbl (%esi),%edx
  11fbe2:	52                   	push   %edx
  11fbe3:	50                   	push   %eax
  11fbe4:	e8 51 fd ff ff       	call   11f93a <parse_url_char>
  11fbe9:	5a                   	pop    %edx
  11fbea:	8d 50 eb             	lea    -0x15(%eax),%edx
  11fbed:	59                   	pop    %ecx
		switch (s) {
  11fbee:	83 fa 0a             	cmp    $0xa,%edx
  11fbf1:	77 6a                	ja     11fc5d <http_parser_parse_url+0xb8>
  11fbf3:	ff 24 95 34 46 12 00 	jmp    *0x124634(,%edx,4)
			found_at = 1;
  11fbfa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			uf = UF_HOST;
  11fc01:	b9 01 00 00 00       	mov    $0x1,%ecx
  11fc06:	eb 17                	jmp    11fc1f <http_parser_parse_url+0x7a>
			uf = UF_PATH;
  11fc08:	b9 03 00 00 00       	mov    $0x3,%ecx
			break;
  11fc0d:	eb 10                	jmp    11fc1f <http_parser_parse_url+0x7a>
			uf = UF_QUERY;
  11fc0f:	b9 04 00 00 00       	mov    $0x4,%ecx
			break;
  11fc14:	eb 09                	jmp    11fc1f <http_parser_parse_url+0x7a>
			uf = UF_FRAGMENT;
  11fc16:	b9 05 00 00 00       	mov    $0x5,%ecx
			break;
  11fc1b:	eb 02                	jmp    11fc1f <http_parser_parse_url+0x7a>
		s = parse_url_char(s, *p);
  11fc1d:	31 c9                	xor    %ecx,%ecx
		if (uf == old_uf) {
  11fc1f:	39 cf                	cmp    %ecx,%edi
  11fc21:	75 07                	jne    11fc2a <http_parser_parse_url+0x85>
			u->field_data[uf].len++;
  11fc23:	66 ff 44 bb 06       	incw   0x6(%ebx,%edi,4)
			continue;
  11fc28:	eb 1e                	jmp    11fc48 <http_parser_parse_url+0xa3>
		u->field_data[uf].off = p - buf;
  11fc2a:	89 f7                	mov    %esi,%edi
  11fc2c:	8d 14 8b             	lea    (%ebx,%ecx,4),%edx
  11fc2f:	2b 7d 08             	sub    0x8(%ebp),%edi
		u->field_data[uf].len = 1U;
  11fc32:	66 c7 42 06 01 00    	movw   $0x1,0x6(%edx)
		u->field_data[uf].off = p - buf;
  11fc38:	66 89 7a 04          	mov    %di,0x4(%edx)
		u->field_set |= (1 << uf);
  11fc3c:	ba 01 00 00 00       	mov    $0x1,%edx
  11fc41:	89 cf                	mov    %ecx,%edi
  11fc43:	d3 e2                	shl    %cl,%edx
  11fc45:	66 09 13             	or     %dx,(%ebx)
	for (p = buf; p < buf + buflen; p++) {
  11fc48:	46                   	inc    %esi
  11fc49:	eb 8f                	jmp    11fbda <http_parser_parse_url+0x35>
		old_uf = uf;
	}

	/* host must be present if there is a schema */
	/* parsing http:///toto will fail */
	if ((u->field_set & (1 << UF_SCHEMA)) &&
  11fc4b:	66 8b 13             	mov    (%ebx),%dx
  11fc4e:	89 d0                	mov    %edx,%eax
  11fc50:	83 e0 02             	and    $0x2,%eax
  11fc53:	80 e2 01             	and    $0x1,%dl
  11fc56:	74 11                	je     11fc69 <http_parser_parse_url+0xc4>
  11fc58:	66 85 c0             	test   %ax,%ax
  11fc5b:	75 15                	jne    11fc72 <http_parser_parse_url+0xcd>
			(u->field_set & (1 << UF_HOST)) == 0U) {
		return 1;
  11fc5d:	c7 45 10 01 00 00 00 	movl   $0x1,0x10(%ebp)
  11fc64:	e9 de 02 00 00       	jmp    11ff47 <http_parser_parse_url+0x3a2>
	}

	if (u->field_set & (1 << UF_HOST)) {
  11fc69:	66 85 c0             	test   %ax,%ax
  11fc6c:	0f 84 16 02 00 00    	je     11fe88 <http_parser_parse_url+0x2e3>
	buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;
  11fc72:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  11fc76:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  11fc7a:	01 f2                	add    %esi,%edx
	u->field_data[UF_HOST].len = 0U;
  11fc7c:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	s = found_at ? s_http_userinfo_start : s_http_host_start;
  11fc82:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
  11fc86:	19 c0                	sbb    %eax,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
  11fc88:	03 55 08             	add    0x8(%ebp),%edx
	s = found_at ? s_http_userinfo_start : s_http_host_start;
  11fc8b:	83 e0 02             	and    $0x2,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
  11fc8e:	03 75 08             	add    0x8(%ebp),%esi
	s = found_at ? s_http_userinfo_start : s_http_host_start;
  11fc91:	83 c0 02             	add    $0x2,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
  11fc94:	89 55 f0             	mov    %edx,-0x10(%ebp)
		if (IS_USERINFO_CHAR(ch)) {
  11fc97:	bf 39 3f 00 16       	mov    $0x16003f39,%edi
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
  11fc9c:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  11fc9f:	0f 83 c9 01 00 00    	jae    11fe6e <http_parser_parse_url+0x2c9>
		enum http_host_state new_s = http_parse_host_char(s, *p);
  11fca5:	8d 50 fe             	lea    -0x2(%eax),%edx
  11fca8:	8a 0e                	mov    (%esi),%cl
	switch (s) {
  11fcaa:	83 fa 0a             	cmp    $0xa,%edx
  11fcad:	77 ae                	ja     11fc5d <http_parser_parse_url+0xb8>
  11fcaf:	ff 24 95 60 46 12 00 	jmp    *0x124660(,%edx,4)
		if (ch == '@') {
  11fcb6:	80 f9 40             	cmp    $0x40,%cl
  11fcb9:	0f 84 96 01 00 00    	je     11fe55 <http_parser_parse_url+0x2b0>
		if (IS_USERINFO_CHAR(ch)) {
  11fcbf:	88 ca                	mov    %cl,%dl
  11fcc1:	83 ca 20             	or     $0x20,%edx
  11fcc4:	83 ea 61             	sub    $0x61,%edx
  11fcc7:	80 fa 19             	cmp    $0x19,%dl
  11fcca:	0f 86 51 02 00 00    	jbe    11ff21 <http_parser_parse_url+0x37c>
  11fcd0:	8d 51 d0             	lea    -0x30(%ecx),%edx
  11fcd3:	80 fa 09             	cmp    $0x9,%dl
  11fcd6:	0f 86 45 02 00 00    	jbe    11ff21 <http_parser_parse_url+0x37c>
  11fcdc:	80 f9 5f             	cmp    $0x5f,%cl
  11fcdf:	0f 84 3c 02 00 00    	je     11ff21 <http_parser_parse_url+0x37c>
  11fce5:	8d 51 df             	lea    -0x21(%ecx),%edx
  11fce8:	80 fa 1c             	cmp    $0x1c,%dl
  11fceb:	77 09                	ja     11fcf6 <http_parser_parse_url+0x151>
  11fced:	0f a3 d7             	bt     %edx,%edi
  11fcf0:	0f 82 2b 02 00 00    	jb     11ff21 <http_parser_parse_url+0x37c>
  11fcf6:	80 f9 7e             	cmp    $0x7e,%cl
  11fcf9:	0f 84 22 02 00 00    	je     11ff21 <http_parser_parse_url+0x37c>
  11fcff:	83 e9 27             	sub    $0x27,%ecx
  11fd02:	80 f9 01             	cmp    $0x1,%cl
  11fd05:	0f 87 52 ff ff ff    	ja     11fc5d <http_parser_parse_url+0xb8>
  11fd0b:	e9 11 02 00 00       	jmp    11ff21 <http_parser_parse_url+0x37c>
		if (ch == '[') {
  11fd10:	80 f9 5b             	cmp    $0x5b,%cl
  11fd13:	0f 84 43 01 00 00    	je     11fe5c <http_parser_parse_url+0x2b7>
		if (IS_HOST_CHAR(ch)) {
  11fd19:	88 c8                	mov    %cl,%al
  11fd1b:	83 c8 20             	or     $0x20,%eax
  11fd1e:	83 e8 61             	sub    $0x61,%eax
  11fd21:	3c 19                	cmp    $0x19,%al
  11fd23:	0f 86 18 01 00 00    	jbe    11fe41 <http_parser_parse_url+0x29c>
  11fd29:	8d 41 d0             	lea    -0x30(%ecx),%eax
  11fd2c:	3c 09                	cmp    $0x9,%al
  11fd2e:	0f 86 0d 01 00 00    	jbe    11fe41 <http_parser_parse_url+0x29c>
  11fd34:	8d 41 d3             	lea    -0x2d(%ecx),%eax
  11fd37:	3c 01                	cmp    $0x1,%al
  11fd39:	0f 86 02 01 00 00    	jbe    11fe41 <http_parser_parse_url+0x29c>
  11fd3f:	80 f9 5f             	cmp    $0x5f,%cl
  11fd42:	0f 85 15 ff ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
  11fd48:	e9 f4 00 00 00       	jmp    11fe41 <http_parser_parse_url+0x29c>
		if (IS_HOST_CHAR(ch)) {
  11fd4d:	88 c8                	mov    %cl,%al
  11fd4f:	83 c8 20             	or     $0x20,%eax
  11fd52:	83 e8 61             	sub    $0x61,%eax
  11fd55:	3c 19                	cmp    $0x19,%al
  11fd57:	0f 86 ed 00 00 00    	jbe    11fe4a <http_parser_parse_url+0x2a5>
  11fd5d:	8d 41 d0             	lea    -0x30(%ecx),%eax
  11fd60:	3c 09                	cmp    $0x9,%al
  11fd62:	0f 86 e2 00 00 00    	jbe    11fe4a <http_parser_parse_url+0x2a5>
  11fd68:	8d 41 d3             	lea    -0x2d(%ecx),%eax
  11fd6b:	3c 01                	cmp    $0x1,%al
  11fd6d:	0f 86 d7 00 00 00    	jbe    11fe4a <http_parser_parse_url+0x2a5>
  11fd73:	80 f9 5f             	cmp    $0x5f,%cl
  11fd76:	0f 84 ce 00 00 00    	je     11fe4a <http_parser_parse_url+0x2a5>
		if (ch == ':') {
  11fd7c:	80 f9 3a             	cmp    $0x3a,%cl
  11fd7f:	0f 85 d8 fe ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
			return s_http_host_port_start;
  11fd85:	b8 0b 00 00 00       	mov    $0xb,%eax
  11fd8a:	e9 d9 00 00 00       	jmp    11fe68 <http_parser_parse_url+0x2c3>
		if (ch == ']') {
  11fd8f:	80 f9 5d             	cmp    $0x5d,%cl
  11fd92:	0f 84 cb 00 00 00    	je     11fe63 <http_parser_parse_url+0x2be>
		if (IS_HEX(ch) || ch == ':' || ch == '.') {
  11fd98:	8d 51 d0             	lea    -0x30(%ecx),%edx
  11fd9b:	80 fa 09             	cmp    $0x9,%dl
  11fd9e:	0f 86 2d 01 00 00    	jbe    11fed1 <http_parser_parse_url+0x32c>
  11fda4:	88 ca                	mov    %cl,%dl
  11fda6:	83 ca 20             	or     $0x20,%edx
  11fda9:	83 ea 61             	sub    $0x61,%edx
  11fdac:	80 fa 05             	cmp    $0x5,%dl
  11fdaf:	0f 86 1c 01 00 00    	jbe    11fed1 <http_parser_parse_url+0x32c>
  11fdb5:	80 f9 3a             	cmp    $0x3a,%cl
  11fdb8:	0f 84 13 01 00 00    	je     11fed1 <http_parser_parse_url+0x32c>
  11fdbe:	80 f9 2e             	cmp    $0x2e,%cl
  11fdc1:	0f 84 0a 01 00 00    	je     11fed1 <http_parser_parse_url+0x32c>
		if (s == s_http_host_v6 && ch == '%') {
  11fdc7:	83 f8 07             	cmp    $0x7,%eax
  11fdca:	0f 85 8d fe ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
  11fdd0:	80 f9 25             	cmp    $0x25,%cl
  11fdd3:	0f 85 84 fe ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
			return s_http_host_v6_zone_start;
  11fdd9:	b8 09 00 00 00       	mov    $0x9,%eax
  11fdde:	e9 0f 01 00 00       	jmp    11fef2 <http_parser_parse_url+0x34d>
		if (ch == ']') {
  11fde3:	80 f9 5d             	cmp    $0x5d,%cl
  11fde6:	74 7b                	je     11fe63 <http_parser_parse_url+0x2be>
		if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' ||
  11fde8:	88 c8                	mov    %cl,%al
  11fdea:	83 c8 20             	or     $0x20,%eax
  11fded:	83 e8 61             	sub    $0x61,%eax
  11fdf0:	3c 19                	cmp    $0x19,%al
  11fdf2:	0f 86 f5 00 00 00    	jbe    11feed <http_parser_parse_url+0x348>
  11fdf8:	8d 41 d0             	lea    -0x30(%ecx),%eax
  11fdfb:	3c 09                	cmp    $0x9,%al
  11fdfd:	0f 86 ea 00 00 00    	jbe    11feed <http_parser_parse_url+0x348>
  11fe03:	80 f9 25             	cmp    $0x25,%cl
  11fe06:	0f 84 e1 00 00 00    	je     11feed <http_parser_parse_url+0x348>
  11fe0c:	8d 41 d3             	lea    -0x2d(%ecx),%eax
  11fe0f:	3c 01                	cmp    $0x1,%al
  11fe11:	0f 96 c2             	setbe  %dl
				ch == '_' ||
  11fe14:	80 f9 5f             	cmp    $0x5f,%cl
  11fe17:	0f 94 c0             	sete   %al
  11fe1a:	08 c2                	or     %al,%dl
  11fe1c:	0f 85 cb 00 00 00    	jne    11feed <http_parser_parse_url+0x348>
  11fe22:	80 f9 7e             	cmp    $0x7e,%cl
  11fe25:	0f 85 32 fe ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
  11fe2b:	e9 bd 00 00 00       	jmp    11feed <http_parser_parse_url+0x348>
		if (IS_NUM(ch)) {
  11fe30:	83 e9 30             	sub    $0x30,%ecx
  11fe33:	80 f9 09             	cmp    $0x9,%cl
  11fe36:	0f 87 21 fe ff ff    	ja     11fc5d <http_parser_parse_url+0xb8>
  11fe3c:	e9 ba 00 00 00       	jmp    11fefb <http_parser_parse_url+0x356>
				u->field_data[UF_HOST].off = p - buf;
  11fe41:	89 f0                	mov    %esi,%eax
  11fe43:	2b 45 08             	sub    0x8(%ebp),%eax
  11fe46:	66 89 43 08          	mov    %ax,0x8(%ebx)
			u->field_data[UF_HOST].len++;
  11fe4a:	66 ff 43 0a          	incw   0xa(%ebx)
			break;
  11fe4e:	b8 06 00 00 00       	mov    $0x6,%eax
  11fe53:	eb 13                	jmp    11fe68 <http_parser_parse_url+0x2c3>
			return s_http_host_start;
  11fe55:	b8 04 00 00 00       	mov    $0x4,%eax
  11fe5a:	eb 0c                	jmp    11fe68 <http_parser_parse_url+0x2c3>
			return s_http_host_v6_start;
  11fe5c:	b8 05 00 00 00       	mov    $0x5,%eax
  11fe61:	eb 05                	jmp    11fe68 <http_parser_parse_url+0x2c3>
			return s_http_host_v6_end;
  11fe63:	b8 08 00 00 00       	mov    $0x8,%eax
	for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
  11fe68:	46                   	inc    %esi
  11fe69:	e9 2e fe ff ff       	jmp    11fc9c <http_parser_parse_url+0xf7>
	switch (s) {
  11fe6e:	83 f8 0b             	cmp    $0xb,%eax
  11fe71:	77 15                	ja     11fe88 <http_parser_parse_url+0x2e3>
  11fe73:	ba 01 00 00 00       	mov    $0x1,%edx
  11fe78:	88 c1                	mov    %al,%cl
  11fe7a:	d3 e2                	shl    %cl,%edx
  11fe7c:	81 e2 bc 0e 00 00    	and    $0xebc,%edx
  11fe82:	0f 85 d5 fd ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
			return 1;
		}
	}

	/* CONNECT requests can only contain "hostname:port" */
	if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
  11fe88:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  11fe8c:	66 8b 03             	mov    (%ebx),%ax
  11fe8f:	74 0c                	je     11fe9d <http_parser_parse_url+0x2f8>
  11fe91:	66 83 f8 06          	cmp    $0x6,%ax
  11fe95:	0f 85 c2 fd ff ff    	jne    11fc5d <http_parser_parse_url+0xb8>
  11fe9b:	eb 08                	jmp    11fea5 <http_parser_parse_url+0x300>
		return 1;
	}

	if (u->field_set & (1 << UF_PORT)) {
  11fe9d:	a8 04                	test   $0x4,%al
  11fe9f:	0f 84 a2 00 00 00    	je     11ff47 <http_parser_parse_url+0x3a2>
		/* Don't bother with endp; we've already validated the string */
		unsigned long v;

		v = strtoul(buf + u->field_data[UF_PORT].off, NULL, 10);
  11fea5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  11fea9:	6a 0a                	push   $0xa
  11feab:	03 45 08             	add    0x8(%ebp),%eax
  11feae:	6a 00                	push   $0x0
  11feb0:	50                   	push   %eax
  11feb1:	e8 2c bc fe ff       	call   10bae2 <strtoul>
  11feb6:	83 c4 0c             	add    $0xc,%esp

		/* Ports have a max value of 2^16 */
		if (v > 0xffff) {
  11feb9:	3d ff ff 00 00       	cmp    $0xffff,%eax
  11febe:	0f 87 99 fd ff ff    	ja     11fc5d <http_parser_parse_url+0xb8>
			return 1;
		}

		u->port = (uint16_t) v;
  11fec4:	66 89 43 02          	mov    %ax,0x2(%ebx)
	}

	return 0;
  11fec8:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
  11fecf:	eb 76                	jmp    11ff47 <http_parser_parse_url+0x3a2>
			if (s != s_http_host_v6) {
  11fed1:	83 f8 07             	cmp    $0x7,%eax
  11fed4:	74 09                	je     11fedf <http_parser_parse_url+0x33a>
				u->field_data[UF_HOST].off = p - buf;
  11fed6:	89 f0                	mov    %esi,%eax
  11fed8:	2b 45 08             	sub    0x8(%ebp),%eax
  11fedb:	66 89 43 08          	mov    %ax,0x8(%ebx)
			u->field_data[UF_HOST].len++;
  11fedf:	66 ff 43 0a          	incw   0xa(%ebx)
			break;
  11fee3:	b8 07 00 00 00       	mov    $0x7,%eax
  11fee8:	e9 7b ff ff ff       	jmp    11fe68 <http_parser_parse_url+0x2c3>
			return s_http_host_v6_zone;
  11feed:	b8 0a 00 00 00       	mov    $0xa,%eax
			u->field_data[UF_HOST].len++;
  11fef2:	66 ff 43 0a          	incw   0xa(%ebx)
			break;
  11fef6:	e9 6d ff ff ff       	jmp    11fe68 <http_parser_parse_url+0x2c3>
			if (s != s_http_host_port) {
  11fefb:	83 f8 0c             	cmp    $0xc,%eax
  11fefe:	74 13                	je     11ff13 <http_parser_parse_url+0x36e>
				u->field_data[UF_PORT].off = p - buf;
  11ff00:	89 f0                	mov    %esi,%eax
				u->field_data[UF_PORT].len = 0U;
  11ff02:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
				u->field_data[UF_PORT].off = p - buf;
  11ff08:	2b 45 08             	sub    0x8(%ebp),%eax
				u->field_set |= (1 << UF_PORT);
  11ff0b:	66 83 0b 04          	orw    $0x4,(%ebx)
				u->field_data[UF_PORT].off = p - buf;
  11ff0f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
			u->field_data[UF_PORT].len++;
  11ff13:	66 ff 43 0e          	incw   0xe(%ebx)
			return s_http_host_port;
  11ff17:	b8 0c 00 00 00       	mov    $0xc,%eax
			break;
  11ff1c:	e9 47 ff ff ff       	jmp    11fe68 <http_parser_parse_url+0x2c3>
			if (s != s_http_userinfo) {
  11ff21:	83 f8 03             	cmp    $0x3,%eax
  11ff24:	74 13                	je     11ff39 <http_parser_parse_url+0x394>
				u->field_data[UF_USERINFO].off = p - buf;
  11ff26:	89 f0                	mov    %esi,%eax
				u->field_data[UF_USERINFO].len = 0U;
  11ff28:	66 c7 43 1e 00 00    	movw   $0x0,0x1e(%ebx)
				u->field_data[UF_USERINFO].off = p - buf;
  11ff2e:	2b 45 08             	sub    0x8(%ebp),%eax
				u->field_set |= (1 << UF_USERINFO);
  11ff31:	66 83 0b 40          	orw    $0x40,(%ebx)
				u->field_data[UF_USERINFO].off = p - buf;
  11ff35:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
			u->field_data[UF_USERINFO].len++;
  11ff39:	66 ff 43 1e          	incw   0x1e(%ebx)
			return s_http_userinfo;
  11ff3d:	b8 03 00 00 00       	mov    $0x3,%eax
			break;
  11ff42:	e9 21 ff ff ff       	jmp    11fe68 <http_parser_parse_url+0x2c3>
}
  11ff47:	8b 45 10             	mov    0x10(%ebp),%eax
  11ff4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  11ff4d:	5b                   	pop    %ebx
  11ff4e:	5e                   	pop    %esi
  11ff4f:	5f                   	pop    %edi
  11ff50:	5d                   	pop    %ebp
  11ff51:	c3                   	ret    

0011ff52 <z_impl_sys_rand32_get>:
 *
 * @return a 32-bit number
 */

uint32_t z_impl_sys_rand32_get(void)
{
  11ff52:	55                   	push   %ebp
  11ff53:	89 e5                	mov    %esp,%ebp
  11ff55:	e8 a8 ac fe ff       	call   10ac02 <z_timer_cycle_get_32>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  11ff5a:	ba 0d ca 9a 3b       	mov    $0x3b9aca0d,%edx
  11ff5f:	f0 0f c1 15 60 ed 12 	lock xadd %edx,0x12ed60
  11ff66:	00 
	return k_cycle_get_32() + atomic_add(&_rand32_counter, _RAND32_INC);
  11ff67:	01 d0                	add    %edx,%eax
}
  11ff69:	5d                   	pop    %ebp
  11ff6a:	c3                   	ret    

0011ff6b <uart_ns16550_configure>:
	}
}

static int uart_ns16550_configure(const struct device *dev,
				  const struct uart_config *cfg)
{
  11ff6b:	55                   	push   %ebp
  11ff6c:	89 e5                	mov    %esp,%ebp
  11ff6e:	57                   	push   %edi
  11ff6f:	56                   	push   %esi
  11ff70:	53                   	push   %ebx
  11ff71:	83 ec 14             	sub    $0x14,%esp
  11ff74:	8b 75 08             	mov    0x8(%ebp),%esi
  11ff77:	8b 7d 0c             	mov    0xc(%ebp),%edi
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  11ff7a:	8b 46 0c             	mov    0xc(%esi),%eax
  11ff7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  11ff80:	9c                   	pushf  
  11ff81:	fa                   	cli    
  11ff82:	8f 45 e0             	popl   -0x20(%ebp)
		DEVICE_MMIO_MAP(dev, K_MEM_CACHE_NONE);
	}
#endif /* UART_NS15660_ACCESS_IOPORT */

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	dev_data->iir_cache = 0U;
  11ff85:	8b 45 ec             	mov    -0x14(%ebp),%eax
  11ff88:	c6 40 09 00          	movb   $0x0,0x9(%eax)
		OUTWORD(PCP(dev), pcp & ~PCP_UPDATE);
		OUTWORD(PCP(dev), pcp | PCP_UPDATE);
	}
#endif

	set_baud_rate(dev, cfg->baudrate);
  11ff8c:	8b 0f                	mov    (%edi),%ecx
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
  11ff8e:	85 c9                	test   %ecx,%ecx
  11ff90:	74 45                	je     11ffd7 <uart_ns16550_configure+0x6c>
	const struct uart_ns16550_device_config * const dev_cfg = DEV_CFG(dev);
  11ff92:	8b 5e 04             	mov    0x4(%esi),%ebx
	if ((baud_rate != 0U) && (dev_cfg->sys_clk_freq != 0U)) {
  11ff95:	8b 43 04             	mov    0x4(%ebx),%eax
  11ff98:	85 c0                	test   %eax,%eax
  11ff9a:	74 3b                	je     11ffd7 <uart_ns16550_configure+0x6c>
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  11ff9c:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
					/ baud_rate) >> 4;
  11ff9f:	31 d2                	xor    %edx,%edx
	return DEV_CFG(dev)->port;
  11ffa1:	8b 1b                	mov    (%ebx),%ebx
					/ baud_rate) >> 4;
  11ffa3:	f7 f1                	div    %ecx
  11ffa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		lcr_cache = INBYTE(LCR(dev));
  11ffa8:	8d 43 03             	lea    0x3(%ebx),%eax
  11ffab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  11ffae:	89 c2                	mov    %eax,%edx
  11ffb0:	ec                   	in     (%dx),%al
  11ffb1:	88 45 eb             	mov    %al,-0x15(%ebp)
		OUTBYTE(LCR(dev), LCR_DLAB | lcr_cache);
  11ffb4:	83 c8 80             	or     $0xffffff80,%eax
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  11ffb7:	ee                   	out    %al,(%dx)
		divisor = ((dev_cfg->sys_clk_freq + (baud_rate << 3))
  11ffb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ffbb:	89 da                	mov    %ebx,%edx
  11ffbd:	c1 e8 04             	shr    $0x4,%eax
  11ffc0:	ee                   	out    %al,(%dx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
  11ffc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  11ffc4:	8d 53 01             	lea    0x1(%ebx),%edx
  11ffc7:	c1 e8 0c             	shr    $0xc,%eax
  11ffca:	ee                   	out    %al,(%dx)
  11ffcb:	8a 45 eb             	mov    -0x15(%ebp),%al
  11ffce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  11ffd1:	ee                   	out    %al,(%dx)
		dev_data->uart_config.baudrate = baud_rate;
  11ffd2:	8b 46 0c             	mov    0xc(%esi),%eax
  11ffd5:	89 08                	mov    %ecx,(%eax)

	/* Local structure to hold temporary values to pass to OUTBYTE() */
	struct uart_config uart_cfg;

	switch (cfg->data_bits) {
  11ffd7:	8a 47 06             	mov    0x6(%edi),%al
		break;
	case UART_CFG_DATA_BITS_8:
		uart_cfg.data_bits = LCR_CS8;
		break;
	default:
		ret = -ENOTSUP;
  11ffda:	ba dd ff ff ff       	mov    $0xffffffdd,%edx
	switch (cfg->data_bits) {
  11ffdf:	88 45 f0             	mov    %al,-0x10(%ebp)
  11ffe2:	3c 03                	cmp    $0x3,%al
  11ffe4:	77 57                	ja     12003d <uart_ns16550_configure+0xd2>
		goto out;
	}

	switch (cfg->stop_bits) {
  11ffe6:	8a 47 05             	mov    0x5(%edi),%al
  11ffe9:	3c 01                	cmp    $0x1,%al
  11ffeb:	74 08                	je     11fff5 <uart_ns16550_configure+0x8a>
  11ffed:	b3 04                	mov    $0x4,%bl
  11ffef:	3c 03                	cmp    $0x3,%al
  11fff1:	74 04                	je     11fff7 <uart_ns16550_configure+0x8c>
  11fff3:	eb 48                	jmp    12003d <uart_ns16550_configure+0xd2>
	case UART_CFG_STOP_BITS_1:
		uart_cfg.stop_bits = LCR_1_STB;
  11fff5:	31 db                	xor    %ebx,%ebx
	default:
		ret = -ENOTSUP;
		goto out;
	}

	switch (cfg->parity) {
  11fff7:	8a 47 04             	mov    0x4(%edi),%al
  11fffa:	84 c0                	test   %al,%al
  11fffc:	74 0b                	je     120009 <uart_ns16550_configure+0x9e>
  11fffe:	ba dd ff ff ff       	mov    $0xffffffdd,%edx
  120003:	3c 02                	cmp    $0x2,%al
  120005:	75 36                	jne    12003d <uart_ns16550_configure+0xd2>
  120007:	b0 10                	mov    $0x10,%al
	default:
		ret = -ENOTSUP;
		goto out;
	}

	dev_data->uart_config = *cfg;
  120009:	8b 17                	mov    (%edi),%edx
  12000b:	8b 4f 04             	mov    0x4(%edi),%ecx
  12000e:	8b 7d ec             	mov    -0x14(%ebp),%edi
  120011:	89 17                	mov    %edx,(%edi)
	return DEV_CFG(dev)->port;
  120013:	8b 56 04             	mov    0x4(%esi),%edx
	dev_data->uart_config = *cfg;
  120016:	89 4f 04             	mov    %ecx,0x4(%edi)

	/* data bits, stop bits, parity, clear DLAB */
	OUTBYTE(LCR(dev),
  120019:	8a 4d f0             	mov    -0x10(%ebp),%cl
	return DEV_CFG(dev)->port;
  12001c:	8b 32                	mov    (%edx),%esi
	OUTBYTE(LCR(dev),
  12001e:	09 d9                	or     %ebx,%ecx
  120020:	09 c8                	or     %ecx,%eax
  120022:	8d 56 03             	lea    0x3(%esi),%edx
  120025:	ee                   	out    %al,(%dx)
  120026:	b0 0b                	mov    $0xb,%al
	if (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS) {
		mdc |= MCR_AFCE;
	}
#endif

	OUTBYTE(MDC(dev), mdc);
  120028:	8d 56 04             	lea    0x4(%esi),%edx
  12002b:	ee                   	out    %al,(%dx)
  12002c:	b0 87                	mov    $0x87,%al
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
  12002e:	8d 56 02             	lea    0x2(%esi),%edx
  120031:	ee                   	out    %al,(%dx)
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  120032:	89 f2                	mov    %esi,%edx
  120034:	ec                   	in     (%dx),%al
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  120035:	31 c0                	xor    %eax,%eax

	/* clear the port */
	INBYTE(RDR(dev));

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
  120037:	8d 56 01             	lea    0x1(%esi),%edx
  12003a:	ee                   	out    %al,(%dx)
	int ret = 0;
  12003b:	31 d2                	xor    %edx,%edx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12003d:	0f ba 65 e0 09       	btl    $0x9,-0x20(%ebp)
  120042:	73 01                	jae    120045 <uart_ns16550_configure+0xda>
		__asm__ volatile ("sti" ::: "memory");
  120044:	fb                   	sti    

out:
	k_spin_unlock(&dev_data->lock, key);
	return ret;
};
  120045:	83 c4 14             	add    $0x14,%esp
  120048:	89 d0                	mov    %edx,%eax
  12004a:	5b                   	pop    %ebx
  12004b:	5e                   	pop    %esi
  12004c:	5f                   	pop    %edi
  12004d:	5d                   	pop    %ebp
  12004e:	c3                   	ret    

0012004f <uart_ns16550_config_get>:

static int uart_ns16550_config_get(const struct device *dev,
				   struct uart_config *cfg)
{
  12004f:	55                   	push   %ebp
  120050:	89 e5                	mov    %esp,%ebp
	struct uart_ns16550_dev_data_t *data = DEV_DATA(dev);
  120052:	8b 55 08             	mov    0x8(%ebp),%edx
{
  120055:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct uart_ns16550_dev_data_t *data = DEV_DATA(dev);
  120058:	8b 52 0c             	mov    0xc(%edx),%edx

	cfg->baudrate = data->uart_config.baudrate;
  12005b:	8b 0a                	mov    (%edx),%ecx
  12005d:	89 08                	mov    %ecx,(%eax)
	cfg->parity = data->uart_config.parity;
  12005f:	8a 4a 04             	mov    0x4(%edx),%cl
  120062:	88 48 04             	mov    %cl,0x4(%eax)
	cfg->stop_bits = data->uart_config.stop_bits;
  120065:	8a 4a 05             	mov    0x5(%edx),%cl
  120068:	88 48 05             	mov    %cl,0x5(%eax)
	cfg->data_bits = data->uart_config.data_bits;
  12006b:	8a 4a 06             	mov    0x6(%edx),%cl
  12006e:	88 48 06             	mov    %cl,0x6(%eax)
	cfg->flow_ctrl = data->uart_config.flow_ctrl;
  120071:	8a 52 07             	mov    0x7(%edx),%dl
  120074:	88 50 07             	mov    %dl,0x7(%eax)

	return 0;
}
  120077:	31 c0                	xor    %eax,%eax
  120079:	5d                   	pop    %ebp
  12007a:	c3                   	ret    

0012007b <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(const struct device *dev, unsigned char *c)
{
  12007b:	55                   	push   %ebp
  12007c:	89 e5                	mov    %esp,%ebp
  12007e:	53                   	push   %ebx
  12007f:	9c                   	pushf  
  120080:	fa                   	cli    
  120081:	5b                   	pop    %ebx
	return DEV_CFG(dev)->port;
  120082:	8b 45 08             	mov    0x8(%ebp),%eax
  120085:	8b 40 04             	mov    0x4(%eax),%eax
  120088:	8b 08                	mov    (%eax),%ecx
	int ret = -1;
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	if ((INBYTE(LSR(dev)) & LSR_RXRDY) != 0) {
  12008a:	8d 51 05             	lea    0x5(%ecx),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  12008d:	ec                   	in     (%dx),%al
  12008e:	88 c2                	mov    %al,%dl
  120090:	80 e2 01             	and    $0x1,%dl
  120093:	74 0c                	je     1200a1 <uart_ns16550_poll_in+0x26>
  120095:	89 ca                	mov    %ecx,%edx
  120097:	ec                   	in     (%dx),%al
		/* got a character */
		*c = INBYTE(RDR(dev));
  120098:	8b 55 0c             	mov    0xc(%ebp),%edx
  12009b:	88 02                	mov    %al,(%edx)
		ret = 0;
  12009d:	31 c0                	xor    %eax,%eax
  12009f:	eb 03                	jmp    1200a4 <uart_ns16550_poll_in+0x29>
  1200a1:	83 c8 ff             	or     $0xffffffff,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1200a4:	0f ba e3 09          	bt     $0x9,%ebx
  1200a8:	73 01                	jae    1200ab <uart_ns16550_poll_in+0x30>
		__asm__ volatile ("sti" ::: "memory");
  1200aa:	fb                   	sti    
	}

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
  1200ab:	5b                   	pop    %ebx
  1200ac:	5d                   	pop    %ebp
  1200ad:	c3                   	ret    

001200ae <uart_ns16550_poll_out>:
 * @param dev UART device struct
 * @param c Character to send
 */
static void uart_ns16550_poll_out(const struct device *dev,
					   unsigned char c)
{
  1200ae:	55                   	push   %ebp
  1200af:	89 e5                	mov    %esp,%ebp
  1200b1:	56                   	push   %esi
  1200b2:	53                   	push   %ebx
  1200b3:	8b 75 0c             	mov    0xc(%ebp),%esi
  1200b6:	9c                   	pushf  
  1200b7:	fa                   	cli    
  1200b8:	5b                   	pop    %ebx
	return DEV_CFG(dev)->port;
  1200b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1200bc:	8b 40 04             	mov    0x4(%eax),%eax
  1200bf:	8b 08                	mov    (%eax),%ecx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	while ((INBYTE(LSR(dev)) & LSR_THRE) == 0) {
  1200c1:	8d 51 05             	lea    0x5(%ecx),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  1200c4:	ec                   	in     (%dx),%al
  1200c5:	a8 20                	test   $0x20,%al
  1200c7:	74 fb                	je     1200c4 <uart_ns16550_poll_out+0x16>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  1200c9:	89 f0                	mov    %esi,%eax
  1200cb:	89 ca                	mov    %ecx,%edx
  1200cd:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1200ce:	0f ba e3 09          	bt     $0x9,%ebx
  1200d2:	73 01                	jae    1200d5 <uart_ns16550_poll_out+0x27>
		__asm__ volatile ("sti" ::: "memory");
  1200d4:	fb                   	sti    
	}

	OUTBYTE(THR(dev), c);

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  1200d5:	5b                   	pop    %ebx
  1200d6:	5e                   	pop    %esi
  1200d7:	5d                   	pop    %ebp
  1200d8:	c3                   	ret    

001200d9 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(const struct device *dev)
{
  1200d9:	55                   	push   %ebp
  1200da:	89 e5                	mov    %esp,%ebp
  1200dc:	9c                   	pushf  
  1200dd:	fa                   	cli    
  1200de:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  1200df:	8b 45 08             	mov    0x8(%ebp),%eax
  1200e2:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);
	int check = (INBYTE(LSR(dev)) & LSR_EOB_MASK);
  1200e5:	8b 00                	mov    (%eax),%eax
  1200e7:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  1200ea:	ec                   	in     (%dx),%al
  1200eb:	83 e0 1e             	and    $0x1e,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1200ee:	0f ba e1 09          	bt     $0x9,%ecx
  1200f2:	73 01                	jae    1200f5 <uart_ns16550_err_check+0x1c>
		__asm__ volatile ("sti" ::: "memory");
  1200f4:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return check >> 1;
  1200f5:	d1 f8                	sar    %eax
}
  1200f7:	5d                   	pop    %ebp
  1200f8:	c3                   	ret    

001200f9 <uart_ns16550_fifo_fill>:
 * @return Number of bytes sent
 */
static int uart_ns16550_fifo_fill(const struct device *dev,
				  const uint8_t *tx_data,
				  int size)
{
  1200f9:	55                   	push   %ebp
  1200fa:	89 e5                	mov    %esp,%ebp
  1200fc:	57                   	push   %edi
  1200fd:	56                   	push   %esi
  1200fe:	53                   	push   %ebx
  1200ff:	8b 7d 0c             	mov    0xc(%ebp),%edi
  120102:	9c                   	pushf  
  120103:	fa                   	cli    
  120104:	5e                   	pop    %esi
	int i;
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	for (i = 0; (i < size) && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  120105:	31 c9                	xor    %ecx,%ecx
  120107:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  12010a:	7c 09                	jl     120115 <uart_ns16550_fifo_fill+0x1c>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12010c:	0f ba e6 09          	bt     $0x9,%esi
  120110:	73 1c                	jae    12012e <uart_ns16550_fifo_fill+0x35>
		__asm__ volatile ("sti" ::: "memory");
  120112:	fb                   	sti    
		OUTBYTE(THR(dev), tx_data[i]);
	}

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return i;
  120113:	eb 19                	jmp    12012e <uart_ns16550_fifo_fill+0x35>
	return DEV_CFG(dev)->port;
  120115:	8b 45 08             	mov    0x8(%ebp),%eax
  120118:	8b 40 04             	mov    0x4(%eax),%eax
  12011b:	8b 18                	mov    (%eax),%ebx
	for (i = 0; (i < size) && (INBYTE(LSR(dev)) & LSR_THRE) != 0; i++) {
  12011d:	8d 53 05             	lea    0x5(%ebx),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  120120:	ec                   	in     (%dx),%al
  120121:	a8 20                	test   $0x20,%al
  120123:	74 e7                	je     12010c <uart_ns16550_fifo_fill+0x13>
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  120125:	8a 04 0f             	mov    (%edi,%ecx,1),%al
  120128:	89 da                	mov    %ebx,%edx
  12012a:	ee                   	out    %al,(%dx)
  12012b:	41                   	inc    %ecx
  12012c:	eb d9                	jmp    120107 <uart_ns16550_fifo_fill+0xe>
}
  12012e:	5b                   	pop    %ebx
  12012f:	89 c8                	mov    %ecx,%eax
  120131:	5e                   	pop    %esi
  120132:	5f                   	pop    %edi
  120133:	5d                   	pop    %ebp
  120134:	c3                   	ret    

00120135 <uart_ns16550_fifo_read>:
 *
 * @return Number of bytes read
 */
static int uart_ns16550_fifo_read(const struct device *dev, uint8_t *rx_data,
				  const int size)
{
  120135:	55                   	push   %ebp
  120136:	89 e5                	mov    %esp,%ebp
  120138:	57                   	push   %edi
  120139:	56                   	push   %esi
  12013a:	53                   	push   %ebx
  12013b:	8b 7d 08             	mov    0x8(%ebp),%edi
  12013e:	9c                   	pushf  
  12013f:	fa                   	cli    
  120140:	5e                   	pop    %esi
	int i;
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	for (i = 0; (i < size) && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  120141:	31 c9                	xor    %ecx,%ecx
  120143:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  120146:	7c 09                	jl     120151 <uart_ns16550_fifo_read+0x1c>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120148:	0f ba e6 09          	bt     $0x9,%esi
  12014c:	73 1c                	jae    12016a <uart_ns16550_fifo_read+0x35>
		__asm__ volatile ("sti" ::: "memory");
  12014e:	fb                   	sti    
		rx_data[i] = INBYTE(RDR(dev));
	}

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return i;
  12014f:	eb 19                	jmp    12016a <uart_ns16550_fifo_read+0x35>
	return DEV_CFG(dev)->port;
  120151:	8b 47 04             	mov    0x4(%edi),%eax
  120154:	8b 18                	mov    (%eax),%ebx
	for (i = 0; (i < size) && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  120156:	8d 53 05             	lea    0x5(%ebx),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  120159:	ec                   	in     (%dx),%al
  12015a:	a8 01                	test   $0x1,%al
  12015c:	74 ea                	je     120148 <uart_ns16550_fifo_read+0x13>
  12015e:	89 da                	mov    %ebx,%edx
  120160:	ec                   	in     (%dx),%al
		rx_data[i] = INBYTE(RDR(dev));
  120161:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  120164:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
	for (i = 0; (i < size) && (INBYTE(LSR(dev)) & LSR_RXRDY) != 0; i++) {
  120167:	41                   	inc    %ecx
  120168:	eb d9                	jmp    120143 <uart_ns16550_fifo_read+0xe>
}
  12016a:	5b                   	pop    %ebx
  12016b:	89 c8                	mov    %ecx,%eax
  12016d:	5e                   	pop    %esi
  12016e:	5f                   	pop    %edi
  12016f:	5d                   	pop    %ebp
  120170:	c3                   	ret    

00120171 <uart_ns16550_irq_tx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_enable(const struct device *dev)
{
  120171:	55                   	push   %ebp
  120172:	89 e5                	mov    %esp,%ebp
  120174:	9c                   	pushf  
  120175:	fa                   	cli    
  120176:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  120177:	8b 45 08             	mov    0x8(%ebp),%eax
  12017a:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_TBE);
  12017d:	8b 10                	mov    (%eax),%edx
  12017f:	42                   	inc    %edx
  120180:	ec                   	in     (%dx),%al
  120181:	83 c8 02             	or     $0x2,%eax
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  120184:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120185:	0f ba e1 09          	bt     $0x9,%ecx
  120189:	73 01                	jae    12018c <uart_ns16550_irq_tx_enable+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  12018b:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  12018c:	5d                   	pop    %ebp
  12018d:	c3                   	ret    

0012018e <uart_ns16550_irq_tx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_tx_disable(const struct device *dev)
{
  12018e:	55                   	push   %ebp
  12018f:	89 e5                	mov    %esp,%ebp
  120191:	9c                   	pushf  
  120192:	fa                   	cli    
  120193:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  120194:	8b 45 08             	mov    0x8(%ebp),%eax
  120197:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_TBE));
  12019a:	8b 10                	mov    (%eax),%edx
  12019c:	42                   	inc    %edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  12019d:	ec                   	in     (%dx),%al
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  12019e:	83 e0 fd             	and    $0xfffffffd,%eax
  1201a1:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1201a2:	0f ba e1 09          	bt     $0x9,%ecx
  1201a6:	73 01                	jae    1201a9 <uart_ns16550_irq_tx_disable+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  1201a8:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  1201a9:	5d                   	pop    %ebp
  1201aa:	c3                   	ret    

001201ab <uart_ns16550_irq_tx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_tx_ready(const struct device *dev)
{
  1201ab:	55                   	push   %ebp
  1201ac:	89 e5                	mov    %esp,%ebp
  1201ae:	9c                   	pushf  
  1201af:	fa                   	cli    
  1201b0:	5a                   	pop    %edx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	int ret = ((IIRC(dev) & IIR_ID) == IIR_THRE) ? 1 : 0;
  1201b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1201b4:	8b 40 0c             	mov    0xc(%eax),%eax
  1201b7:	8a 40 09             	mov    0x9(%eax),%al
  1201ba:	83 e0 06             	and    $0x6,%eax
  1201bd:	3c 02                	cmp    $0x2,%al
  1201bf:	0f 94 c0             	sete   %al
  1201c2:	0f b6 c0             	movzbl %al,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1201c5:	0f ba e2 09          	bt     $0x9,%edx
  1201c9:	73 01                	jae    1201cc <uart_ns16550_irq_tx_ready+0x21>
		__asm__ volatile ("sti" ::: "memory");
  1201cb:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
  1201cc:	5d                   	pop    %ebp
  1201cd:	c3                   	ret    

001201ce <uart_ns16550_irq_tx_complete>:
 * @param dev UART device struct
 *
 * @return 1 if nothing remains to be transmitted, 0 otherwise
 */
static int uart_ns16550_irq_tx_complete(const struct device *dev)
{
  1201ce:	55                   	push   %ebp
  1201cf:	89 e5                	mov    %esp,%ebp
  1201d1:	9c                   	pushf  
  1201d2:	fa                   	cli    
  1201d3:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  1201d4:	8b 45 08             	mov    0x8(%ebp),%eax
  1201d7:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	int ret = ((INBYTE(LSR(dev)) & (LSR_TEMT | LSR_THRE))
  1201da:	8b 00                	mov    (%eax),%eax
  1201dc:	8d 50 05             	lea    0x5(%eax),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  1201df:	ec                   	in     (%dx),%al
				== (LSR_TEMT | LSR_THRE)) ? 1 : 0;
  1201e0:	83 e0 60             	and    $0x60,%eax
  1201e3:	3c 60                	cmp    $0x60,%al
  1201e5:	0f 94 c0             	sete   %al
  1201e8:	0f b6 c0             	movzbl %al,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1201eb:	0f ba e1 09          	bt     $0x9,%ecx
  1201ef:	73 01                	jae    1201f2 <uart_ns16550_irq_tx_complete+0x24>
		__asm__ volatile ("sti" ::: "memory");
  1201f1:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
  1201f2:	5d                   	pop    %ebp
  1201f3:	c3                   	ret    

001201f4 <uart_ns16550_irq_rx_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_enable(const struct device *dev)
{
  1201f4:	55                   	push   %ebp
  1201f5:	89 e5                	mov    %esp,%ebp
  1201f7:	9c                   	pushf  
  1201f8:	fa                   	cli    
  1201f9:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  1201fa:	8b 45 08             	mov    0x8(%ebp),%eax
  1201fd:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_RXRDY);
  120200:	8b 10                	mov    (%eax),%edx
  120202:	42                   	inc    %edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  120203:	ec                   	in     (%dx),%al
  120204:	83 c8 01             	or     $0x1,%eax
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  120207:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120208:	0f ba e1 09          	bt     $0x9,%ecx
  12020c:	73 01                	jae    12020f <uart_ns16550_irq_rx_enable+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  12020e:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  12020f:	5d                   	pop    %ebp
  120210:	c3                   	ret    

00120211 <uart_ns16550_irq_rx_disable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_rx_disable(const struct device *dev)
{
  120211:	55                   	push   %ebp
  120212:	89 e5                	mov    %esp,%ebp
  120214:	9c                   	pushf  
  120215:	fa                   	cli    
  120216:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  120217:	8b 45 08             	mov    0x8(%ebp),%eax
  12021a:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_RXRDY));
  12021d:	8b 10                	mov    (%eax),%edx
  12021f:	42                   	inc    %edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  120220:	ec                   	in     (%dx),%al
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  120221:	83 e0 fe             	and    $0xfffffffe,%eax
  120224:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120225:	0f ba e1 09          	bt     $0x9,%ecx
  120229:	73 01                	jae    12022c <uart_ns16550_irq_rx_disable+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  12022b:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  12022c:	5d                   	pop    %ebp
  12022d:	c3                   	ret    

0012022e <uart_ns16550_irq_rx_ready>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static int uart_ns16550_irq_rx_ready(const struct device *dev)
{
  12022e:	55                   	push   %ebp
  12022f:	89 e5                	mov    %esp,%ebp
  120231:	9c                   	pushf  
  120232:	fa                   	cli    
  120233:	5a                   	pop    %edx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	int ret = ((IIRC(dev) & IIR_ID) == IIR_RBRF) ? 1 : 0;
  120234:	8b 45 08             	mov    0x8(%ebp),%eax
  120237:	8b 40 0c             	mov    0xc(%eax),%eax
  12023a:	8a 40 09             	mov    0x9(%eax),%al
  12023d:	83 e0 06             	and    $0x6,%eax
  120240:	3c 04                	cmp    $0x4,%al
  120242:	0f 94 c0             	sete   %al
  120245:	0f b6 c0             	movzbl %al,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120248:	0f ba e2 09          	bt     $0x9,%edx
  12024c:	73 01                	jae    12024f <uart_ns16550_irq_rx_ready+0x21>
		__asm__ volatile ("sti" ::: "memory");
  12024e:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
  12024f:	5d                   	pop    %ebp
  120250:	c3                   	ret    

00120251 <uart_ns16550_irq_err_enable>:
 * @param dev UART device struct
 *
 * @return N/A
 */
static void uart_ns16550_irq_err_enable(const struct device *dev)
{
  120251:	55                   	push   %ebp
  120252:	89 e5                	mov    %esp,%ebp
  120254:	9c                   	pushf  
  120255:	fa                   	cli    
  120256:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  120257:	8b 45 08             	mov    0x8(%ebp),%eax
  12025a:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	OUTBYTE(IER(dev), INBYTE(IER(dev)) | IER_LSR);
  12025d:	8b 10                	mov    (%eax),%edx
  12025f:	42                   	inc    %edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  120260:	ec                   	in     (%dx),%al
  120261:	83 c8 04             	or     $0x4,%eax
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  120264:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120265:	0f ba e1 09          	bt     $0x9,%ecx
  120269:	73 01                	jae    12026c <uart_ns16550_irq_err_enable+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  12026b:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  12026c:	5d                   	pop    %ebp
  12026d:	c3                   	ret    

0012026e <uart_ns16550_irq_err_disable>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is ready, 0 otherwise
 */
static void uart_ns16550_irq_err_disable(const struct device *dev)
{
  12026e:	55                   	push   %ebp
  12026f:	89 e5                	mov    %esp,%ebp
  120271:	9c                   	pushf  
  120272:	fa                   	cli    
  120273:	59                   	pop    %ecx
	return DEV_CFG(dev)->port;
  120274:	8b 45 08             	mov    0x8(%ebp),%eax
  120277:	8b 40 04             	mov    0x4(%eax),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	OUTBYTE(IER(dev), INBYTE(IER(dev)) & (~IER_LSR));
  12027a:	8b 10                	mov    (%eax),%edx
  12027c:	42                   	inc    %edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  12027d:	ec                   	in     (%dx),%al
	__asm__ volatile("outb %b0, %w1" :: "a"(data), "Nd"(port));
  12027e:	83 e0 fb             	and    $0xfffffffb,%eax
  120281:	ee                   	out    %al,(%dx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120282:	0f ba e1 09          	bt     $0x9,%ecx
  120286:	73 01                	jae    120289 <uart_ns16550_irq_err_disable+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  120288:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);
}
  120289:	5d                   	pop    %ebp
  12028a:	c3                   	ret    

0012028b <uart_ns16550_irq_is_pending>:
 * @param dev UART device struct
 *
 * @return 1 if an IRQ is pending, 0 otherwise
 */
static int uart_ns16550_irq_is_pending(const struct device *dev)
{
  12028b:	55                   	push   %ebp
  12028c:	89 e5                	mov    %esp,%ebp
  12028e:	9c                   	pushf  
  12028f:	fa                   	cli    
  120290:	5a                   	pop    %edx
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	int ret = (!(IIRC(dev) & IIR_NIP)) ? 1 : 0;
  120291:	8b 45 08             	mov    0x8(%ebp),%eax
  120294:	8b 40 0c             	mov    0xc(%eax),%eax
  120297:	8a 40 09             	mov    0x9(%eax),%al
  12029a:	f7 d0                	not    %eax
  12029c:	83 e0 01             	and    $0x1,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12029f:	0f ba e2 09          	bt     $0x9,%edx
  1202a3:	73 01                	jae    1202a6 <uart_ns16550_irq_is_pending+0x1b>
		__asm__ volatile ("sti" ::: "memory");
  1202a5:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return ret;
}
  1202a6:	5d                   	pop    %ebp
  1202a7:	c3                   	ret    

001202a8 <uart_ns16550_irq_update>:
 * @param dev UART device struct
 *
 * @return Always 1
 */
static int uart_ns16550_irq_update(const struct device *dev)
{
  1202a8:	55                   	push   %ebp
  1202a9:	89 e5                	mov    %esp,%ebp
  1202ab:	53                   	push   %ebx
  1202ac:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1202af:	9c                   	pushf  
  1202b0:	fa                   	cli    
  1202b1:	5b                   	pop    %ebx
	return DEV_CFG(dev)->port;
  1202b2:	8b 41 04             	mov    0x4(%ecx),%eax
	k_spinlock_key_t key = k_spin_lock(&DEV_DATA(dev)->lock);

	IIRC(dev) = INBYTE(IIR(dev));
  1202b5:	8b 00                	mov    (%eax),%eax
  1202b7:	8d 50 02             	lea    0x2(%eax),%edx
	__asm__ volatile("inb %w1, %b0" : "=a"(ret) : "Nd"(port));
  1202ba:	ec                   	in     (%dx),%al
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1202bb:	0f ba e3 09          	bt     $0x9,%ebx
  1202bf:	8b 51 0c             	mov    0xc(%ecx),%edx
  1202c2:	88 42 09             	mov    %al,0x9(%edx)
  1202c5:	73 01                	jae    1202c8 <uart_ns16550_irq_update+0x20>
		__asm__ volatile ("sti" ::: "memory");
  1202c7:	fb                   	sti    

	k_spin_unlock(&DEV_DATA(dev)->lock, key);

	return 1;
}
  1202c8:	5b                   	pop    %ebx
  1202c9:	b8 01 00 00 00       	mov    $0x1,%eax
  1202ce:	5d                   	pop    %ebp
  1202cf:	c3                   	ret    

001202d0 <uart_ns16550_irq_callback_set>:
 * @return N/A
 */
static void uart_ns16550_irq_callback_set(const struct device *dev,
					  uart_irq_callback_user_data_t cb,
					  void *cb_data)
{
  1202d0:	55                   	push   %ebp
  1202d1:	89 e5                	mov    %esp,%ebp
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  1202d3:	8b 45 08             	mov    0x8(%ebp),%eax
  1202d6:	8b 40 0c             	mov    0xc(%eax),%eax
  1202d9:	9c                   	pushf  
  1202da:	fa                   	cli    
  1202db:	5a                   	pop    %edx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1202dc:	0f ba e2 09          	bt     $0x9,%edx
	k_spinlock_key_t key = k_spin_lock(&dev_data->lock);

	dev_data->cb = cb;
  1202e0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1202e3:	89 48 0c             	mov    %ecx,0xc(%eax)
	dev_data->cb_data = cb_data;
  1202e6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1202e9:	89 48 10             	mov    %ecx,0x10(%eax)
  1202ec:	73 01                	jae    1202ef <uart_ns16550_irq_callback_set+0x1f>
		__asm__ volatile ("sti" ::: "memory");
  1202ee:	fb                   	sti    

	k_spin_unlock(&dev_data->lock, key);
}
  1202ef:	5d                   	pop    %ebp
  1202f0:	c3                   	ret    

001202f1 <uart_ns16550_isr>:
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_ns16550_isr(const struct device *dev)
{
  1202f1:	55                   	push   %ebp
  1202f2:	89 e5                	mov    %esp,%ebp
  1202f4:	8b 55 08             	mov    0x8(%ebp),%edx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  1202f7:	8b 4a 0c             	mov    0xc(%edx),%ecx

	if (dev_data->cb) {
  1202fa:	8b 41 0c             	mov    0xc(%ecx),%eax
  1202fd:	85 c0                	test   %eax,%eax
  1202ff:	74 08                	je     120309 <uart_ns16550_isr+0x18>
		dev_data->cb(dev, dev_data->cb_data);
  120301:	ff 71 10             	pushl  0x10(%ecx)
  120304:	52                   	push   %edx
  120305:	ff d0                	call   *%eax
  120307:	58                   	pop    %eax
  120308:	5a                   	pop    %edx
	}

}
  120309:	c9                   	leave  
  12030a:	c3                   	ret    

0012030b <irq_config_func_0>:
#define INST_0_IRQ_FLAGS 0
#endif

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_0(const struct device *dev)
{
  12030b:	55                   	push   %ebp
  12030c:	89 e5                	mov    %esp,%ebp
#endif
#else

	/* not PCI(e) */

	IRQ_CONNECT(DT_INST_IRQN(0),
  12030e:	0f b6 05 14 93 12 00 	movzbl 0x129314,%eax
  120315:	68 00 01 00 00       	push   $0x100
  12031a:	6a 04                	push   $0x4
  12031c:	50                   	push   %eax
  12031d:	e8 e9 a2 fe ff       	call   10a60b <z_irq_controller_irq_config>
  120322:	83 c4 0c             	add    $0xc,%esp
		    DT_INST_IRQ(0, priority),
		    uart_ns16550_isr,
		    DEVICE_GET(uart_ns16550_0),
		    INST_0_IRQ_FLAGS);

	irq_enable(DT_INST_IRQN(0));
  120325:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)

#endif
}
  12032c:	c9                   	leave  
	irq_enable(DT_INST_IRQN(0));
  12032d:	e9 ff a2 fe ff       	jmp    10a631 <arch_irq_enable>

00120332 <uart_ns16550_isr_irq4_stub>:
  120332:	68 64 5b 14 00       	push   $0x145b64
  120337:	68 f1 02 12 00       	push   $0x1202f1
  12033c:	e9 42 b4 fe ff       	jmp    10b783 <_interrupt_enter>

00120341 <uart_ns16550_isr_irq3_stub>:
  120341:	68 54 5b 14 00       	push   $0x145b54
  120346:	68 f1 02 12 00       	push   $0x1202f1
  12034b:	e9 33 b4 fe ff       	jmp    10b783 <_interrupt_enter>

00120350 <irq_config_func_1>:
#define INST_1_IRQ_FLAGS 0
#endif

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void irq_config_func_1(const struct device *dev)
{
  120350:	55                   	push   %ebp
  120351:	89 e5                	mov    %esp,%ebp
#endif
#else

	/* not PCI(e) */

	IRQ_CONNECT(DT_INST_IRQN(1),
  120353:	0f b6 05 13 93 12 00 	movzbl 0x129313,%eax
  12035a:	68 00 01 00 00       	push   $0x100
  12035f:	6a 03                	push   $0x3
  120361:	50                   	push   %eax
  120362:	e8 a4 a2 fe ff       	call   10a60b <z_irq_controller_irq_config>
  120367:	83 c4 0c             	add    $0xc,%esp
		    DT_INST_IRQ(1, priority),
		    uart_ns16550_isr,
		    DEVICE_GET(uart_ns16550_1),
		    INST_1_IRQ_FLAGS);

	irq_enable(DT_INST_IRQN(1));
  12036a:	c7 45 08 03 00 00 00 	movl   $0x3,0x8(%ebp)

#endif
}
  120371:	c9                   	leave  
	irq_enable(DT_INST_IRQN(1));
  120372:	e9 ba a2 fe ff       	jmp    10a631 <arch_irq_enable>

00120377 <uart_ns16550_init>:
{
  120377:	55                   	push   %ebp
  120378:	89 e5                	mov    %esp,%ebp
  12037a:	53                   	push   %ebx
  12037b:	52                   	push   %edx
  12037c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	ret = uart_ns16550_configure(dev, &DEV_DATA(dev)->uart_config);
  12037f:	ff 73 0c             	pushl  0xc(%ebx)
  120382:	53                   	push   %ebx
  120383:	e8 e3 fb ff ff       	call   11ff6b <uart_ns16550_configure>
  120388:	59                   	pop    %ecx
	if (ret != 0) {
  120389:	85 c0                	test   %eax,%eax
	ret = uart_ns16550_configure(dev, &DEV_DATA(dev)->uart_config);
  12038b:	5a                   	pop    %edx
	if (ret != 0) {
  12038c:	75 0e                	jne    12039c <uart_ns16550_init+0x25>
	DEV_CFG(dev)->irq_config_func(dev);
  12038e:	8b 53 04             	mov    0x4(%ebx),%edx
  120391:	53                   	push   %ebx
  120392:	89 45 f8             	mov    %eax,-0x8(%ebp)
  120395:	ff 52 08             	call   *0x8(%edx)
  120398:	58                   	pop    %eax
  120399:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  12039c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  12039f:	c9                   	leave  
  1203a0:	c3                   	ret    

001203a1 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
  1203a1:	55                   	push   %ebp
  1203a2:	89 e5                	mov    %esp,%ebp
  1203a4:	57                   	push   %edi
  1203a5:	56                   	push   %esi
  1203a6:	8b 75 08             	mov    0x8(%ebp),%esi
  1203a9:	53                   	push   %ebx
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  1203aa:	8b 3c b5 a4 46 12 00 	mov    0x1246a4(,%esi,4),%edi
  1203b1:	39 3c b5 a8 46 12 00 	cmp    %edi,0x1246a8(,%esi,4)
  1203b8:	76 24                	jbe    1203de <z_sys_init_run_level+0x3d>
		const struct device *dev = entry->dev;
  1203ba:	8b 5f 04             	mov    0x4(%edi),%ebx

		if (dev != NULL) {
			z_object_init(dev);
		}

		if ((entry->init(dev) != 0) && (dev != NULL)) {
  1203bd:	53                   	push   %ebx
  1203be:	ff 17                	call   *(%edi)
  1203c0:	5a                   	pop    %edx
  1203c1:	85 c0                	test   %eax,%eax
  1203c3:	74 14                	je     1203d9 <z_sys_init_run_level+0x38>
  1203c5:	85 db                	test   %ebx,%ebx
  1203c7:	74 10                	je     1203d9 <z_sys_init_run_level+0x38>
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
  1203c9:	81 eb 54 5b 14 00    	sub    $0x145b54,%ebx
  1203cf:	c1 fb 04             	sar    $0x4,%ebx
	__asm__ volatile("btsl %1, %0"
  1203d2:	0f ab 1d 94 5b 14 00 	bts    %ebx,0x145b94
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  1203d9:	83 c7 08             	add    $0x8,%edi
  1203dc:	eb d3                	jmp    1203b1 <z_sys_init_run_level+0x10>
		}
	}
}
  1203de:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1203e1:	5b                   	pop    %ebx
  1203e2:	5e                   	pop    %esi
  1203e3:	5f                   	pop    %edi
  1203e4:	5d                   	pop    %ebp
  1203e5:	c3                   	ret    

001203e6 <z_device_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_ready(const struct device *dev)
{
  1203e6:	55                   	push   %ebp
  1203e7:	89 e5                	mov    %esp,%ebp
	/* Set bit indicates device failed initialization */
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
					(dev - __device_start)));
  1203e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1203ec:	2d 54 5b 14 00       	sub    $0x145b54,%eax
  1203f1:	c1 f8 04             	sar    $0x4,%eax
	__asm__ volatile("btl %2, %1;"
  1203f4:	0f a3 05 94 5b 14 00 	bt     %eax,0x145b94
  1203fb:	19 c0                	sbb    %eax,%eax
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
  1203fd:	85 c0                	test   %eax,%eax
}
  1203ff:	5d                   	pop    %ebp
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
  120400:	0f 94 c0             	sete   %al
}
  120403:	c3                   	ret    

00120404 <z_impl_device_get_binding>:
{
  120404:	55                   	push   %ebp
  120405:	89 e5                	mov    %esp,%ebp
  120407:	56                   	push   %esi
  120408:	53                   	push   %ebx
	for (dev = __device_start; dev != __device_end; dev++) {
  120409:	bb 54 5b 14 00       	mov    $0x145b54,%ebx
{
  12040e:	8b 75 08             	mov    0x8(%ebp),%esi
	for (dev = __device_start; dev != __device_end; dev++) {
  120411:	81 fb 94 5b 14 00    	cmp    $0x145b94,%ebx
  120417:	74 14                	je     12042d <z_impl_device_get_binding+0x29>
		if (z_device_ready(dev) && (dev->name == name)) {
  120419:	53                   	push   %ebx
  12041a:	e8 c7 ff ff ff       	call   1203e6 <z_device_ready>
  12041f:	59                   	pop    %ecx
  120420:	84 c0                	test   %al,%al
  120422:	74 04                	je     120428 <z_impl_device_get_binding+0x24>
  120424:	39 33                	cmp    %esi,(%ebx)
  120426:	74 34                	je     12045c <z_impl_device_get_binding+0x58>
	for (dev = __device_start; dev != __device_end; dev++) {
  120428:	83 c3 10             	add    $0x10,%ebx
  12042b:	eb e4                	jmp    120411 <z_impl_device_get_binding+0xd>
	for (dev = __device_start; dev != __device_end; dev++) {
  12042d:	bb 54 5b 14 00       	mov    $0x145b54,%ebx
  120432:	81 fb 94 5b 14 00    	cmp    $0x145b94,%ebx
  120438:	74 20                	je     12045a <z_impl_device_get_binding+0x56>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
  12043a:	53                   	push   %ebx
  12043b:	e8 a6 ff ff ff       	call   1203e6 <z_device_ready>
  120440:	5a                   	pop    %edx
  120441:	84 c0                	test   %al,%al
  120443:	75 05                	jne    12044a <z_impl_device_get_binding+0x46>
	for (dev = __device_start; dev != __device_end; dev++) {
  120445:	83 c3 10             	add    $0x10,%ebx
  120448:	eb e8                	jmp    120432 <z_impl_device_get_binding+0x2e>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
  12044a:	ff 33                	pushl  (%ebx)
  12044c:	56                   	push   %esi
  12044d:	e8 dd b8 fe ff       	call   10bd2f <strcmp>
  120452:	5a                   	pop    %edx
  120453:	85 c0                	test   %eax,%eax
  120455:	59                   	pop    %ecx
  120456:	75 ed                	jne    120445 <z_impl_device_get_binding+0x41>
  120458:	eb 02                	jmp    12045c <z_impl_device_get_binding+0x58>
	return NULL;
  12045a:	31 db                	xor    %ebx,%ebx
}
  12045c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  12045f:	89 d8                	mov    %ebx,%eax
  120461:	5b                   	pop    %ebx
  120462:	5e                   	pop    %esi
  120463:	5d                   	pop    %ebp
  120464:	c3                   	ret    

00120465 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
  120465:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  12046a:	83 c0 7c             	add    $0x7c,%eax
}
  12046d:	c3                   	ret    

0012046e <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  12046e:	55                   	push   %ebp
  12046f:	89 e5                	mov    %esp,%ebp
	z_impl_log_panic();
  120471:	e8 4f 32 fe ff       	call   1036c5 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  120476:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  12047d:	74 20                	je     12049f <k_sys_fatal_error_handler+0x31>
  12047f:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  120484:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  120489:	c1 e8 03             	shr    $0x3,%eax
  12048c:	c1 e0 06             	shl    $0x6,%eax
  12048f:	83 c8 01             	or     $0x1,%eax
  120492:	50                   	push   %eax
  120493:	68 3d 89 12 00       	push   $0x12893d
  120498:	e8 b0 30 fe ff       	call   10354d <log_0>
  12049d:	58                   	pop    %eax
  12049e:	5a                   	pop    %edx
	arch_system_halt(reason);
  12049f:	ff 75 08             	pushl  0x8(%ebp)
  1204a2:	e8 81 a7 fe ff       	call   10ac28 <arch_system_halt>

001204a7 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  1204a7:	55                   	push   %ebp
  1204a8:	89 e5                	mov    %esp,%ebp
  1204aa:	57                   	push   %edi
  1204ab:	56                   	push   %esi
  1204ac:	53                   	push   %ebx
  1204ad:	83 ec 08             	sub    $0x8,%esp
  1204b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1204b3:	8b 7d 08             	mov    0x8(%ebp),%edi
  1204b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1204b9:	9c                   	pushf  
  1204ba:	fa                   	cli    
  1204bb:	8f 45 ec             	popl   -0x14(%ebp)
	return z_impl_k_current_get();
  1204be:	e8 8e 13 00 00       	call   121851 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  1204c3:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  1204ca:	89 c3                	mov    %eax,%ebx
  1204cc:	74 7c                	je     12054a <z_fatal_error+0xa3>
  1204ce:	be b8 31 12 00       	mov    $0x1231b8,%esi
  1204d3:	ba 4c 89 12 00       	mov    $0x12894c,%edx
  1204d8:	81 ee b0 30 12 00    	sub    $0x1230b0,%esi
  1204de:	c1 ee 03             	shr    $0x3,%esi
  1204e1:	89 f0                	mov    %esi,%eax
  1204e3:	c1 e0 06             	shl    $0x6,%eax
  1204e6:	83 c8 01             	or     $0x1,%eax
	switch (reason) {
  1204e9:	83 ff 04             	cmp    $0x4,%edi
  1204ec:	77 07                	ja     1204f5 <z_fatal_error+0x4e>
  1204ee:	8b 14 bd bc 46 12 00 	mov    0x1246bc(,%edi,4),%edx
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  1204f5:	50                   	push   %eax
  1204f6:	6a 00                	push   $0x0
  1204f8:	52                   	push   %edx
  1204f9:	57                   	push   %edi
  1204fa:	68 62 89 12 00       	push   $0x128962
  1204ff:	e8 f5 30 fe ff       	call   1035f9 <log_3>
  120504:	83 c4 14             	add    $0x14,%esp
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  120507:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  12050e:	74 3a                	je     12054a <z_fatal_error+0xa3>
  120510:	c1 e6 06             	shl    $0x6,%esi
  120513:	83 ce 01             	or     $0x1,%esi
	const char *thread_name = thread ? k_thread_name_get(thread) : NULL;
  120516:	85 db                	test   %ebx,%ebx
  120518:	75 07                	jne    120521 <z_fatal_error+0x7a>
		thread_name = "unknown";
  12051a:	b8 5a 89 12 00       	mov    $0x12895a,%eax
  12051f:	eb 10                	jmp    120531 <z_fatal_error+0x8a>
	const char *thread_name = thread ? k_thread_name_get(thread) : NULL;
  120521:	53                   	push   %ebx
  120522:	e8 33 15 00 00       	call   121a5a <k_thread_name_get>
  120527:	59                   	pop    %ecx
	if (thread_name == NULL || thread_name[0] == '\0') {
  120528:	85 c0                	test   %eax,%eax
  12052a:	74 ee                	je     12051a <z_fatal_error+0x73>
  12052c:	80 38 00             	cmpb   $0x0,(%eax)
  12052f:	74 e9                	je     12051a <z_fatal_error+0x73>
	LOG_ERR("Current thread: %p (%s)", thread,
  120531:	50                   	push   %eax
  120532:	e8 20 2d fe ff       	call   103257 <log_strdup>
  120537:	66 89 34 24          	mov    %si,(%esp)
  12053b:	50                   	push   %eax
  12053c:	53                   	push   %ebx
  12053d:	68 8a 89 12 00       	push   $0x12898a
  120542:	e8 69 30 fe ff       	call   1035b0 <log_2>
  120547:	83 c4 10             	add    $0x10,%esp
		log_strdup(thread_name_get(thread)));

	z_coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
  12054a:	ff 75 f0             	pushl  -0x10(%ebp)
  12054d:	57                   	push   %edi
  12054e:	e8 1b ff ff ff       	call   12046e <k_sys_fatal_error_handler>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120553:	0f ba 65 ec 09       	btl    $0x9,-0x14(%ebp)
  120558:	58                   	pop    %eax
  120559:	5a                   	pop    %edx
  12055a:	73 01                	jae    12055d <z_fatal_error+0xb6>
		__asm__ volatile ("sti" ::: "memory");
  12055c:	fb                   	sti    
	z_impl_k_thread_abort(thread);
  12055d:	89 5d 08             	mov    %ebx,0x8(%ebp)
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
  120560:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120563:	5b                   	pop    %ebx
  120564:	5e                   	pop    %esi
  120565:	5f                   	pop    %edi
  120566:	5d                   	pop    %ebp
  120567:	e9 cb 17 00 00       	jmp    121d37 <z_impl_k_thread_abort>

0012056c <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  12056c:	55                   	push   %ebp
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
  12056d:	c6 05 82 ed 12 00 01 	movb   $0x1,0x12ed82
{
  120574:	89 e5                	mov    %esp,%ebp

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
  120576:	6a 02                	push   $0x2
  120578:	e8 24 fe ff ff       	call   1203a1 <z_sys_init_run_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
  12057d:	c7 04 24 02 4e 12 00 	movl   $0x124e02,(%esp)
  120584:	68 ec 89 12 00       	push   $0x1289ec
  120589:	68 0d 8a 12 00       	push   $0x128a0d
  12058e:	e8 17 0d fe ff       	call   1012aa <printk>
  120593:	83 c4 0c             	add    $0xc,%esp

#ifdef CONFIG_CPLUSPLUS
	/* Process the .ctors and .init_array sections */
	extern void __do_global_ctors_aux(void);
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
  120596:	e8 7b 7c fe ff       	call   108216 <__do_global_ctors_aux>
	__do_init_array_aux();
  12059b:	e8 5b 7c fe ff       	call   1081fb <__do_init_array_aux>
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
  1205a0:	6a 03                	push   $0x3
  1205a2:	e8 fa fd ff ff       	call   1203a1 <z_sys_init_run_level>
  1205a7:	58                   	pop    %eax

	z_init_static_threads();
  1205a8:	e8 93 16 00 00       	call   121c40 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
  1205ad:	e8 1f 03 fe ff       	call   1008d1 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  1205b2:	80 25 2c e9 12 00 fe 	andb   $0xfe,0x12e92c

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  1205b9:	c9                   	leave  
  1205ba:	c3                   	ret    

001205bb <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
  1205bb:	55                   	push   %ebp
  1205bc:	89 e5                	mov    %esp,%ebp
  1205be:	56                   	push   %esi
  1205bf:	53                   	push   %ebx
  1205c0:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	snprintk(tname, 8, "idle %02d", i);
  1205c6:	8d b5 5c ff ff ff    	lea    -0xa4(%ebp),%esi
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
  1205cc:	e8 88 29 fe ff       	call   102f59 <log_core_init>
	_current_cpu->current = dummy_thread;
  1205d1:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  1205d7:	6a 00                	push   $0x0
  1205d9:	a3 c8 e9 12 00       	mov    %eax,0x12e9c8
	dummy_thread->base.user_options = K_ESSENTIAL;
  1205de:	66 c7 85 70 ff ff ff 	movw   $0x101,-0x90(%ebp)
  1205e5:	01 01 
	dummy_thread->stack_info.start = 0U;
  1205e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	dummy_thread->stack_info.size = 0U;
  1205ee:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1205f5:	e8 a7 fd ff ff       	call   1203a1 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  1205fa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  120601:	e8 9b fd ff ff       	call   1203a1 <z_sys_init_run_level>
  120606:	58                   	pop    %eax
	z_sched_init();
  120607:	e8 79 11 00 00       	call   121785 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  12060c:	68 34 8a 12 00       	push   $0x128a34
	_kernel.ready_q.cache = &z_main_thread;
  120611:	c7 05 e4 e9 12 00 20 	movl   $0x12e920,0x12e9e4
  120618:	e9 12 00 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  12061b:	6a 01                	push   $0x1
  12061d:	6a 00                	push   $0x0
  12061f:	6a 00                	push   $0x0
  120621:	6a 00                	push   $0x0
  120623:	6a 00                	push   $0x0
  120625:	68 6c 05 12 00       	push   $0x12056c
  12062a:	68 00 04 00 00       	push   $0x400
  12062f:	68 ec 47 14 00       	push   $0x1447ec
  120634:	68 20 e9 12 00       	push   $0x12e920
  120639:	e8 89 14 00 00       	call   121ac7 <z_setup_new_thread>
  12063e:	83 c4 28             	add    $0x28,%esp
  120641:	89 c3                	mov    %eax,%ebx
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  120643:	80 25 2d e9 12 00 fb 	andb   $0xfb,0x12e92d
	z_ready_thread(&z_main_thread);
  12064a:	68 20 e9 12 00       	push   $0x12e920
  12064f:	e8 97 0c 00 00       	call   1212eb <z_ready_thread>
	snprintk(tname, 8, "idle %02d", i);
  120654:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  12065b:	68 39 8a 12 00       	push   $0x128a39
  120660:	6a 08                	push   $0x8
  120662:	56                   	push   %esi
  120663:	e8 97 0c fe ff       	call   1012ff <snprintk>
  120668:	83 c4 10             	add    $0x10,%esp
	z_setup_new_thread(thread, stack,
  12066b:	56                   	push   %esi
  12066c:	6a 01                	push   $0x1
  12066e:	6a 0f                	push   $0xf
  120670:	6a 00                	push   $0x0
  120672:	6a 00                	push   $0x0
  120674:	68 c0 e9 12 00       	push   $0x12e9c0
  120679:	68 84 2b 12 00       	push   $0x122b84
  12067e:	68 00 01 00 00       	push   $0x100
  120683:	68 ec 46 14 00       	push   $0x1446ec
  120688:	68 80 e8 12 00       	push   $0x12e880
  12068d:	e8 35 14 00 00       	call   121ac7 <z_setup_new_thread>
  120692:	83 c4 28             	add    $0x28,%esp
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
  120695:	c7 05 cc e9 12 00 80 	movl   $0x12e880,0x12e9cc
  12069c:	e8 12 00 
  12069f:	80 25 8d e8 12 00 fb 	andb   $0xfb,0x12e88d
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  1206a6:	68 6c 05 12 00       	push   $0x12056c
		_kernel.cpus[i].id = i;
  1206ab:	c6 05 d8 e9 12 00 00 	movb   $0x0,0x12e9d8
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  1206b2:	53                   	push   %ebx
		_kernel.cpus[i].irq_stack =
  1206b3:	c7 05 c4 e9 12 00 ec 	movl   $0x1453ec,0x12e9c4
  1206ba:	53 14 00 
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  1206bd:	68 20 e9 12 00       	push   $0x12e920
	list->head = (sys_dnode_t *)list;
  1206c2:	c7 05 dc e9 12 00 dc 	movl   $0x12e9dc,0x12e9dc
  1206c9:	e9 12 00 
	list->tail = (sys_dnode_t *)list;
  1206cc:	c7 05 e0 e9 12 00 dc 	movl   $0x12e9dc,0x12e9e0
  1206d3:	e9 12 00 
  1206d6:	e8 8d b1 fe ff       	call   10b868 <arch_switch_to_main_thread>
  1206db:	83 c4 0c             	add    $0xc,%esp

001206de <k_heap_init>:
#include <ksched.h>
#include <wait_q.h>
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
  1206de:	55                   	push   %ebp
#define _WAIT_Q_FOR_EACH(wq, thread_ptr) \
	RB_FOR_EACH_CONTAINER(&(wq)->waitq.tree, thread_ptr, base.qnode_rb)

static inline void z_waitq_init(_wait_q_t *w)
{
	w->waitq = (struct _priq_rb) {
  1206df:	b9 04 00 00 00       	mov    $0x4,%ecx
  1206e4:	89 e5                	mov    %esp,%ebp
  1206e6:	31 c0                	xor    %eax,%eax
  1206e8:	57                   	push   %edi
  1206e9:	8b 55 08             	mov    0x8(%ebp),%edx
  1206ec:	8d 7a 0c             	lea    0xc(%edx),%edi
  1206ef:	f3 ab                	rep stos %eax,%es:(%edi)
  1206f1:	c7 42 10 c4 0f 12 00 	movl   $0x120fc4,0x10(%edx)
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}
  1206f8:	5f                   	pop    %edi
  1206f9:	5d                   	pop    %ebp
	sys_heap_init(&h->heap, mem, bytes);
  1206fa:	e9 eb 17 fe ff       	jmp    101eea <sys_heap_init>

001206ff <statics_init>:

static int statics_init(const struct device *unused)
{
  1206ff:	55                   	push   %ebp
  120700:	89 e5                	mov    %esp,%ebp
  120702:	53                   	push   %ebx
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
  120703:	bb cc 5c 14 00       	mov    $0x145ccc,%ebx
  120708:	81 fb cc 5c 14 00    	cmp    $0x145ccc,%ebx
  12070e:	73 14                	jae    120724 <statics_init+0x25>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  120710:	ff 73 08             	pushl  0x8(%ebx)
  120713:	ff 73 04             	pushl  0x4(%ebx)
  120716:	53                   	push   %ebx
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
  120717:	83 c3 20             	add    $0x20,%ebx
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  12071a:	e8 bf ff ff ff       	call   1206de <k_heap_init>
  12071f:	83 c4 0c             	add    $0xc,%esp
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
  120722:	eb e4                	jmp    120708 <statics_init+0x9>
	}
	return 0;
}
  120724:	31 c0                	xor    %eax,%eax
  120726:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  120729:	c9                   	leave  
  12072a:	c3                   	ret    

0012072b <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
  12072b:	55                   	push   %ebp
  12072c:	89 e5                	mov    %esp,%ebp
  12072e:	57                   	push   %edi
  12072f:	56                   	push   %esi
  120730:	53                   	push   %ebx
  120731:	83 ec 10             	sub    $0x10,%esp
	int64_t now, end = z_timeout_end_calc(timeout);
  120734:	ff 75 14             	pushl  0x14(%ebp)
  120737:	ff 75 10             	pushl  0x10(%ebp)
  12073a:	e8 4d 1c 00 00       	call   12238c <z_timeout_end_calc>
  12073f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  120742:	8b 45 08             	mov    0x8(%ebp),%eax
	int64_t now, end = z_timeout_end_calc(timeout);
  120745:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  120746:	83 c0 1c             	add    $0x1c,%eax
	int64_t now, end = z_timeout_end_calc(timeout);
  120749:	5e                   	pop    %esi
  12074a:	89 55 ec             	mov    %edx,-0x14(%ebp)
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  12074d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  120750:	9c                   	pushf  
  120751:	fa                   	cli    
  120752:	5b                   	pop    %ebx

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");

	while (ret == NULL) {
		ret = sys_heap_alloc(&h->heap, bytes);
  120753:	ff 75 0c             	pushl  0xc(%ebp)
  120756:	ff 75 08             	pushl  0x8(%ebp)
  120759:	e8 0c 17 fe ff       	call   101e6a <sys_heap_alloc>
  12075e:	5a                   	pop    %edx
  12075f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  120762:	59                   	pop    %ecx

		now = z_tick_get();
  120763:	e8 f1 1b 00 00       	call   122359 <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
  120768:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  12076b:	85 c9                	test   %ecx,%ecx
  12076d:	75 2b                	jne    12079a <k_heap_alloc+0x6f>
  12076f:	8b 75 e8             	mov    -0x18(%ebp),%esi
  120772:	8b 7d ec             	mov    -0x14(%ebp),%edi
  120775:	29 c6                	sub    %eax,%esi
  120777:	19 d7                	sbb    %edx,%edi
  120779:	89 f0                	mov    %esi,%eax
  12077b:	39 f1                	cmp    %esi,%ecx
  12077d:	89 ce                	mov    %ecx,%esi
  12077f:	19 fe                	sbb    %edi,%esi
  120781:	7d 17                	jge    12079a <k_heap_alloc+0x6f>
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  120783:	57                   	push   %edi
  120784:	50                   	push   %eax
  120785:	8b 45 08             	mov    0x8(%ebp),%eax
  120788:	83 c0 0c             	add    $0xc,%eax
  12078b:	50                   	push   %eax
  12078c:	53                   	push   %ebx
  12078d:	ff 75 f0             	pushl  -0x10(%ebp)
  120790:	e8 f4 0e 00 00       	call   121689 <z_pend_curr>
  120795:	83 c4 14             	add    $0x14,%esp
  120798:	eb b6                	jmp    120750 <k_heap_alloc+0x25>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12079a:	0f ba e3 09          	bt     $0x9,%ebx
  12079e:	73 01                	jae    1207a1 <k_heap_alloc+0x76>
		__asm__ volatile ("sti" ::: "memory");
  1207a0:	fb                   	sti    
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
  1207a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1207a4:	89 c8                	mov    %ecx,%eax
  1207a6:	5b                   	pop    %ebx
  1207a7:	5e                   	pop    %esi
  1207a8:	5f                   	pop    %edi
  1207a9:	5d                   	pop    %ebp
  1207aa:	c3                   	ret    

001207ab <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
  1207ab:	55                   	push   %ebp
  1207ac:	89 e5                	mov    %esp,%ebp
  1207ae:	56                   	push   %esi
  1207af:	53                   	push   %ebx
  1207b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1207b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1207b6:	9c                   	pushf  
  1207b7:	fa                   	cli    
  1207b8:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
  1207b9:	50                   	push   %eax
  1207ba:	53                   	push   %ebx
  1207bb:	e8 d2 15 fe ff       	call   101d92 <sys_heap_free>
  1207c0:	58                   	pop    %eax

	if (z_unpend_all(&h->wait_q) != 0) {
  1207c1:	8d 43 0c             	lea    0xc(%ebx),%eax
	sys_heap_free(&h->heap, mem);
  1207c4:	5a                   	pop    %edx
	if (z_unpend_all(&h->wait_q) != 0) {
  1207c5:	50                   	push   %eax
  1207c6:	e8 82 0f 00 00       	call   12174d <z_unpend_all>
  1207cb:	59                   	pop    %ecx
  1207cc:	85 c0                	test   %eax,%eax
  1207ce:	74 14                	je     1207e4 <k_heap_free+0x39>
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  1207d0:	83 c3 1c             	add    $0x1c,%ebx
		z_reschedule(&h->lock, key);
  1207d3:	89 75 0c             	mov    %esi,0xc(%ebp)
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  1207d6:	89 5d 08             	mov    %ebx,0x8(%ebp)
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
  1207d9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1207dc:	5b                   	pop    %ebx
  1207dd:	5e                   	pop    %esi
  1207de:	5d                   	pop    %ebp
		z_reschedule(&h->lock, key);
  1207df:	e9 da 08 00 00       	jmp    1210be <z_reschedule>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1207e4:	0f ba e6 09          	bt     $0x9,%esi
  1207e8:	73 01                	jae    1207eb <k_heap_free+0x40>
		__asm__ volatile ("sti" ::: "memory");
  1207ea:	fb                   	sti    
}
  1207eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1207ee:	5b                   	pop    %ebx
  1207ef:	5e                   	pop    %esi
  1207f0:	5d                   	pop    %ebp
  1207f1:	c3                   	ret    

001207f2 <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
  1207f2:	55                   	push   %ebp
  1207f3:	89 e5                	mov    %esp,%ebp
  1207f5:	57                   	push   %edi
  1207f6:	56                   	push   %esi
	block->id.heap = p->heap;
  1207f7:	8b 45 08             	mov    0x8(%ebp),%eax
{
  1207fa:	53                   	push   %ebx
	block->id.heap = p->heap;
  1207fb:	8b 55 0c             	mov    0xc(%ebp),%edx
{
  1207fe:	8b 7d 18             	mov    0x18(%ebp),%edi
	block->id.heap = p->heap;
  120801:	8b 00                	mov    (%eax),%eax
{
  120803:	8b 75 14             	mov    0x14(%ebp),%esi
	block->id.heap = p->heap;
  120806:	89 42 04             	mov    %eax,0x4(%edx)
	block->data = k_heap_alloc(p->heap, size, timeout);
  120809:	57                   	push   %edi
  12080a:	56                   	push   %esi
{
  12080b:	8b 5d 10             	mov    0x10(%ebp),%ebx
	block->data = k_heap_alloc(p->heap, size, timeout);
  12080e:	53                   	push   %ebx
  12080f:	50                   	push   %eax
  120810:	e8 16 ff ff ff       	call   12072b <k_heap_alloc>
  120815:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  120818:	83 c4 10             	add    $0x10,%esp

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
  12081b:	85 c0                	test   %eax,%eax
	block->data = k_heap_alloc(p->heap, size, timeout);
  12081d:	89 01                	mov    %eax,(%ecx)
	if (size != 0 && block->data == NULL) {
  12081f:	75 13                	jne    120834 <k_mem_pool_alloc+0x42>
  120821:	85 db                	test   %ebx,%ebx
  120823:	74 0f                	je     120834 <k_mem_pool_alloc+0x42>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
  120825:	89 f8                	mov    %edi,%eax
  120827:	09 f0                	or     %esi,%eax
  120829:	0f 95 c0             	setne  %al
  12082c:	0f b6 c0             	movzbl %al,%eax
  12082f:	83 e8 0c             	sub    $0xc,%eax
  120832:	eb 02                	jmp    120836 <k_mem_pool_alloc+0x44>
	} else {
		return 0;
  120834:	31 c0                	xor    %eax,%eax
	}
}
  120836:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120839:	5b                   	pop    %ebx
  12083a:	5e                   	pop    %esi
  12083b:	5f                   	pop    %edi
  12083c:	5d                   	pop    %ebp
  12083d:	c3                   	ret    

0012083e <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
  12083e:	55                   	push   %ebp
  12083f:	89 e5                	mov    %esp,%ebp
  120841:	8b 45 08             	mov    0x8(%ebp),%eax
	k_heap_free(id->heap, id->data);
  120844:	ff 30                	pushl  (%eax)
  120846:	ff 70 04             	pushl  0x4(%eax)
  120849:	e8 5d ff ff ff       	call   1207ab <k_heap_free>
  12084e:	58                   	pop    %eax
  12084f:	5a                   	pop    %edx
}
  120850:	c9                   	leave  
  120851:	c3                   	ret    

00120852 <init_mem_slab_module>:
static int init_mem_slab_module(const struct device *dev)
{
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  120852:	b8 60 5c 14 00       	mov    $0x145c60,%eax
  120857:	3d cc 5c 14 00       	cmp    $0x145ccc,%eax
  12085c:	72 03                	jb     120861 <init_mem_slab_module+0xf>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
  12085e:	31 c0                	xor    %eax,%eax
	return rc;
}
  120860:	c3                   	ret    
{
  120861:	55                   	push   %ebp
  120862:	89 e5                	mov    %esp,%ebp
  120864:	57                   	push   %edi
  120865:	56                   	push   %esi
  120866:	53                   	push   %ebx
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  120867:	8b 48 18             	mov    0x18(%eax),%ecx
  12086a:	8b 58 14             	mov    0x14(%eax),%ebx
  12086d:	89 ca                	mov    %ecx,%edx
  12086f:	09 da                	or     %ebx,%edx
  120871:	83 e2 03             	and    $0x3,%edx
  120874:	75 29                	jne    12089f <init_mem_slab_module+0x4d>
	slab->free_list = NULL;
  120876:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	for (j = 0U; j < slab->num_blocks; j++) {
  12087d:	8b 70 10             	mov    0x10(%eax),%esi
  120880:	39 f2                	cmp    %esi,%edx
  120882:	74 0d                	je     120891 <init_mem_slab_module+0x3f>
		*(char **)p = slab->free_list;
  120884:	8b 78 1c             	mov    0x1c(%eax),%edi
	for (j = 0U; j < slab->num_blocks; j++) {
  120887:	42                   	inc    %edx
		*(char **)p = slab->free_list;
  120888:	89 39                	mov    %edi,(%ecx)
		slab->free_list = p;
  12088a:	89 48 1c             	mov    %ecx,0x1c(%eax)
		p += slab->block_size;
  12088d:	01 d9                	add    %ebx,%ecx
	for (j = 0U; j < slab->num_blocks; j++) {
  12088f:	eb ef                	jmp    120880 <init_mem_slab_module+0x2e>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  120891:	83 c0 24             	add    $0x24,%eax
  120894:	3d cc 5c 14 00       	cmp    $0x145ccc,%eax
  120899:	72 cc                	jb     120867 <init_mem_slab_module+0x15>
out:
  12089b:	31 c0                	xor    %eax,%eax
  12089d:	eb 05                	jmp    1208a4 <init_mem_slab_module+0x52>
		return -EINVAL;
  12089f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  1208a4:	5b                   	pop    %ebx
  1208a5:	5e                   	pop    %esi
  1208a6:	5f                   	pop    %edi
  1208a7:	5d                   	pop    %ebp
  1208a8:	c3                   	ret    

001208a9 <k_mem_slab_init>:
SYS_INIT(init_mem_slab_module, PRE_KERNEL_1,
	 CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, uint32_t num_blocks)
{
  1208a9:	55                   	push   %ebp
  1208aa:	89 e5                	mov    %esp,%ebp
  1208ac:	57                   	push   %edi
  1208ad:	56                   	push   %esi
  1208ae:	be ea ff ff ff       	mov    $0xffffffea,%esi
  1208b3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1208b6:	53                   	push   %ebx
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  1208b7:	89 c8                	mov    %ecx,%eax
{
  1208b9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  1208bc:	8b 55 08             	mov    0x8(%ebp),%edx
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  1208bf:	09 d8                	or     %ebx,%eax
{
  1208c1:	8b 7d 14             	mov    0x14(%ebp),%edi
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  1208c4:	83 e0 03             	and    $0x3,%eax
	int rc = 0;

	slab->num_blocks = num_blocks;
  1208c7:	89 7a 10             	mov    %edi,0x10(%edx)
	slab->block_size = block_size;
  1208ca:	89 5a 14             	mov    %ebx,0x14(%edx)
	slab->buffer = buffer;
  1208cd:	89 4a 18             	mov    %ecx,0x18(%edx)
	slab->num_used = 0U;
  1208d0:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  1208d7:	75 2c                	jne    120905 <k_mem_slab_init+0x5c>
	slab->free_list = NULL;
  1208d9:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	for (j = 0U; j < slab->num_blocks; j++) {
  1208e0:	39 c7                	cmp    %eax,%edi
  1208e2:	74 0d                	je     1208f1 <k_mem_slab_init+0x48>
		*(char **)p = slab->free_list;
  1208e4:	8b 72 1c             	mov    0x1c(%edx),%esi
	for (j = 0U; j < slab->num_blocks; j++) {
  1208e7:	40                   	inc    %eax
		*(char **)p = slab->free_list;
  1208e8:	89 31                	mov    %esi,(%ecx)
		slab->free_list = p;
  1208ea:	89 4a 1c             	mov    %ecx,0x1c(%edx)
		p += slab->block_size;
  1208ed:	01 d9                	add    %ebx,%ecx
	for (j = 0U; j < slab->num_blocks; j++) {
  1208ef:	eb ef                	jmp    1208e0 <k_mem_slab_init+0x37>
  1208f1:	b9 04 00 00 00       	mov    $0x4,%ecx
  1208f6:	31 c0                	xor    %eax,%eax
  1208f8:	89 d7                	mov    %edx,%edi
		.tree = {
			.lessthan_fn = z_priq_rb_lessthan
		}
	};
}
  1208fa:	31 f6                	xor    %esi,%esi
	w->waitq = (struct _priq_rb) {
  1208fc:	f3 ab                	rep stos %eax,%es:(%edi)
  1208fe:	c7 42 04 c4 0f 12 00 	movl   $0x120fc4,0x4(%edx)

	z_object_init(slab);

out:
	return rc;
}
  120905:	5b                   	pop    %ebx
  120906:	89 f0                	mov    %esi,%eax
  120908:	5e                   	pop    %esi
  120909:	5f                   	pop    %edi
  12090a:	5d                   	pop    %ebp
  12090b:	c3                   	ret    

0012090c <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
  12090c:	55                   	push   %ebp
  12090d:	89 e5                	mov    %esp,%ebp
  12090f:	57                   	push   %edi
  120910:	56                   	push   %esi
  120911:	53                   	push   %ebx
  120912:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120915:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  120918:	8b 45 10             	mov    0x10(%ebp),%eax
  12091b:	8b 55 14             	mov    0x14(%ebp),%edx
  12091e:	9c                   	pushf  
  12091f:	fa                   	cli    
  120920:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
  120921:	8b 79 1c             	mov    0x1c(%ecx),%edi
  120924:	85 ff                	test   %edi,%edi
  120926:	74 0e                	je     120936 <k_mem_slab_alloc+0x2a>
		/* take a free block */
		*mem = slab->free_list;
  120928:	89 3b                	mov    %edi,(%ebx)
		slab->free_list = *(char **)(slab->free_list);
  12092a:	8b 07                	mov    (%edi),%eax
		slab->num_used++;
  12092c:	ff 41 20             	incl   0x20(%ecx)
		slab->free_list = *(char **)(slab->free_list);
  12092f:	89 41 1c             	mov    %eax,0x1c(%ecx)
		result = 0;
  120932:	31 c0                	xor    %eax,%eax
  120934:	eb 35                	jmp    12096b <k_mem_slab_alloc+0x5f>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  120936:	89 d7                	mov    %edx,%edi
  120938:	09 c7                	or     %eax,%edi
  12093a:	75 0d                	jne    120949 <k_mem_slab_alloc+0x3d>
		/* don't wait for a free block to become available */
		*mem = NULL;
  12093c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		result = -ENOMEM;
  120942:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  120947:	eb 22                	jmp    12096b <k_mem_slab_alloc+0x5f>
	} else {
		/* wait for a free block or timeout */
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
  120949:	52                   	push   %edx
  12094a:	50                   	push   %eax
  12094b:	51                   	push   %ecx
  12094c:	56                   	push   %esi
  12094d:	68 83 ed 12 00       	push   $0x12ed83
  120952:	e8 32 0d 00 00       	call   121689 <z_pend_curr>
  120957:	83 c4 14             	add    $0x14,%esp
		if (result == 0) {
  12095a:	85 c0                	test   %eax,%eax
  12095c:	75 14                	jne    120972 <k_mem_slab_alloc+0x66>
			*mem = _current->base.swap_data;
  12095e:	8b 15 c8 e9 12 00    	mov    0x12e9c8,%edx
  120964:	8b 52 14             	mov    0x14(%edx),%edx
  120967:	89 13                	mov    %edx,(%ebx)
  120969:	eb 07                	jmp    120972 <k_mem_slab_alloc+0x66>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12096b:	0f ba e6 09          	bt     $0x9,%esi
  12096f:	73 01                	jae    120972 <k_mem_slab_alloc+0x66>
		__asm__ volatile ("sti" ::: "memory");
  120971:	fb                   	sti    
	}

	k_spin_unlock(&lock, key);

	return result;
}
  120972:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120975:	5b                   	pop    %ebx
  120976:	5e                   	pop    %esi
  120977:	5f                   	pop    %edi
  120978:	5d                   	pop    %ebp
  120979:	c3                   	ret    

0012097a <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  12097a:	55                   	push   %ebp
  12097b:	89 e5                	mov    %esp,%ebp
  12097d:	57                   	push   %edi
  12097e:	56                   	push   %esi
  12097f:	53                   	push   %ebx
  120980:	8b 75 08             	mov    0x8(%ebp),%esi
  120983:	8b 7d 0c             	mov    0xc(%ebp),%edi
  120986:	9c                   	pushf  
  120987:	fa                   	cli    
  120988:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  120989:	56                   	push   %esi
  12098a:	e8 7c 0d 00 00       	call   12170b <z_unpend_first_thread>
  12098f:	5a                   	pop    %edx

	if (pending_thread != NULL) {
  120990:	85 c0                	test   %eax,%eax
  120992:	74 2b                	je     1209bf <k_mem_slab_free+0x45>
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in z_swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  120994:	8b 48 3c             	mov    0x3c(%eax),%ecx
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  120997:	8b 17                	mov    (%edi),%edx
  120999:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  12099f:	89 50 14             	mov    %edx,0x14(%eax)
		z_ready_thread(pending_thread);
  1209a2:	50                   	push   %eax
  1209a3:	e8 43 09 00 00       	call   1212eb <z_ready_thread>
		z_reschedule(&lock, key);
  1209a8:	89 5d 0c             	mov    %ebx,0xc(%ebp)
  1209ab:	c7 45 08 83 ed 12 00 	movl   $0x12ed83,0x8(%ebp)
		z_ready_thread(pending_thread);
  1209b2:	58                   	pop    %eax
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
  1209b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1209b6:	5b                   	pop    %ebx
  1209b7:	5e                   	pop    %esi
  1209b8:	5f                   	pop    %edi
  1209b9:	5d                   	pop    %ebp
		z_reschedule(&lock, key);
  1209ba:	e9 ff 06 00 00       	jmp    1210be <z_reschedule>
		**(char ***)mem = slab->free_list;
  1209bf:	8b 07                	mov    (%edi),%eax
  1209c1:	8b 56 1c             	mov    0x1c(%esi),%edx
  1209c4:	89 10                	mov    %edx,(%eax)
		slab->free_list = *(char **)mem;
  1209c6:	8b 07                	mov    (%edi),%eax
		slab->num_used--;
  1209c8:	ff 4e 20             	decl   0x20(%esi)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1209cb:	0f ba e3 09          	bt     $0x9,%ebx
		slab->free_list = *(char **)mem;
  1209cf:	89 46 1c             	mov    %eax,0x1c(%esi)
  1209d2:	73 01                	jae    1209d5 <k_mem_slab_free+0x5b>
		__asm__ volatile ("sti" ::: "memory");
  1209d4:	fb                   	sti    
}
  1209d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1209d8:	5b                   	pop    %ebx
  1209d9:	5e                   	pop    %esi
  1209da:	5f                   	pop    %edi
  1209db:	5d                   	pop    %ebp
  1209dc:	c3                   	ret    

001209dd <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  1209dd:	55                   	push   %ebp
  1209de:	89 e5                	mov    %esp,%ebp
  1209e0:	57                   	push   %edi
  1209e1:	56                   	push   %esi
  1209e2:	53                   	push   %ebx
  1209e3:	53                   	push   %ebx
  1209e4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1209e7:	8b 55 0c             	mov    0xc(%ebp),%edx

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  1209ea:	8d 7b 10             	lea    0x10(%ebx),%edi
  1209ed:	9c                   	pushf  
  1209ee:	fa                   	cli    
  1209ef:	5e                   	pop    %esi

	if (msgq->used_msgs < msgq->max_msgs) {
  1209f0:	8b 43 18             	mov    0x18(%ebx),%eax
  1209f3:	39 43 2c             	cmp    %eax,0x2c(%ebx)
  1209f6:	73 6e                	jae    120a66 <z_impl_k_msgq_put+0x89>
  1209f8:	89 55 0c             	mov    %edx,0xc(%ebp)
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  1209fb:	53                   	push   %ebx
  1209fc:	e8 0a 0d 00 00       	call   12170b <z_unpend_first_thread>
  120a01:	59                   	pop    %ecx
		if (pending_thread != NULL) {
  120a02:	85 c0                	test   %eax,%eax
  120a04:	8b 55 0c             	mov    0xc(%ebp),%edx
  120a07:	74 33                	je     120a3c <z_impl_k_msgq_put+0x5f>
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
  120a09:	ff 73 14             	pushl  0x14(%ebx)
  120a0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  120a0f:	52                   	push   %edx
  120a10:	ff 70 14             	pushl  0x14(%eax)
  120a13:	e8 d4 b3 fe ff       	call   10bdec <memcpy>
  120a18:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  120a1b:	83 c4 0c             	add    $0xc,%esp
  120a1e:	8b 41 3c             	mov    0x3c(%ecx),%eax
  120a21:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
  120a27:	51                   	push   %ecx
  120a28:	e8 be 08 00 00       	call   1212eb <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  120a2d:	89 34 24             	mov    %esi,(%esp)
  120a30:	57                   	push   %edi
  120a31:	e8 88 06 00 00       	call   1210be <z_reschedule>
  120a36:	58                   	pop    %eax
			return 0;
  120a37:	31 c0                	xor    %eax,%eax
			z_reschedule(&msgq->lock, key);
  120a39:	5a                   	pop    %edx
			return 0;
  120a3a:	eb 59                	jmp    120a95 <z_impl_k_msgq_put+0xb8>
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
  120a3c:	ff 73 14             	pushl  0x14(%ebx)
  120a3f:	52                   	push   %edx
  120a40:	ff 73 28             	pushl  0x28(%ebx)
  120a43:	e8 a4 b3 fe ff       	call   10bdec <memcpy>
			msgq->write_ptr += msgq->msg_size;
  120a48:	8b 43 14             	mov    0x14(%ebx),%eax
  120a4b:	03 43 28             	add    0x28(%ebx),%eax
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
  120a4e:	83 c4 0c             	add    $0xc,%esp
			msgq->write_ptr += msgq->msg_size;
  120a51:	89 43 28             	mov    %eax,0x28(%ebx)
			if (msgq->write_ptr == msgq->buffer_end) {
  120a54:	3b 43 20             	cmp    0x20(%ebx),%eax
  120a57:	75 06                	jne    120a5f <z_impl_k_msgq_put+0x82>
				msgq->write_ptr = msgq->buffer_start;
  120a59:	8b 43 1c             	mov    0x1c(%ebx),%eax
  120a5c:	89 43 28             	mov    %eax,0x28(%ebx)
			}
			msgq->used_msgs++;
  120a5f:	ff 43 2c             	incl   0x2c(%ebx)
		}
		result = 0;
  120a62:	31 c0                	xor    %eax,%eax
  120a64:	eb 28                	jmp    120a8e <z_impl_k_msgq_put+0xb1>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  120a66:	8b 4d 14             	mov    0x14(%ebp),%ecx
		/* don't wait for message space to become available */
		result = -ENOMSG;
  120a69:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  120a6e:	0b 4d 10             	or     0x10(%ebp),%ecx
  120a71:	74 1b                	je     120a8e <z_impl_k_msgq_put+0xb1>
	} else {
		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
  120a73:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  120a78:	89 50 14             	mov    %edx,0x14(%eax)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  120a7b:	ff 75 14             	pushl  0x14(%ebp)
  120a7e:	ff 75 10             	pushl  0x10(%ebp)
  120a81:	53                   	push   %ebx
  120a82:	56                   	push   %esi
  120a83:	57                   	push   %edi
  120a84:	e8 00 0c 00 00       	call   121689 <z_pend_curr>
  120a89:	83 c4 14             	add    $0x14,%esp
  120a8c:	eb 07                	jmp    120a95 <z_impl_k_msgq_put+0xb8>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120a8e:	0f ba e6 09          	bt     $0x9,%esi
  120a92:	73 01                	jae    120a95 <z_impl_k_msgq_put+0xb8>
		__asm__ volatile ("sti" ::: "memory");
  120a94:	fb                   	sti    
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  120a95:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120a98:	5b                   	pop    %ebx
  120a99:	5e                   	pop    %esi
  120a9a:	5f                   	pop    %edi
  120a9b:	5d                   	pop    %ebp
  120a9c:	c3                   	ret    

00120a9d <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  120a9d:	55                   	push   %ebp
  120a9e:	89 e5                	mov    %esp,%ebp
  120aa0:	57                   	push   %edi
  120aa1:	56                   	push   %esi
  120aa2:	53                   	push   %ebx
  120aa3:	53                   	push   %ebx
  120aa4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  120aa7:	8b 55 0c             	mov    0xc(%ebp),%edx

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  120aaa:	8d 7b 10             	lea    0x10(%ebx),%edi
  120aad:	9c                   	pushf  
  120aae:	fa                   	cli    
  120aaf:	5e                   	pop    %esi

	if (msgq->used_msgs > 0) {
  120ab0:	83 7b 2c 00          	cmpl   $0x0,0x2c(%ebx)
  120ab4:	0f 84 81 00 00 00    	je     120b3b <z_impl_k_msgq_get+0x9e>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
  120aba:	ff 73 14             	pushl  0x14(%ebx)
  120abd:	ff 73 24             	pushl  0x24(%ebx)
  120ac0:	52                   	push   %edx
  120ac1:	e8 26 b3 fe ff       	call   10bdec <memcpy>
		msgq->read_ptr += msgq->msg_size;
  120ac6:	8b 43 14             	mov    0x14(%ebx),%eax
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
  120ac9:	83 c4 0c             	add    $0xc,%esp
		msgq->read_ptr += msgq->msg_size;
  120acc:	03 43 24             	add    0x24(%ebx),%eax
		if (msgq->read_ptr == msgq->buffer_end) {
  120acf:	3b 43 20             	cmp    0x20(%ebx),%eax
		msgq->read_ptr += msgq->msg_size;
  120ad2:	89 43 24             	mov    %eax,0x24(%ebx)
		if (msgq->read_ptr == msgq->buffer_end) {
  120ad5:	75 06                	jne    120add <z_impl_k_msgq_get+0x40>
			msgq->read_ptr = msgq->buffer_start;
  120ad7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  120ada:	89 43 24             	mov    %eax,0x24(%ebx)
		}
		msgq->used_msgs--;
  120add:	ff 4b 2c             	decl   0x2c(%ebx)

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  120ae0:	53                   	push   %ebx
  120ae1:	e8 25 0c 00 00       	call   12170b <z_unpend_first_thread>
  120ae6:	59                   	pop    %ecx
  120ae7:	89 c2                	mov    %eax,%edx
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
		}
		result = 0;
  120ae9:	31 c0                	xor    %eax,%eax
		if (pending_thread != NULL) {
  120aeb:	85 d2                	test   %edx,%edx
  120aed:	74 74                	je     120b63 <z_impl_k_msgq_get+0xc6>
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
  120aef:	ff 73 14             	pushl  0x14(%ebx)
  120af2:	ff 72 14             	pushl  0x14(%edx)
  120af5:	ff 73 28             	pushl  0x28(%ebx)
  120af8:	89 55 f0             	mov    %edx,-0x10(%ebp)
  120afb:	e8 ec b2 fe ff       	call   10bdec <memcpy>
			msgq->write_ptr += msgq->msg_size;
  120b00:	8b 43 14             	mov    0x14(%ebx),%eax
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
  120b03:	83 c4 0c             	add    $0xc,%esp
			msgq->write_ptr += msgq->msg_size;
  120b06:	03 43 28             	add    0x28(%ebx),%eax
			if (msgq->write_ptr == msgq->buffer_end) {
  120b09:	8b 55 f0             	mov    -0x10(%ebp),%edx
  120b0c:	3b 43 20             	cmp    0x20(%ebx),%eax
			msgq->write_ptr += msgq->msg_size;
  120b0f:	89 43 28             	mov    %eax,0x28(%ebx)
			if (msgq->write_ptr == msgq->buffer_end) {
  120b12:	75 06                	jne    120b1a <z_impl_k_msgq_get+0x7d>
				msgq->write_ptr = msgq->buffer_start;
  120b14:	8b 43 1c             	mov    0x1c(%ebx),%eax
  120b17:	89 43 28             	mov    %eax,0x28(%ebx)
  120b1a:	8b 42 3c             	mov    0x3c(%edx),%eax
			msgq->used_msgs++;
  120b1d:	ff 43 2c             	incl   0x2c(%ebx)
  120b20:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			z_ready_thread(pending_thread);
  120b26:	52                   	push   %edx
  120b27:	e8 bf 07 00 00       	call   1212eb <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  120b2c:	89 34 24             	mov    %esi,(%esp)
  120b2f:	57                   	push   %edi
  120b30:	e8 89 05 00 00       	call   1210be <z_reschedule>
  120b35:	58                   	pop    %eax
			return 0;
  120b36:	31 c0                	xor    %eax,%eax
			z_reschedule(&msgq->lock, key);
  120b38:	5a                   	pop    %edx
			return 0;
  120b39:	eb 2f                	jmp    120b6a <z_impl_k_msgq_get+0xcd>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  120b3b:	8b 4d 14             	mov    0x14(%ebp),%ecx
		/* don't wait for a message to become available */
		result = -ENOMSG;
  120b3e:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  120b43:	0b 4d 10             	or     0x10(%ebp),%ecx
  120b46:	74 1b                	je     120b63 <z_impl_k_msgq_get+0xc6>
	} else {
		/* wait for get message success or timeout */
		_current->base.swap_data = data;
  120b48:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  120b4d:	89 50 14             	mov    %edx,0x14(%eax)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  120b50:	ff 75 14             	pushl  0x14(%ebp)
  120b53:	ff 75 10             	pushl  0x10(%ebp)
  120b56:	53                   	push   %ebx
  120b57:	56                   	push   %esi
  120b58:	57                   	push   %edi
  120b59:	e8 2b 0b 00 00       	call   121689 <z_pend_curr>
  120b5e:	83 c4 14             	add    $0x14,%esp
  120b61:	eb 07                	jmp    120b6a <z_impl_k_msgq_get+0xcd>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120b63:	0f ba e6 09          	bt     $0x9,%esi
  120b67:	73 01                	jae    120b6a <z_impl_k_msgq_get+0xcd>
		__asm__ volatile ("sti" ::: "memory");
  120b69:	fb                   	sti    
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  120b6a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120b6d:	5b                   	pop    %ebx
  120b6e:	5e                   	pop    %esi
  120b6f:	5f                   	pop    %edi
  120b70:	5d                   	pop    %ebp
  120b71:	c3                   	ret    

00120b72 <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
  120b72:	55                   	push   %ebp
  120b73:	89 e5                	mov    %esp,%ebp
  120b75:	53                   	push   %ebx
  120b76:	8b 55 08             	mov    0x8(%ebp),%edx
  120b79:	9c                   	pushf  
  120b7a:	fa                   	cli    
  120b7b:	5b                   	pop    %ebx
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);

	if (msgq->used_msgs > 0) {
  120b7c:	b8 b0 ff ff ff       	mov    $0xffffffb0,%eax
  120b81:	83 7a 2c 00          	cmpl   $0x0,0x2c(%edx)
  120b85:	74 13                	je     120b9a <z_impl_k_msgq_peek+0x28>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
  120b87:	ff 72 14             	pushl  0x14(%edx)
  120b8a:	ff 72 24             	pushl  0x24(%edx)
  120b8d:	ff 75 0c             	pushl  0xc(%ebp)
  120b90:	e8 57 b2 fe ff       	call   10bdec <memcpy>
  120b95:	83 c4 0c             	add    $0xc,%esp
		result = 0;
  120b98:	31 c0                	xor    %eax,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120b9a:	0f ba e3 09          	bt     $0x9,%ebx
  120b9e:	73 01                	jae    120ba1 <z_impl_k_msgq_peek+0x2f>
		__asm__ volatile ("sti" ::: "memory");
  120ba0:	fb                   	sti    
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  120ba1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  120ba4:	c9                   	leave  
  120ba5:	c3                   	ret    

00120ba6 <z_impl_k_mutex_init>:
SYS_INIT(init_mutex_module, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

#endif /* CONFIG_OBJECT_TRACING */

int z_impl_k_mutex_init(struct k_mutex *mutex)
{
  120ba6:	55                   	push   %ebp
  120ba7:	31 c0                	xor    %eax,%eax
  120ba9:	89 e5                	mov    %esp,%ebp
  120bab:	b9 04 00 00 00       	mov    $0x4,%ecx
  120bb0:	57                   	push   %edi
  120bb1:	8b 55 08             	mov    0x8(%ebp),%edx
  120bb4:	89 d7                	mov    %edx,%edi
	mutex->owner = NULL;
  120bb6:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
	mutex->lock_count = 0U;
  120bbd:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  120bc4:	f3 ab                	rep stos %eax,%es:(%edi)
  120bc6:	c7 42 04 c4 0f 12 00 	movl   $0x120fc4,0x4(%edx)
	SYS_TRACING_OBJ_INIT(k_mutex, mutex);
	z_object_init(mutex);
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_INIT);

	return 0;
}
  120bcd:	5f                   	pop    %edi
  120bce:	5d                   	pop    %ebp
  120bcf:	c3                   	ret    

00120bd0 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  120bd0:	55                   	push   %ebp
  120bd1:	89 e5                	mov    %esp,%ebp
  120bd3:	57                   	push   %edi
  120bd4:	56                   	push   %esi
  120bd5:	53                   	push   %ebx
  120bd6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  120bd9:	9c                   	pushf  
  120bda:	fa                   	cli    
  120bdb:	5f                   	pop    %edi
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	sys_trace_mutex_lock(mutex);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  120bdc:	8b 4b 14             	mov    0x14(%ebx),%ecx
  120bdf:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  120be4:	85 c9                	test   %ecx,%ecx
  120be6:	74 0c                	je     120bf4 <z_impl_k_mutex_lock+0x24>
  120be8:	8b 53 10             	mov    0x10(%ebx),%edx
  120beb:	39 c2                	cmp    %eax,%edx
  120bed:	75 23                	jne    120c12 <z_impl_k_mutex_lock+0x42>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
  120bef:	8b 53 18             	mov    0x18(%ebx),%edx
  120bf2:	eb 04                	jmp    120bf8 <z_impl_k_mutex_lock+0x28>
  120bf4:	0f be 50 0e          	movsbl 0xe(%eax),%edx
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  120bf8:	89 53 18             	mov    %edx,0x18(%ebx)
					mutex->owner_orig_prio;

		mutex->lock_count++;
  120bfb:	8d 51 01             	lea    0x1(%ecx),%edx
  120bfe:	89 53 14             	mov    %edx,0x14(%ebx)
		mutex->owner = _current;
  120c01:	89 43 10             	mov    %eax,0x10(%ebx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120c04:	0f ba e7 09          	bt     $0x9,%edi
  120c08:	73 01                	jae    120c0b <z_impl_k_mutex_lock+0x3b>
		__asm__ volatile ("sti" ::: "memory");
  120c0a:	fb                   	sti    
			mutex->owner_orig_prio);

		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
  120c0b:	31 c0                	xor    %eax,%eax
  120c0d:	e9 b4 00 00 00       	jmp    120cc6 <z_impl_k_mutex_lock+0xf6>
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  120c12:	8b 75 10             	mov    0x10(%ebp),%esi
  120c15:	0b 75 0c             	or     0xc(%ebp),%esi
  120c18:	75 0a                	jne    120c24 <z_impl_k_mutex_lock+0x54>
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
  120c1a:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  120c1f:	e9 9b 00 00 00       	jmp    120cbf <z_impl_k_mutex_lock+0xef>
	}

	new_prio = new_prio_for_inheritance(_current->base.prio,
  120c24:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
  120c28:	0f be 40 0e          	movsbl 0xe(%eax),%eax
  120c2c:	39 c8                	cmp    %ecx,%eax
  120c2e:	7e 02                	jle    120c32 <z_impl_k_mutex_lock+0x62>
  120c30:	89 c8                	mov    %ecx,%eax
  120c32:	85 c0                	test   %eax,%eax
  120c34:	79 02                	jns    120c38 <z_impl_k_mutex_lock+0x68>
  120c36:	31 c0                	xor    %eax,%eax
	bool resched = false;
  120c38:	31 f6                	xor    %esi,%esi
					    mutex->owner->base.prio);

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  120c3a:	39 c1                	cmp    %eax,%ecx
  120c3c:	7e 0b                	jle    120c49 <z_impl_k_mutex_lock+0x79>
		return z_set_prio(mutex->owner, new_prio);
  120c3e:	50                   	push   %eax
  120c3f:	52                   	push   %edx
  120c40:	e8 6c 0a 00 00       	call   1216b1 <z_set_prio>
  120c45:	5e                   	pop    %esi
  120c46:	89 c6                	mov    %eax,%esi
  120c48:	5a                   	pop    %edx
		resched = adjust_owner_prio(mutex, new_prio);
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  120c49:	ff 75 10             	pushl  0x10(%ebp)
  120c4c:	ff 75 0c             	pushl  0xc(%ebp)
  120c4f:	53                   	push   %ebx
  120c50:	57                   	push   %edi
  120c51:	68 84 ed 12 00       	push   $0x12ed84
  120c56:	e8 2e 0a 00 00       	call   121689 <z_pend_curr>
  120c5b:	83 c4 14             	add    $0x14,%esp
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
  120c5e:	85 c0                	test   %eax,%eax
  120c60:	74 a9                	je     120c0b <z_impl_k_mutex_lock+0x3b>
  120c62:	9c                   	pushf  
  120c63:	fa                   	cli    
  120c64:	5f                   	pop    %edi
/**
 * @brief Returns the lowest-sorted member of the tree
 */
static inline struct rbnode *rb_get_min(struct rbtree *tree)
{
	return z_rb_get_minmax(tree, 0);
  120c65:	6a 00                	push   $0x0
  120c67:	53                   	push   %ebx
  120c68:	e8 a1 09 fe ff       	call   10160e <z_rb_get_minmax>
  120c6d:	5a                   	pop    %edx
	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);

	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  120c6e:	85 c0                	test   %eax,%eax
  120c70:	89 c2                	mov    %eax,%edx
  120c72:	59                   	pop    %ecx
  120c73:	8b 43 18             	mov    0x18(%ebx),%eax
  120c76:	74 10                	je     120c88 <z_impl_k_mutex_lock+0xb8>
  120c78:	0f be 52 0e          	movsbl 0xe(%edx),%edx
  120c7c:	39 d0                	cmp    %edx,%eax
  120c7e:	7e 02                	jle    120c82 <z_impl_k_mutex_lock+0xb2>
  120c80:	89 d0                	mov    %edx,%eax
  120c82:	85 c0                	test   %eax,%eax
  120c84:	79 02                	jns    120c88 <z_impl_k_mutex_lock+0xb8>
  120c86:	31 c0                	xor    %eax,%eax
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);

	resched = adjust_owner_prio(mutex, new_prio) || resched;
  120c88:	8b 53 10             	mov    0x10(%ebx),%edx
	if (mutex->owner->base.prio != new_prio) {
  120c8b:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
  120c8f:	39 c8                	cmp    %ecx,%eax
  120c91:	74 21                	je     120cb4 <z_impl_k_mutex_lock+0xe4>
		return z_set_prio(mutex->owner, new_prio);
  120c93:	50                   	push   %eax
  120c94:	52                   	push   %edx
  120c95:	e8 17 0a 00 00       	call   1216b1 <z_set_prio>
  120c9a:	59                   	pop    %ecx
	resched = adjust_owner_prio(mutex, new_prio) || resched;
  120c9b:	84 c0                	test   %al,%al
		return z_set_prio(mutex->owner, new_prio);
  120c9d:	5b                   	pop    %ebx
	resched = adjust_owner_prio(mutex, new_prio) || resched;
  120c9e:	74 14                	je     120cb4 <z_impl_k_mutex_lock+0xe4>

	if (resched) {
		z_reschedule(&lock, key);
  120ca0:	57                   	push   %edi
  120ca1:	68 84 ed 12 00       	push   $0x12ed84
  120ca6:	e8 13 04 00 00       	call   1210be <z_reschedule>
  120cab:	58                   	pop    %eax
	} else {
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
  120cac:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
		z_reschedule(&lock, key);
  120cb1:	5a                   	pop    %edx
  120cb2:	eb 12                	jmp    120cc6 <z_impl_k_mutex_lock+0xf6>
	if (resched) {
  120cb4:	89 f0                	mov    %esi,%eax
  120cb6:	84 c0                	test   %al,%al
  120cb8:	75 e6                	jne    120ca0 <z_impl_k_mutex_lock+0xd0>
	return -EAGAIN;
  120cba:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120cbf:	0f ba e7 09          	bt     $0x9,%edi
  120cc3:	73 01                	jae    120cc6 <z_impl_k_mutex_lock+0xf6>
		__asm__ volatile ("sti" ::: "memory");
  120cc5:	fb                   	sti    
}
  120cc6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120cc9:	5b                   	pop    %ebx
  120cca:	5e                   	pop    %esi
  120ccb:	5f                   	pop    %edi
  120ccc:	5d                   	pop    %ebp
  120ccd:	c3                   	ret    

00120cce <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  120cce:	55                   	push   %ebp
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	CHECKIF(mutex->owner == NULL) {
		return -EINVAL;
  120ccf:	ba ea ff ff ff       	mov    $0xffffffea,%edx
{
  120cd4:	89 e5                	mov    %esp,%ebp
  120cd6:	56                   	push   %esi
  120cd7:	53                   	push   %ebx
  120cd8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	CHECKIF(mutex->owner == NULL) {
  120cdb:	8b 43 10             	mov    0x10(%ebx),%eax
  120cde:	85 c0                	test   %eax,%eax
  120ce0:	0f 84 80 00 00 00    	je     120d66 <z_impl_k_mutex_unlock+0x98>
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
		return -EPERM;
  120ce6:	83 ca ff             	or     $0xffffffff,%edx
	CHECKIF(mutex->owner != _current) {
  120ce9:	3b 05 c8 e9 12 00    	cmp    0x12e9c8,%eax
  120cef:	75 75                	jne    120d66 <z_impl_k_mutex_unlock+0x98>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  120cf1:	fe 48 0f             	decb   0xf(%eax)

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
  120cf4:	8b 43 14             	mov    0x14(%ebx),%eax
  120cf7:	83 f8 01             	cmp    $0x1,%eax
  120cfa:	74 06                	je     120d02 <z_impl_k_mutex_unlock+0x34>
		mutex->lock_count--;
  120cfc:	48                   	dec    %eax
  120cfd:	89 43 14             	mov    %eax,0x14(%ebx)
		goto k_mutex_unlock_return;
  120d00:	eb 5d                	jmp    120d5f <z_impl_k_mutex_unlock+0x91>
  120d02:	9c                   	pushf  
  120d03:	fa                   	cli    
  120d04:	5e                   	pop    %esi
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  120d05:	8b 43 10             	mov    0x10(%ebx),%eax
  120d08:	8b 53 18             	mov    0x18(%ebx),%edx
	if (mutex->owner->base.prio != new_prio) {
  120d0b:	0f be 48 0e          	movsbl 0xe(%eax),%ecx
  120d0f:	39 ca                	cmp    %ecx,%edx
  120d11:	74 09                	je     120d1c <z_impl_k_mutex_unlock+0x4e>
		return z_set_prio(mutex->owner, new_prio);
  120d13:	52                   	push   %edx
  120d14:	50                   	push   %eax
  120d15:	e8 97 09 00 00       	call   1216b1 <z_set_prio>
  120d1a:	58                   	pop    %eax
  120d1b:	5a                   	pop    %edx

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  120d1c:	53                   	push   %ebx
  120d1d:	e8 e9 09 00 00       	call   12170b <z_unpend_first_thread>
  120d22:	59                   	pop    %ecx
	mutex->owner = new_owner;

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
  120d23:	85 c0                	test   %eax,%eax
	mutex->owner = new_owner;
  120d25:	89 43 10             	mov    %eax,0x10(%ebx)
	if (new_owner != NULL) {
  120d28:	74 27                	je     120d51 <z_impl_k_mutex_unlock+0x83>
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
  120d2a:	0f be 50 0e          	movsbl 0xe(%eax),%edx
  120d2e:	89 53 18             	mov    %edx,0x18(%ebx)
  120d31:	8b 50 3c             	mov    0x3c(%eax),%edx
  120d34:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
  120d3a:	50                   	push   %eax
  120d3b:	e8 ab 05 00 00       	call   1212eb <z_ready_thread>
		z_reschedule(&lock, key);
  120d40:	89 34 24             	mov    %esi,(%esp)
  120d43:	68 84 ed 12 00       	push   $0x12ed84
  120d48:	e8 71 03 00 00       	call   1210be <z_reschedule>
  120d4d:	58                   	pop    %eax
  120d4e:	5a                   	pop    %edx
  120d4f:	eb 0e                	jmp    120d5f <z_impl_k_mutex_unlock+0x91>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120d51:	0f ba e6 09          	bt     $0x9,%esi
	} else {
		mutex->lock_count = 0U;
  120d55:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
  120d5c:	73 01                	jae    120d5f <z_impl_k_mutex_unlock+0x91>
		__asm__ volatile ("sti" ::: "memory");
  120d5e:	fb                   	sti    
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
  120d5f:	e8 2b 05 00 00       	call   12128f <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
  120d64:	31 d2                	xor    %edx,%edx
}
  120d66:	8d 65 f8             	lea    -0x8(%ebp),%esp
  120d69:	89 d0                	mov    %edx,%eax
  120d6b:	5b                   	pop    %ebx
  120d6c:	5e                   	pop    %esi
  120d6d:	5d                   	pop    %ebp
  120d6e:	c3                   	ret    

00120d6f <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  120d6f:	55                   	push   %ebp
  120d70:	89 e5                	mov    %esp,%ebp
  120d72:	57                   	push   %edi
  120d73:	56                   	push   %esi
  120d74:	89 d7                	mov    %edx,%edi
  120d76:	53                   	push   %ebx
  120d77:	89 c3                	mov    %eax,%ebx
  120d79:	83 ec 0c             	sub    $0xc,%esp
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  120d7c:	8d 73 08             	lea    0x8(%ebx),%esi
{
  120d7f:	8b 55 08             	mov    0x8(%ebp),%edx
  120d82:	8b 45 0c             	mov    0xc(%ebp),%eax
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  120d85:	89 75 f0             	mov    %esi,-0x10(%ebp)
  120d88:	9c                   	pushf  
  120d89:	fa                   	cli    
  120d8a:	5e                   	pop    %esi

	if (is_append) {
  120d8b:	84 c0                	test   %al,%al
  120d8d:	74 03                	je     120d92 <queue_insert+0x23>
		prev = sys_sflist_peek_tail(&queue->data_q);
  120d8f:	8b 7b 04             	mov    0x4(%ebx),%edi
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  120d92:	8d 43 0c             	lea    0xc(%ebx),%eax
  120d95:	89 55 e8             	mov    %edx,-0x18(%ebp)
  120d98:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  120d9b:	50                   	push   %eax
  120d9c:	e8 6a 09 00 00       	call   12170b <z_unpend_first_thread>
  120da1:	59                   	pop    %ecx

	if (first_pending_thread != NULL) {
  120da2:	85 c0                	test   %eax,%eax
  120da4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  120da7:	8b 55 e8             	mov    -0x18(%ebp),%edx
  120daa:	74 1a                	je     120dc6 <queue_insert+0x57>
  120dac:	8b 50 3c             	mov    0x3c(%eax),%edx
  120daf:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  120db5:	89 48 14             	mov    %ecx,0x14(%eax)
	z_ready_thread(thread);
  120db8:	50                   	push   %eax
  120db9:	e8 2d 05 00 00       	call   1212eb <z_ready_thread>
		prepare_thread_to_run(first_pending_thread, data);
		z_reschedule(&queue->lock, key);
  120dbe:	89 34 24             	mov    %esi,(%esp)
  120dc1:	e9 8e 00 00 00       	jmp    120e54 <queue_insert+0xe5>
		return 0;
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
  120dc6:	84 d2                	test   %dl,%dl
  120dc8:	74 2b                	je     120df5 <queue_insert+0x86>
  120dca:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
  120dcd:	6a 08                	push   $0x8
  120dcf:	e8 84 1d 00 00       	call   122b58 <z_thread_malloc>
  120dd4:	5a                   	pop    %edx
		if (anode == NULL) {
  120dd5:	85 c0                	test   %eax,%eax
  120dd7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  120dda:	75 0e                	jne    120dea <queue_insert+0x7b>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120ddc:	0f ba e6 09          	bt     $0x9,%esi
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
  120de0:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  120de5:	73 79                	jae    120e60 <queue_insert+0xf1>
		__asm__ volatile ("sti" ::: "memory");
  120de7:	fb                   	sti    
  120de8:	eb 76                	jmp    120e60 <queue_insert+0xf1>
		}
		anode->data = data;
  120dea:	89 48 04             	mov    %ecx,0x4(%eax)
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  120ded:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		sys_sfnode_init(&anode->node, 0x1);
		data = anode;
  120df3:	eb 08                	jmp    120dfd <queue_insert+0x8e>
  120df5:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
}
  120dfb:	89 c8                	mov    %ecx,%eax
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  120dfd:	8b 10                	mov    (%eax),%edx
  120dff:	83 e2 03             	and    $0x3,%edx
  120e02:	85 ff                	test   %edi,%edi
  120e04:	75 0e                	jne    120e14 <queue_insert+0xa5>
	parent->next_and_flags = cur_flags | (unative_t)child;
  120e06:	0b 13                	or     (%ebx),%edx
Z_GENLIST_PREPEND(sflist, sfnode)
  120e08:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
	parent->next_and_flags = cur_flags | (unative_t)child;
  120e0c:	89 10                	mov    %edx,(%eax)
	list->head = node;
  120e0e:	89 03                	mov    %eax,(%ebx)
Z_GENLIST_PREPEND(sflist, sfnode)
  120e10:	75 34                	jne    120e46 <queue_insert+0xd7>
  120e12:	eb 20                	jmp    120e34 <queue_insert+0xc5>
Z_GENLIST_INSERT(sflist, sfnode)
  120e14:	8b 0f                	mov    (%edi),%ecx
  120e16:	83 e1 fc             	and    $0xfffffffc,%ecx
  120e19:	75 1e                	jne    120e39 <queue_insert+0xca>
Z_GENLIST_APPEND(sflist, sfnode)
  120e1b:	8b 4b 04             	mov    0x4(%ebx),%ecx
	parent->next_and_flags = cur_flags | (unative_t)child;
  120e1e:	89 10                	mov    %edx,(%eax)
Z_GENLIST_APPEND(sflist, sfnode)
  120e20:	85 c9                	test   %ecx,%ecx
  120e22:	75 07                	jne    120e2b <queue_insert+0xbc>
	list->tail = node;
  120e24:	89 43 04             	mov    %eax,0x4(%ebx)
	list->head = node;
  120e27:	89 03                	mov    %eax,(%ebx)
}
  120e29:	eb 1b                	jmp    120e46 <queue_insert+0xd7>
	parent->next_and_flags = cur_flags | (unative_t)child;
  120e2b:	8b 11                	mov    (%ecx),%edx
  120e2d:	83 e2 03             	and    $0x3,%edx
  120e30:	09 c2                	or     %eax,%edx
  120e32:	89 11                	mov    %edx,(%ecx)
	list->tail = node;
  120e34:	89 43 04             	mov    %eax,0x4(%ebx)
}
  120e37:	eb 0d                	jmp    120e46 <queue_insert+0xd7>
	parent->next_and_flags = cur_flags | (unative_t)child;
  120e39:	09 ca                	or     %ecx,%edx
  120e3b:	89 10                	mov    %edx,(%eax)
  120e3d:	8b 17                	mov    (%edi),%edx
  120e3f:	83 e2 03             	and    $0x3,%edx
  120e42:	09 d0                	or     %edx,%eax
  120e44:	89 07                	mov    %eax,(%edi)
	z_handle_obj_poll_events(&queue->poll_events, state);
  120e46:	6a 04                	push   $0x4
  120e48:	83 c3 1c             	add    $0x1c,%ebx
  120e4b:	53                   	push   %ebx
  120e4c:	e8 e6 1b 00 00       	call   122a37 <z_handle_obj_poll_events>
  120e51:	59                   	pop    %ecx
  120e52:	5b                   	pop    %ebx
		sys_sfnode_init(data, 0x0);
	}

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  120e53:	56                   	push   %esi
  120e54:	ff 75 f0             	pushl  -0x10(%ebp)
  120e57:	e8 62 02 00 00       	call   1210be <z_reschedule>
  120e5c:	58                   	pop    %eax
	return 0;
  120e5d:	31 c0                	xor    %eax,%eax
	z_reschedule(&queue->lock, key);
  120e5f:	5a                   	pop    %edx
}
  120e60:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120e63:	5b                   	pop    %ebx
  120e64:	5e                   	pop    %esi
  120e65:	5f                   	pop    %edi
  120e66:	5d                   	pop    %ebp
  120e67:	c3                   	ret    

00120e68 <z_queue_node_peek>:
{
  120e68:	55                   	push   %ebp
  120e69:	89 e5                	mov    %esp,%ebp
  120e6b:	53                   	push   %ebx
  120e6c:	8b 45 08             	mov    0x8(%ebp),%eax
  120e6f:	8b 55 0c             	mov    0xc(%ebp),%edx
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
  120e72:	85 c0                	test   %eax,%eax
  120e74:	74 15                	je     120e8b <z_queue_node_peek+0x23>
  120e76:	f6 00 03             	testb  $0x3,(%eax)
  120e79:	74 10                	je     120e8b <z_queue_node_peek+0x23>
		ret = anode->data;
  120e7b:	8b 58 04             	mov    0x4(%eax),%ebx
		if (needs_free) {
  120e7e:	84 d2                	test   %dl,%dl
  120e80:	74 07                	je     120e89 <z_queue_node_peek+0x21>
			k_free(anode);
  120e82:	50                   	push   %eax
  120e83:	e8 b8 1c 00 00       	call   122b40 <k_free>
  120e88:	58                   	pop    %eax
  120e89:	89 d8                	mov    %ebx,%eax
}
  120e8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  120e8e:	c9                   	leave  
  120e8f:	c3                   	ret    

00120e90 <z_impl_k_queue_init>:
{
  120e90:	55                   	push   %ebp
  120e91:	31 c0                	xor    %eax,%eax
  120e93:	89 e5                	mov    %esp,%ebp
  120e95:	b9 04 00 00 00       	mov    $0x4,%ecx
  120e9a:	57                   	push   %edi
  120e9b:	8b 55 08             	mov    0x8(%ebp),%edx
  120e9e:	8d 7a 0c             	lea    0xc(%edx),%edi
	list->head = NULL;
  120ea1:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	list->tail = NULL;
  120ea7:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	queue->lock = (struct k_spinlock) {};
  120eae:	c6 42 08 00          	movb   $0x0,0x8(%edx)
  120eb2:	f3 ab                	rep stos %eax,%es:(%edi)
	sys_dlist_init(&queue->poll_events);
  120eb4:	8d 42 1c             	lea    0x1c(%edx),%eax
  120eb7:	c7 42 10 c4 0f 12 00 	movl   $0x120fc4,0x10(%edx)
	list->head = (sys_dnode_t *)list;
  120ebe:	89 42 1c             	mov    %eax,0x1c(%edx)
	list->tail = (sys_dnode_t *)list;
  120ec1:	89 42 20             	mov    %eax,0x20(%edx)
}
  120ec4:	5f                   	pop    %edi
  120ec5:	5d                   	pop    %ebp
  120ec6:	c3                   	ret    

00120ec7 <z_impl_k_queue_cancel_wait>:
{
  120ec7:	55                   	push   %ebp
  120ec8:	89 e5                	mov    %esp,%ebp
  120eca:	57                   	push   %edi
  120ecb:	56                   	push   %esi
  120ecc:	53                   	push   %ebx
  120ecd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  120ed0:	8d 73 08             	lea    0x8(%ebx),%esi
  120ed3:	9c                   	pushf  
  120ed4:	fa                   	cli    
  120ed5:	5f                   	pop    %edi
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  120ed6:	8d 43 0c             	lea    0xc(%ebx),%eax
  120ed9:	50                   	push   %eax
  120eda:	e8 2c 08 00 00       	call   12170b <z_unpend_first_thread>
  120edf:	5a                   	pop    %edx
	if (first_pending_thread != NULL) {
  120ee0:	85 c0                	test   %eax,%eax
  120ee2:	74 17                	je     120efb <z_impl_k_queue_cancel_wait+0x34>
  120ee4:	8b 50 3c             	mov    0x3c(%eax),%edx
  120ee7:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  120eed:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	z_ready_thread(thread);
  120ef4:	50                   	push   %eax
  120ef5:	e8 f1 03 00 00       	call   1212eb <z_ready_thread>
  120efa:	58                   	pop    %eax
	z_handle_obj_poll_events(&queue->poll_events, state);
  120efb:	6a 08                	push   $0x8
  120efd:	83 c3 1c             	add    $0x1c,%ebx
  120f00:	53                   	push   %ebx
  120f01:	e8 31 1b 00 00       	call   122a37 <z_handle_obj_poll_events>
  120f06:	58                   	pop    %eax
  120f07:	5a                   	pop    %edx
	z_reschedule(&queue->lock, key);
  120f08:	57                   	push   %edi
  120f09:	56                   	push   %esi
  120f0a:	e8 af 01 00 00       	call   1210be <z_reschedule>
  120f0f:	59                   	pop    %ecx
  120f10:	5b                   	pop    %ebx
}
  120f11:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120f14:	5b                   	pop    %ebx
  120f15:	5e                   	pop    %esi
  120f16:	5f                   	pop    %edi
  120f17:	5d                   	pop    %ebp
  120f18:	c3                   	ret    

00120f19 <k_queue_append>:
{
	(void)queue_insert(queue, prev, data, false, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
  120f19:	55                   	push   %ebp
	(void)queue_insert(queue, NULL, data, false, true);
  120f1a:	31 d2                	xor    %edx,%edx
{
  120f1c:	89 e5                	mov    %esp,%ebp
  120f1e:	8b 45 08             	mov    0x8(%ebp),%eax
  120f21:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	(void)queue_insert(queue, NULL, data, false, true);
  120f24:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  120f2b:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
}
  120f32:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false, true);
  120f33:	e9 37 fe ff ff       	jmp    120d6f <queue_insert>

00120f38 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
  120f38:	55                   	push   %ebp
	(void)queue_insert(queue, NULL, data, false, false);
  120f39:	31 d2                	xor    %edx,%edx
{
  120f3b:	89 e5                	mov    %esp,%ebp
  120f3d:	8b 45 08             	mov    0x8(%ebp),%eax
  120f40:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	(void)queue_insert(queue, NULL, data, false, false);
  120f43:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  120f4a:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
}
  120f51:	5d                   	pop    %ebp
	(void)queue_insert(queue, NULL, data, false, false);
  120f52:	e9 18 fe ff ff       	jmp    120d6f <queue_insert>

00120f57 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
  120f57:	55                   	push   %ebp
  120f58:	89 e5                	mov    %esp,%ebp
  120f5a:	57                   	push   %edi
  120f5b:	56                   	push   %esi
  120f5c:	53                   	push   %ebx
  120f5d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120f60:	8b 45 0c             	mov    0xc(%ebp),%eax
  120f63:	8b 55 10             	mov    0x10(%ebp),%edx
  120f66:	9c                   	pushf  
  120f67:	fa                   	cli    
  120f68:	5e                   	pop    %esi
Z_GENLIST_IS_EMPTY(sflist)
  120f69:	8b 19                	mov    (%ecx),%ebx
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
  120f6b:	85 db                	test   %ebx,%ebx
  120f6d:	74 1d                	je     120f8c <z_impl_k_queue_get+0x35>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  120f6f:	8b 03                	mov    (%ebx),%eax
  120f71:	83 e0 fc             	and    $0xfffffffc,%eax
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  120f74:	3b 59 04             	cmp    0x4(%ecx),%ebx
	list->head = node;
  120f77:	89 01                	mov    %eax,(%ecx)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  120f79:	75 03                	jne    120f7e <z_impl_k_queue_get+0x27>
	list->tail = node;
  120f7b:	89 41 04             	mov    %eax,0x4(%ecx)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
  120f7e:	6a 01                	push   $0x1
  120f80:	53                   	push   %ebx
  120f81:	e8 e2 fe ff ff       	call   120e68 <z_queue_node_peek>
  120f86:	5a                   	pop    %edx
  120f87:	89 c3                	mov    %eax,%ebx
  120f89:	59                   	pop    %ecx
  120f8a:	eb 06                	jmp    120f92 <z_impl_k_queue_get+0x3b>
		k_spin_unlock(&queue->lock, key);
		return data;
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  120f8c:	89 d7                	mov    %edx,%edi
  120f8e:	09 c7                	or     %eax,%edi
  120f90:	75 09                	jne    120f9b <z_impl_k_queue_get+0x44>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  120f92:	0f ba e6 09          	bt     $0x9,%esi
  120f96:	73 22                	jae    120fba <z_impl_k_queue_get+0x63>
		__asm__ volatile ("sti" ::: "memory");
  120f98:	fb                   	sti    
  120f99:	eb 1f                	jmp    120fba <z_impl_k_queue_get+0x63>
		k_spin_unlock(&queue->lock, key);
		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  120f9b:	52                   	push   %edx
  120f9c:	50                   	push   %eax
  120f9d:	8d 41 0c             	lea    0xc(%ecx),%eax
  120fa0:	50                   	push   %eax
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  120fa1:	83 c1 08             	add    $0x8,%ecx
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  120fa4:	56                   	push   %esi
  120fa5:	51                   	push   %ecx
  120fa6:	e8 de 06 00 00       	call   121689 <z_pend_curr>
  120fab:	83 c4 14             	add    $0x14,%esp

	return (ret != 0) ? NULL : _current->base.swap_data;
  120fae:	85 c0                	test   %eax,%eax
  120fb0:	75 08                	jne    120fba <z_impl_k_queue_get+0x63>
  120fb2:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  120fb7:	8b 58 14             	mov    0x14(%eax),%ebx
}
  120fba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  120fbd:	89 d8                	mov    %ebx,%eax
  120fbf:	5b                   	pop    %ebx
  120fc0:	5e                   	pop    %esi
  120fc1:	5f                   	pop    %edi
  120fc2:	5d                   	pop    %ebp
  120fc3:	c3                   	ret    

00120fc4 <z_priq_rb_lessthan>:
	}
	return thread;
}

bool z_priq_rb_lessthan(struct rbnode *a, struct rbnode *b)
{
  120fc4:	55                   	push   %ebp

	thread_a = CONTAINER_OF(a, struct k_thread, base.qnode_rb);
	thread_b = CONTAINER_OF(b, struct k_thread, base.qnode_rb);

	if (z_is_t1_higher_prio_than_t2(thread_a, thread_b)) {
		return true;
  120fc5:	b0 01                	mov    $0x1,%al
{
  120fc7:	89 e5                	mov    %esp,%ebp
  120fc9:	53                   	push   %ebx
  120fca:	8b 4d 08             	mov    0x8(%ebp),%ecx
  120fcd:	8b 55 0c             	mov    0xc(%ebp),%edx
	if (thread_1->base.prio < thread_2->base.prio) {
  120fd0:	8a 59 0e             	mov    0xe(%ecx),%bl
  120fd3:	38 5a 0e             	cmp    %bl,0xe(%edx)
  120fd6:	7f 0d                	jg     120fe5 <z_priq_rb_lessthan+0x21>
	} else if (z_is_t1_higher_prio_than_t2(thread_b, thread_a)) {
		return false;
  120fd8:	b0 00                	mov    $0x0,%al
	if (thread_1->base.prio < thread_2->base.prio) {
  120fda:	7c 09                	jl     120fe5 <z_priq_rb_lessthan+0x21>
	} else {
		return thread_a->base.order_key < thread_b->base.order_key
			? 1 : 0;
  120fdc:	8b 42 10             	mov    0x10(%edx),%eax
  120fdf:	39 41 10             	cmp    %eax,0x10(%ecx)
  120fe2:	0f 92 c0             	setb   %al
	}
}
  120fe5:	5b                   	pop    %ebx
  120fe6:	5d                   	pop    %ebp
  120fe7:	c3                   	ret    

00120fe8 <z_is_t1_higher_prio_than_t2>:
{
  120fe8:	55                   	push   %ebp
  120fe9:	89 e5                	mov    %esp,%ebp
	if (thread_1->base.prio < thread_2->base.prio) {
  120feb:	8b 45 0c             	mov    0xc(%ebp),%eax
  120fee:	8b 55 08             	mov    0x8(%ebp),%edx
}
  120ff1:	5d                   	pop    %ebp
	if (thread_1->base.prio < thread_2->base.prio) {
  120ff2:	8a 40 0e             	mov    0xe(%eax),%al
  120ff5:	38 42 0e             	cmp    %al,0xe(%edx)
  120ff8:	0f 9c c0             	setl   %al
}
  120ffb:	c3                   	ret    

00120ffc <z_reset_time_slice>:
	if (slice_time != 0) {
  120ffc:	83 3d 68 ed 12 00 00 	cmpl   $0x0,0x12ed68
  121003:	74 21                	je     121026 <z_reset_time_slice+0x2a>
{
  121005:	55                   	push   %ebp
  121006:	89 e5                	mov    %esp,%ebp
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  121008:	e8 d1 9b fe ff       	call   10abde <z_clock_elapsed>
		z_set_timeout_expiry(slice_time, false);
  12100d:	6a 00                	push   $0x0
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  12100f:	8b 15 68 ed 12 00    	mov    0x12ed68,%edx
  121015:	01 d0                	add    %edx,%eax
		z_set_timeout_expiry(slice_time, false);
  121017:	52                   	push   %edx
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
  121018:	a3 d4 e9 12 00       	mov    %eax,0x12e9d4
		z_set_timeout_expiry(slice_time, false);
  12101d:	e8 01 12 00 00       	call   122223 <z_set_timeout_expiry>
  121022:	58                   	pop    %eax
  121023:	5a                   	pop    %edx
}
  121024:	c9                   	leave  
  121025:	c3                   	ret    
  121026:	c3                   	ret    

00121027 <k_sched_time_slice_set>:
{
  121027:	55                   	push   %ebp
  121028:	89 e5                	mov    %esp,%ebp
  12102a:	57                   	push   %edi
  12102b:	56                   	push   %esi
  12102c:	53                   	push   %ebx
  12102d:	8b 45 08             	mov    0x8(%ebp),%eax
  121030:	9c                   	pushf  
  121031:	fa                   	cli    
  121032:	5b                   	pop    %ebx
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
  121033:	89 c6                	mov    %eax,%esi
  121035:	31 ff                	xor    %edi,%edi
		t += off;
  121037:	83 c6 09             	add    $0x9,%esi
		_current_cpu->slice_ticks = 0;
  12103a:	c7 05 d4 e9 12 00 00 	movl   $0x0,0x12e9d4
  121041:	00 00 00 
  121044:	83 d7 00             	adc    $0x0,%edi
		if (result32 && (t < BIT64(32))) {
  121047:	83 ff 00             	cmp    $0x0,%edi
  12104a:	77 0e                	ja     12105a <k_sched_time_slice_set+0x33>
			return ((uint32_t)t) / (from_hz / to_hz);
  12104c:	83 c0 09             	add    $0x9,%eax
  12104f:	b9 0a 00 00 00       	mov    $0xa,%ecx
  121054:	31 d2                	xor    %edx,%edx
  121056:	f7 f1                	div    %ecx
  121058:	eb 0e                	jmp    121068 <k_sched_time_slice_set+0x41>
			return t / (from_hz / to_hz);
  12105a:	6a 00                	push   $0x0
  12105c:	6a 0a                	push   $0xa
  12105e:	57                   	push   %edi
  12105f:	56                   	push   %esi
  121060:	e8 bb f1 fd ff       	call   100220 <__udivdi3>
  121065:	83 c4 10             	add    $0x10,%esp
		slice_time = k_ms_to_ticks_ceil32(slice);
  121068:	a3 68 ed 12 00       	mov    %eax,0x12ed68
		slice_max_prio = prio;
  12106d:	8b 45 0c             	mov    0xc(%ebp),%eax
  121070:	a3 64 ed 12 00       	mov    %eax,0x12ed64
		z_reset_time_slice();
  121075:	e8 82 ff ff ff       	call   120ffc <z_reset_time_slice>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12107a:	0f ba e3 09          	bt     $0x9,%ebx
  12107e:	73 01                	jae    121081 <k_sched_time_slice_set+0x5a>
		__asm__ volatile ("sti" ::: "memory");
  121080:	fb                   	sti    
}
  121081:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121084:	5b                   	pop    %ebx
  121085:	5e                   	pop    %esi
  121086:	5f                   	pop    %edi
  121087:	5d                   	pop    %ebp
  121088:	c3                   	ret    

00121089 <z_find_first_thread_to_unpend>:
{
  121089:	55                   	push   %ebp
  12108a:	89 e5                	mov    %esp,%ebp
  12108c:	53                   	push   %ebx
  12108d:	9c                   	pushf  
  12108e:	fa                   	cli    
  12108f:	5b                   	pop    %ebx
		ret = _priq_wait_best(&wait_q->waitq);
  121090:	ff 75 08             	pushl  0x8(%ebp)
  121093:	e8 79 01 00 00       	call   121211 <z_priq_rb_best>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121098:	0f ba e3 09          	bt     $0x9,%ebx
  12109c:	5a                   	pop    %edx
  12109d:	73 01                	jae    1210a0 <z_find_first_thread_to_unpend+0x17>
		__asm__ volatile ("sti" ::: "memory");
  12109f:	fb                   	sti    
}
  1210a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1210a3:	c9                   	leave  
  1210a4:	c3                   	ret    

001210a5 <z_unpend_thread_no_timeout>:
{
  1210a5:	55                   	push   %ebp
  1210a6:	89 e5                	mov    %esp,%ebp
  1210a8:	53                   	push   %ebx
  1210a9:	9c                   	pushf  
  1210aa:	fa                   	cli    
  1210ab:	5b                   	pop    %ebx
		unpend_thread_no_timeout(thread);
  1210ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1210af:	e8 15 01 00 00       	call   1211c9 <unpend_thread_no_timeout>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1210b4:	0f ba e3 09          	bt     $0x9,%ebx
  1210b8:	73 01                	jae    1210bb <z_unpend_thread_no_timeout+0x16>
		__asm__ volatile ("sti" ::: "memory");
  1210ba:	fb                   	sti    
}
  1210bb:	5b                   	pop    %ebx
  1210bc:	5d                   	pop    %ebp
  1210bd:	c3                   	ret    

001210be <z_reschedule>:
{
  1210be:	55                   	push   %ebp
  1210bf:	89 e5                	mov    %esp,%ebp
  1210c1:	8b 45 0c             	mov    0xc(%ebp),%eax
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  1210c4:	0f ba e0 09          	bt     $0x9,%eax
  1210c8:	73 21                	jae    1210eb <z_reschedule+0x2d>
  1210ca:	83 3d c0 e9 12 00 00 	cmpl   $0x0,0x12e9c0
  1210d1:	75 17                	jne    1210ea <z_reschedule+0x2c>
	if (resched(key.key) && need_swap()) {
  1210d3:	8b 15 c8 e9 12 00    	mov    0x12e9c8,%edx
  1210d9:	39 15 e4 e9 12 00    	cmp    %edx,0x12e9e4
  1210df:	74 09                	je     1210ea <z_reschedule+0x2c>
	ret = arch_swap(key);
  1210e1:	89 45 08             	mov    %eax,0x8(%ebp)
}
  1210e4:	5d                   	pop    %ebp
  1210e5:	e9 07 a7 fe ff       	jmp    10b7f1 <arch_swap>
  1210ea:	fb                   	sti    
  1210eb:	5d                   	pop    %ebp
  1210ec:	c3                   	ret    

001210ed <z_reschedule_irqlock>:
{
  1210ed:	55                   	push   %ebp
  1210ee:	89 e5                	mov    %esp,%ebp
	return arch_irq_unlocked(key) && !arch_is_in_isr();
  1210f0:	0f ba 65 08 09       	btl    $0x9,0x8(%ebp)
  1210f5:	73 10                	jae    121107 <z_reschedule_irqlock+0x1a>
  1210f7:	83 3d c0 e9 12 00 00 	cmpl   $0x0,0x12e9c0
  1210fe:	75 06                	jne    121106 <z_reschedule_irqlock+0x19>
}
  121100:	5d                   	pop    %ebp
  121101:	e9 eb a6 fe ff       	jmp    10b7f1 <arch_swap>
  121106:	fb                   	sti    
  121107:	5d                   	pop    %ebp
  121108:	c3                   	ret    

00121109 <z_reschedule_unlocked>:
{
  121109:	55                   	push   %ebp
  12110a:	89 e5                	mov    %esp,%ebp
  12110c:	9c                   	pushf  
  12110d:	fa                   	cli    
  12110e:	58                   	pop    %eax
	(void) z_reschedule_irqlock(arch_irq_lock());
  12110f:	50                   	push   %eax
  121110:	e8 d8 ff ff ff       	call   1210ed <z_reschedule_irqlock>
  121115:	58                   	pop    %eax
}
  121116:	c9                   	leave  
  121117:	c3                   	ret    

00121118 <k_sched_lock>:
  121118:	9c                   	pushf  
  121119:	fa                   	cli    
  12111a:	5a                   	pop    %edx
	--_current->base.sched_locked;
  12111b:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  121120:	fe 48 0f             	decb   0xf(%eax)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121123:	0f ba e2 09          	bt     $0x9,%edx
  121127:	73 01                	jae    12112a <k_sched_lock+0x12>
		__asm__ volatile ("sti" ::: "memory");
  121129:	fb                   	sti    
}
  12112a:	c3                   	ret    

0012112b <z_priq_rb_add>:

void z_priq_rb_add(struct _priq_rb *pq, struct k_thread *thread)
{
  12112b:	55                   	push   %ebp
  12112c:	89 e5                	mov    %esp,%ebp
  12112e:	56                   	push   %esi
  12112f:	53                   	push   %ebx
  121130:	83 ec 0c             	sub    $0xc,%esp
  121133:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121136:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct k_thread *t;

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	thread->base.order_key = pq->next_order_key++;
  121139:	8b 53 0c             	mov    0xc(%ebx),%edx
  12113c:	8d 42 01             	lea    0x1(%edx),%eax
  12113f:	89 43 0c             	mov    %eax,0xc(%ebx)
	 * will almost never be hit on real systems.  BUT on very
	 * long-running systems where a priq never completely empties
	 * AND that contains very large numbers of threads, it can be
	 * a latency glitch to loop over all the threads like this.
	 */
	if (!pq->next_order_key) {
  121142:	85 c0                	test   %eax,%eax
	thread->base.order_key = pq->next_order_key++;
  121144:	89 56 10             	mov    %edx,0x10(%esi)
	if (!pq->next_order_key) {
  121147:	75 4d                	jne    121196 <z_priq_rb_add+0x6b>
		RB_FOR_EACH_CONTAINER(&pq->tree, t, base.qnode_rb) {
  121149:	8b 43 08             	mov    0x8(%ebx),%eax
  12114c:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
  121153:	8d 14 85 0c 00 00 00 	lea    0xc(,%eax,4),%edx
  12115a:	83 c0 0f             	add    $0xf,%eax
  12115d:	29 d4                	sub    %edx,%esp
  12115f:	83 e0 fc             	and    $0xfffffffc,%eax
  121162:	8d 54 24 0f          	lea    0xf(%esp),%edx
  121166:	29 c4                	sub    %eax,%esp
  121168:	83 e2 f0             	and    $0xfffffff0,%edx
  12116b:	8d 44 24 0f          	lea    0xf(%esp),%eax
  12116f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  121172:	83 e0 f0             	and    $0xfffffff0,%eax
  121175:	89 45 f0             	mov    %eax,-0x10(%ebp)
  121178:	8d 45 ec             	lea    -0x14(%ebp),%eax
  12117b:	50                   	push   %eax
  12117c:	53                   	push   %ebx
  12117d:	e8 d3 07 fe ff       	call   101955 <z_rb_foreach_next>
  121182:	59                   	pop    %ecx
  121183:	85 c0                	test   %eax,%eax
  121185:	5a                   	pop    %edx
  121186:	74 0e                	je     121196 <z_priq_rb_add+0x6b>
			t->base.order_key = pq->next_order_key++;
  121188:	8b 53 0c             	mov    0xc(%ebx),%edx
  12118b:	8d 4a 01             	lea    0x1(%edx),%ecx
  12118e:	89 4b 0c             	mov    %ecx,0xc(%ebx)
  121191:	89 50 10             	mov    %edx,0x10(%eax)
  121194:	eb e2                	jmp    121178 <z_priq_rb_add+0x4d>
		}
	}

	rb_insert(&pq->tree, &thread->base.qnode_rb);
  121196:	56                   	push   %esi
  121197:	53                   	push   %ebx
  121198:	e8 98 04 fe ff       	call   101635 <rb_insert>
  12119d:	58                   	pop    %eax
  12119e:	5a                   	pop    %edx
}
  12119f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1211a2:	5b                   	pop    %ebx
  1211a3:	5e                   	pop    %esi
  1211a4:	5d                   	pop    %ebp
  1211a5:	c3                   	ret    

001211a6 <z_priq_rb_remove>:

void z_priq_rb_remove(struct _priq_rb *pq, struct k_thread *thread)
{
  1211a6:	55                   	push   %ebp
  1211a7:	89 e5                	mov    %esp,%ebp
  1211a9:	53                   	push   %ebx
		return;
	}
#endif
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	rb_remove(&pq->tree, &thread->base.qnode_rb);
  1211aa:	ff 75 0c             	pushl  0xc(%ebp)
{
  1211ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
	rb_remove(&pq->tree, &thread->base.qnode_rb);
  1211b0:	53                   	push   %ebx
  1211b1:	e8 c7 05 fe ff       	call   10177d <rb_remove>
  1211b6:	58                   	pop    %eax

	if (!pq->tree.root) {
  1211b7:	83 3b 00             	cmpl   $0x0,(%ebx)
	rb_remove(&pq->tree, &thread->base.qnode_rb);
  1211ba:	5a                   	pop    %edx
	if (!pq->tree.root) {
  1211bb:	75 07                	jne    1211c4 <z_priq_rb_remove+0x1e>
		pq->next_order_key = 0;
  1211bd:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	}
}
  1211c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1211c7:	c9                   	leave  
  1211c8:	c3                   	ret    

001211c9 <unpend_thread_no_timeout>:
{
  1211c9:	55                   	push   %ebp
  1211ca:	89 e5                	mov    %esp,%ebp
  1211cc:	53                   	push   %ebx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
  1211cd:	50                   	push   %eax
{
  1211ce:	89 c3                	mov    %eax,%ebx
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
  1211d0:	ff 70 08             	pushl  0x8(%eax)
  1211d3:	e8 ce ff ff ff       	call   1211a6 <z_priq_rb_remove>
	thread->base.pended_on = NULL;
  1211d8:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
  1211df:	58                   	pop    %eax
	thread->base.thread_state &= ~_THREAD_PENDING;
  1211e0:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
  1211e4:	5a                   	pop    %edx
}
  1211e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1211e8:	c9                   	leave  
  1211e9:	c3                   	ret    

001211ea <z_unpend_thread>:
{
  1211ea:	55                   	push   %ebp
  1211eb:	89 e5                	mov    %esp,%ebp
  1211ed:	56                   	push   %esi
  1211ee:	53                   	push   %ebx
  1211ef:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1211f2:	9c                   	pushf  
  1211f3:	fa                   	cli    
  1211f4:	5e                   	pop    %esi
		unpend_thread_no_timeout(thread);
  1211f5:	89 d8                	mov    %ebx,%eax
  1211f7:	e8 cd ff ff ff       	call   1211c9 <unpend_thread_no_timeout>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1211fc:	0f ba e6 09          	bt     $0x9,%esi
  121200:	73 01                	jae    121203 <z_unpend_thread+0x19>
		__asm__ volatile ("sti" ::: "memory");
  121202:	fb                   	sti    
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  121203:	83 c3 18             	add    $0x18,%ebx
  121206:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  121209:	5b                   	pop    %ebx
  12120a:	5e                   	pop    %esi
  12120b:	5d                   	pop    %ebp
  12120c:	e9 bc 0f 00 00       	jmp    1221cd <z_abort_timeout>

00121211 <z_priq_rb_best>:

struct k_thread *z_priq_rb_best(struct _priq_rb *pq)
{
  121211:	55                   	push   %ebp
  121212:	89 e5                	mov    %esp,%ebp
  121214:	6a 00                	push   $0x0
  121216:	ff 75 08             	pushl  0x8(%ebp)
  121219:	e8 f0 03 fe ff       	call   10160e <z_rb_get_minmax>
  12121e:	5a                   	pop    %edx
  12121f:	59                   	pop    %ecx

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_rb);
	}
	return thread;
}
  121220:	c9                   	leave  
  121221:	c3                   	ret    

00121222 <update_cache>:
{
  121222:	55                   	push   %ebp
  121223:	89 e5                	mov    %esp,%ebp
  121225:	56                   	push   %esi
	if (_current_cpu->pending_abort != NULL) {
  121226:	83 3d d0 e9 12 00 00 	cmpl   $0x0,0x12e9d0
{
  12122d:	53                   	push   %ebx
  12122e:	89 c6                	mov    %eax,%esi
	if (_current_cpu->pending_abort != NULL) {
  121230:	75 24                	jne    121256 <update_cache+0x34>
	thread = _priq_run_best(&_kernel.ready_q.runq);
  121232:	68 e8 e9 12 00       	push   $0x12e9e8
  121237:	e8 d5 ff ff ff       	call   121211 <z_priq_rb_best>
  12123c:	5a                   	pop    %edx
	if (_current->base.thread_state & _THREAD_ABORTING) {
  12123d:	8b 15 c8 e9 12 00    	mov    0x12e9c8,%edx
	thread = _priq_run_best(&_kernel.ready_q.runq);
  121243:	89 c3                	mov    %eax,%ebx
	if (_current->base.thread_state & _THREAD_ABORTING) {
  121245:	8a 42 0d             	mov    0xd(%edx),%al
  121248:	a8 20                	test   $0x20,%al
  12124a:	74 06                	je     121252 <update_cache+0x30>
		_current->base.thread_state |= _THREAD_DEAD;
  12124c:	83 c8 08             	or     $0x8,%eax
  12124f:	88 42 0d             	mov    %al,0xd(%edx)
	return thread ? thread : _current_cpu->idle_thread;
  121252:	85 db                	test   %ebx,%ebx
  121254:	75 06                	jne    12125c <update_cache+0x3a>
  121256:	8b 1d cc e9 12 00    	mov    0x12e9cc,%ebx
	if (preempt_ok != 0) {
  12125c:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  121261:	85 f6                	test   %esi,%esi
  121263:	75 14                	jne    121279 <update_cache+0x57>
	if (z_is_thread_prevented_from_running(_current)) {
  121265:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  121269:	75 0e                	jne    121279 <update_cache+0x57>
	if (is_preempt(_current) || is_metairq(thread)) {
  12126b:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
  121270:	76 07                	jbe    121279 <update_cache+0x57>
		_kernel.ready_q.cache = _current;
  121272:	a3 e4 e9 12 00       	mov    %eax,0x12e9e4
  121277:	eb 0f                	jmp    121288 <update_cache+0x66>
		if (thread != _current) {
  121279:	39 c3                	cmp    %eax,%ebx
  12127b:	74 05                	je     121282 <update_cache+0x60>
			z_reset_time_slice();
  12127d:	e8 7a fd ff ff       	call   120ffc <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  121282:	89 1d e4 e9 12 00    	mov    %ebx,0x12e9e4
}
  121288:	8d 65 f8             	lea    -0x8(%ebp),%esp
  12128b:	5b                   	pop    %ebx
  12128c:	5e                   	pop    %esi
  12128d:	5d                   	pop    %ebp
  12128e:	c3                   	ret    

0012128f <k_sched_unlock>:
{
  12128f:	55                   	push   %ebp
  121290:	89 e5                	mov    %esp,%ebp
  121292:	53                   	push   %ebx
  121293:	9c                   	pushf  
  121294:	fa                   	cli    
  121295:	5b                   	pop    %ebx
		++_current->base.sched_locked;
  121296:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  12129b:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
  12129e:	31 c0                	xor    %eax,%eax
  1212a0:	e8 7d ff ff ff       	call   121222 <update_cache>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1212a5:	0f ba e3 09          	bt     $0x9,%ebx
  1212a9:	73 01                	jae    1212ac <k_sched_unlock+0x1d>
		__asm__ volatile ("sti" ::: "memory");
  1212ab:	fb                   	sti    
}
  1212ac:	5b                   	pop    %ebx
  1212ad:	5d                   	pop    %ebp
	z_reschedule_unlocked();
  1212ae:	e9 56 fe ff ff       	jmp    121109 <z_reschedule_unlocked>

001212b3 <ready_thread>:
{
  1212b3:	55                   	push   %ebp
  1212b4:	89 e5                	mov    %esp,%ebp
  1212b6:	53                   	push   %ebx
  1212b7:	89 c3                	mov    %eax,%ebx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
  1212b9:	8a 40 0d             	mov    0xd(%eax),%al
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  1212bc:	84 c0                	test   %al,%al
  1212be:	78 26                	js     1212e6 <ready_thread+0x33>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  1212c0:	a8 1f                	test   $0x1f,%al
  1212c2:	75 22                	jne    1212e6 <ready_thread+0x33>
  1212c4:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  1212c8:	75 1c                	jne    1212e6 <ready_thread+0x33>
		_priq_run_add(&_kernel.ready_q.runq, thread);
  1212ca:	53                   	push   %ebx
  1212cb:	68 e8 e9 12 00       	push   $0x12e9e8
  1212d0:	e8 56 fe ff ff       	call   12112b <z_priq_rb_add>
	thread->base.thread_state |= states;
  1212d5:	80 4b 0d 80          	orb    $0x80,0xd(%ebx)
  1212d9:	58                   	pop    %eax
}
  1212da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
		update_cache(0);
  1212dd:	31 c0                	xor    %eax,%eax
		_priq_run_add(&_kernel.ready_q.runq, thread);
  1212df:	5a                   	pop    %edx
}
  1212e0:	c9                   	leave  
		update_cache(0);
  1212e1:	e9 3c ff ff ff       	jmp    121222 <update_cache>
}
  1212e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1212e9:	c9                   	leave  
  1212ea:	c3                   	ret    

001212eb <z_ready_thread>:
{
  1212eb:	55                   	push   %ebp
  1212ec:	89 e5                	mov    %esp,%ebp
  1212ee:	53                   	push   %ebx
  1212ef:	9c                   	pushf  
  1212f0:	fa                   	cli    
  1212f1:	5b                   	pop    %ebx
		ready_thread(thread);
  1212f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1212f5:	e8 b9 ff ff ff       	call   1212b3 <ready_thread>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1212fa:	0f ba e3 09          	bt     $0x9,%ebx
  1212fe:	73 01                	jae    121301 <z_ready_thread+0x16>
		__asm__ volatile ("sti" ::: "memory");
  121300:	fb                   	sti    
}
  121301:	5b                   	pop    %ebx
  121302:	5d                   	pop    %ebp
  121303:	c3                   	ret    

00121304 <z_sched_start>:
{
  121304:	55                   	push   %ebp
  121305:	89 e5                	mov    %esp,%ebp
  121307:	53                   	push   %ebx
  121308:	8b 55 08             	mov    0x8(%ebp),%edx
  12130b:	9c                   	pushf  
  12130c:	fa                   	cli    
  12130d:	5b                   	pop    %ebx
	if (z_has_thread_started(thread)) {
  12130e:	8a 42 0d             	mov    0xd(%edx),%al
  121311:	a8 04                	test   $0x4,%al
  121313:	75 09                	jne    12131e <z_sched_start+0x1a>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121315:	0f ba e3 09          	bt     $0x9,%ebx
  121319:	73 1d                	jae    121338 <z_sched_start+0x34>
		__asm__ volatile ("sti" ::: "memory");
  12131b:	fb                   	sti    
  12131c:	eb 1a                	jmp    121338 <z_sched_start+0x34>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  12131e:	83 e0 fb             	and    $0xfffffffb,%eax
  121321:	88 42 0d             	mov    %al,0xd(%edx)
	ready_thread(thread);
  121324:	89 d0                	mov    %edx,%eax
  121326:	e8 88 ff ff ff       	call   1212b3 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  12132b:	53                   	push   %ebx
  12132c:	68 85 ed 12 00       	push   $0x12ed85
  121331:	e8 88 fd ff ff       	call   1210be <z_reschedule>
  121336:	58                   	pop    %eax
  121337:	5a                   	pop    %edx
}
  121338:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  12133b:	c9                   	leave  
  12133c:	c3                   	ret    

0012133d <z_thread_timeout>:
{
  12133d:	55                   	push   %ebp
  12133e:	89 e5                	mov    %esp,%ebp
  121340:	56                   	push   %esi
  121341:	53                   	push   %ebx
  121342:	52                   	push   %edx
  121343:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121346:	9c                   	pushf  
  121347:	fa                   	cli    
  121348:	5e                   	pop    %esi
		if (thread->base.pended_on != NULL) {
  121349:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
		struct k_thread *thread = CONTAINER_OF(timeout,
  12134d:	8d 43 e8             	lea    -0x18(%ebx),%eax
		if (thread->base.pended_on != NULL) {
  121350:	74 0b                	je     12135d <z_thread_timeout+0x20>
			unpend_thread_no_timeout(thread);
  121352:	89 45 f4             	mov    %eax,-0xc(%ebp)
  121355:	e8 6f fe ff ff       	call   1211c9 <unpend_thread_no_timeout>
  12135a:	8b 45 f4             	mov    -0xc(%ebp),%eax
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
  12135d:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
		ready_thread(thread);
  121361:	e8 4d ff ff ff       	call   1212b3 <ready_thread>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121366:	0f ba e6 09          	bt     $0x9,%esi
  12136a:	73 01                	jae    12136d <z_thread_timeout+0x30>
		__asm__ volatile ("sti" ::: "memory");
  12136c:	fb                   	sti    
}
  12136d:	58                   	pop    %eax
  12136e:	5b                   	pop    %ebx
  12136f:	5e                   	pop    %esi
  121370:	5d                   	pop    %ebp
  121371:	c3                   	ret    

00121372 <move_thread_to_end_of_prio_q>:
{
  121372:	55                   	push   %ebp
  121373:	89 e5                	mov    %esp,%ebp
  121375:	53                   	push   %ebx
	if (z_is_thread_queued(thread)) {
  121376:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
{
  12137a:	89 c3                	mov    %eax,%ebx
	if (z_is_thread_queued(thread)) {
  12137c:	79 0d                	jns    12138b <move_thread_to_end_of_prio_q+0x19>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
  12137e:	50                   	push   %eax
  12137f:	68 e8 e9 12 00       	push   $0x12e9e8
  121384:	e8 1d fe ff ff       	call   1211a6 <z_priq_rb_remove>
  121389:	59                   	pop    %ecx
  12138a:	58                   	pop    %eax
	_priq_run_add(&_kernel.ready_q.runq, thread);
  12138b:	53                   	push   %ebx
  12138c:	68 e8 e9 12 00       	push   $0x12e9e8
  121391:	e8 95 fd ff ff       	call   12112b <z_priq_rb_add>
	thread->base.thread_state |= states;
  121396:	80 4b 0d 80          	orb    $0x80,0xd(%ebx)
  12139a:	58                   	pop    %eax
	update_cache(thread == _current);
  12139b:	31 c0                	xor    %eax,%eax
  12139d:	39 1d c8 e9 12 00    	cmp    %ebx,0x12e9c8
}
  1213a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	update_cache(thread == _current);
  1213a6:	0f 94 c0             	sete   %al
	_priq_run_add(&_kernel.ready_q.runq, thread);
  1213a9:	5a                   	pop    %edx
}
  1213aa:	c9                   	leave  
	update_cache(thread == _current);
  1213ab:	e9 72 fe ff ff       	jmp    121222 <update_cache>

001213b0 <z_time_slice>:
{
  1213b0:	55                   	push   %ebp
  1213b1:	89 e5                	mov    %esp,%ebp
  1213b3:	53                   	push   %ebx
  1213b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1213b7:	9c                   	pushf  
  1213b8:	fa                   	cli    
  1213b9:	5b                   	pop    %ebx
	if (slice_time && sliceable(_current)) {
  1213ba:	83 3d 68 ed 12 00 00 	cmpl   $0x0,0x12ed68
  1213c1:	74 45                	je     121408 <z_time_slice+0x58>
  1213c3:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
		&& !z_is_idle_thread_object(thread);
  1213c8:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
  1213cd:	77 39                	ja     121408 <z_time_slice+0x58>
		&& !z_is_thread_prevented_from_running(thread)
  1213cf:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
  1213d3:	75 33                	jne    121408 <z_time_slice+0x58>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  1213d5:	0f be 50 0e          	movsbl 0xe(%eax),%edx
		&& !z_is_idle_thread_object(thread);
  1213d9:	39 15 64 ed 12 00    	cmp    %edx,0x12ed64
  1213df:	7f 27                	jg     121408 <z_time_slice+0x58>
  1213e1:	3d 80 e8 12 00       	cmp    $0x12e880,%eax
  1213e6:	74 20                	je     121408 <z_time_slice+0x58>
		if (ticks >= _current_cpu->slice_ticks) {
  1213e8:	8b 15 d4 e9 12 00    	mov    0x12e9d4,%edx
  1213ee:	39 ca                	cmp    %ecx,%edx
  1213f0:	7f 0c                	jg     1213fe <z_time_slice+0x4e>
			move_thread_to_end_of_prio_q(_current);
  1213f2:	e8 7b ff ff ff       	call   121372 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
  1213f7:	e8 00 fc ff ff       	call   120ffc <z_reset_time_slice>
  1213fc:	eb 14                	jmp    121412 <z_time_slice+0x62>
			_current_cpu->slice_ticks -= ticks;
  1213fe:	29 ca                	sub    %ecx,%edx
  121400:	89 15 d4 e9 12 00    	mov    %edx,0x12e9d4
  121406:	eb 0a                	jmp    121412 <z_time_slice+0x62>
		_current_cpu->slice_ticks = 0;
  121408:	c7 05 d4 e9 12 00 00 	movl   $0x0,0x12e9d4
  12140f:	00 00 00 
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121412:	0f ba e3 09          	bt     $0x9,%ebx
  121416:	73 01                	jae    121419 <z_time_slice+0x69>
		__asm__ volatile ("sti" ::: "memory");
  121418:	fb                   	sti    
}
  121419:	5b                   	pop    %ebx
  12141a:	5d                   	pop    %ebp
  12141b:	c3                   	ret    

0012141c <z_impl_k_thread_suspend>:
{
  12141c:	55                   	push   %ebp
  12141d:	89 e5                	mov    %esp,%ebp
  12141f:	56                   	push   %esi
  121420:	53                   	push   %ebx
  121421:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121424:	8d 43 18             	lea    0x18(%ebx),%eax
  121427:	50                   	push   %eax
  121428:	e8 a0 0d 00 00       	call   1221cd <z_abort_timeout>
  12142d:	59                   	pop    %ecx
  12142e:	9c                   	pushf  
  12142f:	fa                   	cli    
  121430:	5e                   	pop    %esi
		if (z_is_thread_queued(thread)) {
  121431:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
  121435:	79 11                	jns    121448 <z_impl_k_thread_suspend+0x2c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
  121437:	53                   	push   %ebx
  121438:	68 e8 e9 12 00       	push   $0x12e9e8
  12143d:	e8 64 fd ff ff       	call   1211a6 <z_priq_rb_remove>
  121442:	58                   	pop    %eax
  121443:	5a                   	pop    %edx
	thread->base.thread_state &= ~states;
  121444:	80 63 0d 7f          	andb   $0x7f,0xd(%ebx)
	thread->base.thread_state |= _THREAD_SUSPENDED;
  121448:	80 4b 0d 10          	orb    $0x10,0xd(%ebx)
		update_cache(thread == _current);
  12144c:	31 c0                	xor    %eax,%eax
  12144e:	39 1d c8 e9 12 00    	cmp    %ebx,0x12e9c8
  121454:	0f 94 c0             	sete   %al
  121457:	e8 c6 fd ff ff       	call   121222 <update_cache>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12145c:	0f ba e6 09          	bt     $0x9,%esi
  121460:	73 01                	jae    121463 <z_impl_k_thread_suspend+0x47>
		__asm__ volatile ("sti" ::: "memory");
  121462:	fb                   	sti    
	if (thread == _current) {
  121463:	39 1d c8 e9 12 00    	cmp    %ebx,0x12e9c8
  121469:	75 0b                	jne    121476 <z_impl_k_thread_suspend+0x5a>
}
  12146b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  12146e:	5b                   	pop    %ebx
  12146f:	5e                   	pop    %esi
  121470:	5d                   	pop    %ebp
		z_reschedule_unlocked();
  121471:	e9 93 fc ff ff       	jmp    121109 <z_reschedule_unlocked>
}
  121476:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121479:	5b                   	pop    %ebx
  12147a:	5e                   	pop    %esi
  12147b:	5d                   	pop    %ebp
  12147c:	c3                   	ret    

0012147d <z_thread_single_abort>:
{
  12147d:	55                   	push   %ebp
  12147e:	89 e5                	mov    %esp,%ebp
  121480:	57                   	push   %edi
  121481:	56                   	push   %esi
  121482:	53                   	push   %ebx
  121483:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121486:	9c                   	pushf  
  121487:	fa                   	cli    
  121488:	5a                   	pop    %edx
	if ((thread->base.thread_state &
  121489:	8a 43 0d             	mov    0xd(%ebx),%al
  12148c:	a8 28                	test   $0x28,%al
  12148e:	74 10                	je     1214a0 <z_thread_single_abort+0x23>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121490:	0f ba e2 09          	bt     $0x9,%edx
  121494:	0f 83 f1 00 00 00    	jae    12158b <z_thread_single_abort+0x10e>
		__asm__ volatile ("sti" ::: "memory");
  12149a:	fb                   	sti    
  12149b:	e9 eb 00 00 00       	jmp    12158b <z_thread_single_abort+0x10e>
	thread->base.thread_state |= _THREAD_ABORTING;
  1214a0:	83 c8 20             	or     $0x20,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1214a3:	0f ba e2 09          	bt     $0x9,%edx
  1214a7:	88 43 0d             	mov    %al,0xd(%ebx)
  1214aa:	73 01                	jae    1214ad <z_thread_single_abort+0x30>
		__asm__ volatile ("sti" ::: "memory");
  1214ac:	fb                   	sti    
  1214ad:	8d 43 18             	lea    0x18(%ebx),%eax
  1214b0:	50                   	push   %eax
  1214b1:	e8 17 0d 00 00       	call   1221cd <z_abort_timeout>
  1214b6:	59                   	pop    %ecx
  1214b7:	9c                   	pushf  
  1214b8:	fa                   	cli    
  1214b9:	5f                   	pop    %edi
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  1214ba:	8a 43 0d             	mov    0xd(%ebx),%al
  1214bd:	a8 1f                	test   $0x1f,%al
  1214bf:	75 2d                	jne    1214ee <z_thread_single_abort+0x71>
		if (z_is_thread_ready(thread)) {
  1214c1:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  1214c5:	75 27                	jne    1214ee <z_thread_single_abort+0x71>
			if (z_is_thread_queued(thread)) {
  1214c7:	84 c0                	test   %al,%al
  1214c9:	79 11                	jns    1214dc <z_thread_single_abort+0x5f>
				_priq_run_remove(&_kernel.ready_q.runq,
  1214cb:	53                   	push   %ebx
  1214cc:	68 e8 e9 12 00       	push   $0x12e9e8
  1214d1:	e8 d0 fc ff ff       	call   1211a6 <z_priq_rb_remove>
  1214d6:	58                   	pop    %eax
  1214d7:	5a                   	pop    %edx
	thread->base.thread_state &= ~states;
  1214d8:	80 63 0d 7f          	andb   $0x7f,0xd(%ebx)
			update_cache(thread == _current);
  1214dc:	31 c0                	xor    %eax,%eax
  1214de:	39 1d c8 e9 12 00    	cmp    %ebx,0x12e9c8
  1214e4:	0f 94 c0             	sete   %al
  1214e7:	e8 36 fd ff ff       	call   121222 <update_cache>
  1214ec:	eb 1a                	jmp    121508 <z_thread_single_abort+0x8b>
			if (z_is_thread_pending(thread)) {
  1214ee:	a8 02                	test   $0x2,%al
  1214f0:	74 16                	je     121508 <z_thread_single_abort+0x8b>
				_priq_wait_remove(&pended_on(thread)->waitq,
  1214f2:	53                   	push   %ebx
  1214f3:	ff 73 08             	pushl  0x8(%ebx)
  1214f6:	e8 ab fc ff ff       	call   1211a6 <z_priq_rb_remove>
  1214fb:	59                   	pop    %ecx
  1214fc:	5e                   	pop    %esi
				thread->base.pended_on = NULL;
  1214fd:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	thread->base.thread_state &= ~_THREAD_PENDING;
  121504:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
  121508:	6a 00                	push   $0x0

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)rb_get_min(&w->waitq.tree);
  12150a:	8d 43 2c             	lea    0x2c(%ebx),%eax
  12150d:	50                   	push   %eax
  12150e:	e8 fb 00 fe ff       	call   10160e <z_rb_get_minmax>
  121513:	5a                   	pop    %edx
  121514:	89 c6                	mov    %eax,%esi
  121516:	59                   	pop    %ecx
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
  121517:	85 c0                	test   %eax,%eax
  121519:	74 33                	je     12154e <z_thread_single_abort+0xd1>
  12151b:	8d 46 18             	lea    0x18(%esi),%eax
  12151e:	50                   	push   %eax
  12151f:	e8 a9 0c 00 00       	call   1221cd <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
  121524:	89 34 24             	mov    %esi,(%esp)
  121527:	ff 76 08             	pushl  0x8(%esi)
  12152a:	e8 77 fc ff ff       	call   1211a6 <z_priq_rb_remove>
  12152f:	58                   	pop    %eax
  121530:	8b 46 3c             	mov    0x3c(%esi),%eax
  121533:	5a                   	pop    %edx
			waiter->base.pended_on = NULL;
  121534:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  12153b:	80 66 0d fd          	andb   $0xfd,0xd(%esi)
  12153f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			ready_thread(waiter);
  121545:	89 f0                	mov    %esi,%eax
  121547:	e8 67 fd ff ff       	call   1212b3 <ready_thread>
  12154c:	eb ba                	jmp    121508 <z_thread_single_abort+0x8b>
		if (z_is_idle_thread_object(_current)) {
  12154e:	81 3d c8 e9 12 00 80 	cmpl   $0x12e880,0x12e9c8
  121555:	e8 12 00 
  121558:	75 0a                	jne    121564 <z_thread_single_abort+0xe7>
			update_cache(1);
  12155a:	b8 01 00 00 00       	mov    $0x1,%eax
  12155f:	e8 be fc ff ff       	call   121222 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
  121564:	80 4b 0d 08          	orb    $0x8,0xd(%ebx)
		fn_abort = thread->fn_abort;
  121568:	8b 73 44             	mov    0x44(%ebx),%esi
		z_thread_monitor_exit(thread);
  12156b:	53                   	push   %ebx
  12156c:	e8 80 04 00 00       	call   1219f1 <z_thread_monitor_exit>
  121571:	58                   	pop    %eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121572:	0f ba e7 09          	bt     $0x9,%edi
  121576:	73 01                	jae    121579 <z_thread_single_abort+0xfc>
		__asm__ volatile ("sti" ::: "memory");
  121578:	fb                   	sti    
	if (fn_abort != NULL) {
  121579:	85 f6                	test   %esi,%esi
  12157b:	74 0e                	je     12158b <z_thread_single_abort+0x10e>
		fn_abort(thread);
  12157d:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  121580:	8d 65 f4             	lea    -0xc(%ebp),%esp
		fn_abort(thread);
  121583:	89 f0                	mov    %esi,%eax
}
  121585:	5b                   	pop    %ebx
  121586:	5e                   	pop    %esi
  121587:	5f                   	pop    %edi
  121588:	5d                   	pop    %ebp
		fn_abort(thread);
  121589:	ff e0                	jmp    *%eax
}
  12158b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  12158e:	5b                   	pop    %ebx
  12158f:	5e                   	pop    %esi
  121590:	5f                   	pop    %edi
  121591:	5d                   	pop    %ebp
  121592:	c3                   	ret    

00121593 <unready_thread>:
{
  121593:	55                   	push   %ebp
  121594:	89 e5                	mov    %esp,%ebp
  121596:	53                   	push   %ebx
	if (z_is_thread_queued(thread)) {
  121597:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
{
  12159b:	89 c3                	mov    %eax,%ebx
	if (z_is_thread_queued(thread)) {
  12159d:	79 11                	jns    1215b0 <unready_thread+0x1d>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
  12159f:	50                   	push   %eax
  1215a0:	68 e8 e9 12 00       	push   $0x12e9e8
  1215a5:	e8 fc fb ff ff       	call   1211a6 <z_priq_rb_remove>
	thread->base.thread_state &= ~states;
  1215aa:	80 63 0d 7f          	andb   $0x7f,0xd(%ebx)
  1215ae:	58                   	pop    %eax
  1215af:	5a                   	pop    %edx
	update_cache(thread == _current);
  1215b0:	31 c0                	xor    %eax,%eax
  1215b2:	39 1d c8 e9 12 00    	cmp    %ebx,0x12e9c8
}
  1215b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1215bb:	c9                   	leave  
	update_cache(thread == _current);
  1215bc:	0f 94 c0             	sete   %al
  1215bf:	e9 5e fc ff ff       	jmp    121222 <update_cache>

001215c4 <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(int32_t ticks)
  1215c4:	55                   	push   %ebp
  1215c5:	89 e5                	mov    %esp,%ebp
  1215c7:	57                   	push   %edi
  1215c8:	56                   	push   %esi
  1215c9:	89 c7                	mov    %eax,%edi
  1215cb:	53                   	push   %ebx
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
  1215cc:	e8 ac 0d 00 00       	call   12237d <z_tick_get_32>
  1215d1:	8d 1c 07             	lea    (%edi,%eax,1),%ebx
  1215d4:	9c                   	pushf  
  1215d5:	fa                   	cli    
  1215d6:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
  1215d7:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  1215dc:	e8 b2 ff ff ff       	call   121593 <unready_thread>
	timeout = Z_TIMEOUT_TICKS(ticks);
  1215e1:	89 f8                	mov    %edi,%eax
  1215e3:	99                   	cltd   
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  1215e4:	52                   	push   %edx
  1215e5:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  1215ea:	57                   	push   %edi
  1215eb:	83 c0 18             	add    $0x18,%eax
  1215ee:	68 3d 13 12 00       	push   $0x12133d
  1215f3:	50                   	push   %eax
  1215f4:	e8 86 0a 00 00       	call   12207f <z_add_timeout>
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);
  1215f9:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  1215fe:	83 c4 10             	add    $0x10,%esp
	thread->base.thread_state |= _THREAD_SUSPENDED;
  121601:	80 48 0d 10          	orb    $0x10,0xd(%eax)
  121605:	56                   	push   %esi
  121606:	e8 e6 a1 fe ff       	call   10b7f1 <arch_swap>
  12160b:	58                   	pop    %eax

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
  12160c:	e8 6c 0d 00 00       	call   12237d <z_tick_get_32>
	if (ticks > 0) {
  121611:	29 c3                	sub    %eax,%ebx
  121613:	89 d8                	mov    %ebx,%eax
  121615:	79 02                	jns    121619 <z_tick_sleep.part.0+0x55>
  121617:	31 c0                	xor    %eax,%eax
		return ticks;
	}
#endif

	return 0;
}
  121619:	8d 65 f4             	lea    -0xc(%ebp),%esp
  12161c:	5b                   	pop    %ebx
  12161d:	5e                   	pop    %esi
  12161e:	5f                   	pop    %edi
  12161f:	5d                   	pop    %ebp
  121620:	c3                   	ret    

00121621 <pend>:
{
  121621:	55                   	push   %ebp
  121622:	89 e5                	mov    %esp,%ebp
  121624:	57                   	push   %edi
  121625:	56                   	push   %esi
  121626:	53                   	push   %ebx
  121627:	83 ec 08             	sub    $0x8,%esp
  12162a:	89 55 ec             	mov    %edx,-0x14(%ebp)
  12162d:	8b 75 08             	mov    0x8(%ebp),%esi
  121630:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  121633:	9c                   	pushf  
  121634:	fa                   	cli    
  121635:	5f                   	pop    %edi
	unready_thread(thread);
  121636:	89 45 f0             	mov    %eax,-0x10(%ebp)
  121639:	e8 55 ff ff ff       	call   121593 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  12163e:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (wait_q != NULL) {
  121641:	8b 55 ec             	mov    -0x14(%ebp),%edx
  121644:	80 48 0d 02          	orb    $0x2,0xd(%eax)
  121648:	85 d2                	test   %edx,%edx
  12164a:	74 0f                	je     12165b <pend+0x3a>
		thread->base.pended_on = wait_q;
  12164c:	89 50 08             	mov    %edx,0x8(%eax)
		z_priq_wait_add(&wait_q->waitq, thread);
  12164f:	50                   	push   %eax
  121650:	52                   	push   %edx
  121651:	e8 d5 fa ff ff       	call   12112b <z_priq_rb_add>
  121656:	58                   	pop    %eax
  121657:	8b 45 f0             	mov    -0x10(%ebp),%eax
  12165a:	5a                   	pop    %edx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12165b:	0f ba e7 09          	bt     $0x9,%edi
  12165f:	73 01                	jae    121662 <pend+0x41>
		__asm__ volatile ("sti" ::: "memory");
  121661:	fb                   	sti    
	add_thread_timeout(thread, timeout);
  121662:	89 f2                	mov    %esi,%edx
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  121664:	83 fb ff             	cmp    $0xffffffff,%ebx
  121667:	75 05                	jne    12166e <pend+0x4d>
  121669:	83 fe ff             	cmp    $0xffffffff,%esi
  12166c:	74 13                	je     121681 <pend+0x60>
  12166e:	53                   	push   %ebx
  12166f:	83 c0 18             	add    $0x18,%eax
  121672:	52                   	push   %edx
  121673:	68 3d 13 12 00       	push   $0x12133d
  121678:	50                   	push   %eax
  121679:	e8 01 0a 00 00       	call   12207f <z_add_timeout>
  12167e:	83 c4 10             	add    $0x10,%esp
}
  121681:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121684:	5b                   	pop    %ebx
  121685:	5e                   	pop    %esi
  121686:	5f                   	pop    %edi
  121687:	5d                   	pop    %ebp
  121688:	c3                   	ret    

00121689 <z_pend_curr>:
{
  121689:	55                   	push   %ebp
	pend(_current, wait_q, timeout);
  12168a:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
{
  12168f:	89 e5                	mov    %esp,%ebp
  121691:	53                   	push   %ebx
	pend(_current, wait_q, timeout);
  121692:	ff 75 18             	pushl  0x18(%ebp)
  121695:	ff 75 14             	pushl  0x14(%ebp)
  121698:	8b 55 10             	mov    0x10(%ebp),%edx
{
  12169b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	pend(_current, wait_q, timeout);
  12169e:	e8 7e ff ff ff       	call   121621 <pend>
  1216a3:	58                   	pop    %eax
  1216a4:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  1216a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	pend(_current, wait_q, timeout);
  1216aa:	5a                   	pop    %edx
}
  1216ab:	c9                   	leave  
  1216ac:	e9 40 a1 fe ff       	jmp    10b7f1 <arch_swap>

001216b1 <z_set_prio>:
{
  1216b1:	55                   	push   %ebp
  1216b2:	89 e5                	mov    %esp,%ebp
  1216b4:	57                   	push   %edi
  1216b5:	56                   	push   %esi
  1216b6:	53                   	push   %ebx
  1216b7:	8b 75 08             	mov    0x8(%ebp),%esi
  1216ba:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1216bd:	9c                   	pushf  
  1216be:	fa                   	cli    
  1216bf:	5f                   	pop    %edi
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  1216c0:	f6 46 0d 1f          	testb  $0x1f,0xd(%esi)
  1216c4:	75 31                	jne    1216f7 <z_set_prio+0x46>
		if (need_sched) {
  1216c6:	83 7e 18 00          	cmpl   $0x0,0x18(%esi)
  1216ca:	75 2b                	jne    1216f7 <z_set_prio+0x46>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
  1216cc:	56                   	push   %esi
  1216cd:	68 e8 e9 12 00       	push   $0x12e9e8
  1216d2:	e8 cf fa ff ff       	call   1211a6 <z_priq_rb_remove>
  1216d7:	58                   	pop    %eax
  1216d8:	5a                   	pop    %edx
				thread->base.prio = prio;
  1216d9:	88 5e 0e             	mov    %bl,0xe(%esi)
				_priq_run_add(&_kernel.ready_q.runq, thread);
  1216dc:	56                   	push   %esi
  1216dd:	68 e8 e9 12 00       	push   $0x12e9e8
  1216e2:	e8 44 fa ff ff       	call   12112b <z_priq_rb_add>
  1216e7:	59                   	pop    %ecx
			update_cache(1);
  1216e8:	b8 01 00 00 00       	mov    $0x1,%eax
				_priq_run_add(&_kernel.ready_q.runq, thread);
  1216ed:	5b                   	pop    %ebx
			update_cache(1);
  1216ee:	e8 2f fb ff ff       	call   121222 <update_cache>
  1216f3:	b0 01                	mov    $0x1,%al
  1216f5:	eb 05                	jmp    1216fc <z_set_prio+0x4b>
			thread->base.prio = prio;
  1216f7:	88 5e 0e             	mov    %bl,0xe(%esi)
  1216fa:	31 c0                	xor    %eax,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1216fc:	0f ba e7 09          	bt     $0x9,%edi
  121700:	73 01                	jae    121703 <z_set_prio+0x52>
		__asm__ volatile ("sti" ::: "memory");
  121702:	fb                   	sti    
}
  121703:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121706:	5b                   	pop    %ebx
  121707:	5e                   	pop    %esi
  121708:	5f                   	pop    %edi
  121709:	5d                   	pop    %ebp
  12170a:	c3                   	ret    

0012170b <z_unpend_first_thread>:
{
  12170b:	55                   	push   %ebp
  12170c:	89 e5                	mov    %esp,%ebp
  12170e:	56                   	push   %esi
  12170f:	53                   	push   %ebx
  121710:	9c                   	pushf  
  121711:	fa                   	cli    
  121712:	5e                   	pop    %esi
		ret = _priq_wait_best(&wait_q->waitq);
  121713:	ff 75 08             	pushl  0x8(%ebp)
  121716:	e8 f6 fa ff ff       	call   121211 <z_priq_rb_best>
  12171b:	5a                   	pop    %edx
  12171c:	89 c3                	mov    %eax,%ebx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12171e:	0f ba e6 09          	bt     $0x9,%esi
  121722:	73 01                	jae    121725 <z_unpend_first_thread+0x1a>
		__asm__ volatile ("sti" ::: "memory");
  121724:	fb                   	sti    

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
  121725:	85 db                	test   %ebx,%ebx
  121727:	74 1b                	je     121744 <z_unpend_first_thread+0x39>
  121729:	9c                   	pushf  
  12172a:	fa                   	cli    
  12172b:	5e                   	pop    %esi
		unpend_thread_no_timeout(thread);
  12172c:	89 d8                	mov    %ebx,%eax
  12172e:	e8 96 fa ff ff       	call   1211c9 <unpend_thread_no_timeout>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121733:	0f ba e6 09          	bt     $0x9,%esi
  121737:	73 01                	jae    12173a <z_unpend_first_thread+0x2f>
		__asm__ volatile ("sti" ::: "memory");
  121739:	fb                   	sti    
	return z_abort_timeout(&thread->base.timeout);
  12173a:	8d 43 18             	lea    0x18(%ebx),%eax
  12173d:	50                   	push   %eax
  12173e:	e8 8a 0a 00 00       	call   1221cd <z_abort_timeout>
  121743:	58                   	pop    %eax
}
  121744:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121747:	89 d8                	mov    %ebx,%eax
  121749:	5b                   	pop    %ebx
  12174a:	5e                   	pop    %esi
  12174b:	5d                   	pop    %ebp
  12174c:	c3                   	ret    

0012174d <z_unpend_all>:
{
  12174d:	55                   	push   %ebp
  12174e:	89 e5                	mov    %esp,%ebp
  121750:	56                   	push   %esi
  121751:	53                   	push   %ebx
	int need_sched = 0;
  121752:	31 f6                	xor    %esi,%esi
  121754:	6a 00                	push   $0x0
  121756:	ff 75 08             	pushl  0x8(%ebp)
  121759:	e8 b0 fe fd ff       	call   10160e <z_rb_get_minmax>
  12175e:	5a                   	pop    %edx
  12175f:	89 c3                	mov    %eax,%ebx
  121761:	59                   	pop    %ecx
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  121762:	85 c0                	test   %eax,%eax
  121764:	74 16                	je     12177c <z_unpend_all+0x2f>
		z_unpend_thread(thread);
  121766:	53                   	push   %ebx
		need_sched = 1;
  121767:	be 01 00 00 00       	mov    $0x1,%esi
		z_unpend_thread(thread);
  12176c:	e8 79 fa ff ff       	call   1211ea <z_unpend_thread>
		z_ready_thread(thread);
  121771:	89 1c 24             	mov    %ebx,(%esp)
  121774:	e8 72 fb ff ff       	call   1212eb <z_ready_thread>
  121779:	5b                   	pop    %ebx
		need_sched = 1;
  12177a:	eb d8                	jmp    121754 <z_unpend_all+0x7>
}
  12177c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  12177f:	89 f0                	mov    %esi,%eax
  121781:	5b                   	pop    %ebx
  121782:	5e                   	pop    %esi
  121783:	5d                   	pop    %ebp
  121784:	c3                   	ret    

00121785 <z_sched_init>:
{
  121785:	55                   	push   %ebp
	_kernel.ready_q.runq = (struct _priq_rb) {
  121786:	ba e8 e9 12 00       	mov    $0x12e9e8,%edx
{
  12178b:	89 e5                	mov    %esp,%ebp
	_kernel.ready_q.runq = (struct _priq_rb) {
  12178d:	31 c0                	xor    %eax,%eax
{
  12178f:	57                   	push   %edi
	_kernel.ready_q.runq = (struct _priq_rb) {
  121790:	b9 04 00 00 00       	mov    $0x4,%ecx
  121795:	89 d7                	mov    %edx,%edi
  121797:	f3 ab                	rep stos %eax,%es:(%edi)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  121799:	6a 00                	push   $0x0
	_kernel.ready_q.runq = (struct _priq_rb) {
  12179b:	c7 05 ec e9 12 00 c4 	movl   $0x120fc4,0x12e9ec
  1217a2:	0f 12 00 
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  1217a5:	6a 00                	push   $0x0
  1217a7:	e8 7b f8 ff ff       	call   121027 <k_sched_time_slice_set>
  1217ac:	58                   	pop    %eax
}
  1217ad:	8b 7d fc             	mov    -0x4(%ebp),%edi
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
  1217b0:	5a                   	pop    %edx
}
  1217b1:	c9                   	leave  
  1217b2:	c3                   	ret    

001217b3 <z_impl_k_yield>:
{
  1217b3:	55                   	push   %ebp
  1217b4:	89 e5                	mov    %esp,%ebp
  1217b6:	53                   	push   %ebx
	if (!z_is_idle_thread_object(_current)) {
  1217b7:	81 3d c8 e9 12 00 80 	cmpl   $0x12e880,0x12e9c8
  1217be:	e8 12 00 
  1217c1:	74 41                	je     121804 <z_impl_k_yield+0x51>
  1217c3:	9c                   	pushf  
  1217c4:	fa                   	cli    
  1217c5:	5b                   	pop    %ebx
				_priq_run_remove(&_kernel.ready_q.runq,
  1217c6:	ff 35 c8 e9 12 00    	pushl  0x12e9c8
  1217cc:	68 e8 e9 12 00       	push   $0x12e9e8
  1217d1:	e8 d0 f9 ff ff       	call   1211a6 <z_priq_rb_remove>
  1217d6:	5a                   	pop    %edx
  1217d7:	59                   	pop    %ecx
			_priq_run_add(&_kernel.ready_q.runq, _current);
  1217d8:	ff 35 c8 e9 12 00    	pushl  0x12e9c8
  1217de:	68 e8 e9 12 00       	push   $0x12e9e8
  1217e3:	e8 43 f9 ff ff       	call   12112b <z_priq_rb_add>
  1217e8:	58                   	pop    %eax
			z_mark_thread_as_queued(_current);
  1217e9:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
			_priq_run_add(&_kernel.ready_q.runq, _current);
  1217ee:	5a                   	pop    %edx
	thread->base.thread_state |= states;
  1217ef:	80 48 0d 80          	orb    $0x80,0xd(%eax)
			update_cache(1);
  1217f3:	b8 01 00 00 00       	mov    $0x1,%eax
  1217f8:	e8 25 fa ff ff       	call   121222 <update_cache>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1217fd:	0f ba e3 09          	bt     $0x9,%ebx
  121801:	73 01                	jae    121804 <z_impl_k_yield+0x51>
		__asm__ volatile ("sti" ::: "memory");
  121803:	fb                   	sti    
  121804:	9c                   	pushf  
  121805:	fa                   	cli    
  121806:	58                   	pop    %eax
  121807:	50                   	push   %eax
  121808:	e8 e4 9f fe ff       	call   10b7f1 <arch_swap>
  12180d:	58                   	pop    %eax
}
  12180e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  121811:	c9                   	leave  
  121812:	c3                   	ret    

00121813 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
  121813:	55                   	push   %ebp
  121814:	89 e5                	mov    %esp,%ebp
  121816:	52                   	push   %edx
  121817:	8b 55 0c             	mov    0xc(%ebp),%edx
  12181a:	8b 45 08             	mov    0x8(%ebp),%eax

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  12181d:	42                   	inc    %edx
  12181e:	75 16                	jne    121836 <z_impl_k_sleep+0x23>
  121820:	83 f8 ff             	cmp    $0xffffffff,%eax
  121823:	75 11                	jne    121836 <z_impl_k_sleep+0x23>
		k_thread_suspend(_current);
  121825:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
	z_impl_k_thread_suspend(thread);
  12182a:	50                   	push   %eax
  12182b:	e8 ec fb ff ff       	call   12141c <z_impl_k_thread_suspend>
  121830:	58                   	pop    %eax
		return (int32_t) K_TICKS_FOREVER;
  121831:	83 c8 ff             	or     $0xffffffff,%eax
}
  121834:	eb 19                	jmp    12184f <z_impl_k_sleep+0x3c>
	if (ticks == 0) {
  121836:	85 c0                	test   %eax,%eax
  121838:	75 0d                	jne    121847 <z_impl_k_sleep+0x34>
  12183a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	z_impl_k_yield();
  12183d:	e8 71 ff ff ff       	call   1217b3 <z_impl_k_yield>
}
  121842:	8b 45 fc             	mov    -0x4(%ebp),%eax
  121845:	eb 05                	jmp    12184c <z_impl_k_sleep+0x39>
  121847:	e8 78 fd ff ff       	call   1215c4 <z_tick_sleep.part.0>
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
  12184c:	6b c0 0a             	imul   $0xa,%eax,%eax
}
  12184f:	c9                   	leave  
  121850:	c3                   	ret    

00121851 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  121851:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  121856:	c3                   	ret    

00121857 <z_impl_k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
  121857:	55                   	push   %ebp
  121858:	89 e5                	mov    %esp,%ebp
  12185a:	57                   	push   %edi
  12185b:	8b 45 10             	mov    0x10(%ebp),%eax
  12185e:	8b 55 08             	mov    0x8(%ebp),%edx
  121861:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || initial_count > limit) {
  121864:	85 c0                	test   %eax,%eax
  121866:	74 29                	je     121891 <z_impl_k_sem_init+0x3a>
  121868:	39 c8                	cmp    %ecx,%eax
  12186a:	72 25                	jb     121891 <z_impl_k_sem_init+0x3a>
		return -EINVAL;
	}

	sem->count = initial_count;
  12186c:	89 4a 10             	mov    %ecx,0x10(%edx)
	sem->limit = limit;
  12186f:	89 42 14             	mov    %eax,0x14(%edx)
	w->waitq = (struct _priq_rb) {
  121872:	b9 04 00 00 00       	mov    $0x4,%ecx
  121877:	31 c0                	xor    %eax,%eax
  121879:	89 d7                	mov    %edx,%edi
  12187b:	f3 ab                	rep stos %eax,%es:(%edi)
	sys_trace_semaphore_init(sem);
	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  12187d:	8d 42 18             	lea    0x18(%edx),%eax
  121880:	c7 42 04 c4 0f 12 00 	movl   $0x120fc4,0x4(%edx)
	list->head = (sys_dnode_t *)list;
  121887:	89 42 18             	mov    %eax,0x18(%edx)
	list->tail = (sys_dnode_t *)list;
  12188a:	89 42 1c             	mov    %eax,0x1c(%edx)
	SYS_TRACING_OBJ_INIT(k_sem, sem);

	z_object_init(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_INIT);

	return 0;
  12188d:	31 c0                	xor    %eax,%eax
  12188f:	eb 05                	jmp    121896 <z_impl_k_sem_init+0x3f>
		return -EINVAL;
  121891:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
  121896:	5f                   	pop    %edi
  121897:	5d                   	pop    %ebp
  121898:	c3                   	ret    

00121899 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  121899:	55                   	push   %ebp
  12189a:	89 e5                	mov    %esp,%ebp
  12189c:	56                   	push   %esi
  12189d:	53                   	push   %ebx
  12189e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1218a1:	9c                   	pushf  
  1218a2:	fa                   	cli    
  1218a3:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
  1218a4:	53                   	push   %ebx
  1218a5:	e8 61 fe ff ff       	call   12170b <z_unpend_first_thread>
  1218aa:	5a                   	pop    %edx

	if (thread != NULL) {
  1218ab:	85 c0                	test   %eax,%eax
  1218ad:	74 12                	je     1218c1 <z_impl_k_sem_give+0x28>
  1218af:	8b 50 3c             	mov    0x3c(%eax),%edx
  1218b2:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  1218b8:	50                   	push   %eax
  1218b9:	e8 2d fa ff ff       	call   1212eb <z_ready_thread>
  1218be:	58                   	pop    %eax
  1218bf:	eb 1d                	jmp    1218de <z_impl_k_sem_give+0x45>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  1218c1:	8b 53 10             	mov    0x10(%ebx),%edx
  1218c4:	31 c0                	xor    %eax,%eax
  1218c6:	39 53 14             	cmp    %edx,0x14(%ebx)
  1218c9:	0f 95 c0             	setne  %al
  1218cc:	01 d0                	add    %edx,%eax
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  1218ce:	83 c3 18             	add    $0x18,%ebx
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  1218d1:	89 43 f8             	mov    %eax,-0x8(%ebx)
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  1218d4:	6a 02                	push   $0x2
  1218d6:	53                   	push   %ebx
  1218d7:	e8 5b 11 00 00       	call   122a37 <z_handle_obj_poll_events>
  1218dc:	59                   	pop    %ecx
  1218dd:	5b                   	pop    %ebx
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
  1218de:	56                   	push   %esi
  1218df:	68 86 ed 12 00       	push   $0x12ed86
  1218e4:	e8 d5 f7 ff ff       	call   1210be <z_reschedule>
  1218e9:	58                   	pop    %eax
  1218ea:	5a                   	pop    %edx
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
  1218eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1218ee:	5b                   	pop    %ebx
  1218ef:	5e                   	pop    %esi
  1218f0:	5d                   	pop    %ebp
  1218f1:	c3                   	ret    

001218f2 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  1218f2:	55                   	push   %ebp
  1218f3:	89 e5                	mov    %esp,%ebp
  1218f5:	56                   	push   %esi
  1218f6:	53                   	push   %ebx
  1218f7:	8b 75 08             	mov    0x8(%ebp),%esi
  1218fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  1218fd:	8b 55 10             	mov    0x10(%ebp),%edx
  121900:	9c                   	pushf  
  121901:	fa                   	cli    
  121902:	5b                   	pop    %ebx
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
  121903:	8b 4e 10             	mov    0x10(%esi),%ecx
  121906:	85 c9                	test   %ecx,%ecx
  121908:	74 08                	je     121912 <z_impl_k_sem_take+0x20>
		sem->count--;
  12190a:	49                   	dec    %ecx
		k_spin_unlock(&lock, key);
		ret = 0;
  12190b:	31 c0                	xor    %eax,%eax
		sem->count--;
  12190d:	89 4e 10             	mov    %ecx,0x10(%esi)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121910:	eb 0b                	jmp    12191d <z_impl_k_sem_take+0x2b>
		goto out;
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  121912:	89 d1                	mov    %edx,%ecx
  121914:	09 c1                	or     %eax,%ecx
  121916:	75 0e                	jne    121926 <z_impl_k_sem_take+0x34>
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
  121918:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  12191d:	0f ba e3 09          	bt     $0x9,%ebx
  121921:	73 14                	jae    121937 <z_impl_k_sem_take+0x45>
		__asm__ volatile ("sti" ::: "memory");
  121923:	fb                   	sti    
  121924:	eb 11                	jmp    121937 <z_impl_k_sem_take+0x45>
		goto out;
	}

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  121926:	52                   	push   %edx
  121927:	50                   	push   %eax
  121928:	56                   	push   %esi
  121929:	53                   	push   %ebx
  12192a:	68 86 ed 12 00       	push   $0x12ed86
  12192f:	e8 55 fd ff ff       	call   121689 <z_pend_curr>
  121934:	83 c4 14             	add    $0x14,%esp

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
  121937:	8d 65 f8             	lea    -0x8(%ebp),%esp
  12193a:	5b                   	pop    %ebx
  12193b:	5e                   	pop    %esi
  12193c:	5d                   	pop    %ebp
  12193d:	c3                   	ret    

0012193e <k_sys_work_q_init>:
K_KERNEL_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
  12193e:	55                   	push   %ebp
  12193f:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
  121941:	6a ff                	push   $0xffffffff
  121943:	68 00 04 00 00       	push   $0x400
  121948:	68 ec 53 14 00       	push   $0x1453ec
  12194d:	68 00 ea 12 00       	push   $0x12ea00
  121952:	e8 ef 04 00 00       	call   121e46 <k_work_q_start>
  121957:	83 c4 10             	add    $0x10,%esp
	return z_impl_k_thread_name_set(thread_id, value);
  12195a:	68 46 8a 12 00       	push   $0x128a46
  12195f:	68 24 ea 12 00       	push   $0x12ea24
  121964:	e8 c4 00 00 00       	call   121a2d <z_impl_k_thread_name_set>
  121969:	58                   	pop    %eax
		       K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
  12196a:	31 c0                	xor    %eax,%eax
  12196c:	5a                   	pop    %edx
  12196d:	c9                   	leave  
  12196e:	c3                   	ret    

0012196f <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	Z_STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
  12196f:	55                   	push   %ebp
  121970:	89 e5                	mov    %esp,%ebp
  121972:	56                   	push   %esi
  121973:	53                   	push   %ebx
  121974:	9c                   	pushf  
  121975:	fa                   	cli    
  121976:	5b                   	pop    %ebx
	 * modified by the user_cb either directly or indirectly.
	 * The indirect ways are through calling k_thread_create and
	 * k_thread_abort from user_cb.
	 */
	key = k_spin_lock(&z_thread_monitor_lock);
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
  121977:	8b 35 f8 e9 12 00    	mov    0x12e9f8,%esi
  12197d:	85 f6                	test   %esi,%esi
  12197f:	74 0e                	je     12198f <k_thread_foreach+0x20>
		user_cb(thread, user_data);
  121981:	ff 75 0c             	pushl  0xc(%ebp)
  121984:	56                   	push   %esi
  121985:	ff 55 08             	call   *0x8(%ebp)
  121988:	58                   	pop    %eax
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
  121989:	8b 76 58             	mov    0x58(%esi),%esi
		user_cb(thread, user_data);
  12198c:	5a                   	pop    %edx
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
  12198d:	eb ee                	jmp    12197d <k_thread_foreach+0xe>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12198f:	0f ba e3 09          	bt     $0x9,%ebx
  121993:	73 01                	jae    121996 <k_thread_foreach+0x27>
		__asm__ volatile ("sti" ::: "memory");
  121995:	fb                   	sti    
	}
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
  121996:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121999:	5b                   	pop    %ebx
  12199a:	5e                   	pop    %esi
  12199b:	5d                   	pop    %ebp
  12199c:	c3                   	ret    

0012199d <k_is_in_isr>:
	__asm__ volatile ("pushf; cli");
	ret = arch_curr_cpu()->nested != 0;
	__asm__ volatile ("popf");
	return ret;
#else
	return _kernel.cpus[0].nested != 0U;
  12199d:	83 3d c0 e9 12 00 00 	cmpl   $0x0,0x12e9c0
  1219a4:	0f 95 c0             	setne  %al
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
  1219a7:	c3                   	ret    

001219a8 <z_impl_k_busy_wait>:
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
}

#ifdef CONFIG_SYS_CLOCK_EXISTS
void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
  1219a8:	55                   	push   %ebp
  1219a9:	89 e5                	mov    %esp,%ebp
  1219ab:	56                   	push   %esi
  1219ac:	53                   	push   %ebx
  1219ad:	8b 75 08             	mov    0x8(%ebp),%esi
	if (usec_to_wait == 0) {
  1219b0:	85 f6                	test   %esi,%esi
  1219b2:	74 36                	je     1219ea <z_impl_k_busy_wait+0x42>
	return z_timer_cycle_get_32();
  1219b4:	e8 49 92 fe ff       	call   10ac02 <z_timer_cycle_get_32>
  1219b9:	89 c3                	mov    %eax,%ebx
	uint32_t start_cycles = k_cycle_get_32();

	/* use 64-bit math to prevent overflow when multiplying */
	uint32_t cycles_to_wait = (uint32_t)(
		(uint64_t)usec_to_wait *
		(uint64_t)sys_clock_hw_cycles_per_sec() /
  1219bb:	a1 44 5b 14 00       	mov    0x145b44,%eax
  1219c0:	6a 00                	push   $0x0
  1219c2:	89 c1                	mov    %eax,%ecx
  1219c4:	68 40 42 0f 00       	push   $0xf4240
  1219c9:	c1 f9 1f             	sar    $0x1f,%ecx
		(uint64_t)usec_to_wait *
  1219cc:	f7 e6                	mul    %esi
  1219ce:	0f af ce             	imul   %esi,%ecx
  1219d1:	01 ca                	add    %ecx,%edx
		(uint64_t)sys_clock_hw_cycles_per_sec() /
  1219d3:	52                   	push   %edx
  1219d4:	50                   	push   %eax
  1219d5:	e8 46 e8 fd ff       	call   100220 <__udivdi3>
  1219da:	83 c4 10             	add    $0x10,%esp
  1219dd:	89 c6                	mov    %eax,%esi
  1219df:	e8 1e 92 fe ff       	call   10ac02 <z_timer_cycle_get_32>

	for (;;) {
		uint32_t current_cycles = k_cycle_get_32();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
  1219e4:	29 d8                	sub    %ebx,%eax
  1219e6:	39 f0                	cmp    %esi,%eax
  1219e8:	72 f5                	jb     1219df <z_impl_k_busy_wait+0x37>
		}
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
}
  1219ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1219ed:	5b                   	pop    %ebx
  1219ee:	5e                   	pop    %esi
  1219ef:	5d                   	pop    %ebp
  1219f0:	c3                   	ret    

001219f1 <z_thread_monitor_exit>:
#if defined(CONFIG_THREAD_MONITOR)
/*
 * Remove a thread from the kernel's list of active threads.
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
  1219f1:	55                   	push   %ebp
  1219f2:	89 e5                	mov    %esp,%ebp
  1219f4:	53                   	push   %ebx
  1219f5:	8b 55 08             	mov    0x8(%ebp),%edx
  1219f8:	9c                   	pushf  
  1219f9:	fa                   	cli    
  1219fa:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
  1219fb:	a1 f8 e9 12 00       	mov    0x12e9f8,%eax
  121a00:	39 d0                	cmp    %edx,%eax
  121a02:	75 13                	jne    121a17 <z_thread_monitor_exit+0x26>
		_kernel.threads = _kernel.threads->next_thread;
  121a04:	8b 40 58             	mov    0x58(%eax),%eax
  121a07:	a3 f8 e9 12 00       	mov    %eax,0x12e9f8
  121a0c:	eb 15                	jmp    121a23 <z_thread_monitor_exit+0x32>
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while ((prev_thread != NULL) &&
			(thread != prev_thread->next_thread)) {
  121a0e:	8b 48 58             	mov    0x58(%eax),%ecx
		while ((prev_thread != NULL) &&
  121a11:	39 d1                	cmp    %edx,%ecx
  121a13:	74 08                	je     121a1d <z_thread_monitor_exit+0x2c>
  121a15:	89 c8                	mov    %ecx,%eax
  121a17:	85 c0                	test   %eax,%eax
  121a19:	75 f3                	jne    121a0e <z_thread_monitor_exit+0x1d>
  121a1b:	eb 06                	jmp    121a23 <z_thread_monitor_exit+0x32>
			prev_thread = prev_thread->next_thread;
		}
		if (prev_thread != NULL) {
			prev_thread->next_thread = thread->next_thread;
  121a1d:	8b 52 58             	mov    0x58(%edx),%edx
  121a20:	89 50 58             	mov    %edx,0x58(%eax)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121a23:	0f ba e3 09          	bt     $0x9,%ebx
  121a27:	73 01                	jae    121a2a <z_thread_monitor_exit+0x39>
		__asm__ volatile ("sti" ::: "memory");
  121a29:	fb                   	sti    
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
  121a2a:	5b                   	pop    %ebx
  121a2b:	5d                   	pop    %ebp
  121a2c:	c3                   	ret    

00121a2d <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  121a2d:	55                   	push   %ebp
  121a2e:	89 e5                	mov    %esp,%ebp
  121a30:	53                   	push   %ebx
  121a31:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
  121a34:	85 db                	test   %ebx,%ebx
  121a36:	75 06                	jne    121a3e <z_impl_k_thread_name_set+0x11>
		thread = _current;
  121a38:	8b 1d c8 e9 12 00    	mov    0x12e9c8,%ebx
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
  121a3e:	6a 20                	push   $0x20
  121a40:	8d 43 5c             	lea    0x5c(%ebx),%eax
  121a43:	ff 75 0c             	pushl  0xc(%ebp)
  121a46:	50                   	push   %eax
  121a47:	e8 59 a2 fe ff       	call   10bca5 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  121a4c:	c6 43 7b 00          	movb   $0x0,0x7b(%ebx)
	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
  121a50:	83 c4 0c             	add    $0xc,%esp
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(value);
	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
  121a53:	31 c0                	xor    %eax,%eax
  121a55:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  121a58:	c9                   	leave  
  121a59:	c3                   	ret    

00121a5a <k_thread_name_get>:
}
#include <syscalls/k_thread_name_set_mrsh.c>
#endif /* CONFIG_USERSPACE */

const char *k_thread_name_get(struct k_thread *thread)
{
  121a5a:	55                   	push   %ebp
  121a5b:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_THREAD_NAME
	return (const char *)thread->name;
  121a5d:	8b 45 08             	mov    0x8(%ebp),%eax
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
  121a60:	5d                   	pop    %ebp
	return (const char *)thread->name;
  121a61:	83 c0 5c             	add    $0x5c,%eax
}
  121a64:	c3                   	ret    

00121a65 <k_thread_state_str>:
	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}

const char *k_thread_state_str(k_tid_t thread_id)
{
  121a65:	55                   	push   %ebp
  121a66:	89 e5                	mov    %esp,%ebp
	switch (thread_id->base.thread_state) {
  121a68:	8b 45 08             	mov    0x8(%ebp),%eax
  121a6b:	0f b6 50 0d          	movzbl 0xd(%eax),%edx
  121a6f:	80 fa 10             	cmp    $0x10,%dl
  121a72:	77 0e                	ja     121a82 <k_thread_state_str+0x1d>
  121a74:	ff 24 95 d0 46 12 00 	jmp    *0x1246d0(,%edx,4)
  121a7b:	b8 6f 8a 12 00       	mov    $0x128a6f,%eax
  121a80:	eb 43                	jmp    121ac5 <k_thread_state_str+0x60>
		break;
	case _THREAD_SUSPENDED:
		return "suspended";
		break;
	case _THREAD_ABORTING:
		return "aborting";
  121a82:	b8 75 8a 12 00       	mov    $0x128a75,%eax
	switch (thread_id->base.thread_state) {
  121a87:	80 fa 20             	cmp    $0x20,%dl
  121a8a:	74 39                	je     121ac5 <k_thread_state_str+0x60>
		break;
	case _THREAD_QUEUED:
		return "queued";
		break;
	}
	return "unknown";
  121a8c:	b8 5a 89 12 00       	mov    $0x12895a,%eax
	switch (thread_id->base.thread_state) {
  121a91:	80 fa 80             	cmp    $0x80,%dl
  121a94:	75 2f                	jne    121ac5 <k_thread_state_str+0x60>
		return "queued";
  121a96:	b8 7e 8a 12 00       	mov    $0x128a7e,%eax
  121a9b:	eb 28                	jmp    121ac5 <k_thread_state_str+0x60>
		return "pending";
  121a9d:	b8 4f 8a 12 00       	mov    $0x128a4f,%eax
  121aa2:	eb 21                	jmp    121ac5 <k_thread_state_str+0x60>
		return "prestart";
  121aa4:	b8 57 8a 12 00       	mov    $0x128a57,%eax
  121aa9:	eb 1a                	jmp    121ac5 <k_thread_state_str+0x60>
		return "dead";
  121aab:	b8 60 8a 12 00       	mov    $0x128a60,%eax
  121ab0:	eb 13                	jmp    121ac5 <k_thread_state_str+0x60>
		return "suspended";
  121ab2:	b8 65 8a 12 00       	mov    $0x128a65,%eax
  121ab7:	eb 0c                	jmp    121ac5 <k_thread_state_str+0x60>
	return "unknown";
  121ab9:	b8 5a 89 12 00       	mov    $0x12895a,%eax
  121abe:	eb 05                	jmp    121ac5 <k_thread_state_str+0x60>
		return "";
  121ac0:	b8 02 4e 12 00       	mov    $0x124e02,%eax
}
  121ac5:	5d                   	pop    %ebp
  121ac6:	c3                   	ret    

00121ac7 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
  121ac7:	55                   	push   %ebp
  121ac8:	b9 04 00 00 00       	mov    $0x4,%ecx
  121acd:	89 e5                	mov    %esp,%ebp
  121acf:	57                   	push   %edi
  121ad0:	56                   	push   %esi
  121ad1:	53                   	push   %ebx
  121ad2:	50                   	push   %eax
  121ad3:	31 c0                	xor    %eax,%eax
  121ad5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121ad8:	8b 75 0c             	mov    0xc(%ebp),%esi
  121adb:	8d 7b 2c             	lea    0x2c(%ebx),%edi
  121ade:	f3 ab                	rep stos %eax,%es:(%edi)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  121ae0:	8b 45 28             	mov    0x28(%ebp),%eax
  121ae3:	c7 43 30 c4 0f 12 00 	movl   $0x120fc4,0x30(%ebx)
  121aea:	88 43 0c             	mov    %al,0xc(%ebx)
	thread_base->thread_state = (uint8_t)initial_state;

	thread_base->prio = priority;
  121aed:	8b 45 24             	mov    0x24(%ebp),%eax
  121af0:	88 43 0e             	mov    %al,0xe(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  121af3:	8b 45 10             	mov    0x10(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
  121af6:	c6 43 0d 04          	movb   $0x4,0xd(%ebx)

	thread_base->sched_locked = 0U;
  121afa:	c6 43 0f 00          	movb   $0x0,0xf(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  121afe:	8d 48 03             	lea    0x3(%eax),%ecx
	node->next = NULL;
  121b01:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
  121b08:	83 e1 fc             	and    $0xfffffffc,%ecx
	node->prev = NULL;
  121b0b:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	memset(stack_buf_start, 0xaa, stack_buf_size);
  121b12:	51                   	push   %ecx
  121b13:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  121b16:	68 aa 00 00 00       	push   $0xaa
	stack_ptr = (char *)stack + stack_obj_size;
  121b1b:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
	memset(stack_buf_start, 0xaa, stack_buf_size);
  121b1e:	56                   	push   %esi
  121b1f:	e8 37 a3 fe ff       	call   10be5b <memset>
  121b24:	83 c4 0c             	add    $0xc,%esp
	new_thread->stack_info.size = stack_buf_size;
  121b27:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
  121b2a:	89 b3 80 00 00 00    	mov    %esi,0x80(%ebx)
	new_thread->stack_info.size = stack_buf_size;
  121b30:	89 8b 84 00 00 00    	mov    %ecx,0x84(%ebx)
	new_thread->stack_info.delta = delta;
  121b36:	c7 83 88 00 00 00 00 	movl   $0x0,0x88(%ebx)
  121b3d:	00 00 00 
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  121b40:	ff 75 20             	pushl  0x20(%ebp)
  121b43:	ff 75 1c             	pushl  0x1c(%ebp)
  121b46:	ff 75 18             	pushl  0x18(%ebp)
  121b49:	ff 75 14             	pushl  0x14(%ebp)
  121b4c:	57                   	push   %edi
  121b4d:	56                   	push   %esi
  121b4e:	53                   	push   %ebx
  121b4f:	e8 cf 9c fe ff       	call   10b823 <arch_new_thread>
	new_thread->entry.pEntry = entry;
  121b54:	8b 45 14             	mov    0x14(%ebp),%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  121b57:	83 c4 1c             	add    $0x1c,%esp
	new_thread->entry.pEntry = entry;
  121b5a:	89 43 48             	mov    %eax,0x48(%ebx)
	new_thread->entry.parameter1 = p1;
  121b5d:	8b 45 18             	mov    0x18(%ebp),%eax
  121b60:	89 43 4c             	mov    %eax,0x4c(%ebx)
	new_thread->entry.parameter2 = p2;
  121b63:	8b 45 1c             	mov    0x1c(%ebp),%eax
  121b66:	89 43 50             	mov    %eax,0x50(%ebx)
	new_thread->entry.parameter3 = p3;
  121b69:	8b 45 20             	mov    0x20(%ebp),%eax
	new_thread->init_data = NULL;
  121b6c:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
	new_thread->fn_abort = NULL;
  121b73:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
	new_thread->entry.parameter3 = p3;
  121b7a:	89 43 54             	mov    %eax,0x54(%ebx)
  121b7d:	9c                   	pushf  
  121b7e:	fa                   	cli    
  121b7f:	58                   	pop    %eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121b80:	0f ba e0 09          	bt     $0x9,%eax
	new_thread->next_thread = _kernel.threads;
  121b84:	8b 15 f8 e9 12 00    	mov    0x12e9f8,%edx
  121b8a:	89 53 58             	mov    %edx,0x58(%ebx)
	_kernel.threads = new_thread;
  121b8d:	89 1d f8 e9 12 00    	mov    %ebx,0x12e9f8
  121b93:	73 01                	jae    121b96 <z_setup_new_thread+0xcf>
		__asm__ volatile ("sti" ::: "memory");
  121b95:	fb                   	sti    
	if (name != NULL) {
  121b96:	83 7d 2c 00          	cmpl   $0x0,0x2c(%ebp)
  121b9a:	74 17                	je     121bb3 <z_setup_new_thread+0xec>
		strncpy(new_thread->name, name,
  121b9c:	6a 1f                	push   $0x1f
  121b9e:	8d 43 5c             	lea    0x5c(%ebx),%eax
  121ba1:	ff 75 2c             	pushl  0x2c(%ebp)
  121ba4:	50                   	push   %eax
  121ba5:	e8 fb a0 fe ff       	call   10bca5 <strncpy>
  121baa:	83 c4 0c             	add    $0xc,%esp
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  121bad:	c6 43 7b 00          	movb   $0x0,0x7b(%ebx)
  121bb1:	eb 04                	jmp    121bb7 <z_setup_new_thread+0xf0>
		new_thread->name[0] = '\0';
  121bb3:	c6 43 5c 00          	movb   $0x0,0x5c(%ebx)
	if (!_current) {
  121bb7:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  121bbc:	85 c0                	test   %eax,%eax
  121bbe:	74 06                	je     121bc6 <z_setup_new_thread+0xff>
	new_thread->resource_pool = _current->resource_pool;
  121bc0:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
	return stack_ptr;
  121bc6:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
}
  121bcc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121bcf:	89 f8                	mov    %edi,%eax
  121bd1:	5b                   	pop    %ebx
  121bd2:	5e                   	pop    %esi
  121bd3:	5f                   	pop    %edi
  121bd4:	5d                   	pop    %ebp
  121bd5:	c3                   	ret    

00121bd6 <z_impl_k_thread_create>:
{
  121bd6:	55                   	push   %ebp
  121bd7:	89 e5                	mov    %esp,%ebp
  121bd9:	57                   	push   %edi
  121bda:	56                   	push   %esi
  121bdb:	53                   	push   %ebx
  121bdc:	8b 75 08             	mov    0x8(%ebp),%esi
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  121bdf:	6a 00                	push   $0x0
{
  121be1:	8b 5d 30             	mov    0x30(%ebp),%ebx
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  121be4:	ff 75 28             	pushl  0x28(%ebp)
  121be7:	ff 75 24             	pushl  0x24(%ebp)
  121bea:	ff 75 20             	pushl  0x20(%ebp)
  121bed:	ff 75 1c             	pushl  0x1c(%ebp)
  121bf0:	ff 75 18             	pushl  0x18(%ebp)
  121bf3:	ff 75 14             	pushl  0x14(%ebp)
  121bf6:	ff 75 10             	pushl  0x10(%ebp)
  121bf9:	ff 75 0c             	pushl  0xc(%ebp)
{
  121bfc:	8b 7d 2c             	mov    0x2c(%ebp),%edi
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  121bff:	56                   	push   %esi
  121c00:	e8 c2 fe ff ff       	call   121ac7 <z_setup_new_thread>
  121c05:	83 c4 28             	add    $0x28,%esp
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  121c08:	89 d8                	mov    %ebx,%eax
  121c0a:	89 fa                	mov    %edi,%edx
  121c0c:	43                   	inc    %ebx
  121c0d:	75 05                	jne    121c14 <z_impl_k_thread_create+0x3e>
  121c0f:	83 ff ff             	cmp    $0xffffffff,%edi
  121c12:	74 22                	je     121c36 <z_impl_k_thread_create+0x60>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  121c14:	89 c3                	mov    %eax,%ebx
  121c16:	09 d3                	or     %edx,%ebx
  121c18:	75 09                	jne    121c23 <z_impl_k_thread_create+0x4d>
	z_sched_start(thread);
  121c1a:	56                   	push   %esi
  121c1b:	e8 e4 f6 ff ff       	call   121304 <z_sched_start>
  121c20:	58                   	pop    %eax
}
  121c21:	eb 13                	jmp    121c36 <z_impl_k_thread_create+0x60>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
  121c23:	50                   	push   %eax
  121c24:	8d 46 18             	lea    0x18(%esi),%eax
  121c27:	52                   	push   %edx
  121c28:	68 3d 13 12 00       	push   $0x12133d
  121c2d:	50                   	push   %eax
  121c2e:	e8 4c 04 00 00       	call   12207f <z_add_timeout>
  121c33:	83 c4 10             	add    $0x10,%esp
}
  121c36:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121c39:	89 f0                	mov    %esi,%eax
  121c3b:	5b                   	pop    %ebx
  121c3c:	5e                   	pop    %esi
  121c3d:	5f                   	pop    %edi
  121c3e:	5d                   	pop    %ebp
  121c3f:	c3                   	ret    

00121c40 <z_init_static_threads>:
{
  121c40:	55                   	push   %ebp
  121c41:	89 e5                	mov    %esp,%ebp
  121c43:	56                   	push   %esi
  121c44:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
  121c45:	bb 30 5c 14 00       	mov    $0x145c30,%ebx
  121c4a:	81 fb 60 5c 14 00    	cmp    $0x145c60,%ebx
  121c50:	73 2f                	jae    121c81 <z_init_static_threads+0x41>
		z_setup_new_thread(
  121c52:	ff 73 2c             	pushl  0x2c(%ebx)
  121c55:	ff 73 20             	pushl  0x20(%ebx)
  121c58:	ff 73 1c             	pushl  0x1c(%ebx)
  121c5b:	ff 73 18             	pushl  0x18(%ebx)
  121c5e:	ff 73 14             	pushl  0x14(%ebx)
  121c61:	ff 73 10             	pushl  0x10(%ebx)
  121c64:	ff 73 0c             	pushl  0xc(%ebx)
  121c67:	ff 73 08             	pushl  0x8(%ebx)
  121c6a:	ff 73 04             	pushl  0x4(%ebx)
  121c6d:	ff 33                	pushl  (%ebx)
  121c6f:	e8 53 fe ff ff       	call   121ac7 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  121c74:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
  121c76:	83 c4 28             	add    $0x28,%esp
		thread_data->init_thread->init_data = thread_data;
  121c79:	89 58 40             	mov    %ebx,0x40(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
  121c7c:	83 c3 30             	add    $0x30,%ebx
  121c7f:	eb c9                	jmp    121c4a <z_init_static_threads+0xa>
	k_sched_lock();
  121c81:	e8 92 f4 ff ff       	call   121118 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
  121c86:	bb 30 5c 14 00       	mov    $0x145c30,%ebx
  121c8b:	81 fb 60 5c 14 00    	cmp    $0x145c60,%ebx
  121c91:	73 4f                	jae    121ce2 <z_init_static_threads+0xa2>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  121c93:	8b 43 24             	mov    0x24(%ebx),%eax
  121c96:	83 f8 ff             	cmp    $0xffffffff,%eax
  121c99:	74 42                	je     121cdd <z_init_static_threads+0x9d>
					    K_MSEC(thread_data->init_delay));
  121c9b:	85 c0                	test   %eax,%eax
  121c9d:	79 02                	jns    121ca1 <z_init_static_threads+0x61>
  121c9f:	31 c0                	xor    %eax,%eax
  121ca1:	99                   	cltd   
		t += off;
  121ca2:	83 c0 09             	add    $0x9,%eax
			schedule_new_thread(thread_data->init_thread,
  121ca5:	8b 33                	mov    (%ebx),%esi
  121ca7:	83 d2 00             	adc    $0x0,%edx
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  121caa:	89 c1                	mov    %eax,%ecx
  121cac:	83 f1 09             	xor    $0x9,%ecx
  121caf:	09 d1                	or     %edx,%ecx
  121cb1:	75 09                	jne    121cbc <z_init_static_threads+0x7c>
	z_sched_start(thread);
  121cb3:	56                   	push   %esi
  121cb4:	e8 4b f6 ff ff       	call   121304 <z_sched_start>
  121cb9:	58                   	pop    %eax
  121cba:	eb 21                	jmp    121cdd <z_init_static_threads+0x9d>
			return t / (from_hz / to_hz);
  121cbc:	6a 00                	push   $0x0
  121cbe:	83 c6 18             	add    $0x18,%esi
  121cc1:	6a 0a                	push   $0xa
  121cc3:	52                   	push   %edx
  121cc4:	50                   	push   %eax
  121cc5:	e8 56 e5 fd ff       	call   100220 <__udivdi3>
  121cca:	83 c4 10             	add    $0x10,%esp
  121ccd:	52                   	push   %edx
  121cce:	50                   	push   %eax
  121ccf:	68 3d 13 12 00       	push   $0x12133d
  121cd4:	56                   	push   %esi
  121cd5:	e8 a5 03 00 00       	call   12207f <z_add_timeout>
  121cda:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
  121cdd:	83 c3 30             	add    $0x30,%ebx
  121ce0:	eb a9                	jmp    121c8b <z_init_static_threads+0x4b>
}
  121ce2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121ce5:	5b                   	pop    %ebx
  121ce6:	5e                   	pop    %esi
  121ce7:	5d                   	pop    %ebp
	k_sched_unlock();
  121ce8:	e9 a2 f5 ff ff       	jmp    12128f <k_sched_unlock>

00121ced <z_impl_k_thread_stack_space_get>:
#error "Unsupported configuration for stack analysis"
#endif

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
  121ced:	55                   	push   %ebp
  121cee:	89 e5                	mov    %esp,%ebp
  121cf0:	8b 45 08             	mov    0x8(%ebp),%eax
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
  121cf3:	8b 88 80 00 00 00    	mov    0x80(%eax),%ecx
	size_t size = thread->stack_info.size;
  121cf9:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
	size_t unused = 0;
  121cff:	31 c0                	xor    %eax,%eax
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
  121d01:	39 d0                	cmp    %edx,%eax
  121d03:	74 09                	je     121d0e <z_impl_k_thread_stack_space_get+0x21>
		if ((checked_stack[i]) == 0xaaU) {
  121d05:	80 3c 01 aa          	cmpb   $0xaa,(%ecx,%eax,1)
  121d09:	75 03                	jne    121d0e <z_impl_k_thread_stack_space_get+0x21>
			unused++;
  121d0b:	40                   	inc    %eax
	for (size_t i = 0; i < size; i++) {
  121d0c:	eb f3                	jmp    121d01 <z_impl_k_thread_stack_space_get+0x14>
		} else {
			break;
		}
	}

	*unused_ptr = unused;
  121d0e:	8b 55 0c             	mov    0xc(%ebp),%edx
  121d11:	89 02                	mov    %eax,(%edx)

	return 0;
}
  121d13:	31 c0                	xor    %eax,%eax
  121d15:	5d                   	pop    %ebp
  121d16:	c3                   	ret    

00121d17 <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os);

FUNC_NORETURN void z_self_abort(void)
{
  121d17:	55                   	push   %ebp
  121d18:	89 e5                	mov    %esp,%ebp
  121d1a:	53                   	push   %ebx
  121d1b:	9c                   	pushf  
  121d1c:	fa                   	cli    
  121d1d:	5b                   	pop    %ebx
	 * while we set this up
	 */
	key = arch_irq_lock();
	cpu = _current_cpu;
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
	cpu->pending_abort = _current;
  121d1e:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  121d23:	a3 d0 e9 12 00       	mov    %eax,0x12e9d0
	z_impl_k_thread_suspend(thread);
  121d28:	50                   	push   %eax
  121d29:	e8 ee f6 ff ff       	call   12141c <z_impl_k_thread_suspend>
  121d2e:	89 1c 24             	mov    %ebx,(%esp)
  121d31:	e8 bb 9a fe ff       	call   10b7f1 <arch_swap>
  121d36:	58                   	pop    %eax

00121d37 <z_impl_k_thread_abort>:
	CODE_UNREACHABLE;
}

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  121d37:	55                   	push   %ebp
  121d38:	89 e5                	mov    %esp,%ebp
  121d3a:	8b 45 08             	mov    0x8(%ebp),%eax
	if (thread == _current && !arch_is_in_isr()) {
  121d3d:	39 05 c8 e9 12 00    	cmp    %eax,0x12e9c8
  121d43:	75 0e                	jne    121d53 <z_impl_k_thread_abort+0x1c>
  121d45:	83 3d c0 e9 12 00 00 	cmpl   $0x0,0x12e9c0
  121d4c:	75 05                	jne    121d53 <z_impl_k_thread_abort+0x1c>
		/* Thread is self-exiting, idle thread on this CPU will do
		 * the cleanup
		 */
		z_self_abort();
  121d4e:	e8 c4 ff ff ff       	call   121d17 <z_self_abort>
	}

	z_thread_single_abort(thread);
  121d53:	50                   	push   %eax
  121d54:	e8 24 f7 ff ff       	call   12147d <z_thread_single_abort>

	if (!arch_is_in_isr()) {
  121d59:	83 3d c0 e9 12 00 00 	cmpl   $0x0,0x12e9c0
	z_thread_single_abort(thread);
  121d60:	58                   	pop    %eax
	if (!arch_is_in_isr()) {
  121d61:	75 0c                	jne    121d6f <z_impl_k_thread_abort+0x38>
  121d63:	9c                   	pushf  
  121d64:	fa                   	cli    
  121d65:	58                   	pop    %eax
	(void) z_reschedule_irqlock(arch_irq_lock());
  121d66:	89 45 08             	mov    %eax,0x8(%ebp)
		/* Don't need to do this if we're in an ISR */
		z_reschedule_unlocked();
	}
}
  121d69:	c9                   	leave  
  121d6a:	e9 7e f3 ff ff       	jmp    1210ed <z_reschedule_irqlock>
  121d6f:	c9                   	leave  
  121d70:	c3                   	ret    

00121d71 <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
  121d71:	b8 00 63 04 02       	mov    $0x2046300,%eax
  121d76:	c3                   	ret    

00121d77 <k_work_submit_to_queue>:
{
  121d77:	55                   	push   %ebp
  121d78:	89 c1                	mov    %eax,%ecx
  121d7a:	89 e5                	mov    %esp,%ebp
  121d7c:	56                   	push   %esi
  121d7d:	53                   	push   %ebx
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
  121d7e:	8b 42 08             	mov    0x8(%edx),%eax
  121d81:	89 c6                	mov    %eax,%esi
  121d83:	89 c3                	mov    %eax,%ebx
  121d85:	83 ce 01             	or     $0x1,%esi
  121d88:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
  121d8d:	75 f2                	jne    121d81 <k_work_submit_to_queue+0xa>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
  121d8f:	80 e3 01             	and    $0x1,%bl
  121d92:	75 09                	jne    121d9d <k_work_submit_to_queue+0x26>
		k_queue_append(&work_q->queue, work);
  121d94:	52                   	push   %edx
  121d95:	51                   	push   %ecx
  121d96:	e8 7e f1 ff ff       	call   120f19 <k_queue_append>
  121d9b:	58                   	pop    %eax
  121d9c:	5a                   	pop    %edx
}
  121d9d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121da0:	5b                   	pop    %ebx
  121da1:	5e                   	pop    %esi
  121da2:	5d                   	pop    %ebp
  121da3:	c3                   	ret    

00121da4 <work_timeout>:
	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}

#ifdef CONFIG_SYS_CLOCK_EXISTS
static void work_timeout(struct _timeout *t)
{
  121da4:	55                   	push   %ebp
  121da5:	89 e5                	mov    %esp,%ebp
  121da7:	8b 45 08             	mov    0x8(%ebp),%eax
	struct k_delayed_work *w = CONTAINER_OF(t, struct k_delayed_work,
						   timeout);

	/* submit work to workqueue */
	k_work_submit_to_queue(w->work_q, &w->work);
}
  121daa:	5d                   	pop    %ebp
	k_work_submit_to_queue(w->work_q, &w->work);
  121dab:	8d 50 f4             	lea    -0xc(%eax),%edx
  121dae:	8b 40 14             	mov    0x14(%eax),%eax
  121db1:	e9 c1 ff ff ff       	jmp    121d77 <k_work_submit_to_queue>

00121db6 <work_cancel>:
	z_init_timeout(&work->timeout);
	work->work_q = NULL;
}

static int work_cancel(struct k_delayed_work *work)
{
  121db6:	55                   	push   %ebp
  121db7:	89 e5                	mov    %esp,%ebp
  121db9:	57                   	push   %edi
  121dba:	56                   	push   %esi
  121dbb:	53                   	push   %ebx
  121dbc:	89 c3                	mov    %eax,%ebx
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
  121dbe:	83 c0 08             	add    $0x8,%eax
  121dc1:	51                   	push   %ecx
  121dc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
  121dc5:	8b 43 08             	mov    0x8(%ebx),%eax
	if (k_work_pending(&work->work)) {
  121dc8:	a8 01                	test   $0x1,%al
  121dca:	74 4d                	je     121e19 <work_cancel+0x63>
		/* Remove from the queue if already submitted */
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
  121dcc:	8b 43 20             	mov    0x20(%ebx),%eax
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
  121dcf:	31 d2                	xor    %edx,%edx
  121dd1:	8b 08                	mov    (%eax),%ecx
  121dd3:	85 c9                	test   %ecx,%ecx
  121dd5:	74 3b                	je     121e12 <work_cancel+0x5c>
  121dd7:	39 cb                	cmp    %ecx,%ebx
  121dd9:	75 2c                	jne    121e07 <work_cancel+0x51>
Z_GENLIST_REMOVE(sflist, sfnode)
  121ddb:	8b 0b                	mov    (%ebx),%ecx
  121ddd:	8b 78 04             	mov    0x4(%eax),%edi
  121de0:	83 e1 fc             	and    $0xfffffffc,%ecx
  121de3:	85 d2                	test   %edx,%edx
  121de5:	75 0b                	jne    121df2 <work_cancel+0x3c>
	list->head = node;
  121de7:	89 08                	mov    %ecx,(%eax)
Z_GENLIST_REMOVE(sflist, sfnode)
  121de9:	39 fb                	cmp    %edi,%ebx
  121deb:	75 15                	jne    121e02 <work_cancel+0x4c>
	list->tail = node;
  121ded:	89 48 04             	mov    %ecx,0x4(%eax)
}
  121df0:	eb 10                	jmp    121e02 <work_cancel+0x4c>
	parent->next_and_flags = cur_flags | (unative_t)child;
  121df2:	8b 32                	mov    (%edx),%esi
  121df4:	83 e6 03             	and    $0x3,%esi
  121df7:	09 f1                	or     %esi,%ecx
Z_GENLIST_REMOVE(sflist, sfnode)
  121df9:	39 fb                	cmp    %edi,%ebx
	parent->next_and_flags = cur_flags | (unative_t)child;
  121dfb:	89 0a                	mov    %ecx,(%edx)
Z_GENLIST_REMOVE(sflist, sfnode)
  121dfd:	75 03                	jne    121e02 <work_cancel+0x4c>
	list->tail = node;
  121dff:	89 50 04             	mov    %edx,0x4(%eax)
	parent->next_and_flags = cur_flags | (unative_t)child;
  121e02:	83 23 03             	andl   $0x3,(%ebx)
  121e05:	eb 27                	jmp    121e2e <work_cancel+0x78>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  121e07:	8b 39                	mov    (%ecx),%edi
  121e09:	89 ca                	mov    %ecx,%edx
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
  121e0b:	83 e7 fc             	and    $0xfffffffc,%edi
  121e0e:	89 f9                	mov    %edi,%ecx
  121e10:	eb c1                	jmp    121dd3 <work_cancel+0x1d>
			return -EINVAL;
  121e12:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  121e17:	eb 25                	jmp    121e3e <work_cancel+0x88>
		}
	} else {
		int err = z_abort_timeout(&work->timeout);
  121e19:	8d 43 0c             	lea    0xc(%ebx),%eax
  121e1c:	50                   	push   %eax
  121e1d:	e8 ab 03 00 00       	call   1221cd <z_abort_timeout>
  121e22:	5a                   	pop    %edx
  121e23:	89 c2                	mov    %eax,%edx

		if (err) {
  121e25:	85 d2                	test   %edx,%edx
			return -EALREADY;
  121e27:	b8 bb ff ff ff       	mov    $0xffffffbb,%eax
		if (err) {
  121e2c:	75 10                	jne    121e3e <work_cancel+0x88>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
  121e2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
		}
	}

	/* Detach from workqueue */
	work->work_q = NULL;
  121e31:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  121e38:	f0 83 20 fe          	lock andl $0xfffffffe,(%eax)

	atomic_clear_bit(work->work.flags, K_WORK_STATE_PENDING);

	return 0;
  121e3c:	31 c0                	xor    %eax,%eax
}
  121e3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121e41:	5b                   	pop    %ebx
  121e42:	5e                   	pop    %esi
  121e43:	5f                   	pop    %edi
  121e44:	5d                   	pop    %ebp
  121e45:	c3                   	ret    

00121e46 <k_work_q_start>:
{
  121e46:	55                   	push   %ebp
  121e47:	89 e5                	mov    %esp,%ebp
  121e49:	57                   	push   %edi
  121e4a:	56                   	push   %esi
  121e4b:	53                   	push   %ebx
  121e4c:	83 ec 08             	sub    $0x8,%esp
  121e4f:	8b 45 10             	mov    0x10(%ebp),%eax
  121e52:	8b 55 14             	mov    0x14(%ebp),%edx
  121e55:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121e58:	8b 7d 0c             	mov    0xc(%ebp),%edi
  121e5b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  121e5e:	89 55 f0             	mov    %edx,-0x10(%ebp)
	z_impl_k_queue_init(queue);
  121e61:	53                   	push   %ebx
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
  121e62:	8d 73 24             	lea    0x24(%ebx),%esi
  121e65:	e8 26 f0 ff ff       	call   120e90 <z_impl_k_queue_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  121e6a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  121e71:	6a 00                	push   $0x0
  121e73:	6a 00                	push   $0x0
  121e75:	8b 55 f0             	mov    -0x10(%ebp),%edx
  121e78:	52                   	push   %edx
  121e79:	8b 45 ec             	mov    -0x14(%ebp),%eax
  121e7c:	6a 00                	push   $0x0
  121e7e:	6a 00                	push   $0x0
  121e80:	53                   	push   %ebx
  121e81:	68 e5 19 10 00       	push   $0x1019e5
  121e86:	50                   	push   %eax
  121e87:	57                   	push   %edi
  121e88:	56                   	push   %esi
  121e89:	e8 48 fd ff ff       	call   121bd6 <z_impl_k_thread_create>
  121e8e:	83 c4 2c             	add    $0x2c,%esp
	return z_impl_k_thread_name_set(thread_id, value);
  121e91:	89 75 08             	mov    %esi,0x8(%ebp)
  121e94:	c7 45 0c 85 8a 12 00 	movl   $0x128a85,0xc(%ebp)
}
  121e9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  121e9e:	5b                   	pop    %ebx
  121e9f:	5e                   	pop    %esi
  121ea0:	5f                   	pop    %edi
  121ea1:	5d                   	pop    %ebp
  121ea2:	e9 86 fb ff ff       	jmp    121a2d <z_impl_k_thread_name_set>

00121ea7 <k_delayed_work_init>:
{
  121ea7:	55                   	push   %ebp
  121ea8:	89 e5                	mov    %esp,%ebp
  121eaa:	8b 45 08             	mov    0x8(%ebp),%eax
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  121ead:	8b 55 0c             	mov    0xc(%ebp),%edx
  121eb0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  121eb6:	89 50 04             	mov    %edx,0x4(%eax)
  121eb9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	node->next = NULL;
  121ec0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	node->prev = NULL;
  121ec7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	work->work_q = NULL;
  121ece:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
  121ed5:	5d                   	pop    %ebp
  121ed6:	c3                   	ret    

00121ed7 <k_delayed_work_submit_to_queue>:

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
  121ed7:	55                   	push   %ebp
  121ed8:	89 e5                	mov    %esp,%ebp
  121eda:	56                   	push   %esi
  121edb:	53                   	push   %ebx
  121edc:	50                   	push   %eax
  121edd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  121ee0:	8b 55 0c             	mov    0xc(%ebp),%edx
  121ee3:	9c                   	pushf  
  121ee4:	fa                   	cli    
  121ee5:	5e                   	pop    %esi
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
  121ee6:	8b 4a 20             	mov    0x20(%edx),%ecx
  121ee9:	85 c9                	test   %ecx,%ecx
  121eeb:	74 0b                	je     121ef8 <k_delayed_work_submit_to_queue+0x21>
		err = -EADDRINUSE;
  121eed:	b8 d0 ff ff ff       	mov    $0xffffffd0,%eax
	if (work->work_q != NULL && work->work_q != work_q) {
  121ef2:	39 d9                	cmp    %ebx,%ecx
  121ef4:	75 5a                	jne    121f50 <k_delayed_work_submit_to_queue+0x79>
  121ef6:	eb 08                	jmp    121f00 <k_delayed_work_submit_to_queue+0x29>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
  121ef8:	85 db                	test   %ebx,%ebx
  121efa:	74 04                	je     121f00 <k_delayed_work_submit_to_queue+0x29>
	int err = 0;
  121efc:	31 c0                	xor    %eax,%eax
  121efe:	eb 16                	jmp    121f16 <k_delayed_work_submit_to_queue+0x3f>
		err = work_cancel(work);
  121f00:	89 d0                	mov    %edx,%eax
  121f02:	89 55 0c             	mov    %edx,0xc(%ebp)
  121f05:	e8 ac fe ff ff       	call   121db6 <work_cancel>
		/* -EALREADY may indicate the work has already completed so
		 * this is likely a recurring work.  It may also indicate that
		 * the work handler is still executing.  But it's neither
		 * delayed nor pending, so it can be rescheduled.
		 */
		if (err == -EALREADY) {
  121f0a:	8b 55 0c             	mov    0xc(%ebp),%edx
  121f0d:	83 f8 bb             	cmp    $0xffffffbb,%eax
  121f10:	74 ea                	je     121efc <k_delayed_work_submit_to_queue+0x25>
			err = 0;
		} else if (err < 0) {
  121f12:	85 c0                	test   %eax,%eax
  121f14:	78 3a                	js     121f50 <k_delayed_work_submit_to_queue+0x79>
	work->work_q = work_q;

	/* Submit work directly if no delay.  Note that this is a
	 * blocking operation, so release the lock first.
	 */
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  121f16:	8b 4d 14             	mov    0x14(%ebp),%ecx
	work->work_q = work_q;
  121f19:	89 5a 20             	mov    %ebx,0x20(%edx)
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  121f1c:	0b 4d 10             	or     0x10(%ebp),%ecx
  121f1f:	75 12                	jne    121f33 <k_delayed_work_submit_to_queue+0x5c>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121f21:	0f ba e6 09          	bt     $0x9,%esi
  121f25:	73 01                	jae    121f28 <k_delayed_work_submit_to_queue+0x51>
		__asm__ volatile ("sti" ::: "memory");
  121f27:	fb                   	sti    
		k_spin_unlock(&lock, key);
		k_work_submit_to_queue(work_q, &work->work);
  121f28:	89 d8                	mov    %ebx,%eax
  121f2a:	e8 48 fe ff ff       	call   121d77 <k_work_submit_to_queue>
		return 0;
  121f2f:	31 c0                	xor    %eax,%eax
  121f31:	eb 24                	jmp    121f57 <k_delayed_work_submit_to_queue+0x80>
#ifdef CONFIG_LEGACY_TIMEOUT_API
	delay = _TICK_ALIGN + k_ms_to_ticks_ceil32(delay);
#endif

	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);
  121f33:	ff 75 14             	pushl  0x14(%ebp)
  121f36:	ff 75 10             	pushl  0x10(%ebp)
  121f39:	83 c2 0c             	add    $0xc,%edx
  121f3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  121f3f:	68 a4 1d 12 00       	push   $0x121da4
  121f44:	52                   	push   %edx
  121f45:	e8 35 01 00 00       	call   12207f <z_add_timeout>
  121f4a:	83 c4 10             	add    $0x10,%esp
  121f4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121f50:	0f ba e6 09          	bt     $0x9,%esi
  121f54:	73 01                	jae    121f57 <k_delayed_work_submit_to_queue+0x80>
		__asm__ volatile ("sti" ::: "memory");
  121f56:	fb                   	sti    

done:
	k_spin_unlock(&lock, key);
	return err;
}
  121f57:	8d 65 f8             	lea    -0x8(%ebp),%esp
  121f5a:	5b                   	pop    %ebx
  121f5b:	5e                   	pop    %esi
  121f5c:	5d                   	pop    %ebp
  121f5d:	c3                   	ret    

00121f5e <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
  121f5e:	55                   	push   %ebp
  121f5f:	89 e5                	mov    %esp,%ebp
  121f61:	53                   	push   %ebx
  121f62:	8b 55 08             	mov    0x8(%ebp),%edx
  121f65:	9c                   	pushf  
  121f66:	fa                   	cli    
  121f67:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = -EINVAL;

	if (work->work_q != NULL) {
  121f68:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  121f6d:	83 7a 20 00          	cmpl   $0x0,0x20(%edx)
  121f71:	74 07                	je     121f7a <k_delayed_work_cancel+0x1c>
		ret = work_cancel(work);
  121f73:	89 d0                	mov    %edx,%eax
  121f75:	e8 3c fe ff ff       	call   121db6 <work_cancel>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  121f7a:	0f ba e3 09          	bt     $0x9,%ebx
  121f7e:	73 01                	jae    121f81 <k_delayed_work_cancel+0x23>
		__asm__ volatile ("sti" ::: "memory");
  121f80:	fb                   	sti    
	}

	k_spin_unlock(&lock, key);
	return ret;
}
  121f81:	5b                   	pop    %ebx
  121f82:	5d                   	pop    %ebp
  121f83:	c3                   	ret    

00121f84 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
  121f84:	83 3d 6c ed 12 00 00 	cmpl   $0x0,0x12ed6c
  121f8b:	75 05                	jne    121f92 <elapsed+0xe>
  121f8d:	e9 4c 8c fe ff       	jmp    10abde <z_clock_elapsed>
}
  121f92:	31 c0                	xor    %eax,%eax
  121f94:	c3                   	ret    

00121f95 <remove_timeout>:
{
  121f95:	55                   	push   %ebp
  121f96:	8b 10                	mov    (%eax),%edx
  121f98:	89 e5                	mov    %esp,%ebp
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  121f9a:	85 c0                	test   %eax,%eax
  121f9c:	53                   	push   %ebx
  121f9d:	74 18                	je     121fb7 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
  121f9f:	3b 05 4c 5b 14 00    	cmp    0x145b4c,%eax
  121fa5:	74 10                	je     121fb7 <remove_timeout+0x22>
	if (next(t) != NULL) {
  121fa7:	85 d2                	test   %edx,%edx
  121fa9:	74 0c                	je     121fb7 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
  121fab:	8b 48 0c             	mov    0xc(%eax),%ecx
  121fae:	8b 58 10             	mov    0x10(%eax),%ebx
  121fb1:	01 4a 0c             	add    %ecx,0xc(%edx)
  121fb4:	11 5a 10             	adc    %ebx,0x10(%edx)
	node->prev->next = node->next;
  121fb7:	8b 48 04             	mov    0x4(%eax),%ecx
  121fba:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
  121fbc:	89 4a 04             	mov    %ecx,0x4(%edx)
}
  121fbf:	5b                   	pop    %ebx
	node->next = NULL;
  121fc0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  121fc6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  121fcd:	5d                   	pop    %ebp
  121fce:	c3                   	ret    

00121fcf <timeout_rem>:
/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
  121fcf:	83 38 00             	cmpl   $0x0,(%eax)
  121fd2:	74 45                	je     122019 <timeout_rem+0x4a>
{
  121fd4:	55                   	push   %ebp
	return list->head == list;
  121fd5:	8b 15 48 5b 14 00    	mov    0x145b48,%edx
  121fdb:	89 e5                	mov    %esp,%ebp
  121fdd:	57                   	push   %edi
  121fde:	56                   	push   %esi
  121fdf:	31 ff                	xor    %edi,%edi
  121fe1:	31 f6                	xor    %esi,%esi
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  121fe3:	8b 0d 4c 5b 14 00    	mov    0x145b4c,%ecx
	return sys_dlist_is_empty(list) ? NULL : list->head;
  121fe9:	81 fa 48 5b 14 00    	cmp    $0x145b48,%edx
  121fef:	74 16                	je     122007 <timeout_rem+0x38>
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
  121ff1:	85 d2                	test   %edx,%edx
  121ff3:	74 12                	je     122007 <timeout_rem+0x38>
		ticks += t->dticks;
  121ff5:	03 72 0c             	add    0xc(%edx),%esi
  121ff8:	13 7a 10             	adc    0x10(%edx),%edi
		if (timeout == t) {
  121ffb:	39 c2                	cmp    %eax,%edx
  121ffd:	74 08                	je     122007 <timeout_rem+0x38>
	return (node == list->tail) ? NULL : node->next;
  121fff:	39 ca                	cmp    %ecx,%edx
  122001:	74 04                	je     122007 <timeout_rem+0x38>
  122003:	8b 12                	mov    (%edx),%edx
  122005:	eb ea                	jmp    121ff1 <timeout_rem+0x22>
			break;
		}
	}

	return ticks - elapsed();
  122007:	e8 78 ff ff ff       	call   121f84 <elapsed>
  12200c:	99                   	cltd   
  12200d:	29 c6                	sub    %eax,%esi
  12200f:	19 d7                	sbb    %edx,%edi
  122011:	89 f0                	mov    %esi,%eax
}
  122013:	5e                   	pop    %esi
	return ticks - elapsed();
  122014:	89 fa                	mov    %edi,%edx
}
  122016:	5f                   	pop    %edi
  122017:	5d                   	pop    %ebp
  122018:	c3                   	ret    
		return 0;
  122019:	31 c0                	xor    %eax,%eax
  12201b:	31 d2                	xor    %edx,%edx
}
  12201d:	c3                   	ret    

0012201e <next_timeout>:
{
  12201e:	55                   	push   %ebp
  12201f:	89 e5                	mov    %esp,%ebp
  122021:	53                   	push   %ebx
	return list->head == list;
  122022:	8b 1d 48 5b 14 00    	mov    0x145b48,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
  122028:	81 fb 48 5b 14 00    	cmp    $0x145b48,%ebx
  12202e:	75 02                	jne    122032 <next_timeout+0x14>
  122030:	31 db                	xor    %ebx,%ebx
	int32_t ticks_elapsed = elapsed();
  122032:	e8 4d ff ff ff       	call   121f84 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
  122037:	85 db                	test   %ebx,%ebx
	int32_t ticks_elapsed = elapsed();
  122039:	89 c2                	mov    %eax,%edx
	int32_t ret = to == NULL ? MAX_WAIT
  12203b:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  122040:	74 2a                	je     12206c <next_timeout+0x4e>
		: MIN(MAX_WAIT, MAX(0, to->dticks - ticks_elapsed));
  122042:	89 d0                	mov    %edx,%eax
  122044:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  122047:	99                   	cltd   
  122048:	8b 5b 10             	mov    0x10(%ebx),%ebx
  12204b:	29 c1                	sub    %eax,%ecx
  12204d:	19 d3                	sbb    %edx,%ebx
	int32_t ret = to == NULL ? MAX_WAIT
  12204f:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  122054:	39 c8                	cmp    %ecx,%eax
  122056:	b8 00 00 00 00       	mov    $0x0,%eax
  12205b:	19 d8                	sbb    %ebx,%eax
  12205d:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  122062:	7c 08                	jl     12206c <next_timeout+0x4e>
		: MIN(MAX_WAIT, MAX(0, to->dticks - ticks_elapsed));
  122064:	89 c8                	mov    %ecx,%eax
  122066:	85 db                	test   %ebx,%ebx
  122068:	79 02                	jns    12206c <next_timeout+0x4e>
  12206a:	31 c0                	xor    %eax,%eax
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
  12206c:	8b 15 d4 e9 12 00    	mov    0x12e9d4,%edx
  122072:	85 d2                	test   %edx,%edx
  122074:	74 06                	je     12207c <next_timeout+0x5e>
  122076:	39 d0                	cmp    %edx,%eax
  122078:	7e 02                	jle    12207c <next_timeout+0x5e>
  12207a:	89 d0                	mov    %edx,%eax
}
  12207c:	5b                   	pop    %ebx
  12207d:	5d                   	pop    %ebp
  12207e:	c3                   	ret    

0012207f <z_add_timeout>:
{
  12207f:	55                   	push   %ebp
  122080:	89 e5                	mov    %esp,%ebp
  122082:	57                   	push   %edi
  122083:	56                   	push   %esi
  122084:	53                   	push   %ebx
  122085:	83 ec 08             	sub    $0x8,%esp
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  122088:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
  12208c:	75 0a                	jne    122098 <z_add_timeout+0x19>
  12208e:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
  122092:	0f 84 2d 01 00 00    	je     1221c5 <z_add_timeout+0x146>
	k_ticks_t ticks = timeout.ticks + 1;
  122098:	8b 75 10             	mov    0x10(%ebp),%esi
  12209b:	8b 7d 14             	mov    0x14(%ebp),%edi
  12209e:	83 c6 01             	add    $0x1,%esi
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
  1220a1:	b9 fe ff ff ff       	mov    $0xfffffffe,%ecx
	k_ticks_t ticks = timeout.ticks + 1;
  1220a6:	83 d7 00             	adc    $0x0,%edi
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
  1220a9:	83 cb ff             	or     $0xffffffff,%ebx
  1220ac:	89 da                	mov    %ebx,%edx
  1220ae:	39 f1                	cmp    %esi,%ecx
  1220b0:	19 fa                	sbb    %edi,%edx
  1220b2:	85 d2                	test   %edx,%edx
  1220b4:	78 34                	js     1220ea <z_add_timeout+0x6b>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
  1220b6:	e8 c9 fe ff ff       	call   121f84 <elapsed>
  1220bb:	b9 fe ff ff ff       	mov    $0xfffffffe,%ecx
  1220c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1220c3:	89 c8                	mov    %ecx,%eax
  1220c5:	83 cb ff             	or     $0xffffffff,%ebx
  1220c8:	2b 05 b8 ea 12 00    	sub    0x12eab8,%eax
  1220ce:	89 da                	mov    %ebx,%edx
  1220d0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1220d3:	1b 15 bc ea 12 00    	sbb    0x12eabc,%edx
  1220d9:	29 f0                	sub    %esi,%eax
  1220db:	19 fa                	sbb    %edi,%edx
  1220dd:	89 c6                	mov    %eax,%esi
  1220df:	89 cb                	mov    %ecx,%ebx
  1220e1:	89 d7                	mov    %edx,%edi
  1220e3:	c1 fb 1f             	sar    $0x1f,%ebx
  1220e6:	29 ce                	sub    %ecx,%esi
  1220e8:	19 df                	sbb    %ebx,%edi
	to->fn = fn;
  1220ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1220ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  1220f0:	89 43 08             	mov    %eax,0x8(%ebx)
  1220f3:	9c                   	pushf  
  1220f4:	fa                   	cli    
  1220f5:	8f 45 ec             	popl   -0x14(%ebp)
		to->dticks = ticks + elapsed();
  1220f8:	e8 87 fe ff ff       	call   121f84 <elapsed>
	ticks = MAX(1, ticks);
  1220fd:	31 d2                	xor    %edx,%edx
  1220ff:	39 f2                	cmp    %esi,%edx
  122101:	19 fa                	sbb    %edi,%edx
  122103:	7c 07                	jl     12210c <z_add_timeout+0x8d>
  122105:	be 01 00 00 00       	mov    $0x1,%esi
  12210a:	31 ff                	xor    %edi,%edi
		to->dticks = ticks + elapsed();
  12210c:	99                   	cltd   
  12210d:	01 c6                	add    %eax,%esi
  12210f:	8b 45 08             	mov    0x8(%ebp),%eax
  122112:	11 d7                	adc    %edx,%edi
  122114:	89 70 0c             	mov    %esi,0xc(%eax)
  122117:	89 78 10             	mov    %edi,0x10(%eax)
	return list->head == list;
  12211a:	a1 48 5b 14 00       	mov    0x145b48,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
  12211f:	3d 48 5b 14 00       	cmp    $0x145b48,%eax
  122124:	74 56                	je     12217c <z_add_timeout+0xfd>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  122126:	8b 15 4c 5b 14 00    	mov    0x145b4c,%edx
  12212c:	89 55 f0             	mov    %edx,-0x10(%ebp)
		for (t = first(); t != NULL; t = next(t)) {
  12212f:	85 c0                	test   %eax,%eax
  122131:	74 49                	je     12217c <z_add_timeout+0xfd>
			if (t->dticks > to->dticks) {
  122133:	8b 5d 08             	mov    0x8(%ebp),%ebx
  122136:	8b 70 0c             	mov    0xc(%eax),%esi
  122139:	8b 78 10             	mov    0x10(%eax),%edi
  12213c:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  12213f:	8b 5b 10             	mov    0x10(%ebx),%ebx
  122142:	39 f1                	cmp    %esi,%ecx
  122144:	89 da                	mov    %ebx,%edx
  122146:	19 fa                	sbb    %edi,%edx
  122148:	7d 1c                	jge    122166 <z_add_timeout+0xe7>
				t->dticks -= to->dticks;
  12214a:	29 ce                	sub    %ecx,%esi
	node->prev = successor->prev;
  12214c:	8b 50 04             	mov    0x4(%eax),%edx
  12214f:	19 df                	sbb    %ebx,%edi
  122151:	89 70 0c             	mov    %esi,0xc(%eax)
  122154:	89 78 10             	mov    %edi,0x10(%eax)
  122157:	8b 7d 08             	mov    0x8(%ebp),%edi
  12215a:	89 57 04             	mov    %edx,0x4(%edi)
	node->next = successor;
  12215d:	89 07                	mov    %eax,(%edi)
	successor->prev->next = node;
  12215f:	89 3a                	mov    %edi,(%edx)
	successor->prev = node;
  122161:	89 78 04             	mov    %edi,0x4(%eax)
		if (t == NULL) {
  122164:	eb 37                	jmp    12219d <z_add_timeout+0x11e>
			to->dticks -= t->dticks;
  122166:	29 f1                	sub    %esi,%ecx
  122168:	19 fb                	sbb    %edi,%ebx
  12216a:	8b 7d 08             	mov    0x8(%ebp),%edi
	return (node == list->tail) ? NULL : node->next;
  12216d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  122170:	89 4f 0c             	mov    %ecx,0xc(%edi)
  122173:	89 5f 10             	mov    %ebx,0x10(%edi)
  122176:	74 04                	je     12217c <z_add_timeout+0xfd>
  122178:	8b 00                	mov    (%eax),%eax
  12217a:	eb b3                	jmp    12212f <z_add_timeout+0xb0>
	node->next = list;
  12217c:	8b 45 08             	mov    0x8(%ebp),%eax
	node->prev = list->tail;
  12217f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	node->next = list;
  122182:	c7 00 48 5b 14 00    	movl   $0x145b48,(%eax)
	node->prev = list->tail;
  122188:	a1 4c 5b 14 00       	mov    0x145b4c,%eax
  12218d:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
  122190:	a1 4c 5b 14 00       	mov    0x145b4c,%eax
  122195:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  122197:	89 1d 4c 5b 14 00    	mov    %ebx,0x145b4c
	return list->head == list;
  12219d:	a1 48 5b 14 00       	mov    0x145b48,%eax
		if (to == first()) {
  1221a2:	39 45 08             	cmp    %eax,0x8(%ebp)
  1221a5:	75 16                	jne    1221bd <z_add_timeout+0x13e>
  1221a7:	3d 48 5b 14 00       	cmp    $0x145b48,%eax
  1221ac:	74 0f                	je     1221bd <z_add_timeout+0x13e>
			z_clock_set_timeout(next_timeout(), false);
  1221ae:	e8 6b fe ff ff       	call   12201e <next_timeout>
  1221b3:	6a 00                	push   $0x0
  1221b5:	50                   	push   %eax
  1221b6:	e8 6c 89 fe ff       	call   10ab27 <z_clock_set_timeout>
  1221bb:	58                   	pop    %eax
  1221bc:	5a                   	pop    %edx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1221bd:	0f ba 65 ec 09       	btl    $0x9,-0x14(%ebp)
  1221c2:	73 01                	jae    1221c5 <z_add_timeout+0x146>
		__asm__ volatile ("sti" ::: "memory");
  1221c4:	fb                   	sti    
}
  1221c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1221c8:	5b                   	pop    %ebx
  1221c9:	5e                   	pop    %esi
  1221ca:	5f                   	pop    %edi
  1221cb:	5d                   	pop    %ebp
  1221cc:	c3                   	ret    

001221cd <z_abort_timeout>:
{
  1221cd:	55                   	push   %ebp
  1221ce:	89 e5                	mov    %esp,%ebp
  1221d0:	53                   	push   %ebx
  1221d1:	8b 55 08             	mov    0x8(%ebp),%edx
  1221d4:	9c                   	pushf  
  1221d5:	fa                   	cli    
  1221d6:	5b                   	pop    %ebx
	return node->next != NULL;
  1221d7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		if (sys_dnode_is_linked(&to->node)) {
  1221dc:	83 3a 00             	cmpl   $0x0,(%edx)
  1221df:	74 09                	je     1221ea <z_abort_timeout+0x1d>
			remove_timeout(to);
  1221e1:	89 d0                	mov    %edx,%eax
  1221e3:	e8 ad fd ff ff       	call   121f95 <remove_timeout>
			ret = 0;
  1221e8:	31 c0                	xor    %eax,%eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1221ea:	0f ba e3 09          	bt     $0x9,%ebx
  1221ee:	73 01                	jae    1221f1 <z_abort_timeout+0x24>
		__asm__ volatile ("sti" ::: "memory");
  1221f0:	fb                   	sti    
}
  1221f1:	5b                   	pop    %ebx
  1221f2:	5d                   	pop    %ebp
  1221f3:	c3                   	ret    

001221f4 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
  1221f4:	55                   	push   %ebp
  1221f5:	89 e5                	mov    %esp,%ebp
  1221f7:	53                   	push   %ebx
  1221f8:	9c                   	pushf  
  1221f9:	fa                   	cli    
  1221fa:	5b                   	pop    %ebx
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
  1221fb:	8b 45 08             	mov    0x8(%ebp),%eax
  1221fe:	e8 cc fd ff ff       	call   121fcf <timeout_rem>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122203:	0f ba e3 09          	bt     $0x9,%ebx
  122207:	73 01                	jae    12220a <z_timeout_remaining+0x16>
		__asm__ volatile ("sti" ::: "memory");
  122209:	fb                   	sti    
	}

	return ticks;
}
  12220a:	5b                   	pop    %ebx
  12220b:	5d                   	pop    %ebp
  12220c:	c3                   	ret    

0012220d <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
  12220d:	55                   	push   %ebp
  12220e:	89 e5                	mov    %esp,%ebp
  122210:	53                   	push   %ebx
  122211:	9c                   	pushf  
  122212:	fa                   	cli    
  122213:	5b                   	pop    %ebx
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
  122214:	e8 05 fe ff ff       	call   12201e <next_timeout>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122219:	0f ba e3 09          	bt     $0x9,%ebx
  12221d:	73 01                	jae    122220 <z_get_next_timeout_expiry+0x13>
		__asm__ volatile ("sti" ::: "memory");
  12221f:	fb                   	sti    
	}
	return ret;
}
  122220:	5b                   	pop    %ebx
  122221:	5d                   	pop    %ebp
  122222:	c3                   	ret    

00122223 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
  122223:	55                   	push   %ebp
  122224:	89 e5                	mov    %esp,%ebp
  122226:	57                   	push   %edi
  122227:	56                   	push   %esi
  122228:	53                   	push   %ebx
  122229:	8b 75 08             	mov    0x8(%ebp),%esi
  12222c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  12222f:	9c                   	pushf  
  122230:	fa                   	cli    
  122231:	5f                   	pop    %edi
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
  122232:	e8 e7 fd ff ff       	call   12201e <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
  122237:	83 f8 ff             	cmp    $0xffffffff,%eax
  12223a:	0f 94 c1             	sete   %cl
			      || (ticks < next_to);
  12223d:	39 f0                	cmp    %esi,%eax
  12223f:	0f 9f c2             	setg   %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
  122242:	08 d1                	or     %dl,%cl
  122244:	74 0f                	je     122255 <z_set_timeout_expiry+0x32>
  122246:	48                   	dec    %eax
  122247:	7e 0c                	jle    122255 <z_set_timeout_expiry+0x32>
			z_clock_set_timeout(ticks, is_idle);
  122249:	0f b6 db             	movzbl %bl,%ebx
  12224c:	53                   	push   %ebx
  12224d:	56                   	push   %esi
  12224e:	e8 d4 88 fe ff       	call   10ab27 <z_clock_set_timeout>
  122253:	58                   	pop    %eax
  122254:	5a                   	pop    %edx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122255:	0f ba e7 09          	bt     $0x9,%edi
  122259:	73 01                	jae    12225c <z_set_timeout_expiry+0x39>
		__asm__ volatile ("sti" ::: "memory");
  12225b:	fb                   	sti    
		}
	}
}
  12225c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  12225f:	5b                   	pop    %ebx
  122260:	5e                   	pop    %esi
  122261:	5f                   	pop    %edi
  122262:	5d                   	pop    %ebp
  122263:	c3                   	ret    

00122264 <z_clock_announce>:

void z_clock_announce(int32_t ticks)
{
  122264:	55                   	push   %ebp
  122265:	89 e5                	mov    %esp,%ebp
  122267:	57                   	push   %edi
  122268:	56                   	push   %esi
  122269:	53                   	push   %ebx
  12226a:	83 ec 10             	sub    $0x10,%esp
  12226d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
  122270:	53                   	push   %ebx
  122271:	e8 3a f1 ff ff       	call   1213b0 <z_time_slice>
  122276:	5e                   	pop    %esi
  122277:	9c                   	pushf  
  122278:	fa                   	cli    
  122279:	5f                   	pop    %edi
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
  12227a:	89 1d 6c ed 12 00    	mov    %ebx,0x12ed6c
	return list->head == list;
  122280:	a1 48 5b 14 00       	mov    0x145b48,%eax
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
  122285:	8b 15 b8 ea 12 00    	mov    0x12eab8,%edx
  12228b:	8b 0d bc ea 12 00    	mov    0x12eabc,%ecx
  122291:	81 e7 00 02 00 00    	and    $0x200,%edi
  122297:	8b 35 6c ed 12 00    	mov    0x12ed6c,%esi
  12229d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1222a0:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
  1222a3:	85 c0                	test   %eax,%eax
  1222a5:	74 73                	je     12231a <z_clock_announce+0xb6>
  1222a7:	3d 48 5b 14 00       	cmp    $0x145b48,%eax
  1222ac:	74 6c                	je     12231a <z_clock_announce+0xb6>
  1222ae:	89 f2                	mov    %esi,%edx
  1222b0:	8b 48 0c             	mov    0xc(%eax),%ecx
  1222b3:	c1 fa 1f             	sar    $0x1f,%edx
  1222b6:	8b 58 10             	mov    0x10(%eax),%ebx
  1222b9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1222bc:	39 ce                	cmp    %ecx,%esi
  1222be:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1222c1:	89 75 ec             	mov    %esi,-0x14(%ebp)
  1222c4:	19 da                	sbb    %ebx,%edx
  1222c6:	7c 46                	jl     12230e <z_clock_announce+0xaa>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
  1222c8:	89 cb                	mov    %ecx,%ebx
		int dt = t->dticks;
  1222ca:	89 ca                	mov    %ecx,%edx
		curr_tick += dt;
  1222cc:	c1 fb 1f             	sar    $0x1f,%ebx
  1222cf:	03 4d e4             	add    -0x1c(%ebp),%ecx
  1222d2:	13 5d e8             	adc    -0x18(%ebp),%ebx
		announce_remaining -= dt;
		t->dticks = 0;
  1222d5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
		announce_remaining -= dt;
  1222dc:	29 d6                	sub    %edx,%esi
		t->dticks = 0;
  1222de:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		curr_tick += dt;
  1222e5:	89 0d b8 ea 12 00    	mov    %ecx,0x12eab8
  1222eb:	89 1d bc ea 12 00    	mov    %ebx,0x12eabc
		announce_remaining -= dt;
  1222f1:	89 35 6c ed 12 00    	mov    %esi,0x12ed6c
		remove_timeout(t);
  1222f7:	e8 99 fc ff ff       	call   121f95 <remove_timeout>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  1222fc:	85 ff                	test   %edi,%edi
  1222fe:	74 01                	je     122301 <z_clock_announce+0x9d>
		__asm__ volatile ("sti" ::: "memory");
  122300:	fb                   	sti    

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
  122301:	50                   	push   %eax
  122302:	ff 50 08             	call   *0x8(%eax)
  122305:	59                   	pop    %ecx
  122306:	9c                   	pushf  
  122307:	fa                   	cli    
  122308:	5f                   	pop    %edi
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
  122309:	e9 72 ff ff ff       	jmp    122280 <z_clock_announce+0x1c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
  12230e:	2b 4d ec             	sub    -0x14(%ebp),%ecx
  122311:	1b 5d f0             	sbb    -0x10(%ebp),%ebx
  122314:	89 48 0c             	mov    %ecx,0xc(%eax)
  122317:	89 58 10             	mov    %ebx,0x10(%eax)
	}

	curr_tick += announce_remaining;
  12231a:	89 f1                	mov    %esi,%ecx
  12231c:	89 f3                	mov    %esi,%ebx
  12231e:	c1 fb 1f             	sar    $0x1f,%ebx
  122321:	03 4d e4             	add    -0x1c(%ebp),%ecx
  122324:	13 5d e8             	adc    -0x18(%ebp),%ebx
  122327:	89 0d b8 ea 12 00    	mov    %ecx,0x12eab8
  12232d:	89 1d bc ea 12 00    	mov    %ebx,0x12eabc
	announce_remaining = 0;
  122333:	c7 05 6c ed 12 00 00 	movl   $0x0,0x12ed6c
  12233a:	00 00 00 

	z_clock_set_timeout(next_timeout(), false);
  12233d:	e8 dc fc ff ff       	call   12201e <next_timeout>
  122342:	6a 00                	push   $0x0
  122344:	50                   	push   %eax
  122345:	e8 dd 87 fe ff       	call   10ab27 <z_clock_set_timeout>
  12234a:	58                   	pop    %eax
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12234b:	85 ff                	test   %edi,%edi
  12234d:	5a                   	pop    %edx
  12234e:	74 01                	je     122351 <z_clock_announce+0xed>
		__asm__ volatile ("sti" ::: "memory");
  122350:	fb                   	sti    

	k_spin_unlock(&timeout_lock, key);
}
  122351:	8d 65 f4             	lea    -0xc(%ebp),%esp
  122354:	5b                   	pop    %ebx
  122355:	5e                   	pop    %esi
  122356:	5f                   	pop    %edi
  122357:	5d                   	pop    %ebp
  122358:	c3                   	ret    

00122359 <z_tick_get>:

int64_t z_tick_get(void)
{
  122359:	55                   	push   %ebp
  12235a:	89 e5                	mov    %esp,%ebp
  12235c:	53                   	push   %ebx
  12235d:	9c                   	pushf  
  12235e:	fa                   	cli    
  12235f:	5b                   	pop    %ebx
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
  122360:	e8 79 88 fe ff       	call   10abde <z_clock_elapsed>
  122365:	31 d2                	xor    %edx,%edx
  122367:	03 05 b8 ea 12 00    	add    0x12eab8,%eax
  12236d:	13 15 bc ea 12 00    	adc    0x12eabc,%edx
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122373:	0f ba e3 09          	bt     $0x9,%ebx
  122377:	73 01                	jae    12237a <z_tick_get+0x21>
		__asm__ volatile ("sti" ::: "memory");
  122379:	fb                   	sti    
	}
	return t;
}
  12237a:	5b                   	pop    %ebx
  12237b:	5d                   	pop    %ebp
  12237c:	c3                   	ret    

0012237d <z_tick_get_32>:

uint32_t z_tick_get_32(void)
{
  12237d:	55                   	push   %ebp
  12237e:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)z_tick_get();
  122380:	e8 d4 ff ff ff       	call   122359 <z_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  122385:	5d                   	pop    %ebp
  122386:	c3                   	ret    

00122387 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
  122387:	e9 cd ff ff ff       	jmp    122359 <z_tick_get>

0012238c <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t z_timeout_end_calc(k_timeout_t timeout)
{
  12238c:	55                   	push   %ebp
  12238d:	89 e5                	mov    %esp,%ebp
  12238f:	57                   	push   %edi
  122390:	56                   	push   %esi
  122391:	8b 7d 0c             	mov    0xc(%ebp),%edi
  122394:	8b 75 08             	mov    0x8(%ebp),%esi
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  122397:	83 ff ff             	cmp    $0xffffffff,%edi
  12239a:	75 05                	jne    1223a1 <z_timeout_end_calc+0x15>
  12239c:	83 fe ff             	cmp    $0xffffffff,%esi
  12239f:	74 38                	je     1223d9 <z_timeout_end_calc+0x4d>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  1223a1:	89 f8                	mov    %edi,%eax
  1223a3:	09 f0                	or     %esi,%eax
  1223a5:	75 08                	jne    1223af <z_timeout_end_calc+0x23>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
  1223a7:	5e                   	pop    %esi
  1223a8:	5f                   	pop    %edi
  1223a9:	5d                   	pop    %ebp
		return z_tick_get();
  1223aa:	e9 aa ff ff ff       	jmp    122359 <z_tick_get>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  1223af:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  1223b4:	83 ca ff             	or     $0xffffffff,%edx
  1223b7:	29 f0                	sub    %esi,%eax
  1223b9:	19 fa                	sbb    %edi,%edx
  1223bb:	85 d2                	test   %edx,%edx
  1223bd:	79 1f                	jns    1223de <z_timeout_end_calc+0x52>
	return z_tick_get() + MAX(1, dt);
  1223bf:	e8 95 ff ff ff       	call   122359 <z_tick_get>
  1223c4:	31 c9                	xor    %ecx,%ecx
  1223c6:	39 f1                	cmp    %esi,%ecx
  1223c8:	19 f9                	sbb    %edi,%ecx
  1223ca:	7c 07                	jl     1223d3 <z_timeout_end_calc+0x47>
  1223cc:	be 01 00 00 00       	mov    $0x1,%esi
  1223d1:	31 ff                	xor    %edi,%edi
  1223d3:	01 f0                	add    %esi,%eax
  1223d5:	11 fa                	adc    %edi,%edx
  1223d7:	eb 05                	jmp    1223de <z_timeout_end_calc+0x52>
		return UINT64_MAX;
  1223d9:	83 c8 ff             	or     $0xffffffff,%eax
  1223dc:	89 c2                	mov    %eax,%edx
}
  1223de:	5e                   	pop    %esi
  1223df:	5f                   	pop    %edi
  1223e0:	5d                   	pop    %ebp
  1223e1:	c3                   	ret    

001223e2 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  1223e2:	55                   	push   %ebp
  1223e3:	89 e5                	mov    %esp,%ebp
  1223e5:	57                   	push   %edi
  1223e6:	56                   	push   %esi

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  1223e7:	bf 01 00 00 00       	mov    $0x1,%edi
{
  1223ec:	53                   	push   %ebx
  1223ed:	83 ec 08             	sub    $0x8,%esp
  1223f0:	8b 75 08             	mov    0x8(%ebp),%esi
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  1223f3:	8b 46 2c             	mov    0x2c(%esi),%eax
  1223f6:	8b 56 30             	mov    0x30(%esi),%edx
  1223f9:	89 c1                	mov    %eax,%ecx
  1223fb:	89 d3                	mov    %edx,%ebx
  1223fd:	83 c1 01             	add    $0x1,%ecx
  122400:	83 d3 00             	adc    $0x0,%ebx
  122403:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  122406:	3b 7d ec             	cmp    -0x14(%ebp),%edi
  122409:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  12240c:	b9 00 00 00 00       	mov    $0x0,%ecx
  122411:	1b 4d f0             	sbb    -0x10(%ebp),%ecx
  122414:	73 10                	jae    122426 <z_timer_expiration_handler+0x44>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  122416:	52                   	push   %edx
  122417:	50                   	push   %eax
  122418:	68 e2 23 12 00       	push   $0x1223e2
  12241d:	56                   	push   %esi
  12241e:	e8 5c fc ff ff       	call   12207f <z_add_timeout>
  122423:	83 c4 10             	add    $0x10,%esp

	/* update timer's status */
	timer->status += 1U;

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  122426:	8b 46 24             	mov    0x24(%esi),%eax
	timer->status += 1U;
  122429:	ff 46 34             	incl   0x34(%esi)
	if (timer->expiry_fn != NULL) {
  12242c:	85 c0                	test   %eax,%eax
  12242e:	74 04                	je     122434 <z_timer_expiration_handler+0x52>
		timer->expiry_fn(timer);
  122430:	56                   	push   %esi
  122431:	ff d0                	call   *%eax
  122433:	5b                   	pop    %ebx
  122434:	6a 00                	push   $0x0
	return (struct k_thread *)rb_get_min(&w->waitq.tree);
  122436:	83 c6 14             	add    $0x14,%esi
  122439:	56                   	push   %esi
  12243a:	e8 cf f1 fd ff       	call   10160e <z_rb_get_minmax>
  12243f:	5a                   	pop    %edx
  122440:	89 c3                	mov    %eax,%ebx
  122442:	59                   	pop    %ecx
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  122443:	85 c0                	test   %eax,%eax
  122445:	74 18                	je     12245f <z_timer_expiration_handler+0x7d>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
  122447:	50                   	push   %eax
  122448:	e8 58 ec ff ff       	call   1210a5 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
  12244d:	89 1c 24             	mov    %ebx,(%esp)
  122450:	e8 96 ee ff ff       	call   1212eb <z_ready_thread>
  122455:	58                   	pop    %eax
  122456:	8b 43 3c             	mov    0x3c(%ebx),%eax
  122459:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	arch_thread_return_value_set(thread, 0);
}
  12245f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  122462:	5b                   	pop    %ebx
  122463:	5e                   	pop    %esi
  122464:	5f                   	pop    %edi
  122465:	5d                   	pop    %ebp
  122466:	c3                   	ret    

00122467 <k_timer_init>:


void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
  122467:	55                   	push   %ebp
	w->waitq = (struct _priq_rb) {
  122468:	b9 04 00 00 00       	mov    $0x4,%ecx
  12246d:	89 e5                	mov    %esp,%ebp
  12246f:	57                   	push   %edi
  122470:	8b 55 08             	mov    0x8(%ebp),%edx
	timer->expiry_fn = expiry_fn;
  122473:	8b 45 0c             	mov    0xc(%ebp),%eax
  122476:	89 42 24             	mov    %eax,0x24(%edx)
	timer->stop_fn = stop_fn;
  122479:	8b 45 10             	mov    0x10(%ebp),%eax
  12247c:	89 42 28             	mov    %eax,0x28(%edx)
  12247f:	8d 7a 14             	lea    0x14(%edx),%edi
  122482:	31 c0                	xor    %eax,%eax
	timer->status = 0U;
  122484:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%edx)
  12248b:	f3 ab                	rep stos %eax,%es:(%edi)
  12248d:	c7 42 18 c4 0f 12 00 	movl   $0x120fc4,0x18(%edx)
	node->next = NULL;
  122494:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	node->prev = NULL;
  12249a:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)

	z_waitq_init(&timer->wait_q);
	z_init_timeout(&timer->timeout);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  1224a1:	c7 42 38 00 00 00 00 	movl   $0x0,0x38(%edx)

	z_object_init(timer);
}
  1224a8:	5f                   	pop    %edi
  1224a9:	5d                   	pop    %ebp
  1224aa:	c3                   	ret    

001224ab <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
  1224ab:	55                   	push   %ebp
  1224ac:	89 e5                	mov    %esp,%ebp
  1224ae:	57                   	push   %edi
  1224af:	56                   	push   %esi
  1224b0:	53                   	push   %ebx
  1224b1:	83 ec 0c             	sub    $0xc,%esp
  1224b4:	8b 5d 10             	mov    0x10(%ebp),%ebx
  1224b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1224ba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1224bd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1224c0:	8b 75 14             	mov    0x14(%ebp),%esi
  1224c3:	8b 7d 18             	mov    0x18(%ebp),%edi
  1224c6:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1224c9:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  1224cc:	83 fb ff             	cmp    $0xffffffff,%ebx
  1224cf:	75 09                	jne    1224da <z_impl_k_timer_start+0x2f>
  1224d1:	83 f9 ff             	cmp    $0xffffffff,%ecx
  1224d4:	0f 84 99 00 00 00    	je     122573 <z_impl_k_timer_start+0xc8>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
  1224da:	89 f8                	mov    %edi,%eax
  1224dc:	09 f0                	or     %esi,%eax
  1224de:	74 25                	je     122505 <z_impl_k_timer_start+0x5a>
  1224e0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  1224e5:	83 ca ff             	or     $0xffffffff,%edx
  1224e8:	39 f0                	cmp    %esi,%eax
  1224ea:	19 fa                	sbb    %edi,%edx
  1224ec:	85 d2                	test   %edx,%edx
  1224ee:	79 15                	jns    122505 <z_impl_k_timer_start+0x5a>
		period.ticks = MAX(period.ticks - 1, 1);
  1224f0:	83 c6 ff             	add    $0xffffffff,%esi
  1224f3:	83 d7 ff             	adc    $0xffffffff,%edi
  1224f6:	31 c0                	xor    %eax,%eax
  1224f8:	39 f0                	cmp    %esi,%eax
  1224fa:	19 f8                	sbb    %edi,%eax
  1224fc:	7c 07                	jl     122505 <z_impl_k_timer_start+0x5a>
  1224fe:	be 01 00 00 00       	mov    $0x1,%esi
  122503:	31 ff                	xor    %edi,%edi
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
  122505:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  12250a:	83 ca ff             	or     $0xffffffff,%edx
  12250d:	39 c8                	cmp    %ecx,%eax
  12250f:	19 da                	sbb    %ebx,%edx
  122511:	85 d2                	test   %edx,%edx
  122513:	79 20                	jns    122535 <z_impl_k_timer_start+0x8a>
		duration.ticks = MAX(duration.ticks - 1, 0);
  122515:	83 c1 ff             	add    $0xffffffff,%ecx
  122518:	83 d3 ff             	adc    $0xffffffff,%ebx
  12251b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  12251e:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  122521:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  122525:	79 0e                	jns    122535 <z_impl_k_timer_start+0x8a>
  122527:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  12252e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
  122535:	ff 75 e8             	pushl  -0x18(%ebp)
  122538:	e8 90 fc ff ff       	call   1221cd <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  12253d:	8b 55 f0             	mov    -0x10(%ebp),%edx
	(void)z_abort_timeout(&timer->timeout);
  122540:	58                   	pop    %eax
	timer->period = period;
  122541:	8b 45 e8             	mov    -0x18(%ebp),%eax
  122544:	89 70 2c             	mov    %esi,0x2c(%eax)
  122547:	89 78 30             	mov    %edi,0x30(%eax)
	timer->status = 0U;
  12254a:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  122551:	8b 45 ec             	mov    -0x14(%ebp),%eax
  122554:	89 45 10             	mov    %eax,0x10(%ebp)
  122557:	8b 45 e8             	mov    -0x18(%ebp),%eax
  12255a:	89 55 14             	mov    %edx,0x14(%ebp)
  12255d:	c7 45 0c e2 23 12 00 	movl   $0x1223e2,0xc(%ebp)
  122564:	89 45 08             	mov    %eax,0x8(%ebp)
		     duration);
}
  122567:	8d 65 f4             	lea    -0xc(%ebp),%esp
  12256a:	5b                   	pop    %ebx
  12256b:	5e                   	pop    %esi
  12256c:	5f                   	pop    %edi
  12256d:	5d                   	pop    %ebp
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  12256e:	e9 0c fb ff ff       	jmp    12207f <z_add_timeout>
}
  122573:	8d 65 f4             	lea    -0xc(%ebp),%esp
  122576:	5b                   	pop    %ebx
  122577:	5e                   	pop    %esi
  122578:	5f                   	pop    %edi
  122579:	5d                   	pop    %ebp
  12257a:	c3                   	ret    

0012257b <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  12257b:	55                   	push   %ebp
  12257c:	89 e5                	mov    %esp,%ebp
  12257e:	53                   	push   %ebx
  12257f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int inactive = z_abort_timeout(&timer->timeout) != 0;
  122582:	53                   	push   %ebx
  122583:	e8 45 fc ff ff       	call   1221cd <z_abort_timeout>
  122588:	5a                   	pop    %edx

	if (inactive) {
  122589:	85 c0                	test   %eax,%eax
  12258b:	75 3c                	jne    1225c9 <z_impl_k_timer_stop+0x4e>
		return;
	}

	if (timer->stop_fn != NULL) {
  12258d:	8b 43 28             	mov    0x28(%ebx),%eax
  122590:	85 c0                	test   %eax,%eax
  122592:	74 04                	je     122598 <z_impl_k_timer_stop+0x1d>
		timer->stop_fn(timer);
  122594:	53                   	push   %ebx
  122595:	ff d0                	call   *%eax
  122597:	58                   	pop    %eax
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
  122598:	6a 00                	push   $0x0
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  12259a:	83 c3 14             	add    $0x14,%ebx
  12259d:	53                   	push   %ebx
  12259e:	e8 e6 ea ff ff       	call   121089 <z_find_first_thread_to_unpend>
  1225a3:	5a                   	pop    %edx
  1225a4:	89 c3                	mov    %eax,%ebx
  1225a6:	59                   	pop    %ecx
	if (thread != NULL) {
  1225a7:	85 c0                	test   %eax,%eax
  1225a9:	74 1e                	je     1225c9 <z_impl_k_timer_stop+0x4e>
		z_unpend_thread_no_timeout(thread);
  1225ab:	50                   	push   %eax
  1225ac:	e8 f4 ea ff ff       	call   1210a5 <z_unpend_thread_no_timeout>

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
  1225b1:	89 1c 24             	mov    %ebx,(%esp)
  1225b4:	e8 32 ed ff ff       	call   1212eb <z_ready_thread>
  1225b9:	58                   	pop    %eax
  1225ba:	9c                   	pushf  
  1225bb:	fa                   	cli    
  1225bc:	58                   	pop    %eax
		z_reschedule_unlocked();
	}
}
  1225bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	(void) z_reschedule_irqlock(arch_irq_lock());
  1225c0:	89 45 08             	mov    %eax,0x8(%ebp)
  1225c3:	c9                   	leave  
  1225c4:	e9 24 eb ff ff       	jmp    1210ed <z_reschedule_irqlock>
  1225c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1225cc:	c9                   	leave  
  1225cd:	c3                   	ret    

001225ce <z_mem_map>:
	return addr_offset;
}

void z_mem_map(uint8_t **virt_addr, uintptr_t phys_addr, size_t size,
	       uint32_t flags)
{
  1225ce:	55                   	push   %ebp
  1225cf:	89 e5                	mov    %esp,%ebp
  1225d1:	57                   	push   %edi
  1225d2:	56                   	push   %esi
	addr_offset = phys_addr - *aligned_addr;
  1225d3:	8b 75 0c             	mov    0xc(%ebp),%esi
	*aligned_size = ROUND_UP(size + addr_offset, align);
  1225d6:	8b 45 10             	mov    0x10(%ebp),%eax
	addr_offset = phys_addr - *aligned_addr;
  1225d9:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
	*aligned_addr = ROUND_DOWN(phys_addr, align);
  1225df:	8b 4d 0c             	mov    0xc(%ebp),%ecx
{
  1225e2:	53                   	push   %ebx
	*aligned_addr = ROUND_DOWN(phys_addr, align);
  1225e3:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
	*aligned_size = ROUND_UP(size + addr_offset, align);
  1225e9:	8d 84 06 ff 0f 00 00 	lea    0xfff(%esi,%eax,1),%eax
  1225f0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1225f5:	9c                   	pushf  
  1225f6:	fa                   	cli    
  1225f7:	5f                   	pop    %edi
	key = k_spin_lock(&mm_lock);

	/* Carve out some unused virtual memory from the top of the
	 * address space
	 */
	if ((mapping_pos - aligned_size) < mapping_limit) {
  1225f8:	8b 1d 50 5b 14 00    	mov    0x145b50,%ebx
  1225fe:	29 c3                	sub    %eax,%ebx
  122600:	81 fb ff ff 3f 00    	cmp    $0x3fffff,%ebx
  122606:	77 2b                	ja     122633 <z_mem_map+0x65>
		LOG_ERR("insufficient kernel virtual address space");
  122608:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  12260f:	74 7d                	je     12268e <z_mem_map+0xc0>
  122611:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  122616:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  12261b:	c1 e8 03             	shr    $0x3,%eax
  12261e:	c1 e0 06             	shl    $0x6,%eax
  122621:	83 c8 01             	or     $0x1,%eax
  122624:	50                   	push   %eax
  122625:	68 8f 8a 12 00       	push   $0x128a8f
  12262a:	e8 1e 0f fe ff       	call   10354d <log_0>
  12262f:	58                   	pop    %eax
  122630:	5a                   	pop    %edx
  122631:	eb 5b                	jmp    12268e <z_mem_map+0xc0>
		 dest_virt, size);
	__ASSERT(aligned_addr < (aligned_addr + (size - 1)),
		 "wraparound for physical address 0x%lx (size %zu)",
		 aligned_addr, size);

	ret = arch_mem_map(dest_virt, aligned_addr, aligned_size, flags);
  122633:	ff 75 14             	pushl  0x14(%ebp)
	mapping_pos -= aligned_size;
  122636:	89 1d 50 5b 14 00    	mov    %ebx,0x145b50
	ret = arch_mem_map(dest_virt, aligned_addr, aligned_size, flags);
  12263c:	50                   	push   %eax
  12263d:	51                   	push   %ecx
  12263e:	53                   	push   %ebx
  12263f:	e8 48 8f fe ff       	call   10b58c <arch_mem_map>
  122644:	83 c4 10             	add    $0x10,%esp
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122647:	0f ba e7 09          	bt     $0x9,%edi
  12264b:	73 01                	jae    12264e <z_mem_map+0x80>
		__asm__ volatile ("sti" ::: "memory");
  12264d:	fb                   	sti    
	k_spin_unlock(&mm_lock, key);

	if (ret == 0) {
  12264e:	85 c0                	test   %eax,%eax
  122650:	75 0f                	jne    122661 <z_mem_map+0x93>
		*virt_addr = dest_virt + addr_offset;
  122652:	8b 45 08             	mov    0x8(%ebp),%eax
  122655:	01 f3                	add    %esi,%ebx
  122657:	89 18                	mov    %ebx,(%eax)
	return;
fail:
	LOG_ERR("memory mapping 0x%lx (size %zu, flags 0x%x) failed",
		phys_addr, size, flags);
	k_panic();
}
  122659:	8d 65 f4             	lea    -0xc(%ebp),%esp
  12265c:	5b                   	pop    %ebx
  12265d:	5e                   	pop    %esi
  12265e:	5f                   	pop    %edi
  12265f:	5d                   	pop    %ebp
  122660:	c3                   	ret    
		LOG_ERR("arch_mem_map() to %p returned %d", dest_virt, ret);
  122661:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  122668:	74 24                	je     12268e <z_mem_map+0xc0>
  12266a:	ba b8 31 12 00       	mov    $0x1231b8,%edx
  12266f:	81 ea b0 30 12 00    	sub    $0x1230b0,%edx
  122675:	c1 ea 03             	shr    $0x3,%edx
  122678:	c1 e2 06             	shl    $0x6,%edx
  12267b:	83 ca 01             	or     $0x1,%edx
  12267e:	52                   	push   %edx
  12267f:	50                   	push   %eax
  122680:	53                   	push   %ebx
  122681:	68 b9 8a 12 00       	push   $0x128ab9
  122686:	e8 25 0f fe ff       	call   1035b0 <log_2>
  12268b:	83 c4 10             	add    $0x10,%esp
	LOG_ERR("memory mapping 0x%lx (size %zu, flags 0x%x) failed",
  12268e:	f6 05 1c 5c 14 00 07 	testb  $0x7,0x145c1c
  122695:	74 2a                	je     1226c1 <z_mem_map+0xf3>
  122697:	b8 b8 31 12 00       	mov    $0x1231b8,%eax
  12269c:	2d b0 30 12 00       	sub    $0x1230b0,%eax
  1226a1:	c1 e8 03             	shr    $0x3,%eax
  1226a4:	c1 e0 06             	shl    $0x6,%eax
  1226a7:	83 c8 01             	or     $0x1,%eax
  1226aa:	50                   	push   %eax
  1226ab:	ff 75 14             	pushl  0x14(%ebp)
  1226ae:	ff 75 10             	pushl  0x10(%ebp)
  1226b1:	ff 75 0c             	pushl  0xc(%ebp)
  1226b4:	68 da 8a 12 00       	push   $0x128ada
  1226b9:	e8 3b 0f fe ff       	call   1035f9 <log_3>
  1226be:	83 c4 14             	add    $0x14,%esp
	k_panic();
  1226c1:	6a 04                	push   $0x4
  1226c3:	cd 20                	int    $0x20

001226c5 <clear_event_registrations>:
/* must be called with interrupts locked */
static inline void clear_event_registrations(struct k_poll_event *events,
					      int num_events,
					      k_spinlock_key_t key)
{
	while (num_events--) {
  1226c5:	6b d2 14             	imul   $0x14,%edx,%edx
  1226c8:	01 c2                	add    %eax,%edx
  1226ca:	39 c2                	cmp    %eax,%edx
  1226cc:	75 01                	jne    1226cf <clear_event_registrations+0xa>
  1226ce:	c3                   	ret    
{
  1226cf:	55                   	push   %ebp
  1226d0:	89 e5                	mov    %esp,%ebp
  1226d2:	56                   	push   %esi
  1226d3:	53                   	push   %ebx
	switch (event->type) {
  1226d4:	8a 5a f9             	mov    -0x7(%edx),%bl
	event->poller = NULL;
  1226d7:	c7 42 f4 00 00 00 00 	movl   $0x0,-0xc(%edx)
	switch (event->type) {
  1226de:	83 e3 0f             	and    $0xf,%ebx
  1226e1:	80 fb 02             	cmp    $0x2,%bl
  1226e4:	77 06                	ja     1226ec <clear_event_registrations+0x27>
  1226e6:	84 db                	test   %bl,%bl
  1226e8:	74 24                	je     12270e <clear_event_registrations+0x49>
  1226ea:	eb 05                	jmp    1226f1 <clear_event_registrations+0x2c>
  1226ec:	80 fb 04             	cmp    $0x4,%bl
  1226ef:	75 1d                	jne    12270e <clear_event_registrations+0x49>
	if (remove && sys_dnode_is_linked(&event->_node)) {
  1226f1:	8b 5a ec             	mov    -0x14(%edx),%ebx
  1226f4:	85 db                	test   %ebx,%ebx
  1226f6:	74 16                	je     12270e <clear_event_registrations+0x49>
	node->prev->next = node->next;
  1226f8:	8b 72 f0             	mov    -0x10(%edx),%esi
  1226fb:	89 1e                	mov    %ebx,(%esi)
	node->next->prev = node->prev;
  1226fd:	89 73 04             	mov    %esi,0x4(%ebx)
	node->next = NULL;
  122700:	c7 42 ec 00 00 00 00 	movl   $0x0,-0x14(%edx)
	node->prev = NULL;
  122707:	c7 42 f0 00 00 00 00 	movl   $0x0,-0x10(%edx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  12270e:	0f ba e1 09          	bt     $0x9,%ecx
  122712:	73 01                	jae    122715 <clear_event_registrations+0x50>
		__asm__ volatile ("sti" ::: "memory");
  122714:	fb                   	sti    
  122715:	9c                   	pushf  
  122716:	fa                   	cli    
  122717:	59                   	pop    %ecx
  122718:	83 ea 14             	sub    $0x14,%edx
	while (num_events--) {
  12271b:	39 c2                	cmp    %eax,%edx
  12271d:	75 b5                	jne    1226d4 <clear_event_registrations+0xf>
		clear_event_registration(&events[num_events]);
		k_spin_unlock(&lock, key);
		key = k_spin_lock(&lock);
	}
}
  12271f:	5b                   	pop    %ebx
  122720:	5e                   	pop    %esi
  122721:	5d                   	pop    %ebp
  122722:	c3                   	ret    

00122723 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  122723:	55                   	push   %ebp
  122724:	89 e5                	mov    %esp,%ebp
  122726:	57                   	push   %edi
  122727:	56                   	push   %esi
  122728:	89 d6                	mov    %edx,%esi
  12272a:	53                   	push   %ebx
  12272b:	89 c3                	mov    %eax,%ebx
	struct _poller *poller = event->poller;
  12272d:	8b 78 08             	mov    0x8(%eax),%edi
	int retcode = 0;

	if (poller) {
  122730:	85 ff                	test   %edi,%edi
  122732:	74 1b                	je     12274f <signal_poll_event+0x2c>
		if (poller->cb != NULL) {
  122734:	8b 47 08             	mov    0x8(%edi),%eax
  122737:	85 c0                	test   %eax,%eax
  122739:	75 05                	jne    122740 <signal_poll_event+0x1d>
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
  12273b:	c6 07 00             	movb   $0x0,(%edi)

		if (retcode < 0) {
  12273e:	eb 11                	jmp    122751 <signal_poll_event+0x2e>
			retcode = poller->cb(event, state);
  122740:	52                   	push   %edx
  122741:	53                   	push   %ebx
  122742:	ff d0                	call   *%eax
  122744:	5a                   	pop    %edx
		if (retcode < 0) {
  122745:	85 c0                	test   %eax,%eax
			retcode = poller->cb(event, state);
  122747:	59                   	pop    %ecx
		poller->is_polling = false;
  122748:	c6 07 00             	movb   $0x0,(%edi)
		if (retcode < 0) {
  12274b:	79 04                	jns    122751 <signal_poll_event+0x2e>
  12274d:	eb 24                	jmp    122773 <signal_poll_event+0x50>
	int retcode = 0;
  12274f:	31 c0                	xor    %eax,%eax
	event->state |= state;
  122751:	8b 4b 0c             	mov    0xc(%ebx),%ecx
	event->poller = NULL;
  122754:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
  12275b:	89 ca                	mov    %ecx,%edx
  12275d:	81 e1 ff 0f fe ff    	and    $0xfffe0fff,%ecx
  122763:	c1 ea 0c             	shr    $0xc,%edx
  122766:	09 f2                	or     %esi,%edx
  122768:	83 e2 1f             	and    $0x1f,%edx
  12276b:	c1 e2 0c             	shl    $0xc,%edx
  12276e:	09 ca                	or     %ecx,%edx
  122770:	89 53 0c             	mov    %edx,0xc(%ebx)
		}
	}

	set_event_ready(event, state);
	return retcode;
}
  122773:	8d 65 f4             	lea    -0xc(%ebp),%esp
  122776:	5b                   	pop    %ebx
  122777:	5e                   	pop    %esi
  122778:	5f                   	pop    %edi
  122779:	5d                   	pop    %ebp
  12277a:	c3                   	ret    

0012277b <k_poll_poller_cb>:
{
  12277b:	55                   	push   %ebp
  12277c:	89 e5                	mov    %esp,%ebp
  12277e:	53                   	push   %ebx
	struct k_thread *thread = event->poller->thread;
  12277f:	8b 45 08             	mov    0x8(%ebp),%eax
  122782:	8b 40 08             	mov    0x8(%eax),%eax
  122785:	8b 58 04             	mov    0x4(%eax),%ebx
	if (!z_is_thread_pending(thread)) {
  122788:	f6 43 0d 02          	testb  $0x2,0xd(%ebx)
  12278c:	74 40                	je     1227ce <k_poll_poller_cb+0x53>
	if (z_is_thread_timeout_expired(thread)) {
  12278e:	83 7b 28 ff          	cmpl   $0xffffffff,0x28(%ebx)
  122792:	75 0b                	jne    12279f <k_poll_poller_cb+0x24>
  122794:	83 7b 24 fe          	cmpl   $0xfffffffe,0x24(%ebx)
		return -EAGAIN;
  122798:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (z_is_thread_timeout_expired(thread)) {
  12279d:	74 31                	je     1227d0 <k_poll_poller_cb+0x55>
	z_unpend_thread(thread);
  12279f:	53                   	push   %ebx
  1227a0:	e8 45 ea ff ff       	call   1211ea <z_unpend_thread>
	arch_thread_return_value_set(thread,
  1227a5:	31 c0                	xor    %eax,%eax
	z_unpend_thread(thread);
  1227a7:	5a                   	pop    %edx
	arch_thread_return_value_set(thread,
  1227a8:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
  1227ac:	0f 95 c0             	setne  %al
  1227af:	8b 53 3c             	mov    0x3c(%ebx),%edx
  1227b2:	8d 04 85 fc ff ff ff 	lea    -0x4(,%eax,4),%eax
  1227b9:	89 02                	mov    %eax,(%edx)
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  1227bb:	f6 43 0d 1f          	testb  $0x1f,0xd(%ebx)
  1227bf:	75 0d                	jne    1227ce <k_poll_poller_cb+0x53>
	if (!z_is_thread_ready(thread)) {
  1227c1:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  1227c5:	75 07                	jne    1227ce <k_poll_poller_cb+0x53>
	z_ready_thread(thread);
  1227c7:	53                   	push   %ebx
  1227c8:	e8 1e eb ff ff       	call   1212eb <z_ready_thread>
  1227cd:	58                   	pop    %eax
	return 0;
  1227ce:	31 c0                	xor    %eax,%eax
}
  1227d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1227d3:	c9                   	leave  
  1227d4:	c3                   	ret    

001227d5 <add_event>:
{
  1227d5:	55                   	push   %ebp
  1227d6:	89 e5                	mov    %esp,%ebp
  1227d8:	57                   	push   %edi
  1227d9:	56                   	push   %esi
  1227da:	89 d6                	mov    %edx,%esi
  1227dc:	53                   	push   %ebx
  1227dd:	53                   	push   %ebx
  1227de:	89 c3                	mov    %eax,%ebx
  1227e0:	8b 40 04             	mov    0x4(%eax),%eax
	return sys_dlist_is_empty(list) ? NULL : list->tail;
  1227e3:	3b 1b                	cmp    (%ebx),%ebx
  1227e5:	74 20                	je     122807 <add_event+0x32>
	if ((pending == NULL) ||
  1227e7:	85 c0                	test   %eax,%eax
  1227e9:	74 1c                	je     122807 <add_event+0x32>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
  1227eb:	ff 71 04             	pushl  0x4(%ecx)
  1227ee:	8b 40 08             	mov    0x8(%eax),%eax
  1227f1:	89 cf                	mov    %ecx,%edi
  1227f3:	ff 70 04             	pushl  0x4(%eax)
  1227f6:	e8 ed e7 ff ff       	call   120fe8 <z_is_t1_higher_prio_than_t2>
  1227fb:	5a                   	pop    %edx
	if ((pending == NULL) ||
  1227fc:	84 c0                	test   %al,%al
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
  1227fe:	59                   	pop    %ecx
	if ((pending == NULL) ||
  1227ff:	75 06                	jne    122807 <add_event+0x32>
	return list->head == list;
  122801:	8b 13                	mov    (%ebx),%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
  122803:	39 d3                	cmp    %edx,%ebx
  122805:	75 19                	jne    122820 <add_event+0x4b>
	node->prev = list->tail;
  122807:	8b 43 04             	mov    0x4(%ebx),%eax
	node->next = list;
  12280a:	89 1e                	mov    %ebx,(%esi)
	node->prev = list->tail;
  12280c:	89 46 04             	mov    %eax,0x4(%esi)
	list->tail->next = node;
  12280f:	8b 43 04             	mov    0x4(%ebx),%eax
  122812:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  122814:	89 73 04             	mov    %esi,0x4(%ebx)
}
  122817:	eb 32                	jmp    12284b <add_event+0x76>
	return (node == list->tail) ? NULL : node->next;
  122819:	39 53 04             	cmp    %edx,0x4(%ebx)
  12281c:	74 e9                	je     122807 <add_event+0x32>
  12281e:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
  122820:	85 d2                	test   %edx,%edx
  122822:	74 e3                	je     122807 <add_event+0x32>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
  122824:	8b 42 08             	mov    0x8(%edx),%eax
  122827:	89 55 f0             	mov    %edx,-0x10(%ebp)
  12282a:	ff 70 04             	pushl  0x4(%eax)
  12282d:	ff 77 04             	pushl  0x4(%edi)
  122830:	e8 b3 e7 ff ff       	call   120fe8 <z_is_t1_higher_prio_than_t2>
  122835:	5a                   	pop    %edx
  122836:	84 c0                	test   %al,%al
  122838:	59                   	pop    %ecx
  122839:	8b 55 f0             	mov    -0x10(%ebp),%edx
  12283c:	74 db                	je     122819 <add_event+0x44>
	node->prev = successor->prev;
  12283e:	8b 42 04             	mov    0x4(%edx),%eax
	node->next = successor;
  122841:	89 16                	mov    %edx,(%esi)
	node->prev = successor->prev;
  122843:	89 46 04             	mov    %eax,0x4(%esi)
	successor->prev->next = node;
  122846:	89 30                	mov    %esi,(%eax)
	successor->prev = node;
  122848:	89 72 04             	mov    %esi,0x4(%edx)
}
  12284b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  12284e:	5b                   	pop    %ebx
  12284f:	5e                   	pop    %esi
  122850:	5f                   	pop    %edi
  122851:	5d                   	pop    %ebp
  122852:	c3                   	ret    

00122853 <register_events>:
{
  122853:	55                   	push   %ebp
  122854:	89 e5                	mov    %esp,%ebp
  122856:	57                   	push   %edi
  122857:	56                   	push   %esi
  122858:	89 ce                	mov    %ecx,%esi
  12285a:	53                   	push   %ebx
	for (int ii = 0; ii < num_events; ii++) {
  12285b:	31 ff                	xor    %edi,%edi
{
  12285d:	83 ec 10             	sub    $0x10,%esp
  122860:	89 c3                	mov    %eax,%ebx
  122862:	8a 4d 08             	mov    0x8(%ebp),%cl
  122865:	89 55 ec             	mov    %edx,-0x14(%ebp)
  122868:	88 4d eb             	mov    %cl,-0x15(%ebp)
	int events_registered = 0;
  12286b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for (int ii = 0; ii < num_events; ii++) {
  122872:	3b 7d ec             	cmp    -0x14(%ebp),%edi
  122875:	0f 8d be 00 00 00    	jge    122939 <register_events+0xe6>
  12287b:	9c                   	pushf  
  12287c:	fa                   	cli    
  12287d:	8f 45 e4             	popl   -0x1c(%ebp)
	switch (event->type) {
  122880:	8a 43 0d             	mov    0xd(%ebx),%al
  122883:	83 e0 0f             	and    $0xf,%eax
  122886:	3c 02                	cmp    $0x2,%al
  122888:	74 0a                	je     122894 <register_events+0x41>
  12288a:	3c 04                	cmp    $0x4,%al
  12288c:	74 16                	je     1228a4 <register_events+0x51>
  12288e:	fe c8                	dec    %al
  122890:	75 56                	jne    1228e8 <register_events+0x95>
  122892:	eb 1f                	jmp    1228b3 <register_events+0x60>
		if (k_sem_count_get(event->sem) > 0U) {
  122894:	8b 43 10             	mov    0x10(%ebx),%eax
  122897:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  12289b:	74 4b                	je     1228e8 <register_events+0x95>
			*state = K_POLL_STATE_SEM_AVAILABLE;
  12289d:	ba 02 00 00 00       	mov    $0x2,%edx
  1228a2:	eb 1d                	jmp    1228c1 <register_events+0x6e>
		if (!k_queue_is_empty(event->queue)) {
  1228a4:	8b 43 10             	mov    0x10(%ebx),%eax
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
  1228a7:	ba 04 00 00 00       	mov    $0x4,%edx
		if (!k_queue_is_empty(event->queue)) {
  1228ac:	83 38 00             	cmpl   $0x0,(%eax)
  1228af:	75 10                	jne    1228c1 <register_events+0x6e>
  1228b1:	eb 35                	jmp    1228e8 <register_events+0x95>
		if (event->signal->signaled != 0U) {
  1228b3:	8b 43 10             	mov    0x10(%ebx),%eax
			*state = K_POLL_STATE_SIGNALED;
  1228b6:	ba 01 00 00 00       	mov    $0x1,%edx
		if (event->signal->signaled != 0U) {
  1228bb:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  1228bf:	74 27                	je     1228e8 <register_events+0x95>
	event->state |= state;
  1228c1:	8b 4b 0c             	mov    0xc(%ebx),%ecx
	event->poller = NULL;
  1228c4:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	event->state |= state;
  1228cb:	89 c8                	mov    %ecx,%eax
  1228cd:	81 e1 ff 0f fe ff    	and    $0xfffe0fff,%ecx
  1228d3:	c1 e8 0c             	shr    $0xc,%eax
  1228d6:	83 e0 1f             	and    $0x1f,%eax
  1228d9:	09 d0                	or     %edx,%eax
  1228db:	c1 e0 0c             	shl    $0xc,%eax
  1228de:	09 c8                	or     %ecx,%eax
  1228e0:	89 43 0c             	mov    %eax,0xc(%ebx)
			poller->is_polling = false;
  1228e3:	c6 06 00             	movb   $0x0,(%esi)
  1228e6:	eb 40                	jmp    122928 <register_events+0xd5>
		} else if (!just_check && poller->is_polling) {
  1228e8:	80 7d eb 00          	cmpb   $0x0,-0x15(%ebp)
  1228ec:	75 3a                	jne    122928 <register_events+0xd5>
  1228ee:	8a 06                	mov    (%esi),%al
  1228f0:	84 c0                	test   %al,%al
  1228f2:	74 34                	je     122928 <register_events+0xd5>
	switch (event->type) {
  1228f4:	8a 43 0d             	mov    0xd(%ebx),%al
  1228f7:	83 e0 0f             	and    $0xf,%eax
  1228fa:	3c 02                	cmp    $0x2,%al
  1228fc:	74 0d                	je     12290b <register_events+0xb8>
  1228fe:	3c 04                	cmp    $0x4,%al
  122900:	74 11                	je     122913 <register_events+0xc0>
  122902:	fe c8                	dec    %al
  122904:	75 1c                	jne    122922 <register_events+0xcf>
		add_event(&event->signal->poll_events, event, poller);
  122906:	8b 43 10             	mov    0x10(%ebx),%eax
  122909:	eb 0e                	jmp    122919 <register_events+0xc6>
		add_event(&event->sem->poll_events, event, poller);
  12290b:	8b 43 10             	mov    0x10(%ebx),%eax
  12290e:	83 c0 18             	add    $0x18,%eax
  122911:	eb 06                	jmp    122919 <register_events+0xc6>
		add_event(&event->queue->poll_events, event, poller);
  122913:	8b 43 10             	mov    0x10(%ebx),%eax
  122916:	83 c0 1c             	add    $0x1c,%eax
		add_event(&event->signal->poll_events, event, poller);
  122919:	89 f1                	mov    %esi,%ecx
  12291b:	89 da                	mov    %ebx,%edx
  12291d:	e8 b3 fe ff ff       	call   1227d5 <add_event>
				events_registered += 1;
  122922:	ff 45 f0             	incl   -0x10(%ebp)
	event->poller = poller;
  122925:	89 73 08             	mov    %esi,0x8(%ebx)
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122928:	0f ba 65 e4 09       	btl    $0x9,-0x1c(%ebp)
  12292d:	73 01                	jae    122930 <register_events+0xdd>
		__asm__ volatile ("sti" ::: "memory");
  12292f:	fb                   	sti    
	for (int ii = 0; ii < num_events; ii++) {
  122930:	47                   	inc    %edi
  122931:	83 c3 14             	add    $0x14,%ebx
  122934:	e9 39 ff ff ff       	jmp    122872 <register_events+0x1f>
}
  122939:	8b 45 f0             	mov    -0x10(%ebp),%eax
  12293c:	83 c4 10             	add    $0x10,%esp
  12293f:	5b                   	pop    %ebx
  122940:	5e                   	pop    %esi
  122941:	5f                   	pop    %edi
  122942:	5d                   	pop    %ebp
  122943:	c3                   	ret    

00122944 <k_poll_event_init>:
{
  122944:	55                   	push   %ebp
  122945:	89 e5                	mov    %esp,%ebp
	event->type = type;
  122947:	8b 45 10             	mov    0x10(%ebp),%eax
  12294a:	8b 55 0c             	mov    0xc(%ebp),%edx
  12294d:	c1 e0 11             	shl    $0x11,%eax
{
  122950:	8b 4d 08             	mov    0x8(%ebp),%ecx
	event->type = type;
  122953:	c1 e2 08             	shl    $0x8,%edx
  122956:	25 00 00 02 00       	and    $0x20000,%eax
  12295b:	81 e2 00 0f 00 00    	and    $0xf00,%edx
	event->poller = NULL;
  122961:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
	event->type = type;
  122968:	09 d0                	or     %edx,%eax
  12296a:	0f b6 51 0c          	movzbl 0xc(%ecx),%edx
  12296e:	09 d0                	or     %edx,%eax
  122970:	89 41 0c             	mov    %eax,0xc(%ecx)
	event->obj = obj;
  122973:	8b 45 14             	mov    0x14(%ebp),%eax
  122976:	89 41 10             	mov    %eax,0x10(%ecx)
}
  122979:	5d                   	pop    %ebp
  12297a:	c3                   	ret    

0012297b <z_impl_k_poll>:
{
  12297b:	55                   	push   %ebp
  12297c:	89 e5                	mov    %esp,%ebp
  12297e:	57                   	push   %edi
  12297f:	56                   	push   %esi
  122980:	53                   	push   %ebx
	events_registered = register_events(events, num_events, &poller,
  122981:	8d 4d d8             	lea    -0x28(%ebp),%ecx
{
  122984:	83 ec 28             	sub    $0x28,%esp
	struct _poller poller = { .is_polling = true,
  122987:	c6 45 d8 01          	movb   $0x1,-0x28(%ebp)
{
  12298b:	8b 75 10             	mov    0x10(%ebp),%esi
  12298e:	8b 7d 14             	mov    0x14(%ebp),%edi
  122991:	89 7d d0             	mov    %edi,-0x30(%ebp)
	struct _poller poller = { .is_polling = true,
  122994:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
	events_registered = register_events(events, num_events, &poller,
  122999:	89 f7                	mov    %esi,%edi
	struct _poller poller = { .is_polling = true,
  12299b:	89 45 dc             	mov    %eax,-0x24(%ebp)
	events_registered = register_events(events, num_events, &poller,
  12299e:	31 c0                	xor    %eax,%eax
  1229a0:	0b 7d d0             	or     -0x30(%ebp),%edi
  1229a3:	0f 94 c0             	sete   %al
  1229a6:	50                   	push   %eax
  1229a7:	8b 55 0c             	mov    0xc(%ebp),%edx
  1229aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1229ad:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	struct _poller poller = { .is_polling = true,
  1229b0:	c7 45 e0 7b 27 12 00 	movl   $0x12277b,-0x20(%ebp)
	events_registered = register_events(events, num_events, &poller,
  1229b7:	e8 97 fe ff ff       	call   122853 <register_events>
  1229bc:	5a                   	pop    %edx
  1229bd:	89 c2                	mov    %eax,%edx
  1229bf:	9c                   	pushf  
  1229c0:	fa                   	cli    
  1229c1:	5b                   	pop    %ebx
	if (!poller.is_polling) {
  1229c2:	8a 45 d8             	mov    -0x28(%ebp),%al
  1229c5:	84 c0                	test   %al,%al
  1229c7:	75 0e                	jne    1229d7 <z_impl_k_poll+0x5c>
		clear_event_registrations(events, events_registered, key);
  1229c9:	89 d9                	mov    %ebx,%ecx
  1229cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1229ce:	e8 f2 fc ff ff       	call   1226c5 <clear_event_registrations>
		return 0;
  1229d3:	31 f6                	xor    %esi,%esi
  1229d5:	eb 4f                	jmp    122a26 <z_impl_k_poll+0xab>
	poller.is_polling = false;
  1229d7:	c6 45 d8 00          	movb   $0x0,-0x28(%ebp)
		return -EAGAIN;
  1229db:	be f5 ff ff ff       	mov    $0xfffffff5,%esi
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  1229e0:	85 ff                	test   %edi,%edi
  1229e2:	74 42                	je     122a26 <z_impl_k_poll+0xab>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
  1229e4:	31 c0                	xor    %eax,%eax
  1229e6:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  1229e9:	b9 04 00 00 00       	mov    $0x4,%ecx
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  1229ee:	8b 75 d4             	mov    -0x2c(%ebp),%esi
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
  1229f1:	f3 ab                	rep stos %eax,%es:(%edi)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  1229f3:	8b 7d d0             	mov    -0x30(%ebp),%edi
  1229f6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  1229f9:	57                   	push   %edi
  1229fa:	89 55 cc             	mov    %edx,-0x34(%ebp)
  1229fd:	56                   	push   %esi
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
  1229fe:	c7 45 e8 c4 0f 12 00 	movl   $0x120fc4,-0x18(%ebp)
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
  122a05:	50                   	push   %eax
  122a06:	53                   	push   %ebx
  122a07:	68 87 ed 12 00       	push   $0x12ed87
  122a0c:	e8 78 ec ff ff       	call   121689 <z_pend_curr>
  122a11:	83 c4 14             	add    $0x14,%esp
  122a14:	89 c6                	mov    %eax,%esi
  122a16:	9c                   	pushf  
  122a17:	fa                   	cli    
  122a18:	5b                   	pop    %ebx
	clear_event_registrations(events, events_registered, key);
  122a19:	89 d9                	mov    %ebx,%ecx
  122a1b:	8b 55 cc             	mov    -0x34(%ebp),%edx
  122a1e:	8b 45 08             	mov    0x8(%ebp),%eax
  122a21:	e8 9f fc ff ff       	call   1226c5 <clear_event_registrations>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122a26:	0f ba e3 09          	bt     $0x9,%ebx
  122a2a:	73 01                	jae    122a2d <z_impl_k_poll+0xb2>
		__asm__ volatile ("sti" ::: "memory");
  122a2c:	fb                   	sti    
}
  122a2d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  122a30:	89 f0                	mov    %esi,%eax
  122a32:	5b                   	pop    %ebx
  122a33:	5e                   	pop    %esi
  122a34:	5f                   	pop    %edi
  122a35:	5d                   	pop    %ebp
  122a36:	c3                   	ret    

00122a37 <z_handle_obj_poll_events>:

void z_handle_obj_poll_events(sys_dlist_t *events, uint32_t state)
{
  122a37:	55                   	push   %ebp
  122a38:	89 e5                	mov    %esp,%ebp
  122a3a:	53                   	push   %ebx
  122a3b:	8b 55 08             	mov    0x8(%ebp),%edx
  122a3e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return list->head == list;
  122a41:	8b 02                	mov    (%edx),%eax

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  122a43:	39 c2                	cmp    %eax,%edx
  122a45:	74 20                	je     122a67 <z_handle_obj_poll_events+0x30>
	node->prev->next = node->next;
  122a47:	8b 10                	mov    (%eax),%edx
  122a49:	8b 48 04             	mov    0x4(%eax),%ecx
  122a4c:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
  122a4e:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
  122a51:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  122a57:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
  122a5e:	89 da                	mov    %ebx,%edx
	}
}
  122a60:	5b                   	pop    %ebx
  122a61:	5d                   	pop    %ebp
		(void) signal_poll_event(poll_event, state);
  122a62:	e9 bc fc ff ff       	jmp    122723 <signal_poll_event>
}
  122a67:	5b                   	pop    %ebx
  122a68:	5d                   	pop    %ebp
  122a69:	c3                   	ret    

00122a6a <z_impl_k_poll_signal_init>:

void z_impl_k_poll_signal_init(struct k_poll_signal *signal)
{
  122a6a:	55                   	push   %ebp
  122a6b:	89 e5                	mov    %esp,%ebp
  122a6d:	8b 45 08             	mov    0x8(%ebp),%eax
	list->head = (sys_dnode_t *)list;
  122a70:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  122a72:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&signal->poll_events);
	signal->signaled = 0U;
  122a75:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	/* signal->result is left unitialized */
	z_object_init(signal);
}
  122a7c:	5d                   	pop    %ebp
  122a7d:	c3                   	ret    

00122a7e <z_impl_k_poll_signal_check>:
#include <syscalls/k_poll_signal_init_mrsh.c>
#endif

void z_impl_k_poll_signal_check(struct k_poll_signal *signal,
			       unsigned int *signaled, int *result)
{
  122a7e:	55                   	push   %ebp
  122a7f:	89 e5                	mov    %esp,%ebp
  122a81:	8b 45 08             	mov    0x8(%ebp),%eax
	*signaled = signal->signaled;
  122a84:	8b 55 0c             	mov    0xc(%ebp),%edx
  122a87:	8b 48 08             	mov    0x8(%eax),%ecx
  122a8a:	89 0a                	mov    %ecx,(%edx)
	*result = signal->result;
  122a8c:	8b 50 0c             	mov    0xc(%eax),%edx
  122a8f:	8b 45 10             	mov    0x10(%ebp),%eax
  122a92:	89 10                	mov    %edx,(%eax)
}
  122a94:	5d                   	pop    %ebp
  122a95:	c3                   	ret    

00122a96 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
  122a96:	55                   	push   %ebp
  122a97:	89 e5                	mov    %esp,%ebp
  122a99:	53                   	push   %ebx
  122a9a:	51                   	push   %ecx
  122a9b:	8b 55 08             	mov    0x8(%ebp),%edx
  122a9e:	9c                   	pushf  
  122a9f:	fa                   	cli    
  122aa0:	5b                   	pop    %ebx
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
  122aa1:	8b 45 0c             	mov    0xc(%ebp),%eax
	signal->signaled = 1U;
  122aa4:	c7 42 08 01 00 00 00 	movl   $0x1,0x8(%edx)
	signal->result = result;
  122aab:	89 42 0c             	mov    %eax,0xc(%edx)
	return list->head == list;
  122aae:	8b 02                	mov    (%edx),%eax
	if (!sys_dlist_is_empty(list)) {
  122ab0:	39 c2                	cmp    %eax,%edx
  122ab2:	75 09                	jne    122abd <z_impl_k_poll_signal_raise+0x27>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122ab4:	0f ba e3 09          	bt     $0x9,%ebx
  122ab8:	73 39                	jae    122af3 <z_impl_k_poll_signal_raise+0x5d>
		__asm__ volatile ("sti" ::: "memory");
  122aba:	fb                   	sti    
  122abb:	eb 36                	jmp    122af3 <z_impl_k_poll_signal_raise+0x5d>
	node->prev->next = node->next;
  122abd:	8b 48 04             	mov    0x4(%eax),%ecx
  122ac0:	8b 10                	mov    (%eax),%edx
  122ac2:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
  122ac4:	89 4a 04             	mov    %ecx,0x4(%edx)
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
  122ac7:	ba 01 00 00 00       	mov    $0x1,%edx
	node->next = NULL;
  122acc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
  122ad2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  122ad9:	e8 45 fc ff ff       	call   122723 <signal_poll_event>

	z_reschedule(&lock, key);
  122ade:	53                   	push   %ebx
  122adf:	68 87 ed 12 00       	push   $0x12ed87
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
  122ae4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	z_reschedule(&lock, key);
  122ae7:	e8 d2 e5 ff ff       	call   1210be <z_reschedule>
  122aec:	58                   	pop    %eax
  122aed:	5a                   	pop    %edx
	return rc;
  122aee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  122af1:	eb 02                	jmp    122af5 <z_impl_k_poll_signal_raise+0x5f>
		return 0;
  122af3:	31 c0                	xor    %eax,%eax
}
  122af5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  122af8:	c9                   	leave  
  122af9:	c3                   	ret    

00122afa <k_mem_pool_malloc>:
{
	k_mem_pool_free_id(&block->id);
}

void *k_mem_pool_malloc(struct k_mem_pool *pool, size_t size)
{
  122afa:	55                   	push   %ebp
	 * get a block large enough to hold an initial (hidden) block
	 * descriptor, as well as the space the caller requested
	 */
	if (size_add_overflow(size, WB_UP(sizeof(struct k_mem_block_id)),
			      &size)) {
		return NULL;
  122afb:	31 c0                	xor    %eax,%eax
{
  122afd:	89 e5                	mov    %esp,%ebp
  122aff:	53                   	push   %ebx
  122b00:	83 ec 08             	sub    $0x8,%esp
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
  122b03:	8b 55 0c             	mov    0xc(%ebp),%edx
  122b06:	83 c2 08             	add    $0x8,%edx
  122b09:	72 30                	jb     122b3b <k_mem_pool_malloc+0x41>
	}
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
  122b0b:	6a 00                	push   $0x0
  122b0d:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  122b10:	6a 00                	push   $0x0
  122b12:	52                   	push   %edx
  122b13:	53                   	push   %ebx
  122b14:	ff 75 08             	pushl  0x8(%ebp)
  122b17:	e8 d6 dc ff ff       	call   1207f2 <k_mem_pool_alloc>
  122b1c:	83 c4 14             	add    $0x14,%esp
  122b1f:	85 c0                	test   %eax,%eax
  122b21:	74 04                	je     122b27 <k_mem_pool_malloc+0x2d>
		return NULL;
  122b23:	31 c0                	xor    %eax,%eax
  122b25:	eb 14                	jmp    122b3b <k_mem_pool_malloc+0x41>
	}

	/* save the block descriptor info at the start of the actual block */
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
  122b27:	6a 08                	push   $0x8
  122b29:	53                   	push   %ebx
  122b2a:	ff 75 f4             	pushl  -0xc(%ebp)
  122b2d:	e8 ba 92 fe ff       	call   10bdec <memcpy>

	/* return address of the user area part of the block to the caller */
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
  122b32:	8b 45 f4             	mov    -0xc(%ebp),%eax
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
  122b35:	83 c4 0c             	add    $0xc,%esp
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
  122b38:	83 c0 08             	add    $0x8,%eax
}
  122b3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  122b3e:	c9                   	leave  
  122b3f:	c3                   	ret    

00122b40 <k_free>:

void k_free(void *ptr)
{
  122b40:	55                   	push   %ebp
  122b41:	89 e5                	mov    %esp,%ebp
  122b43:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ptr != NULL) {
  122b46:	85 c0                	test   %eax,%eax
  122b48:	74 0c                	je     122b56 <k_free+0x16>
		/* point to hidden block descriptor at start of block */
		ptr = (char *)ptr - WB_UP(sizeof(struct k_mem_block_id));
  122b4a:	83 e8 08             	sub    $0x8,%eax

		/* return block to the heap memory pool */
		k_mem_pool_free_id(ptr);
  122b4d:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  122b50:	5d                   	pop    %ebp
		k_mem_pool_free_id(ptr);
  122b51:	e9 e8 dc ff ff       	jmp    12083e <k_mem_pool_free_id>
}
  122b56:	5d                   	pop    %ebp
  122b57:	c3                   	ret    

00122b58 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
  122b58:	55                   	push   %ebp
  122b59:	89 e5                	mov    %esp,%ebp
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
  122b5b:	e8 3d ee ff ff       	call   12199d <k_is_in_isr>
  122b60:	88 c2                	mov    %al,%dl
	}

	if (pool) {
		ret = k_mem_pool_malloc(pool, size);
	} else {
		ret = NULL;
  122b62:	31 c0                	xor    %eax,%eax
	if (k_is_in_isr()) {
  122b64:	84 d2                	test   %dl,%dl
  122b66:	75 1a                	jne    122b82 <z_thread_malloc+0x2a>
		pool = _current->resource_pool;
  122b68:	a1 c8 e9 12 00       	mov    0x12e9c8,%eax
  122b6d:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
	if (pool) {
  122b73:	85 c0                	test   %eax,%eax
  122b75:	74 0b                	je     122b82 <z_thread_malloc+0x2a>
		ret = k_mem_pool_malloc(pool, size);
  122b77:	ff 75 08             	pushl  0x8(%ebp)
  122b7a:	50                   	push   %eax
  122b7b:	e8 7a ff ff ff       	call   122afa <k_mem_pool_malloc>
  122b80:	5a                   	pop    %edx
  122b81:	59                   	pop    %ecx
	}

	return ret;
}
  122b82:	c9                   	leave  
  122b83:	c3                   	ret    

00122b84 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
  122b84:	55                   	push   %ebp
  122b85:	89 e5                	mov    %esp,%ebp
  122b87:	53                   	push   %ebx
  122b88:	8b 5d 08             	mov    0x8(%ebp),%ebx
  122b8b:	9c                   	pushf  
  122b8c:	fa                   	cli    
  122b8d:	58                   	pop    %eax
	while (true) {
		/* Lock interrupts to atomically check if to_abort is non-NULL,
		 * and if so clear it
		 */
		int key = arch_irq_lock();
		struct k_thread *to_abort = cpu->pending_abort;
  122b8e:	8b 53 10             	mov    0x10(%ebx),%edx

		if (to_abort) {
  122b91:	85 d2                	test   %edx,%edx
  122b93:	74 22                	je     122bb7 <idle+0x33>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122b95:	0f ba e0 09          	bt     $0x9,%eax
			cpu->pending_abort = NULL;
  122b99:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  122ba0:	73 01                	jae    122ba3 <idle+0x1f>
		__asm__ volatile ("sti" ::: "memory");
  122ba2:	fb                   	sti    
			 * is continued below.
			 */
			LOG_DBG("idle %p aborting thread %p",
				_current, to_abort);

			z_thread_single_abort(to_abort);
  122ba3:	52                   	push   %edx
  122ba4:	e8 d4 e8 ff ff       	call   12147d <z_thread_single_abort>
  122ba9:	9c                   	pushf  
  122baa:	fa                   	cli    
  122bab:	58                   	pop    %eax
	(void) z_reschedule_irqlock(arch_irq_lock());
  122bac:	89 04 24             	mov    %eax,(%esp)
  122baf:	e8 39 e5 ff ff       	call   1210ed <z_reschedule_irqlock>
  122bb4:	59                   	pop    %ecx
			 * in order to abort the thread, and we now need to
			 * figure out what to do next, it's not necessarily
			 * the case that there are no other runnable threads.
			 */
			z_reschedule_unlocked();
			continue;
  122bb5:	eb d4                	jmp    122b8b <idle+0x7>
	if ((key & 0x00000200U) != 0U) { /* 'IF' bit */
  122bb7:	0f ba e0 09          	bt     $0x9,%eax
  122bbb:	73 01                	jae    122bbe <idle+0x3a>
		__asm__ volatile ("sti" ::: "memory");
  122bbd:	fb                   	sti    
  122bbe:	9c                   	pushf  
  122bbf:	fa                   	cli    
  122bc0:	58                   	pop    %eax
	int32_t ticks = z_get_next_timeout_expiry();
  122bc1:	e8 47 f6 ff ff       	call   12220d <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
  122bc6:	83 f8 02             	cmp    $0x2,%eax
  122bc9:	7f 05                	jg     122bd0 <idle+0x4c>
  122bcb:	b8 01 00 00 00       	mov    $0x1,%eax
  122bd0:	6a 01                	push   $0x1
  122bd2:	50                   	push   %eax
  122bd3:	e8 4b f6 ff ff       	call   122223 <z_set_timeout_expiry>
  122bd8:	58                   	pop    %eax
  122bd9:	5a                   	pop    %edx
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  122bda:	e8 2f 80 fe ff       	call   10ac0e <arch_cpu_idle>
}
  122bdf:	eb aa                	jmp    122b8b <idle+0x7>

00122be1 <_OffsetAbsSyms>:
#include "ia32_offsets.c"
#endif

GEN_OFFSET_SYM(_thread_arch_t, flags);

GEN_ABS_SYM_END
  122be1:	c3                   	ret    

00122be2 <_handle_exc_0_vector_0_stub>:
  122be2:	6a 00                	push   $0x0
  122be4:	68 de b8 10 00       	push   $0x10b8de
  122be9:	e9 5d 8b fe ff       	jmp    10b74b <_exception_enter>

00122bee <_handle_exc_2_vector_2_stub>:
  122bee:	6a 00                	push   $0x0
  122bf0:	68 eb b8 10 00       	push   $0x10b8eb
  122bf5:	e9 51 8b fe ff       	jmp    10b74b <_exception_enter>

00122bfa <_handle_exc_4_vector_4_stub>:
  122bfa:	6a 00                	push   $0x0
  122bfc:	68 f8 b8 10 00       	push   $0x10b8f8
  122c01:	e9 45 8b fe ff       	jmp    10b74b <_exception_enter>

00122c06 <_handle_exc_5_vector_5_stub>:
  122c06:	6a 00                	push   $0x0
  122c08:	68 05 b9 10 00       	push   $0x10b905
  122c0d:	e9 39 8b fe ff       	jmp    10b74b <_exception_enter>

00122c12 <_handle_exc_6_vector_6_stub>:
  122c12:	6a 00                	push   $0x0
  122c14:	68 12 b9 10 00       	push   $0x10b912
  122c19:	e9 2d 8b fe ff       	jmp    10b74b <_exception_enter>

00122c1e <_handle_exc_7_vector_7_stub>:
  122c1e:	6a 00                	push   $0x0
  122c20:	68 1f b9 10 00       	push   $0x10b91f
  122c25:	e9 21 8b fe ff       	jmp    10b74b <_exception_enter>

00122c2a <_handle_exc_8_vector_8_stub>:
  122c2a:	6a 00                	push   $0x0
  122c2c:	68 2c b9 10 00       	push   $0x10b92c
  122c31:	e9 15 8b fe ff       	jmp    10b74b <_exception_enter>

00122c36 <_handle_exc_10_vector_10_stub>:
  122c36:	68 39 b9 10 00       	push   $0x10b939
  122c3b:	e9 0b 8b fe ff       	jmp    10b74b <_exception_enter>

00122c40 <_handle_exc_11_vector_11_stub>:
  122c40:	68 46 b9 10 00       	push   $0x10b946
  122c45:	e9 01 8b fe ff       	jmp    10b74b <_exception_enter>

00122c4a <_handle_exc_12_vector_12_stub>:
  122c4a:	68 53 b9 10 00       	push   $0x10b953
  122c4f:	e9 f7 8a fe ff       	jmp    10b74b <_exception_enter>

00122c54 <_handle_exc_13_vector_13_stub>:
  122c54:	68 60 b9 10 00       	push   $0x10b960
  122c59:	e9 ed 8a fe ff       	jmp    10b74b <_exception_enter>

00122c5e <_handle_exc_16_vector_16_stub>:
  122c5e:	6a 00                	push   $0x0
  122c60:	68 6d b9 10 00       	push   $0x10b96d
  122c65:	e9 e1 8a fe ff       	jmp    10b74b <_exception_enter>

00122c6a <_handle_exc_17_vector_17_stub>:
  122c6a:	68 7a b9 10 00       	push   $0x10b97a
  122c6f:	e9 d7 8a fe ff       	jmp    10b74b <_exception_enter>

00122c74 <_handle_exc_18_vector_18_stub>:
  122c74:	6a 00                	push   $0x0
  122c76:	68 87 b9 10 00       	push   $0x10b987
  122c7b:	e9 cb 8a fe ff       	jmp    10b74b <_exception_enter>

00122c80 <_z_x86_page_fault_handler_vector_14_stub>:
  122c80:	68 ca b1 10 00       	push   $0x10b1ca
  122c85:	e9 c1 8a fe ff       	jmp    10b74b <_exception_enter>
  122c8a:	66 90                	xchg   %ax,%ax
  122c8c:	66 90                	xchg   %ax,%ax
  122c8e:	66 90                	xchg   %ax,%ax
  122c90:	66 90                	xchg   %ax,%ax
  122c92:	66 90                	xchg   %ax,%ax
  122c94:	66 90                	xchg   %ax,%ax
  122c96:	66 90                	xchg   %ax,%ax
  122c98:	66 90                	xchg   %ax,%ax
  122c9a:	66 90                	xchg   %ax,%ax
  122c9c:	66 90                	xchg   %ax,%ax
  122c9e:	66 90                	xchg   %ax,%ax
  122ca0:	66 90                	xchg   %ax,%ax
  122ca2:	66 90                	xchg   %ax,%ax
  122ca4:	66 90                	xchg   %ax,%ax
  122ca6:	66 90                	xchg   %ax,%ax
  122ca8:	66 90                	xchg   %ax,%ax
  122caa:	66 90                	xchg   %ax,%ax
  122cac:	66 90                	xchg   %ax,%ax
  122cae:	66 90                	xchg   %ax,%ax
  122cb0:	66 90                	xchg   %ax,%ax
  122cb2:	66 90                	xchg   %ax,%ax
  122cb4:	66 90                	xchg   %ax,%ax
  122cb6:	66 90                	xchg   %ax,%ax
  122cb8:	66 90                	xchg   %ax,%ax
  122cba:	66 90                	xchg   %ax,%ax
  122cbc:	66 90                	xchg   %ax,%ax
  122cbe:	66 90                	xchg   %ax,%ax
  122cc0:	66 90                	xchg   %ax,%ax
  122cc2:	66 90                	xchg   %ax,%ax
  122cc4:	66 90                	xchg   %ax,%ax
  122cc6:	66 90                	xchg   %ax,%ax
  122cc8:	66 90                	xchg   %ax,%ax
  122cca:	66 90                	xchg   %ax,%ax
  122ccc:	66 90                	xchg   %ax,%ax
  122cce:	66 90                	xchg   %ax,%ax
  122cd0:	66 90                	xchg   %ax,%ax
  122cd2:	66 90                	xchg   %ax,%ax
  122cd4:	66 90                	xchg   %ax,%ax
  122cd6:	66 90                	xchg   %ax,%ax
  122cd8:	66 90                	xchg   %ax,%ax
  122cda:	66 90                	xchg   %ax,%ax
  122cdc:	66 90                	xchg   %ax,%ax
  122cde:	66 90                	xchg   %ax,%ax
  122ce0:	66 90                	xchg   %ax,%ax
  122ce2:	66 90                	xchg   %ax,%ax
  122ce4:	66 90                	xchg   %ax,%ax
  122ce6:	66 90                	xchg   %ax,%ax
  122ce8:	66 90                	xchg   %ax,%ax
  122cea:	66 90                	xchg   %ax,%ax
  122cec:	66 90                	xchg   %ax,%ax
  122cee:	66 90                	xchg   %ax,%ax
  122cf0:	66 90                	xchg   %ax,%ax
  122cf2:	66 90                	xchg   %ax,%ax
  122cf4:	66 90                	xchg   %ax,%ax
  122cf6:	66 90                	xchg   %ax,%ax
  122cf8:	66 90                	xchg   %ax,%ax
  122cfa:	66 90                	xchg   %ax,%ax
  122cfc:	66 90                	xchg   %ax,%ax
  122cfe:	66 90                	xchg   %ax,%ax
  122d00:	66 90                	xchg   %ax,%ax
  122d02:	66 90                	xchg   %ax,%ax
  122d04:	66 90                	xchg   %ax,%ax
  122d06:	66 90                	xchg   %ax,%ax
  122d08:	66 90                	xchg   %ax,%ax
  122d0a:	66 90                	xchg   %ax,%ax
  122d0c:	66 90                	xchg   %ax,%ax
  122d0e:	66 90                	xchg   %ax,%ax
  122d10:	66 90                	xchg   %ax,%ax
  122d12:	66 90                	xchg   %ax,%ax
  122d14:	66 90                	xchg   %ax,%ax
  122d16:	66 90                	xchg   %ax,%ax
  122d18:	66 90                	xchg   %ax,%ax
  122d1a:	66 90                	xchg   %ax,%ax
  122d1c:	66 90                	xchg   %ax,%ax
  122d1e:	66 90                	xchg   %ax,%ax
  122d20:	66 90                	xchg   %ax,%ax
  122d22:	66 90                	xchg   %ax,%ax
  122d24:	66 90                	xchg   %ax,%ax
  122d26:	66 90                	xchg   %ax,%ax
  122d28:	66 90                	xchg   %ax,%ax
  122d2a:	66 90                	xchg   %ax,%ax
  122d2c:	66 90                	xchg   %ax,%ax
  122d2e:	66 90                	xchg   %ax,%ax
  122d30:	66 90                	xchg   %ax,%ax
  122d32:	66 90                	xchg   %ax,%ax
  122d34:	66 90                	xchg   %ax,%ax
  122d36:	66 90                	xchg   %ax,%ax
  122d38:	66 90                	xchg   %ax,%ax
  122d3a:	66 90                	xchg   %ax,%ax
  122d3c:	66 90                	xchg   %ax,%ax
  122d3e:	66 90                	xchg   %ax,%ax
  122d40:	66 90                	xchg   %ax,%ax
  122d42:	66 90                	xchg   %ax,%ax
  122d44:	66 90                	xchg   %ax,%ax
  122d46:	66 90                	xchg   %ax,%ax
  122d48:	66 90                	xchg   %ax,%ax
  122d4a:	66 90                	xchg   %ax,%ax
  122d4c:	66 90                	xchg   %ax,%ax
  122d4e:	66 90                	xchg   %ax,%ax
  122d50:	66 90                	xchg   %ax,%ax
  122d52:	66 90                	xchg   %ax,%ax
  122d54:	66 90                	xchg   %ax,%ax
  122d56:	66 90                	xchg   %ax,%ax
  122d58:	66 90                	xchg   %ax,%ax
  122d5a:	66 90                	xchg   %ax,%ax
  122d5c:	66 90                	xchg   %ax,%ax
  122d5e:	66 90                	xchg   %ax,%ax
  122d60:	66 90                	xchg   %ax,%ax
  122d62:	66 90                	xchg   %ax,%ax
  122d64:	66 90                	xchg   %ax,%ax
  122d66:	66 90                	xchg   %ax,%ax
  122d68:	66 90                	xchg   %ax,%ax
  122d6a:	66 90                	xchg   %ax,%ax
  122d6c:	66 90                	xchg   %ax,%ax
  122d6e:	66 90                	xchg   %ax,%ax
  122d70:	66 90                	xchg   %ax,%ax
  122d72:	66 90                	xchg   %ax,%ax
  122d74:	66 90                	xchg   %ax,%ax
  122d76:	66 90                	xchg   %ax,%ax
  122d78:	66 90                	xchg   %ax,%ax
  122d7a:	66 90                	xchg   %ax,%ax
  122d7c:	66 90                	xchg   %ax,%ax
  122d7e:	66 90                	xchg   %ax,%ax
  122d80:	66 90                	xchg   %ax,%ax
  122d82:	66 90                	xchg   %ax,%ax
  122d84:	66 90                	xchg   %ax,%ax
  122d86:	66 90                	xchg   %ax,%ax
  122d88:	66 90                	xchg   %ax,%ax
  122d8a:	66 90                	xchg   %ax,%ax
  122d8c:	66 90                	xchg   %ax,%ax
  122d8e:	66 90                	xchg   %ax,%ax
  122d90:	66 90                	xchg   %ax,%ax
  122d92:	66 90                	xchg   %ax,%ax
  122d94:	66 90                	xchg   %ax,%ax
  122d96:	66 90                	xchg   %ax,%ax
  122d98:	66 90                	xchg   %ax,%ax
  122d9a:	66 90                	xchg   %ax,%ax
  122d9c:	66 90                	xchg   %ax,%ax
  122d9e:	66 90                	xchg   %ax,%ax
  122da0:	66 90                	xchg   %ax,%ax
  122da2:	66 90                	xchg   %ax,%ax
  122da4:	66 90                	xchg   %ax,%ax
  122da6:	66 90                	xchg   %ax,%ax
  122da8:	66 90                	xchg   %ax,%ax
  122daa:	66 90                	xchg   %ax,%ax
  122dac:	66 90                	xchg   %ax,%ax
  122dae:	66 90                	xchg   %ax,%ax
  122db0:	66 90                	xchg   %ax,%ax
  122db2:	66 90                	xchg   %ax,%ax
  122db4:	66 90                	xchg   %ax,%ax
  122db6:	66 90                	xchg   %ax,%ax
  122db8:	66 90                	xchg   %ax,%ax
  122dba:	66 90                	xchg   %ax,%ax
  122dbc:	66 90                	xchg   %ax,%ax
  122dbe:	66 90                	xchg   %ax,%ax
  122dc0:	66 90                	xchg   %ax,%ax
  122dc2:	66 90                	xchg   %ax,%ax
  122dc4:	66 90                	xchg   %ax,%ax
  122dc6:	66 90                	xchg   %ax,%ax
  122dc8:	66 90                	xchg   %ax,%ax
  122dca:	66 90                	xchg   %ax,%ax
  122dcc:	66 90                	xchg   %ax,%ax
  122dce:	66 90                	xchg   %ax,%ax
  122dd0:	66 90                	xchg   %ax,%ax
  122dd2:	66 90                	xchg   %ax,%ax
  122dd4:	66 90                	xchg   %ax,%ax
  122dd6:	66 90                	xchg   %ax,%ax
  122dd8:	66 90                	xchg   %ax,%ax
  122dda:	66 90                	xchg   %ax,%ax
  122ddc:	66 90                	xchg   %ax,%ax
  122dde:	66 90                	xchg   %ax,%ax
  122de0:	66 90                	xchg   %ax,%ax
  122de2:	66 90                	xchg   %ax,%ax
  122de4:	66 90                	xchg   %ax,%ax
  122de6:	66 90                	xchg   %ax,%ax
  122de8:	66 90                	xchg   %ax,%ax
  122dea:	66 90                	xchg   %ax,%ax
  122dec:	66 90                	xchg   %ax,%ax
  122dee:	66 90                	xchg   %ax,%ax
  122df0:	66 90                	xchg   %ax,%ax
  122df2:	66 90                	xchg   %ax,%ax
  122df4:	66 90                	xchg   %ax,%ax
  122df6:	66 90                	xchg   %ax,%ax
  122df8:	66 90                	xchg   %ax,%ax
  122dfa:	66 90                	xchg   %ax,%ax
  122dfc:	66 90                	xchg   %ax,%ax
  122dfe:	66 90                	xchg   %ax,%ax
  122e00:	66 90                	xchg   %ax,%ax
  122e02:	66 90                	xchg   %ax,%ax
  122e04:	66 90                	xchg   %ax,%ax
  122e06:	66 90                	xchg   %ax,%ax
  122e08:	66 90                	xchg   %ax,%ax
  122e0a:	66 90                	xchg   %ax,%ax
  122e0c:	66 90                	xchg   %ax,%ax
  122e0e:	66 90                	xchg   %ax,%ax
  122e10:	66 90                	xchg   %ax,%ax
  122e12:	66 90                	xchg   %ax,%ax
  122e14:	66 90                	xchg   %ax,%ax
  122e16:	66 90                	xchg   %ax,%ax
  122e18:	66 90                	xchg   %ax,%ax
  122e1a:	66 90                	xchg   %ax,%ax
  122e1c:	66 90                	xchg   %ax,%ax
  122e1e:	66 90                	xchg   %ax,%ax
  122e20:	66 90                	xchg   %ax,%ax
  122e22:	66 90                	xchg   %ax,%ax
  122e24:	66 90                	xchg   %ax,%ax
  122e26:	66 90                	xchg   %ax,%ax
  122e28:	66 90                	xchg   %ax,%ax
  122e2a:	66 90                	xchg   %ax,%ax
  122e2c:	66 90                	xchg   %ax,%ax
  122e2e:	66 90                	xchg   %ax,%ax
  122e30:	66 90                	xchg   %ax,%ax
  122e32:	66 90                	xchg   %ax,%ax
  122e34:	66 90                	xchg   %ax,%ax
  122e36:	66 90                	xchg   %ax,%ax
  122e38:	66 90                	xchg   %ax,%ax
  122e3a:	66 90                	xchg   %ax,%ax
  122e3c:	66 90                	xchg   %ax,%ax
  122e3e:	66 90                	xchg   %ax,%ax
  122e40:	66 90                	xchg   %ax,%ax
  122e42:	66 90                	xchg   %ax,%ax
  122e44:	66 90                	xchg   %ax,%ax
  122e46:	66 90                	xchg   %ax,%ax
  122e48:	66 90                	xchg   %ax,%ax
  122e4a:	66 90                	xchg   %ax,%ax
  122e4c:	66 90                	xchg   %ax,%ax
  122e4e:	66 90                	xchg   %ax,%ax
  122e50:	66 90                	xchg   %ax,%ax
  122e52:	66 90                	xchg   %ax,%ax
  122e54:	66 90                	xchg   %ax,%ax
  122e56:	66 90                	xchg   %ax,%ax
  122e58:	66 90                	xchg   %ax,%ax
  122e5a:	66 90                	xchg   %ax,%ax
  122e5c:	66 90                	xchg   %ax,%ax
  122e5e:	66 90                	xchg   %ax,%ax
  122e60:	66 90                	xchg   %ax,%ax
  122e62:	66 90                	xchg   %ax,%ax
  122e64:	66 90                	xchg   %ax,%ax
  122e66:	66 90                	xchg   %ax,%ax
  122e68:	66 90                	xchg   %ax,%ax
  122e6a:	66 90                	xchg   %ax,%ax
  122e6c:	66 90                	xchg   %ax,%ax
  122e6e:	66 90                	xchg   %ax,%ax
  122e70:	66 90                	xchg   %ax,%ax
  122e72:	66 90                	xchg   %ax,%ax
  122e74:	66 90                	xchg   %ax,%ax
  122e76:	66 90                	xchg   %ax,%ax
  122e78:	66 90                	xchg   %ax,%ax
  122e7a:	66 90                	xchg   %ax,%ax
  122e7c:	66 90                	xchg   %ax,%ax
  122e7e:	66 90                	xchg   %ax,%ax
  122e80:	66 90                	xchg   %ax,%ax
  122e82:	66 90                	xchg   %ax,%ax
  122e84:	66 90                	xchg   %ax,%ax
  122e86:	66 90                	xchg   %ax,%ax
  122e88:	66 90                	xchg   %ax,%ax
  122e8a:	66 90                	xchg   %ax,%ax
  122e8c:	66 90                	xchg   %ax,%ax
  122e8e:	66 90                	xchg   %ax,%ax
  122e90:	66 90                	xchg   %ax,%ax
  122e92:	66 90                	xchg   %ax,%ax
  122e94:	66 90                	xchg   %ax,%ax
  122e96:	66 90                	xchg   %ax,%ax
  122e98:	66 90                	xchg   %ax,%ax
  122e9a:	66 90                	xchg   %ax,%ax
  122e9c:	66 90                	xchg   %ax,%ax
  122e9e:	66 90                	xchg   %ax,%ax
  122ea0:	66 90                	xchg   %ax,%ax
  122ea2:	66 90                	xchg   %ax,%ax
  122ea4:	66 90                	xchg   %ax,%ax
  122ea6:	66 90                	xchg   %ax,%ax
  122ea8:	66 90                	xchg   %ax,%ax
  122eaa:	66 90                	xchg   %ax,%ax
  122eac:	66 90                	xchg   %ax,%ax
  122eae:	66 90                	xchg   %ax,%ax
  122eb0:	66 90                	xchg   %ax,%ax
  122eb2:	66 90                	xchg   %ax,%ax
  122eb4:	66 90                	xchg   %ax,%ax
  122eb6:	66 90                	xchg   %ax,%ax
  122eb8:	66 90                	xchg   %ax,%ax
  122eba:	66 90                	xchg   %ax,%ax
  122ebc:	66 90                	xchg   %ax,%ax
  122ebe:	66 90                	xchg   %ax,%ax
  122ec0:	66 90                	xchg   %ax,%ax
  122ec2:	66 90                	xchg   %ax,%ax
  122ec4:	66 90                	xchg   %ax,%ax
  122ec6:	66 90                	xchg   %ax,%ax
  122ec8:	66 90                	xchg   %ax,%ax
  122eca:	66 90                	xchg   %ax,%ax
  122ecc:	66 90                	xchg   %ax,%ax
  122ece:	66 90                	xchg   %ax,%ax
  122ed0:	66 90                	xchg   %ax,%ax
  122ed2:	66 90                	xchg   %ax,%ax
  122ed4:	66 90                	xchg   %ax,%ax
  122ed6:	66 90                	xchg   %ax,%ax
  122ed8:	66 90                	xchg   %ax,%ax
  122eda:	66 90                	xchg   %ax,%ax
  122edc:	66 90                	xchg   %ax,%ax
  122ede:	66 90                	xchg   %ax,%ax
  122ee0:	66 90                	xchg   %ax,%ax
  122ee2:	66 90                	xchg   %ax,%ax
  122ee4:	66 90                	xchg   %ax,%ax
  122ee6:	66 90                	xchg   %ax,%ax
  122ee8:	66 90                	xchg   %ax,%ax
  122eea:	66 90                	xchg   %ax,%ax
  122eec:	66 90                	xchg   %ax,%ax
  122eee:	66 90                	xchg   %ax,%ax
  122ef0:	66 90                	xchg   %ax,%ax
  122ef2:	66 90                	xchg   %ax,%ax
  122ef4:	66 90                	xchg   %ax,%ax
  122ef6:	66 90                	xchg   %ax,%ax
  122ef8:	66 90                	xchg   %ax,%ax
  122efa:	66 90                	xchg   %ax,%ax
  122efc:	66 90                	xchg   %ax,%ax
  122efe:	66 90                	xchg   %ax,%ax
  122f00:	66 90                	xchg   %ax,%ax
  122f02:	66 90                	xchg   %ax,%ax
  122f04:	66 90                	xchg   %ax,%ax
  122f06:	66 90                	xchg   %ax,%ax
  122f08:	66 90                	xchg   %ax,%ax
  122f0a:	66 90                	xchg   %ax,%ax
  122f0c:	66 90                	xchg   %ax,%ax
  122f0e:	66 90                	xchg   %ax,%ax
  122f10:	66 90                	xchg   %ax,%ax
  122f12:	66 90                	xchg   %ax,%ax
  122f14:	66 90                	xchg   %ax,%ax
  122f16:	66 90                	xchg   %ax,%ax
  122f18:	66 90                	xchg   %ax,%ax
  122f1a:	66 90                	xchg   %ax,%ax
  122f1c:	66 90                	xchg   %ax,%ax
  122f1e:	66 90                	xchg   %ax,%ax
  122f20:	66 90                	xchg   %ax,%ax
  122f22:	66 90                	xchg   %ax,%ax
  122f24:	66 90                	xchg   %ax,%ax
  122f26:	66 90                	xchg   %ax,%ax
  122f28:	66 90                	xchg   %ax,%ax
  122f2a:	66 90                	xchg   %ax,%ax
  122f2c:	66 90                	xchg   %ax,%ax
  122f2e:	66 90                	xchg   %ax,%ax
  122f30:	66 90                	xchg   %ax,%ax
  122f32:	66 90                	xchg   %ax,%ax
  122f34:	66 90                	xchg   %ax,%ax
  122f36:	66 90                	xchg   %ax,%ax
  122f38:	66 90                	xchg   %ax,%ax
  122f3a:	66 90                	xchg   %ax,%ax
  122f3c:	66 90                	xchg   %ax,%ax
  122f3e:	66 90                	xchg   %ax,%ax
  122f40:	66 90                	xchg   %ax,%ax
  122f42:	66 90                	xchg   %ax,%ax
  122f44:	66 90                	xchg   %ax,%ax
  122f46:	66 90                	xchg   %ax,%ax
  122f48:	66 90                	xchg   %ax,%ax
  122f4a:	66 90                	xchg   %ax,%ax
  122f4c:	66 90                	xchg   %ax,%ax
  122f4e:	66 90                	xchg   %ax,%ax
  122f50:	66 90                	xchg   %ax,%ax
  122f52:	66 90                	xchg   %ax,%ax
  122f54:	66 90                	xchg   %ax,%ax
  122f56:	66 90                	xchg   %ax,%ax
  122f58:	66 90                	xchg   %ax,%ax
  122f5a:	66 90                	xchg   %ax,%ax
  122f5c:	66 90                	xchg   %ax,%ax
  122f5e:	66 90                	xchg   %ax,%ax
  122f60:	66 90                	xchg   %ax,%ax
  122f62:	66 90                	xchg   %ax,%ax
  122f64:	66 90                	xchg   %ax,%ax
  122f66:	66 90                	xchg   %ax,%ax
  122f68:	66 90                	xchg   %ax,%ax
  122f6a:	66 90                	xchg   %ax,%ax
  122f6c:	66 90                	xchg   %ax,%ax
  122f6e:	66 90                	xchg   %ax,%ax
  122f70:	66 90                	xchg   %ax,%ax
  122f72:	66 90                	xchg   %ax,%ax
  122f74:	66 90                	xchg   %ax,%ax
  122f76:	66 90                	xchg   %ax,%ax
  122f78:	66 90                	xchg   %ax,%ax
  122f7a:	66 90                	xchg   %ax,%ax
  122f7c:	66 90                	xchg   %ax,%ax
  122f7e:	66 90                	xchg   %ax,%ax
  122f80:	66 90                	xchg   %ax,%ax
  122f82:	66 90                	xchg   %ax,%ax
  122f84:	66 90                	xchg   %ax,%ax
  122f86:	66 90                	xchg   %ax,%ax
  122f88:	66 90                	xchg   %ax,%ax
  122f8a:	66 90                	xchg   %ax,%ax
  122f8c:	66 90                	xchg   %ax,%ax
  122f8e:	66 90                	xchg   %ax,%ax
  122f90:	66 90                	xchg   %ax,%ax
  122f92:	66 90                	xchg   %ax,%ax
  122f94:	66 90                	xchg   %ax,%ax
  122f96:	66 90                	xchg   %ax,%ax
  122f98:	66 90                	xchg   %ax,%ax
  122f9a:	66 90                	xchg   %ax,%ax
  122f9c:	66 90                	xchg   %ax,%ax
  122f9e:	66 90                	xchg   %ax,%ax
  122fa0:	66 90                	xchg   %ax,%ax
  122fa2:	66 90                	xchg   %ax,%ax
  122fa4:	66 90                	xchg   %ax,%ax
  122fa6:	66 90                	xchg   %ax,%ax
  122fa8:	66 90                	xchg   %ax,%ax
  122faa:	66 90                	xchg   %ax,%ax
  122fac:	66 90                	xchg   %ax,%ax
  122fae:	66 90                	xchg   %ax,%ax
  122fb0:	66 90                	xchg   %ax,%ax
  122fb2:	66 90                	xchg   %ax,%ax
  122fb4:	66 90                	xchg   %ax,%ax
  122fb6:	66 90                	xchg   %ax,%ax
  122fb8:	66 90                	xchg   %ax,%ax
  122fba:	66 90                	xchg   %ax,%ax
  122fbc:	66 90                	xchg   %ax,%ax
  122fbe:	66 90                	xchg   %ax,%ax
  122fc0:	66 90                	xchg   %ax,%ax
  122fc2:	66 90                	xchg   %ax,%ax
  122fc4:	66 90                	xchg   %ax,%ax
  122fc6:	66 90                	xchg   %ax,%ax
  122fc8:	66 90                	xchg   %ax,%ax
  122fca:	66 90                	xchg   %ax,%ax
  122fcc:	66 90                	xchg   %ax,%ax
  122fce:	66 90                	xchg   %ax,%ax
  122fd0:	66 90                	xchg   %ax,%ax
  122fd2:	66 90                	xchg   %ax,%ax
  122fd4:	66 90                	xchg   %ax,%ax
  122fd6:	66 90                	xchg   %ax,%ax
  122fd8:	66 90                	xchg   %ax,%ax
  122fda:	66 90                	xchg   %ax,%ax
  122fdc:	66 90                	xchg   %ax,%ax
  122fde:	66 90                	xchg   %ax,%ax
  122fe0:	66 90                	xchg   %ax,%ax
  122fe2:	66 90                	xchg   %ax,%ax
  122fe4:	66 90                	xchg   %ax,%ax
  122fe6:	66 90                	xchg   %ax,%ax
  122fe8:	66 90                	xchg   %ax,%ax
  122fea:	66 90                	xchg   %ax,%ax
  122fec:	66 90                	xchg   %ax,%ax
  122fee:	66 90                	xchg   %ax,%ax
  122ff0:	66 90                	xchg   %ax,%ax
  122ff2:	66 90                	xchg   %ax,%ax
  122ff4:	66 90                	xchg   %ax,%ax
  122ff6:	66 90                	xchg   %ax,%ax
  122ff8:	66 90                	xchg   %ax,%ax
  122ffa:	66 90                	xchg   %ax,%ax
  122ffc:	66 90                	xchg   %ax,%ax
  122ffe:	66 90                	xchg   %ax,%ax
